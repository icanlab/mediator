# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_encapSource_huawei_segripv6__segripv6_srv6Site_encapSource(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Site/encapSource. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 Encapsulation Configuation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__encapSrcAddr','__encapSrcAddrTTL',)

  _yang_name = 'encapSource'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encapSrcAddr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="encapSrcAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__encapSrcAddrTTL = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="encapSrcAddrTTL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Site', 'encapSource']

  def _get_encapSrcAddr(self):
    """
    Getter method for encapSrcAddr, mapped from YANG variable /segripv6/srv6Site/encapSource/encapSrcAddr (inet:ipv6-address-no-zone)

    YANG Description: SRv6 VPN Encapsulation Source-address.
    """
    return self.__encapSrcAddr
      
  def _set_encapSrcAddr(self, v, load=False):
    """
    Setter method for encapSrcAddr, mapped from YANG variable /segripv6/srv6Site/encapSource/encapSrcAddr (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapSrcAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapSrcAddr() directly.

    YANG Description: SRv6 VPN Encapsulation Source-address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="encapSrcAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapSrcAddr must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="encapSrcAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__encapSrcAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapSrcAddr(self):
    self.__encapSrcAddr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="encapSrcAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_encapSrcAddrTTL(self):
    """
    Getter method for encapSrcAddrTTL, mapped from YANG variable /segripv6/srv6Site/encapSource/encapSrcAddrTTL (uint8)

    YANG Description: Encapsulation IPv6 header TTL value.
    """
    return self.__encapSrcAddrTTL
      
  def _set_encapSrcAddrTTL(self, v, load=False):
    """
    Setter method for encapSrcAddrTTL, mapped from YANG variable /segripv6/srv6Site/encapSource/encapSrcAddrTTL (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapSrcAddrTTL is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapSrcAddrTTL() directly.

    YANG Description: Encapsulation IPv6 header TTL value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="encapSrcAddrTTL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapSrcAddrTTL must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="encapSrcAddrTTL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)""",
        })

    self.__encapSrcAddrTTL = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapSrcAddrTTL(self):
    self.__encapSrcAddrTTL = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="encapSrcAddrTTL", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)

  encapSrcAddr = __builtin__.property(_get_encapSrcAddr, _set_encapSrcAddr)
  encapSrcAddrTTL = __builtin__.property(_get_encapSrcAddrTTL, _set_encapSrcAddrTTL)


  _pyangbind_elements = OrderedDict([('encapSrcAddr', encapSrcAddr), ('encapSrcAddrTTL', encapSrcAddrTTL), ])


class yc_srv6Site_huawei_segripv6__segripv6_srv6Site(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Site. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Display Segment Routing IPv6 status, enable or disable Segment Routing IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6Enable','__teEnable','__teFrrEnable','__encapSource',)

  _yang_name = 'srv6Site'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    self.__teEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    self.__teFrrEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    self.__encapSource = YANGDynClass(base=yc_encapSource_huawei_segripv6__segripv6_srv6Site_encapSource, is_container='container', yang_name="encapSource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Site']

  def _get_srv6Enable(self):
    """
    Getter method for srv6Enable, mapped from YANG variable /segripv6/srv6Site/srv6Enable (boolean)

    YANG Description: Enable Segment Routing IPv6.
    """
    return self.__srv6Enable
      
  def _set_srv6Enable(self, v, load=False):
    """
    Setter method for srv6Enable, mapped from YANG variable /segripv6/srv6Site/srv6Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6Enable() directly.

    YANG Description: Enable Segment Routing IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__srv6Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6Enable(self):
    self.__srv6Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)


  def _get_teEnable(self):
    """
    Getter method for teEnable, mapped from YANG variable /segripv6/srv6Site/teEnable (boolean)

    YANG Description: Enable te.
    """
    return self.__teEnable
      
  def _set_teEnable(self, v, load=False):
    """
    Setter method for teEnable, mapped from YANG variable /segripv6/srv6Site/teEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_teEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_teEnable() directly.

    YANG Description: Enable te.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """teEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__teEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_teEnable(self):
    self.__teEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)


  def _get_teFrrEnable(self):
    """
    Getter method for teFrrEnable, mapped from YANG variable /segripv6/srv6Site/teFrrEnable (boolean)

    YANG Description: Enable sr te-frr.
    """
    return self.__teFrrEnable
      
  def _set_teFrrEnable(self, v, load=False):
    """
    Setter method for teFrrEnable, mapped from YANG variable /segripv6/srv6Site/teFrrEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_teFrrEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_teFrrEnable() directly.

    YANG Description: Enable sr te-frr.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """teFrrEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__teFrrEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_teFrrEnable(self):
    self.__teFrrEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)


  def _get_encapSource(self):
    """
    Getter method for encapSource, mapped from YANG variable /segripv6/srv6Site/encapSource (container)

    YANG Description: IPv6 Encapsulation Configuation.
    """
    return self.__encapSource
      
  def _set_encapSource(self, v, load=False):
    """
    Setter method for encapSource, mapped from YANG variable /segripv6/srv6Site/encapSource (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapSource is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapSource() directly.

    YANG Description: IPv6 Encapsulation Configuation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encapSource_huawei_segripv6__segripv6_srv6Site_encapSource, is_container='container', yang_name="encapSource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapSource must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encapSource_huawei_segripv6__segripv6_srv6Site_encapSource, is_container='container', yang_name="encapSource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__encapSource = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapSource(self):
    self.__encapSource = YANGDynClass(base=yc_encapSource_huawei_segripv6__segripv6_srv6Site_encapSource, is_container='container', yang_name="encapSource", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

  srv6Enable = __builtin__.property(_get_srv6Enable, _set_srv6Enable)
  teEnable = __builtin__.property(_get_teEnable, _set_teEnable)
  teFrrEnable = __builtin__.property(_get_teFrrEnable, _set_teFrrEnable)
  encapSource = __builtin__.property(_get_encapSource, _set_encapSource) # type: yc_encapSource_huawei_segripv6__segripv6_srv6Site_encapSource


  _pyangbind_elements = OrderedDict([('srv6Enable', srv6Enable), ('teEnable', teEnable), ('teFrrEnable', teFrrEnable), ('encapSource', encapSource), ])


class yc_srv6RemoteEndOtp_huawei_segripv6__segripv6_srv6RemoteEndOtps_srv6RemoteEndOtp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SRv6 Remote End.OTP SID Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remoteEndOtpSid','__prefixLength',)

  _yang_name = 'srv6RemoteEndOtp'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remoteEndOtpSid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="remoteEndOtpSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__prefixLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefixLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6RemoteEndOtps', 'srv6RemoteEndOtp']

  def _get_remoteEndOtpSid(self):
    """
    Getter method for remoteEndOtpSid, mapped from YANG variable /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp/remoteEndOtpSid (inet:ipv6-address-no-zone)

    YANG Description: Remote End.OTP SID.
    """
    return self.__remoteEndOtpSid
      
  def _set_remoteEndOtpSid(self, v, load=False):
    """
    Setter method for remoteEndOtpSid, mapped from YANG variable /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp/remoteEndOtpSid (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remoteEndOtpSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remoteEndOtpSid() directly.

    YANG Description: Remote End.OTP SID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="remoteEndOtpSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remoteEndOtpSid must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="remoteEndOtpSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__remoteEndOtpSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remoteEndOtpSid(self):
    self.__remoteEndOtpSid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="remoteEndOtpSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_prefixLength(self):
    """
    Getter method for prefixLength, mapped from YANG variable /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp/prefixLength (uint8)

    YANG Description: Remote End.OTP SID Prefix Length.
    """
    return self.__prefixLength
      
  def _set_prefixLength(self, v, load=False):
    """
    Setter method for prefixLength, mapped from YANG variable /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp/prefixLength (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixLength() directly.

    YANG Description: Remote End.OTP SID Prefix Length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefixLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixLength must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefixLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)""",
        })

    self.__prefixLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixLength(self):
    self.__prefixLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefixLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)

  remoteEndOtpSid = __builtin__.property(_get_remoteEndOtpSid, _set_remoteEndOtpSid)
  prefixLength = __builtin__.property(_get_prefixLength, _set_prefixLength)


  _pyangbind_elements = OrderedDict([('remoteEndOtpSid', remoteEndOtpSid), ('prefixLength', prefixLength), ])


class yc_srv6RemoteEndOtps_huawei_segripv6__segripv6_srv6RemoteEndOtps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6RemoteEndOtps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SRv6 Remote End.OTP Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6RemoteEndOtp',)

  _yang_name = 'srv6RemoteEndOtps'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6RemoteEndOtp = YANGDynClass(base=YANGListType("remoteEndOtpSid",yc_srv6RemoteEndOtp_huawei_segripv6__segripv6_srv6RemoteEndOtps_srv6RemoteEndOtp, yang_name="srv6RemoteEndOtp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteEndOtpSid', extensions=None), is_container='list', yang_name="srv6RemoteEndOtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6RemoteEndOtps']

  def _get_srv6RemoteEndOtp(self):
    """
    Getter method for srv6RemoteEndOtp, mapped from YANG variable /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp (list)

    YANG Description: SRv6 Remote End.OTP SID Configuration.
    """
    return self.__srv6RemoteEndOtp
      
  def _set_srv6RemoteEndOtp(self, v, load=False):
    """
    Setter method for srv6RemoteEndOtp, mapped from YANG variable /segripv6/srv6RemoteEndOtps/srv6RemoteEndOtp (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6RemoteEndOtp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6RemoteEndOtp() directly.

    YANG Description: SRv6 Remote End.OTP SID Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("remoteEndOtpSid",yc_srv6RemoteEndOtp_huawei_segripv6__segripv6_srv6RemoteEndOtps_srv6RemoteEndOtp, yang_name="srv6RemoteEndOtp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteEndOtpSid', extensions=None), is_container='list', yang_name="srv6RemoteEndOtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6RemoteEndOtp must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("remoteEndOtpSid",yc_srv6RemoteEndOtp_huawei_segripv6__segripv6_srv6RemoteEndOtps_srv6RemoteEndOtp, yang_name="srv6RemoteEndOtp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteEndOtpSid', extensions=None), is_container='list', yang_name="srv6RemoteEndOtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__srv6RemoteEndOtp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6RemoteEndOtp(self):
    self.__srv6RemoteEndOtp = YANGDynClass(base=YANGListType("remoteEndOtpSid",yc_srv6RemoteEndOtp_huawei_segripv6__segripv6_srv6RemoteEndOtps_srv6RemoteEndOtp, yang_name="srv6RemoteEndOtp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteEndOtpSid', extensions=None), is_container='list', yang_name="srv6RemoteEndOtp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  srv6RemoteEndOtp = __builtin__.property(_get_srv6RemoteEndOtp, _set_srv6RemoteEndOtp) # type: yc_srv6RemoteEndOtp_huawei_segripv6__segripv6_srv6RemoteEndOtps_srv6RemoteEndOtp


  _pyangbind_elements = OrderedDict([('srv6RemoteEndOtp', srv6RemoteEndOtp), ])


class yc_endOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes_endOpcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End Type Opcode Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue','__flavor',)

  _yang_name = 'endOpcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__flavor = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endOpcodes', 'endOpcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode/opcodeValue (inet:ipv6-address-no-zone)

    YANG Description: Opcode Value.
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.

    YANG Description: Opcode Value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_flavor(self):
    """
    Getter method for flavor, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode/flavor (boolean)

    YANG Description: Enable PSP Flavor.
    """
    return self.__flavor
      
  def _set_flavor(self, v, load=False):
    """
    Setter method for flavor, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode/flavor (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavor() directly.

    YANG Description: Enable PSP Flavor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flavor must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__flavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flavor(self):
    self.__flavor = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)
  flavor = __builtin__.property(_get_flavor, _set_flavor)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ('flavor', flavor), ])


class yc_endOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End Type Opcodes Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endOpcode',)

  _yang_name = 'endOpcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes_endOpcode, yang_name="endOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endOpcodes']

  def _get_endOpcode(self):
    """
    Getter method for endOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode (list)

    YANG Description: End Type Opcode Configuration.
    """
    return self.__endOpcode
      
  def _set_endOpcode(self, v, load=False):
    """
    Setter method for endOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes/endOpcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endOpcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endOpcode() directly.

    YANG Description: End Type Opcode Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes_endOpcode, yang_name="endOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endOpcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes_endOpcode, yang_name="endOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endOpcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endOpcode(self):
    self.__endOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes_endOpcode, yang_name="endOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endOpcode = __builtin__.property(_get_endOpcode, _set_endOpcode) # type: yc_endOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes_endOpcode


  _pyangbind_elements = OrderedDict([('endOpcode', endOpcode), ])


class yc_endOtpOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes_endOtpOpcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes/endOtpOpcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.OTP Type Opcode Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue',)

  _yang_name = 'endOtpOpcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endOtpOpcodes', 'endOtpOpcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes/endOtpOpcode/opcodeValue (inet:ipv6-address-no-zone)

    YANG Description: Opcode Value.
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes/endOtpOpcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.

    YANG Description: Opcode Value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ])


class yc_endOtpOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.OTP Type Opcodes Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endOtpOpcode',)

  _yang_name = 'endOtpOpcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endOtpOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endOtpOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes_endOtpOpcode, yang_name="endOtpOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOtpOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endOtpOpcodes']

  def _get_endOtpOpcode(self):
    """
    Getter method for endOtpOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes/endOtpOpcode (list)

    YANG Description: End.OTP Type Opcode Configuration.
    """
    return self.__endOtpOpcode
      
  def _set_endOtpOpcode(self, v, load=False):
    """
    Setter method for endOtpOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes/endOtpOpcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endOtpOpcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endOtpOpcode() directly.

    YANG Description: End.OTP Type Opcode Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endOtpOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes_endOtpOpcode, yang_name="endOtpOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOtpOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endOtpOpcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endOtpOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes_endOtpOpcode, yang_name="endOtpOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOtpOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endOtpOpcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endOtpOpcode(self):
    self.__endOtpOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endOtpOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes_endOtpOpcode, yang_name="endOtpOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endOtpOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endOtpOpcode = __builtin__.property(_get_endOtpOpcode, _set_endOtpOpcode) # type: yc_endOtpOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes_endOtpOpcode


  _pyangbind_elements = OrderedDict([('endOtpOpcode', endOtpOpcode), ])


class yc_endxOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes_endxOpcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.X Type Opcode Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue','__ifName','__nextHop','__flavor',)

  _yang_name = 'endxOpcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__flavor = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endxOpcodes', 'endxOpcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/opcodeValue (inet:ipv6-address-no-zone)

    YANG Description: Opcode Value.
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.

    YANG Description: Opcode Value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_ifName(self):
    """
    Getter method for ifName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/ifName (string)

    YANG Description: Interface Name.
    """
    return self.__ifName
      
  def _set_ifName(self, v, load=False):
    """
    Setter method for ifName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/ifName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifName() directly.

    YANG Description: Interface Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)""",
        })

    self.__ifName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifName(self):
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)


  def _get_nextHop(self):
    """
    Getter method for nextHop, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/nextHop (inet:ipv6-address-no-zone)

    YANG Description: NextHop Address.
    """
    return self.__nextHop
      
  def _set_nextHop(self, v, load=False):
    """
    Setter method for nextHop, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/nextHop (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHop() directly.

    YANG Description: NextHop Address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHop must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__nextHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHop(self):
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_flavor(self):
    """
    Getter method for flavor, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/flavor (boolean)

    YANG Description: Flavor.
    """
    return self.__flavor
      
  def _set_flavor(self, v, load=False):
    """
    Setter method for flavor, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode/flavor (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavor() directly.

    YANG Description: Flavor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flavor must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__flavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flavor(self):
    self.__flavor = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)
  ifName = __builtin__.property(_get_ifName, _set_ifName)
  nextHop = __builtin__.property(_get_nextHop, _set_nextHop)
  flavor = __builtin__.property(_get_flavor, _set_flavor)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ('ifName', ifName), ('nextHop', nextHop), ('flavor', flavor), ])


class yc_endxOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.X Type Opcodes Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endxOpcode',)

  _yang_name = 'endxOpcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endxOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endxOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes_endxOpcode, yang_name="endxOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endxOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endxOpcodes']

  def _get_endxOpcode(self):
    """
    Getter method for endxOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode (list)

    YANG Description: End.X Type Opcode Configuration.
    """
    return self.__endxOpcode
      
  def _set_endxOpcode(self, v, load=False):
    """
    Setter method for endxOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes/endxOpcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endxOpcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endxOpcode() directly.

    YANG Description: End.X Type Opcode Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endxOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes_endxOpcode, yang_name="endxOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endxOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endxOpcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endxOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes_endxOpcode, yang_name="endxOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endxOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endxOpcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endxOpcode(self):
    self.__endxOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endxOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes_endxOpcode, yang_name="endxOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endxOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endxOpcode = __builtin__.property(_get_endxOpcode, _set_endxOpcode) # type: yc_endxOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes_endxOpcode


  _pyangbind_elements = OrderedDict([('endxOpcode', endxOpcode), ])


class yc_endDt4Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes_endDt4Opcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.DT4 Type Opcode Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue','__vpnName','__protocolType',)

  _yang_name = 'endDt4Opcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__vpnName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    self.__protocolType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDt4Opcodes', 'endDt4Opcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode/opcodeValue (inet:ipv6-address-no-zone)

    YANG Description: Opcode Value.
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.

    YANG Description: Opcode Value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_vpnName(self):
    """
    Getter method for vpnName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode/vpnName (string)

    YANG Description: VPN Name.
    """
    return self.__vpnName
      
  def _set_vpnName(self, v, load=False):
    """
    Setter method for vpnName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode/vpnName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnName() directly.

    YANG Description: VPN Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)""",
        })

    self.__vpnName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnName(self):
    self.__vpnName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)


  def _get_protocolType(self):
    """
    Getter method for protocolType, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode/protocolType (string)

    YANG Description: Protocol Type.
    """
    return self.__protocolType
      
  def _set_protocolType(self, v, load=False):
    """
    Setter method for protocolType, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode/protocolType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocolType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocolType() directly.

    YANG Description: Protocol Type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocolType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)""",
        })

    self.__protocolType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocolType(self):
    self.__protocolType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)
  vpnName = __builtin__.property(_get_vpnName, _set_vpnName)
  protocolType = __builtin__.property(_get_protocolType, _set_protocolType)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ('vpnName', vpnName), ('protocolType', protocolType), ])


class yc_endDt4Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.DT4 Type Opcodes Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endDt4Opcode',)

  _yang_name = 'endDt4Opcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endDt4Opcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDt4Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes_endDt4Opcode, yang_name="endDt4Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt4Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDt4Opcodes']

  def _get_endDt4Opcode(self):
    """
    Getter method for endDt4Opcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode (list)

    YANG Description: End.DT4 Type Opcode Configuration.
    """
    return self.__endDt4Opcode
      
  def _set_endDt4Opcode(self, v, load=False):
    """
    Setter method for endDt4Opcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes/endDt4Opcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDt4Opcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDt4Opcode() directly.

    YANG Description: End.DT4 Type Opcode Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endDt4Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes_endDt4Opcode, yang_name="endDt4Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt4Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDt4Opcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endDt4Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes_endDt4Opcode, yang_name="endDt4Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt4Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endDt4Opcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDt4Opcode(self):
    self.__endDt4Opcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDt4Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes_endDt4Opcode, yang_name="endDt4Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt4Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endDt4Opcode = __builtin__.property(_get_endDt4Opcode, _set_endDt4Opcode) # type: yc_endDt4Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes_endDt4Opcode


  _pyangbind_elements = OrderedDict([('endDt4Opcode', endDt4Opcode), ])


class yc_endDt6Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes_endDt6Opcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.DT6 Type Opcode Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue','__vpnName','__protocolType',)

  _yang_name = 'endDt6Opcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__vpnName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    self.__protocolType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDt6Opcodes', 'endDt6Opcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode/opcodeValue (inet:ipv6-address-no-zone)

    YANG Description: Opcode Value.
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.

    YANG Description: Opcode Value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_vpnName(self):
    """
    Getter method for vpnName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode/vpnName (string)

    YANG Description: VPN Name.
    """
    return self.__vpnName
      
  def _set_vpnName(self, v, load=False):
    """
    Setter method for vpnName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode/vpnName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnName() directly.

    YANG Description: VPN Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)""",
        })

    self.__vpnName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnName(self):
    self.__vpnName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)


  def _get_protocolType(self):
    """
    Getter method for protocolType, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode/protocolType (string)

    YANG Description: Protocol Type.
    """
    return self.__protocolType
      
  def _set_protocolType(self, v, load=False):
    """
    Setter method for protocolType, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode/protocolType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocolType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocolType() directly.

    YANG Description: Protocol Type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocolType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)""",
        })

    self.__protocolType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocolType(self):
    self.__protocolType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)
  vpnName = __builtin__.property(_get_vpnName, _set_vpnName)
  protocolType = __builtin__.property(_get_protocolType, _set_protocolType)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ('vpnName', vpnName), ('protocolType', protocolType), ])


class yc_endDt6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: End.DT6 Type Opcodes Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endDt6Opcode',)

  _yang_name = 'endDt6Opcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endDt6Opcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDt6Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes_endDt6Opcode, yang_name="endDt6Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt6Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDt6Opcodes']

  def _get_endDt6Opcode(self):
    """
    Getter method for endDt6Opcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode (list)

    YANG Description: End.DT6 Type Opcode Configuration.
    """
    return self.__endDt6Opcode
      
  def _set_endDt6Opcode(self, v, load=False):
    """
    Setter method for endDt6Opcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes/endDt6Opcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDt6Opcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDt6Opcode() directly.

    YANG Description: End.DT6 Type Opcode Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endDt6Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes_endDt6Opcode, yang_name="endDt6Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt6Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDt6Opcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endDt6Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes_endDt6Opcode, yang_name="endDt6Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt6Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endDt6Opcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDt6Opcode(self):
    self.__endDt6Opcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDt6Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes_endDt6Opcode, yang_name="endDt6Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDt6Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endDt6Opcode = __builtin__.property(_get_endDt6Opcode, _set_endDt6Opcode) # type: yc_endDt6Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes_endDt6Opcode


  _pyangbind_elements = OrderedDict([('endDt6Opcode', endDt6Opcode), ])


class yc_endDx2Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes_endDx2Opcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue','__evplID',)

  _yang_name = 'endDx2Opcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDx2Opcodes', 'endDx2Opcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode/opcodeValue (inet:ipv6-address-no-zone)
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_evplID(self):
    """
    Getter method for evplID, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode/evplID (uint32)
    """
    return self.__evplID
      
  def _set_evplID(self, v, load=False):
    """
    Setter method for evplID, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode/evplID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evplID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evplID() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evplID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)""",
        })

    self.__evplID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evplID(self):
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)
  evplID = __builtin__.property(_get_evplID, _set_evplID)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ('evplID', evplID), ])


class yc_endDx2Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endDx2Opcode',)

  _yang_name = 'endDx2Opcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endDx2Opcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDx2Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes_endDx2Opcode, yang_name="endDx2Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDx2Opcodes']

  def _get_endDx2Opcode(self):
    """
    Getter method for endDx2Opcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode (list)
    """
    return self.__endDx2Opcode
      
  def _set_endDx2Opcode(self, v, load=False):
    """
    Setter method for endDx2Opcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes/endDx2Opcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDx2Opcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDx2Opcode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endDx2Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes_endDx2Opcode, yang_name="endDx2Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDx2Opcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endDx2Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes_endDx2Opcode, yang_name="endDx2Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endDx2Opcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDx2Opcode(self):
    self.__endDx2Opcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDx2Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes_endDx2Opcode, yang_name="endDx2Opcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2Opcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endDx2Opcode = __builtin__.property(_get_endDx2Opcode, _set_endDx2Opcode) # type: yc_endDx2Opcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes_endDx2Opcode


  _pyangbind_elements = OrderedDict([('endDx2Opcode', endDx2Opcode), ])


class yc_endDx2lOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes_endDx2lOpcode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opcodeValue','__evplID',)

  _yang_name = 'endDx2lOpcode'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDx2lOpcodes', 'endDx2lOpcode']

  def _get_opcodeValue(self):
    """
    Getter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode/opcodeValue (inet:ipv6-address-no-zone)
    """
    return self.__opcodeValue
      
  def _set_opcodeValue(self, v, load=False):
    """
    Setter method for opcodeValue, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode/opcodeValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opcodeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opcodeValue() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opcodeValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__opcodeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opcodeValue(self):
    self.__opcodeValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="opcodeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_evplID(self):
    """
    Getter method for evplID, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode/evplID (uint32)
    """
    return self.__evplID
      
  def _set_evplID(self, v, load=False):
    """
    Setter method for evplID, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode/evplID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evplID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evplID() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evplID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)""",
        })

    self.__evplID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evplID(self):
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=True)

  opcodeValue = __builtin__.property(_get_opcodeValue, _set_opcodeValue)
  evplID = __builtin__.property(_get_evplID, _set_evplID)


  _pyangbind_elements = OrderedDict([('opcodeValue', opcodeValue), ('evplID', evplID), ])


class yc_endDx2lOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endDx2lOpcode',)

  _yang_name = 'endDx2lOpcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endDx2lOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDx2lOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes_endDx2lOpcode, yang_name="endDx2lOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2lOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes', 'endDx2lOpcodes']

  def _get_endDx2lOpcode(self):
    """
    Getter method for endDx2lOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode (list)
    """
    return self.__endDx2lOpcode
      
  def _set_endDx2lOpcode(self, v, load=False):
    """
    Setter method for endDx2lOpcode, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes/endDx2lOpcode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDx2lOpcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDx2lOpcode() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opcodeValue",yc_endDx2lOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes_endDx2lOpcode, yang_name="endDx2lOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2lOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDx2lOpcode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opcodeValue",yc_endDx2lOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes_endDx2lOpcode, yang_name="endDx2lOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2lOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__endDx2lOpcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDx2lOpcode(self):
    self.__endDx2lOpcode = YANGDynClass(base=YANGListType("opcodeValue",yc_endDx2lOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes_endDx2lOpcode, yang_name="endDx2lOpcode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opcodeValue', extensions=None), is_container='list', yang_name="endDx2lOpcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  endDx2lOpcode = __builtin__.property(_get_endDx2lOpcode, _set_endDx2lOpcode) # type: yc_endDx2lOpcode_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes_endDx2lOpcode


  _pyangbind_elements = OrderedDict([('endDx2lOpcode', endDx2lOpcode), ])


class yc_srv6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator/srv6Opcodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SRv6 Opcodes Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endOpcodes','__endOtpOpcodes','__endxOpcodes','__endDt4Opcodes','__endDt6Opcodes','__endDx2Opcodes','__endDx2lOpcodes',)

  _yang_name = 'srv6Opcodes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endOpcodes = YANGDynClass(base=yc_endOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes, is_container='container', yang_name="endOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__endOtpOpcodes = YANGDynClass(base=yc_endOtpOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes, is_container='container', yang_name="endOtpOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__endxOpcodes = YANGDynClass(base=yc_endxOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes, is_container='container', yang_name="endxOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__endDt4Opcodes = YANGDynClass(base=yc_endDt4Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes, is_container='container', yang_name="endDt4Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__endDt6Opcodes = YANGDynClass(base=yc_endDt6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes, is_container='container', yang_name="endDt6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__endDx2Opcodes = YANGDynClass(base=yc_endDx2Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes, is_container='container', yang_name="endDx2Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__endDx2lOpcodes = YANGDynClass(base=yc_endDx2lOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes, is_container='container', yang_name="endDx2lOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator', 'srv6Opcodes']

  def _get_endOpcodes(self):
    """
    Getter method for endOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes (container)

    YANG Description: End Type Opcodes Configuration.
    """
    return self.__endOpcodes
      
  def _set_endOpcodes(self, v, load=False):
    """
    Setter method for endOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOpcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endOpcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endOpcodes() directly.

    YANG Description: End Type Opcodes Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes, is_container='container', yang_name="endOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endOpcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes, is_container='container', yang_name="endOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endOpcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endOpcodes(self):
    self.__endOpcodes = YANGDynClass(base=yc_endOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes, is_container='container', yang_name="endOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_endOtpOpcodes(self):
    """
    Getter method for endOtpOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes (container)

    YANG Description: End.OTP Type Opcodes Configuration.
    """
    return self.__endOtpOpcodes
      
  def _set_endOtpOpcodes(self, v, load=False):
    """
    Setter method for endOtpOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endOtpOpcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endOtpOpcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endOtpOpcodes() directly.

    YANG Description: End.OTP Type Opcodes Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endOtpOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes, is_container='container', yang_name="endOtpOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endOtpOpcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endOtpOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes, is_container='container', yang_name="endOtpOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endOtpOpcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endOtpOpcodes(self):
    self.__endOtpOpcodes = YANGDynClass(base=yc_endOtpOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes, is_container='container', yang_name="endOtpOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_endxOpcodes(self):
    """
    Getter method for endxOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes (container)

    YANG Description: End.X Type Opcodes Configuration.
    """
    return self.__endxOpcodes
      
  def _set_endxOpcodes(self, v, load=False):
    """
    Setter method for endxOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endxOpcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endxOpcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endxOpcodes() directly.

    YANG Description: End.X Type Opcodes Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endxOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes, is_container='container', yang_name="endxOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endxOpcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endxOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes, is_container='container', yang_name="endxOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endxOpcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endxOpcodes(self):
    self.__endxOpcodes = YANGDynClass(base=yc_endxOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes, is_container='container', yang_name="endxOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_endDt4Opcodes(self):
    """
    Getter method for endDt4Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes (container)

    YANG Description: End.DT4 Type Opcodes Configuration.
    """
    return self.__endDt4Opcodes
      
  def _set_endDt4Opcodes(self, v, load=False):
    """
    Setter method for endDt4Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt4Opcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDt4Opcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDt4Opcodes() directly.

    YANG Description: End.DT4 Type Opcodes Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endDt4Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes, is_container='container', yang_name="endDt4Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDt4Opcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endDt4Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes, is_container='container', yang_name="endDt4Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endDt4Opcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDt4Opcodes(self):
    self.__endDt4Opcodes = YANGDynClass(base=yc_endDt4Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes, is_container='container', yang_name="endDt4Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_endDt6Opcodes(self):
    """
    Getter method for endDt6Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes (container)

    YANG Description: End.DT6 Type Opcodes Configuration.
    """
    return self.__endDt6Opcodes
      
  def _set_endDt6Opcodes(self, v, load=False):
    """
    Setter method for endDt6Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDt6Opcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDt6Opcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDt6Opcodes() directly.

    YANG Description: End.DT6 Type Opcodes Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endDt6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes, is_container='container', yang_name="endDt6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDt6Opcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endDt6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes, is_container='container', yang_name="endDt6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endDt6Opcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDt6Opcodes(self):
    self.__endDt6Opcodes = YANGDynClass(base=yc_endDt6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes, is_container='container', yang_name="endDt6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_endDx2Opcodes(self):
    """
    Getter method for endDx2Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes (container)
    """
    return self.__endDx2Opcodes
      
  def _set_endDx2Opcodes(self, v, load=False):
    """
    Setter method for endDx2Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2Opcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDx2Opcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDx2Opcodes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endDx2Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes, is_container='container', yang_name="endDx2Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDx2Opcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endDx2Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes, is_container='container', yang_name="endDx2Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endDx2Opcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDx2Opcodes(self):
    self.__endDx2Opcodes = YANGDynClass(base=yc_endDx2Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes, is_container='container', yang_name="endDx2Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_endDx2lOpcodes(self):
    """
    Getter method for endDx2lOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes (container)
    """
    return self.__endDx2lOpcodes
      
  def _set_endDx2lOpcodes(self, v, load=False):
    """
    Setter method for endDx2lOpcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes/endDx2lOpcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endDx2lOpcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endDx2lOpcodes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endDx2lOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes, is_container='container', yang_name="endDx2lOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endDx2lOpcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endDx2lOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes, is_container='container', yang_name="endDx2lOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__endDx2lOpcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endDx2lOpcodes(self):
    self.__endDx2lOpcodes = YANGDynClass(base=yc_endDx2lOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes, is_container='container', yang_name="endDx2lOpcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

  endOpcodes = __builtin__.property(_get_endOpcodes, _set_endOpcodes) # type: yc_endOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOpcodes
  endOtpOpcodes = __builtin__.property(_get_endOtpOpcodes, _set_endOtpOpcodes) # type: yc_endOtpOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endOtpOpcodes
  endxOpcodes = __builtin__.property(_get_endxOpcodes, _set_endxOpcodes) # type: yc_endxOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endxOpcodes
  endDt4Opcodes = __builtin__.property(_get_endDt4Opcodes, _set_endDt4Opcodes) # type: yc_endDt4Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt4Opcodes
  endDt6Opcodes = __builtin__.property(_get_endDt6Opcodes, _set_endDt6Opcodes) # type: yc_endDt6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDt6Opcodes
  endDx2Opcodes = __builtin__.property(_get_endDx2Opcodes, _set_endDx2Opcodes) # type: yc_endDx2Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2Opcodes
  endDx2lOpcodes = __builtin__.property(_get_endDx2lOpcodes, _set_endDx2lOpcodes) # type: yc_endDx2lOpcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes_endDx2lOpcodes


  _pyangbind_elements = OrderedDict([('endOpcodes', endOpcodes), ('endOtpOpcodes', endOtpOpcodes), ('endxOpcodes', endxOpcodes), ('endDt4Opcodes', endDt4Opcodes), ('endDt6Opcodes', endDt6Opcodes), ('endDx2Opcodes', endDx2Opcodes), ('endDx2lOpcodes', endDx2lOpcodes), ])


class yc_srv6Locator_huawei_segripv6__segripv6_srv6Locators_srv6Locator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators/srv6Locator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SRv6 Locator Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__locatorName','__ipv6Prefix','__maskLength','__static','__staticLength','__args','__argsLength','__defaultFlag','__srv6Opcodes',)

  _yang_name = 'srv6Locator'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    self.__ipv6Prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['32..120']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    self.__static = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    self.__staticLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..96']}), is_leaf=True, yang_name="staticLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    self.__args = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    self.__argsLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..64']}), is_leaf=True, yang_name="argsLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    self.__defaultFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    self.__srv6Opcodes = YANGDynClass(base=yc_srv6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes, is_container='container', yang_name="srv6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators', 'srv6Locator']

  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/locatorName (string)

    YANG Description: Locator Name.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator Name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=True)


  def _get_ipv6Prefix(self):
    """
    Getter method for ipv6Prefix, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/ipv6Prefix (inet:ipv6-address-no-zone)

    YANG Description: IPv6 Prefix.
    """
    return self.__ipv6Prefix
      
  def _set_ipv6Prefix(self, v, load=False):
    """
    Setter method for ipv6Prefix, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/ipv6Prefix (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Prefix() directly.

    YANG Description: IPv6 Prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Prefix must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ipv6Prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Prefix(self):
    self.__ipv6Prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_maskLength(self):
    """
    Getter method for maskLength, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/maskLength (uint8)

    YANG Description: Mask Length.
    """
    return self.__maskLength
      
  def _set_maskLength(self, v, load=False):
    """
    Setter method for maskLength, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/maskLength (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maskLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maskLength() directly.

    YANG Description: Mask Length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['32..120']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maskLength must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['32..120']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)""",
        })

    self.__maskLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maskLength(self):
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['32..120']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)


  def _get_static(self):
    """
    Getter method for static, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/static (boolean)

    YANG Description: Static Segment, if the value is not enable, configuring Opcode is not allowed.
    """
    return self.__static
      
  def _set_static(self, v, load=False):
    """
    Setter method for static, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/static (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static() directly.

    YANG Description: Static Segment, if the value is not enable, configuring Opcode is not allowed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__static = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static(self):
    self.__static = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)


  def _get_staticLength(self):
    """
    Getter method for staticLength, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/staticLength (uint8)

    YANG Description: The static segment length determines the range of Opcode.
    """
    return self.__staticLength
      
  def _set_staticLength(self, v, load=False):
    """
    Setter method for staticLength, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/staticLength (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_staticLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_staticLength() directly.

    YANG Description: The static segment length determines the range of Opcode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..96']}), is_leaf=True, yang_name="staticLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """staticLength must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..96']}), is_leaf=True, yang_name="staticLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)""",
        })

    self.__staticLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_staticLength(self):
    self.__staticLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..96']}), is_leaf=True, yang_name="staticLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)


  def _get_args(self):
    """
    Getter method for args, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/args (boolean)

    YANG Description: Configuration of args segment.
    """
    return self.__args
      
  def _set_args(self, v, load=False):
    """
    Setter method for args, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/args (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_args is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_args() directly.

    YANG Description: Configuration of args segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """args must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__args = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_args(self):
    self.__args = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="args", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)


  def _get_argsLength(self):
    """
    Getter method for argsLength, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/argsLength (uint8)

    YANG Description: Static segment length.
    """
    return self.__argsLength
      
  def _set_argsLength(self, v, load=False):
    """
    Setter method for argsLength, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/argsLength (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_argsLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_argsLength() directly.

    YANG Description: Static segment length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..64']}), is_leaf=True, yang_name="argsLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """argsLength must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..64']}), is_leaf=True, yang_name="argsLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)""",
        })

    self.__argsLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_argsLength(self):
    self.__argsLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..64']}), is_leaf=True, yang_name="argsLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint8', is_config=True)


  def _get_defaultFlag(self):
    """
    Getter method for defaultFlag, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/defaultFlag (boolean)

    YANG Description: Default Locator.
    """
    return self.__defaultFlag
      
  def _set_defaultFlag(self, v, load=False):
    """
    Setter method for defaultFlag, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/defaultFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultFlag() directly.

    YANG Description: Default Locator.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)""",
        })

    self.__defaultFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultFlag(self):
    self.__defaultFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='boolean', is_config=True)


  def _get_srv6Opcodes(self):
    """
    Getter method for srv6Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes (container)

    YANG Description: SRv6 Opcodes Configuration.
    """
    return self.__srv6Opcodes
      
  def _set_srv6Opcodes(self, v, load=False):
    """
    Setter method for srv6Opcodes, mapped from YANG variable /segripv6/srv6Locators/srv6Locator/srv6Opcodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6Opcodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6Opcodes() directly.

    YANG Description: SRv6 Opcodes Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes, is_container='container', yang_name="srv6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6Opcodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes, is_container='container', yang_name="srv6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6Opcodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6Opcodes(self):
    self.__srv6Opcodes = YANGDynClass(base=yc_srv6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes, is_container='container', yang_name="srv6Opcodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

  locatorName = __builtin__.property(_get_locatorName, _set_locatorName)
  ipv6Prefix = __builtin__.property(_get_ipv6Prefix, _set_ipv6Prefix)
  maskLength = __builtin__.property(_get_maskLength, _set_maskLength)
  static = __builtin__.property(_get_static, _set_static)
  staticLength = __builtin__.property(_get_staticLength, _set_staticLength)
  args = __builtin__.property(_get_args, _set_args)
  argsLength = __builtin__.property(_get_argsLength, _set_argsLength)
  defaultFlag = __builtin__.property(_get_defaultFlag, _set_defaultFlag)
  srv6Opcodes = __builtin__.property(_get_srv6Opcodes, _set_srv6Opcodes) # type: yc_srv6Opcodes_huawei_segripv6__segripv6_srv6Locators_srv6Locator_srv6Opcodes


  _pyangbind_elements = OrderedDict([('locatorName', locatorName), ('ipv6Prefix', ipv6Prefix), ('maskLength', maskLength), ('static', static), ('staticLength', staticLength), ('args', args), ('argsLength', argsLength), ('defaultFlag', defaultFlag), ('srv6Opcodes', srv6Opcodes), ])


class yc_srv6Locators_huawei_segripv6__segripv6_srv6Locators(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6Locators. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SRv6 Locators Configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6Locator',)

  _yang_name = 'srv6Locators'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6Locator = YANGDynClass(base=YANGListType("locatorName",yc_srv6Locator_huawei_segripv6__segripv6_srv6Locators_srv6Locator, yang_name="srv6Locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="srv6Locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6Locators']

  def _get_srv6Locator(self):
    """
    Getter method for srv6Locator, mapped from YANG variable /segripv6/srv6Locators/srv6Locator (list)

    YANG Description: SRv6 Locator Configuration.
    """
    return self.__srv6Locator
      
  def _set_srv6Locator(self, v, load=False):
    """
    Setter method for srv6Locator, mapped from YANG variable /segripv6/srv6Locators/srv6Locator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6Locator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6Locator() directly.

    YANG Description: SRv6 Locator Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("locatorName",yc_srv6Locator_huawei_segripv6__segripv6_srv6Locators_srv6Locator, yang_name="srv6Locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="srv6Locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6Locator must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("locatorName",yc_srv6Locator_huawei_segripv6__segripv6_srv6Locators_srv6Locator, yang_name="srv6Locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="srv6Locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)""",
        })

    self.__srv6Locator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6Locator(self):
    self.__srv6Locator = YANGDynClass(base=YANGListType("locatorName",yc_srv6Locator_huawei_segripv6__segripv6_srv6Locators_srv6Locator, yang_name="srv6Locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="srv6Locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=True)

  srv6Locator = __builtin__.property(_get_srv6Locator, _set_srv6Locator) # type: yc_srv6Locator_huawei_segripv6__segripv6_srv6Locators_srv6Locator


  _pyangbind_elements = OrderedDict([('srv6Locator', srv6Locator), ])


class yc_srv6EndForwTable_huawei_segripv6__segripv6_srv6EndForwTables_srv6EndForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndForwTables/srv6EndForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endSidValue','__endSidFlavor','__locatorName','__locatorID',)

  _yang_name = 'srv6EndForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endSidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__endSidFlavor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndForwTables', 'srv6EndForwTable']

  def _get_endSidValue(self):
    """
    Getter method for endSidValue, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/endSidValue (inet:ipv6-address-no-zone)

    YANG Description: End SID value.
    """
    return self.__endSidValue
      
  def _set_endSidValue(self, v, load=False):
    """
    Setter method for endSidValue, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/endSidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endSidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endSidValue() directly.

    YANG Description: End SID value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endSidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__endSidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endSidValue(self):
    self.__endSidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_endSidFlavor(self):
    """
    Getter method for endSidFlavor, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/endSidFlavor (string)

    YANG Description: End SID Flavor value.
    """
    return self.__endSidFlavor
      
  def _set_endSidFlavor(self, v, load=False):
    """
    Setter method for endSidFlavor, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/endSidFlavor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endSidFlavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endSidFlavor() directly.

    YANG Description: End SID Flavor value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endSidFlavor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__endSidFlavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endSidFlavor(self):
    self.__endSidFlavor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/locatorName (string)

    YANG Description: Locator Name.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/locatorID (uint32)

    YANG Description: Locator ID.
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: Locator ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

  endSidValue = __builtin__.property(_get_endSidValue)
  endSidFlavor = __builtin__.property(_get_endSidFlavor)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)


  _pyangbind_elements = OrderedDict([('endSidValue', endSidValue), ('endSidFlavor', endSidFlavor), ('locatorName', locatorName), ('locatorID', locatorID), ])


class yc_srv6EndForwTables_huawei_segripv6__segripv6_srv6EndForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndForwTable',)

  _yang_name = 'srv6EndForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndForwTable = YANGDynClass(base=YANGListType("endSidValue",yc_srv6EndForwTable_huawei_segripv6__segripv6_srv6EndForwTables_srv6EndForwTable, yang_name="srv6EndForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endSidValue', extensions=None), is_container='list', yang_name="srv6EndForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndForwTables']

  def _get_srv6EndForwTable(self):
    """
    Getter method for srv6EndForwTable, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable (list)

    YANG Description: Segment Routing IPv6 End Local-Sid list.
    """
    return self.__srv6EndForwTable
      
  def _set_srv6EndForwTable(self, v, load=False):
    """
    Setter method for srv6EndForwTable, mapped from YANG variable /segripv6/srv6EndForwTables/srv6EndForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndForwTable() directly.

    YANG Description: Segment Routing IPv6 End Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("endSidValue",yc_srv6EndForwTable_huawei_segripv6__segripv6_srv6EndForwTables_srv6EndForwTable, yang_name="srv6EndForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endSidValue', extensions=None), is_container='list', yang_name="srv6EndForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("endSidValue",yc_srv6EndForwTable_huawei_segripv6__segripv6_srv6EndForwTables_srv6EndForwTable, yang_name="srv6EndForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endSidValue', extensions=None), is_container='list', yang_name="srv6EndForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndForwTable(self):
    self.__srv6EndForwTable = YANGDynClass(base=YANGListType("endSidValue",yc_srv6EndForwTable_huawei_segripv6__segripv6_srv6EndForwTables_srv6EndForwTable, yang_name="srv6EndForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endSidValue', extensions=None), is_container='list', yang_name="srv6EndForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndForwTable = __builtin__.property(_get_srv6EndForwTable) # type: yc_srv6EndForwTable_huawei_segripv6__segripv6_srv6EndForwTables_srv6EndForwTable


  _pyangbind_elements = OrderedDict([('srv6EndForwTable', srv6EndForwTable), ])


class yc_srv6EndOtpForwTable_huawei_segripv6__segripv6_srv6EndOtpForwTables_srv6EndOtpForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.OTP Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endOtpSidValue','__locatorName','__locatorID',)

  _yang_name = 'srv6EndOtpForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endOtpSidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endOtpSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndOtpForwTables', 'srv6EndOtpForwTable']

  def _get_endOtpSidValue(self):
    """
    Getter method for endOtpSidValue, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable/endOtpSidValue (inet:ipv6-address-no-zone)

    YANG Description: End.OTP SID value.
    """
    return self.__endOtpSidValue
      
  def _set_endOtpSidValue(self, v, load=False):
    """
    Setter method for endOtpSidValue, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable/endOtpSidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endOtpSidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endOtpSidValue() directly.

    YANG Description: End.OTP SID value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endOtpSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endOtpSidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endOtpSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__endOtpSidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endOtpSidValue(self):
    self.__endOtpSidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endOtpSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable/locatorName (string)

    YANG Description: Locator Name.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable/locatorID (uint32)

    YANG Description: Locator ID.
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: Locator ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

  endOtpSidValue = __builtin__.property(_get_endOtpSidValue)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)


  _pyangbind_elements = OrderedDict([('endOtpSidValue', endOtpSidValue), ('locatorName', locatorName), ('locatorID', locatorID), ])


class yc_srv6EndOtpForwTables_huawei_segripv6__segripv6_srv6EndOtpForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndOtpForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.OTP Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndOtpForwTable',)

  _yang_name = 'srv6EndOtpForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndOtpForwTable = YANGDynClass(base=YANGListType("endOtpSidValue",yc_srv6EndOtpForwTable_huawei_segripv6__segripv6_srv6EndOtpForwTables_srv6EndOtpForwTable, yang_name="srv6EndOtpForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endOtpSidValue', extensions=None), is_container='list', yang_name="srv6EndOtpForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndOtpForwTables']

  def _get_srv6EndOtpForwTable(self):
    """
    Getter method for srv6EndOtpForwTable, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable (list)

    YANG Description: Segment Routing IPv6 End.OTP Local-Sid list.
    """
    return self.__srv6EndOtpForwTable
      
  def _set_srv6EndOtpForwTable(self, v, load=False):
    """
    Setter method for srv6EndOtpForwTable, mapped from YANG variable /segripv6/srv6EndOtpForwTables/srv6EndOtpForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndOtpForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndOtpForwTable() directly.

    YANG Description: Segment Routing IPv6 End.OTP Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("endOtpSidValue",yc_srv6EndOtpForwTable_huawei_segripv6__segripv6_srv6EndOtpForwTables_srv6EndOtpForwTable, yang_name="srv6EndOtpForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endOtpSidValue', extensions=None), is_container='list', yang_name="srv6EndOtpForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndOtpForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("endOtpSidValue",yc_srv6EndOtpForwTable_huawei_segripv6__segripv6_srv6EndOtpForwTables_srv6EndOtpForwTable, yang_name="srv6EndOtpForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endOtpSidValue', extensions=None), is_container='list', yang_name="srv6EndOtpForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndOtpForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndOtpForwTable(self):
    self.__srv6EndOtpForwTable = YANGDynClass(base=YANGListType("endOtpSidValue",yc_srv6EndOtpForwTable_huawei_segripv6__segripv6_srv6EndOtpForwTables_srv6EndOtpForwTable, yang_name="srv6EndOtpForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endOtpSidValue', extensions=None), is_container='list', yang_name="srv6EndOtpForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndOtpForwTable = __builtin__.property(_get_srv6EndOtpForwTable) # type: yc_srv6EndOtpForwTable_huawei_segripv6__segripv6_srv6EndOtpForwTables_srv6EndOtpForwTable


  _pyangbind_elements = OrderedDict([('srv6EndOtpForwTable', srv6EndOtpForwTable), ])


class yc_endXSidNhpInfo_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos_endXSidNhpInfo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Next hop information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface','__nextHop',)

  _yang_name = 'endXSidNhpInfo'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndXForwTables', 'srv6EndXForwTable', 'endXSidNhpInfos', 'endXSidNhpInfo']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo/interface (string)

    YANG Description: Exit interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo/interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Exit interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_nextHop(self):
    """
    Getter method for nextHop, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo/nextHop (inet:ipv6-address-no-zone)

    YANG Description: Next hop ipv6 address.
    """
    return self.__nextHop
      
  def _set_nextHop(self, v, load=False):
    """
    Setter method for nextHop, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo/nextHop (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHop() directly.

    YANG Description: Next hop ipv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHop must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__nextHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHop(self):
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)

  interface = __builtin__.property(_get_interface)
  nextHop = __builtin__.property(_get_nextHop)


  _pyangbind_elements = OrderedDict([('interface', interface), ('nextHop', nextHop), ])


class yc_endXSidNhpInfos_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Next hop information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endXSidNhpInfo',)

  _yang_name = 'endXSidNhpInfos'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endXSidNhpInfo = YANGDynClass(base=YANGListType("interface nextHop",yc_endXSidNhpInfo_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos_endXSidNhpInfo, yang_name="endXSidNhpInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface nextHop', extensions=None), is_container='list', yang_name="endXSidNhpInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndXForwTables', 'srv6EndXForwTable', 'endXSidNhpInfos']

  def _get_endXSidNhpInfo(self):
    """
    Getter method for endXSidNhpInfo, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo (list)

    YANG Description: Next hop information.
    """
    return self.__endXSidNhpInfo
      
  def _set_endXSidNhpInfo(self, v, load=False):
    """
    Setter method for endXSidNhpInfo, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos/endXSidNhpInfo (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endXSidNhpInfo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endXSidNhpInfo() directly.

    YANG Description: Next hop information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interface nextHop",yc_endXSidNhpInfo_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos_endXSidNhpInfo, yang_name="endXSidNhpInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface nextHop', extensions=None), is_container='list', yang_name="endXSidNhpInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endXSidNhpInfo must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface nextHop",yc_endXSidNhpInfo_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos_endXSidNhpInfo, yang_name="endXSidNhpInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface nextHop', extensions=None), is_container='list', yang_name="endXSidNhpInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__endXSidNhpInfo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endXSidNhpInfo(self):
    self.__endXSidNhpInfo = YANGDynClass(base=YANGListType("interface nextHop",yc_endXSidNhpInfo_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos_endXSidNhpInfo, yang_name="endXSidNhpInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface nextHop', extensions=None), is_container='list', yang_name="endXSidNhpInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  endXSidNhpInfo = __builtin__.property(_get_endXSidNhpInfo) # type: yc_endXSidNhpInfo_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos_endXSidNhpInfo


  _pyangbind_elements = OrderedDict([('endXSidNhpInfo', endXSidNhpInfo), ])


class yc_srv6EndXForwTable_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndXForwTables/srv6EndXForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.X Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endXSidValue','__endXSidFlavor','__locatorName','__locatorID','__endXSidNhpInfos',)

  _yang_name = 'srv6EndXForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endXSidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__endXSidFlavor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endXSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    self.__endXSidNhpInfos = YANGDynClass(base=yc_endXSidNhpInfos_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos, is_container='container', yang_name="endXSidNhpInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndXForwTables', 'srv6EndXForwTable']

  def _get_endXSidValue(self):
    """
    Getter method for endXSidValue, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidValue (inet:ipv6-address-no-zone)

    YANG Description: End.X sid value.
    """
    return self.__endXSidValue
      
  def _set_endXSidValue(self, v, load=False):
    """
    Setter method for endXSidValue, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endXSidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endXSidValue() directly.

    YANG Description: End.X sid value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endXSidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__endXSidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endXSidValue(self):
    self.__endXSidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_endXSidFlavor(self):
    """
    Getter method for endXSidFlavor, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidFlavor (string)

    YANG Description: End.X sid flavor value.
    """
    return self.__endXSidFlavor
      
  def _set_endXSidFlavor(self, v, load=False):
    """
    Setter method for endXSidFlavor, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidFlavor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endXSidFlavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endXSidFlavor() directly.

    YANG Description: End.X sid flavor value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endXSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endXSidFlavor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endXSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__endXSidFlavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endXSidFlavor(self):
    self.__endXSidFlavor = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="endXSidFlavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/locatorName (string)

    YANG Description: Locator Name.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/locatorID (uint32)

    YANG Description: Locator ID.
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: Locator ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)


  def _get_endXSidNhpInfos(self):
    """
    Getter method for endXSidNhpInfos, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos (container)

    YANG Description: Next hop information.
    """
    return self.__endXSidNhpInfos
      
  def _set_endXSidNhpInfos(self, v, load=False):
    """
    Setter method for endXSidNhpInfos, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable/endXSidNhpInfos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endXSidNhpInfos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endXSidNhpInfos() directly.

    YANG Description: Next hop information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endXSidNhpInfos_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos, is_container='container', yang_name="endXSidNhpInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endXSidNhpInfos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endXSidNhpInfos_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos, is_container='container', yang_name="endXSidNhpInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=False)""",
        })

    self.__endXSidNhpInfos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endXSidNhpInfos(self):
    self.__endXSidNhpInfos = YANGDynClass(base=yc_endXSidNhpInfos_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos, is_container='container', yang_name="endXSidNhpInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=False)

  endXSidValue = __builtin__.property(_get_endXSidValue)
  endXSidFlavor = __builtin__.property(_get_endXSidFlavor)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)
  endXSidNhpInfos = __builtin__.property(_get_endXSidNhpInfos) # type: yc_endXSidNhpInfos_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable_endXSidNhpInfos


  _pyangbind_elements = OrderedDict([('endXSidValue', endXSidValue), ('endXSidFlavor', endXSidFlavor), ('locatorName', locatorName), ('locatorID', locatorID), ('endXSidNhpInfos', endXSidNhpInfos), ])


class yc_srv6EndXForwTables_huawei_segripv6__segripv6_srv6EndXForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndXForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.X Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndXForwTable',)

  _yang_name = 'srv6EndXForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndXForwTable = YANGDynClass(base=YANGListType("endXSidValue",yc_srv6EndXForwTable_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable, yang_name="srv6EndXForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSidValue', extensions=None), is_container='list', yang_name="srv6EndXForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndXForwTables']

  def _get_srv6EndXForwTable(self):
    """
    Getter method for srv6EndXForwTable, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable (list)

    YANG Description: Segment Routing IPv6 End.X Local-Sid list.
    """
    return self.__srv6EndXForwTable
      
  def _set_srv6EndXForwTable(self, v, load=False):
    """
    Setter method for srv6EndXForwTable, mapped from YANG variable /segripv6/srv6EndXForwTables/srv6EndXForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndXForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndXForwTable() directly.

    YANG Description: Segment Routing IPv6 End.X Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("endXSidValue",yc_srv6EndXForwTable_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable, yang_name="srv6EndXForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSidValue', extensions=None), is_container='list', yang_name="srv6EndXForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndXForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("endXSidValue",yc_srv6EndXForwTable_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable, yang_name="srv6EndXForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSidValue', extensions=None), is_container='list', yang_name="srv6EndXForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndXForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndXForwTable(self):
    self.__srv6EndXForwTable = YANGDynClass(base=YANGListType("endXSidValue",yc_srv6EndXForwTable_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable, yang_name="srv6EndXForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSidValue', extensions=None), is_container='list', yang_name="srv6EndXForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndXForwTable = __builtin__.property(_get_srv6EndXForwTable) # type: yc_srv6EndXForwTable_huawei_segripv6__segripv6_srv6EndXForwTables_srv6EndXForwTable


  _pyangbind_elements = OrderedDict([('srv6EndXForwTable', srv6EndXForwTable), ])


class yc_srv6EndDt4ForwTable_huawei_segripv6__segripv6_srv6EndDt4ForwTables_srv6EndDt4ForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.DT4 Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6SidValue','__vpnName','__vpnID','__locatorName','__locatorID',)

  _yang_name = 'srv6EndDt4ForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__vpnName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__vpnID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDt4ForwTables', 'srv6EndDt4ForwTable']

  def _get_srv6SidValue(self):
    """
    Getter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/srv6SidValue (inet:ipv6-address-no-zone)

    YANG Description: End.DT4 Sid value.
    """
    return self.__srv6SidValue
      
  def _set_srv6SidValue(self, v, load=False):
    """
    Setter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/srv6SidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6SidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6SidValue() directly.

    YANG Description: End.DT4 Sid value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6SidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__srv6SidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6SidValue(self):
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_vpnName(self):
    """
    Getter method for vpnName, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/vpnName (string)

    YANG Description: VPN Name.
    """
    return self.__vpnName
      
  def _set_vpnName(self, v, load=False):
    """
    Setter method for vpnName, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/vpnName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnName() directly.

    YANG Description: VPN Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__vpnName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnName(self):
    self.__vpnName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_vpnID(self):
    """
    Getter method for vpnID, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/vpnID (uint32)

    YANG Description: VPN ID.
    """
    return self.__vpnID
      
  def _set_vpnID(self, v, load=False):
    """
    Setter method for vpnID, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/vpnID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnID() directly.

    YANG Description: VPN ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__vpnID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnID(self):
    self.__vpnID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/locatorName (string)

    YANG Description: Locator Name.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/locatorID (uint32)

    YANG Description: Locator ID.
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: Locator ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

  srv6SidValue = __builtin__.property(_get_srv6SidValue)
  vpnName = __builtin__.property(_get_vpnName)
  vpnID = __builtin__.property(_get_vpnID)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)


  _pyangbind_elements = OrderedDict([('srv6SidValue', srv6SidValue), ('vpnName', vpnName), ('vpnID', vpnID), ('locatorName', locatorName), ('locatorID', locatorID), ])


class yc_srv6EndDt4ForwTables_huawei_segripv6__segripv6_srv6EndDt4ForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDt4ForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.DT4 Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndDt4ForwTable',)

  _yang_name = 'srv6EndDt4ForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndDt4ForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDt4ForwTable_huawei_segripv6__segripv6_srv6EndDt4ForwTables_srv6EndDt4ForwTable, yang_name="srv6EndDt4ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt4ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDt4ForwTables']

  def _get_srv6EndDt4ForwTable(self):
    """
    Getter method for srv6EndDt4ForwTable, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable (list)

    YANG Description: Segment Routing IPv6 End.DT4 Local-Sid list.
    """
    return self.__srv6EndDt4ForwTable
      
  def _set_srv6EndDt4ForwTable(self, v, load=False):
    """
    Setter method for srv6EndDt4ForwTable, mapped from YANG variable /segripv6/srv6EndDt4ForwTables/srv6EndDt4ForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDt4ForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDt4ForwTable() directly.

    YANG Description: Segment Routing IPv6 End.DT4 Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srv6SidValue",yc_srv6EndDt4ForwTable_huawei_segripv6__segripv6_srv6EndDt4ForwTables_srv6EndDt4ForwTable, yang_name="srv6EndDt4ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt4ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDt4ForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDt4ForwTable_huawei_segripv6__segripv6_srv6EndDt4ForwTables_srv6EndDt4ForwTable, yang_name="srv6EndDt4ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt4ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndDt4ForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDt4ForwTable(self):
    self.__srv6EndDt4ForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDt4ForwTable_huawei_segripv6__segripv6_srv6EndDt4ForwTables_srv6EndDt4ForwTable, yang_name="srv6EndDt4ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt4ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndDt4ForwTable = __builtin__.property(_get_srv6EndDt4ForwTable) # type: yc_srv6EndDt4ForwTable_huawei_segripv6__segripv6_srv6EndDt4ForwTables_srv6EndDt4ForwTable


  _pyangbind_elements = OrderedDict([('srv6EndDt4ForwTable', srv6EndDt4ForwTable), ])


class yc_srv6EndDt6ForwTable_huawei_segripv6__segripv6_srv6EndDt6ForwTables_srv6EndDt6ForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.DT6 Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6SidValue','__vpnName','__vpnID','__locatorName','__locatorID',)

  _yang_name = 'srv6EndDt6ForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__vpnName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__vpnID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDt6ForwTables', 'srv6EndDt6ForwTable']

  def _get_srv6SidValue(self):
    """
    Getter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/srv6SidValue (inet:ipv6-address-no-zone)

    YANG Description: End.DT6 Sid value.
    """
    return self.__srv6SidValue
      
  def _set_srv6SidValue(self, v, load=False):
    """
    Setter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/srv6SidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6SidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6SidValue() directly.

    YANG Description: End.DT6 Sid value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6SidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__srv6SidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6SidValue(self):
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_vpnName(self):
    """
    Getter method for vpnName, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/vpnName (string)

    YANG Description: VPN Name.
    """
    return self.__vpnName
      
  def _set_vpnName(self, v, load=False):
    """
    Setter method for vpnName, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/vpnName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnName() directly.

    YANG Description: VPN Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__vpnName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnName(self):
    self.__vpnName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_vpnID(self):
    """
    Getter method for vpnID, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/vpnID (uint32)

    YANG Description: VPN ID.
    """
    return self.__vpnID
      
  def _set_vpnID(self, v, load=False):
    """
    Setter method for vpnID, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/vpnID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnID() directly.

    YANG Description: VPN ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__vpnID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnID(self):
    self.__vpnID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="vpnID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/locatorName (string)

    YANG Description: Locator Name.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/locatorID (uint32)

    YANG Description: Locator ID.
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: Locator ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

  srv6SidValue = __builtin__.property(_get_srv6SidValue)
  vpnName = __builtin__.property(_get_vpnName)
  vpnID = __builtin__.property(_get_vpnID)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)


  _pyangbind_elements = OrderedDict([('srv6SidValue', srv6SidValue), ('vpnName', vpnName), ('vpnID', vpnID), ('locatorName', locatorName), ('locatorID', locatorID), ])


class yc_srv6EndDt6ForwTables_huawei_segripv6__segripv6_srv6EndDt6ForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDt6ForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6 End.DT6 Local-Sid list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndDt6ForwTable',)

  _yang_name = 'srv6EndDt6ForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndDt6ForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDt6ForwTable_huawei_segripv6__segripv6_srv6EndDt6ForwTables_srv6EndDt6ForwTable, yang_name="srv6EndDt6ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt6ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDt6ForwTables']

  def _get_srv6EndDt6ForwTable(self):
    """
    Getter method for srv6EndDt6ForwTable, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable (list)

    YANG Description: Segment Routing IPv6 End.DT6 Local-Sid list.
    """
    return self.__srv6EndDt6ForwTable
      
  def _set_srv6EndDt6ForwTable(self, v, load=False):
    """
    Setter method for srv6EndDt6ForwTable, mapped from YANG variable /segripv6/srv6EndDt6ForwTables/srv6EndDt6ForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDt6ForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDt6ForwTable() directly.

    YANG Description: Segment Routing IPv6 End.DT6 Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srv6SidValue",yc_srv6EndDt6ForwTable_huawei_segripv6__segripv6_srv6EndDt6ForwTables_srv6EndDt6ForwTable, yang_name="srv6EndDt6ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt6ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDt6ForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDt6ForwTable_huawei_segripv6__segripv6_srv6EndDt6ForwTables_srv6EndDt6ForwTable, yang_name="srv6EndDt6ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt6ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndDt6ForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDt6ForwTable(self):
    self.__srv6EndDt6ForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDt6ForwTable_huawei_segripv6__segripv6_srv6EndDt6ForwTables_srv6EndDt6ForwTable, yang_name="srv6EndDt6ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDt6ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndDt6ForwTable = __builtin__.property(_get_srv6EndDt6ForwTable) # type: yc_srv6EndDt6ForwTable_huawei_segripv6__segripv6_srv6EndDt6ForwTables_srv6EndDt6ForwTable


  _pyangbind_elements = OrderedDict([('srv6EndDt6ForwTable', srv6EndDt6ForwTable), ])


class yc_srv6EndDx2ForwTable_huawei_segripv6__segripv6_srv6EndDx2ForwTables_srv6EndDx2ForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6SidValue','__evplID','__locatorName','__locatorID',)

  _yang_name = 'srv6EndDx2ForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDx2ForwTables', 'srv6EndDx2ForwTable']

  def _get_srv6SidValue(self):
    """
    Getter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/srv6SidValue (inet:ipv6-address-no-zone)
    """
    return self.__srv6SidValue
      
  def _set_srv6SidValue(self, v, load=False):
    """
    Setter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/srv6SidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6SidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6SidValue() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6SidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__srv6SidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6SidValue(self):
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_evplID(self):
    """
    Getter method for evplID, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/evplID (uint32)
    """
    return self.__evplID
      
  def _set_evplID(self, v, load=False):
    """
    Setter method for evplID, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/evplID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evplID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evplID() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evplID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__evplID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evplID(self):
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/locatorName (string)
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/locatorID (uint32)

    YANG Description: locator ID
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: locator ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

  srv6SidValue = __builtin__.property(_get_srv6SidValue)
  evplID = __builtin__.property(_get_evplID)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)


  _pyangbind_elements = OrderedDict([('srv6SidValue', srv6SidValue), ('evplID', evplID), ('locatorName', locatorName), ('locatorID', locatorID), ])


class yc_srv6EndDx2ForwTables_huawei_segripv6__segripv6_srv6EndDx2ForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDx2ForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndDx2ForwTable',)

  _yang_name = 'srv6EndDx2ForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndDx2ForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDx2ForwTable_huawei_segripv6__segripv6_srv6EndDx2ForwTables_srv6EndDx2ForwTable, yang_name="srv6EndDx2ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDx2ForwTables']

  def _get_srv6EndDx2ForwTable(self):
    """
    Getter method for srv6EndDx2ForwTable, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable (list)
    """
    return self.__srv6EndDx2ForwTable
      
  def _set_srv6EndDx2ForwTable(self, v, load=False):
    """
    Setter method for srv6EndDx2ForwTable, mapped from YANG variable /segripv6/srv6EndDx2ForwTables/srv6EndDx2ForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDx2ForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDx2ForwTable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srv6SidValue",yc_srv6EndDx2ForwTable_huawei_segripv6__segripv6_srv6EndDx2ForwTables_srv6EndDx2ForwTable, yang_name="srv6EndDx2ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDx2ForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDx2ForwTable_huawei_segripv6__segripv6_srv6EndDx2ForwTables_srv6EndDx2ForwTable, yang_name="srv6EndDx2ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndDx2ForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDx2ForwTable(self):
    self.__srv6EndDx2ForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDx2ForwTable_huawei_segripv6__segripv6_srv6EndDx2ForwTables_srv6EndDx2ForwTable, yang_name="srv6EndDx2ForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2ForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndDx2ForwTable = __builtin__.property(_get_srv6EndDx2ForwTable) # type: yc_srv6EndDx2ForwTable_huawei_segripv6__segripv6_srv6EndDx2ForwTables_srv6EndDx2ForwTable


  _pyangbind_elements = OrderedDict([('srv6EndDx2ForwTable', srv6EndDx2ForwTable), ])


class yc_srv6EndDx2lForwTable_huawei_segripv6__segripv6_srv6EndDx2lForwTables_srv6EndDx2lForwTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6SidValue','__evplID','__locatorName','__locatorID',)

  _yang_name = 'srv6EndDx2lForwTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDx2lForwTables', 'srv6EndDx2lForwTable']

  def _get_srv6SidValue(self):
    """
    Getter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/srv6SidValue (inet:ipv6-address-no-zone)
    """
    return self.__srv6SidValue
      
  def _set_srv6SidValue(self, v, load=False):
    """
    Setter method for srv6SidValue, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/srv6SidValue (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6SidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6SidValue() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6SidValue must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__srv6SidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6SidValue(self):
    self.__srv6SidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="srv6SidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_evplID(self):
    """
    Getter method for evplID, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/evplID (uint32)
    """
    return self.__evplID
      
  def _set_evplID(self, v, load=False):
    """
    Setter method for evplID, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/evplID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evplID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evplID() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evplID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__evplID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evplID(self):
    self.__evplID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="evplID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/locatorName (string)
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/locatorName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='string', is_config=False)


  def _get_locatorID(self):
    """
    Getter method for locatorID, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/locatorID (uint32)

    YANG Description: locator ID
    """
    return self.__locatorID
      
  def _set_locatorID(self, v, load=False):
    """
    Setter method for locatorID, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable/locatorID (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorID() directly.

    YANG Description: locator ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorID must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)""",
        })

    self.__locatorID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorID(self):
    self.__locatorID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="locatorID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='uint32', is_config=False)

  srv6SidValue = __builtin__.property(_get_srv6SidValue)
  evplID = __builtin__.property(_get_evplID)
  locatorName = __builtin__.property(_get_locatorName)
  locatorID = __builtin__.property(_get_locatorID)


  _pyangbind_elements = OrderedDict([('srv6SidValue', srv6SidValue), ('evplID', evplID), ('locatorName', locatorName), ('locatorID', locatorID), ])


class yc_srv6EndDx2lForwTables_huawei_segripv6__segripv6_srv6EndDx2lForwTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6/srv6EndDx2lForwTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6EndDx2lForwTable',)

  _yang_name = 'srv6EndDx2lForwTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6EndDx2lForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDx2lForwTable_huawei_segripv6__segripv6_srv6EndDx2lForwTables_srv6EndDx2lForwTable, yang_name="srv6EndDx2lForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2lForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6', 'srv6EndDx2lForwTables']

  def _get_srv6EndDx2lForwTable(self):
    """
    Getter method for srv6EndDx2lForwTable, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable (list)
    """
    return self.__srv6EndDx2lForwTable
      
  def _set_srv6EndDx2lForwTable(self, v, load=False):
    """
    Setter method for srv6EndDx2lForwTable, mapped from YANG variable /segripv6/srv6EndDx2lForwTables/srv6EndDx2lForwTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDx2lForwTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDx2lForwTable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srv6SidValue",yc_srv6EndDx2lForwTable_huawei_segripv6__segripv6_srv6EndDx2lForwTables_srv6EndDx2lForwTable, yang_name="srv6EndDx2lForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2lForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDx2lForwTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDx2lForwTable_huawei_segripv6__segripv6_srv6EndDx2lForwTables_srv6EndDx2lForwTable, yang_name="srv6EndDx2lForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2lForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)""",
        })

    self.__srv6EndDx2lForwTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDx2lForwTable(self):
    self.__srv6EndDx2lForwTable = YANGDynClass(base=YANGListType("srv6SidValue",yc_srv6EndDx2lForwTable_huawei_segripv6__segripv6_srv6EndDx2lForwTables_srv6EndDx2lForwTable, yang_name="srv6EndDx2lForwTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srv6SidValue', extensions=None), is_container='list', yang_name="srv6EndDx2lForwTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='list', is_config=False)

  srv6EndDx2lForwTable = __builtin__.property(_get_srv6EndDx2lForwTable) # type: yc_srv6EndDx2lForwTable_huawei_segripv6__segripv6_srv6EndDx2lForwTables_srv6EndDx2lForwTable


  _pyangbind_elements = OrderedDict([('srv6EndDx2lForwTable', srv6EndDx2lForwTable), ])


class yc_segripv6_huawei_segripv6__segripv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /segripv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srv6Site','__srv6RemoteEndOtps','__srv6Locators','__srv6EndForwTables','__srv6EndOtpForwTables','__srv6EndXForwTables','__srv6EndDt4ForwTables','__srv6EndDt6ForwTables','__srv6EndDx2ForwTables','__srv6EndDx2lForwTables',)

  _yang_name = 'segripv6'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srv6Site = YANGDynClass(base=yc_srv6Site_huawei_segripv6__segripv6_srv6Site, is_container='container', yang_name="srv6Site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6RemoteEndOtps = YANGDynClass(base=yc_srv6RemoteEndOtps_huawei_segripv6__segripv6_srv6RemoteEndOtps, is_container='container', yang_name="srv6RemoteEndOtps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6Locators = YANGDynClass(base=yc_srv6Locators_huawei_segripv6__segripv6_srv6Locators, is_container='container', yang_name="srv6Locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndForwTables = YANGDynClass(base=yc_srv6EndForwTables_huawei_segripv6__segripv6_srv6EndForwTables, is_container='container', yang_name="srv6EndForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndOtpForwTables = YANGDynClass(base=yc_srv6EndOtpForwTables_huawei_segripv6__segripv6_srv6EndOtpForwTables, is_container='container', yang_name="srv6EndOtpForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndXForwTables = YANGDynClass(base=yc_srv6EndXForwTables_huawei_segripv6__segripv6_srv6EndXForwTables, is_container='container', yang_name="srv6EndXForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndDt4ForwTables = YANGDynClass(base=yc_srv6EndDt4ForwTables_huawei_segripv6__segripv6_srv6EndDt4ForwTables, is_container='container', yang_name="srv6EndDt4ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndDt6ForwTables = YANGDynClass(base=yc_srv6EndDt6ForwTables_huawei_segripv6__segripv6_srv6EndDt6ForwTables, is_container='container', yang_name="srv6EndDt6ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndDx2ForwTables = YANGDynClass(base=yc_srv6EndDx2ForwTables_huawei_segripv6__segripv6_srv6EndDx2ForwTables, is_container='container', yang_name="srv6EndDx2ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    self.__srv6EndDx2lForwTables = YANGDynClass(base=yc_srv6EndDx2lForwTables_huawei_segripv6__segripv6_srv6EndDx2lForwTables, is_container='container', yang_name="srv6EndDx2lForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['segripv6']

  def _get_srv6Site(self):
    """
    Getter method for srv6Site, mapped from YANG variable /segripv6/srv6Site (container)

    YANG Description: Display Segment Routing IPv6 status, enable or disable Segment Routing IPv6.
    """
    return self.__srv6Site
      
  def _set_srv6Site(self, v, load=False):
    """
    Setter method for srv6Site, mapped from YANG variable /segripv6/srv6Site (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6Site is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6Site() directly.

    YANG Description: Display Segment Routing IPv6 status, enable or disable Segment Routing IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6Site_huawei_segripv6__segripv6_srv6Site, is_container='container', yang_name="srv6Site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6Site must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6Site_huawei_segripv6__segripv6_srv6Site, is_container='container', yang_name="srv6Site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6Site = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6Site(self):
    self.__srv6Site = YANGDynClass(base=yc_srv6Site_huawei_segripv6__segripv6_srv6Site, is_container='container', yang_name="srv6Site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6RemoteEndOtps(self):
    """
    Getter method for srv6RemoteEndOtps, mapped from YANG variable /segripv6/srv6RemoteEndOtps (container)

    YANG Description: SRv6 Remote End.OTP Configuration.
    """
    return self.__srv6RemoteEndOtps
      
  def _set_srv6RemoteEndOtps(self, v, load=False):
    """
    Setter method for srv6RemoteEndOtps, mapped from YANG variable /segripv6/srv6RemoteEndOtps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6RemoteEndOtps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6RemoteEndOtps() directly.

    YANG Description: SRv6 Remote End.OTP Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6RemoteEndOtps_huawei_segripv6__segripv6_srv6RemoteEndOtps, is_container='container', yang_name="srv6RemoteEndOtps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6RemoteEndOtps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6RemoteEndOtps_huawei_segripv6__segripv6_srv6RemoteEndOtps, is_container='container', yang_name="srv6RemoteEndOtps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6RemoteEndOtps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6RemoteEndOtps(self):
    self.__srv6RemoteEndOtps = YANGDynClass(base=yc_srv6RemoteEndOtps_huawei_segripv6__segripv6_srv6RemoteEndOtps, is_container='container', yang_name="srv6RemoteEndOtps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6Locators(self):
    """
    Getter method for srv6Locators, mapped from YANG variable /segripv6/srv6Locators (container)

    YANG Description: SRv6 Locators Configuration.
    """
    return self.__srv6Locators
      
  def _set_srv6Locators(self, v, load=False):
    """
    Setter method for srv6Locators, mapped from YANG variable /segripv6/srv6Locators (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6Locators is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6Locators() directly.

    YANG Description: SRv6 Locators Configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6Locators_huawei_segripv6__segripv6_srv6Locators, is_container='container', yang_name="srv6Locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6Locators must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6Locators_huawei_segripv6__segripv6_srv6Locators, is_container='container', yang_name="srv6Locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6Locators = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6Locators(self):
    self.__srv6Locators = YANGDynClass(base=yc_srv6Locators_huawei_segripv6__segripv6_srv6Locators, is_container='container', yang_name="srv6Locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndForwTables(self):
    """
    Getter method for srv6EndForwTables, mapped from YANG variable /segripv6/srv6EndForwTables (container)

    YANG Description: Segment Routing IPv6 End Local-Sid list.
    """
    return self.__srv6EndForwTables
      
  def _set_srv6EndForwTables(self, v, load=False):
    """
    Setter method for srv6EndForwTables, mapped from YANG variable /segripv6/srv6EndForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndForwTables() directly.

    YANG Description: Segment Routing IPv6 End Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndForwTables_huawei_segripv6__segripv6_srv6EndForwTables, is_container='container', yang_name="srv6EndForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndForwTables_huawei_segripv6__segripv6_srv6EndForwTables, is_container='container', yang_name="srv6EndForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndForwTables(self):
    self.__srv6EndForwTables = YANGDynClass(base=yc_srv6EndForwTables_huawei_segripv6__segripv6_srv6EndForwTables, is_container='container', yang_name="srv6EndForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndOtpForwTables(self):
    """
    Getter method for srv6EndOtpForwTables, mapped from YANG variable /segripv6/srv6EndOtpForwTables (container)

    YANG Description: Segment Routing IPv6 End.OTP Local-Sid list.
    """
    return self.__srv6EndOtpForwTables
      
  def _set_srv6EndOtpForwTables(self, v, load=False):
    """
    Setter method for srv6EndOtpForwTables, mapped from YANG variable /segripv6/srv6EndOtpForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndOtpForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndOtpForwTables() directly.

    YANG Description: Segment Routing IPv6 End.OTP Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndOtpForwTables_huawei_segripv6__segripv6_srv6EndOtpForwTables, is_container='container', yang_name="srv6EndOtpForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndOtpForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndOtpForwTables_huawei_segripv6__segripv6_srv6EndOtpForwTables, is_container='container', yang_name="srv6EndOtpForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndOtpForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndOtpForwTables(self):
    self.__srv6EndOtpForwTables = YANGDynClass(base=yc_srv6EndOtpForwTables_huawei_segripv6__segripv6_srv6EndOtpForwTables, is_container='container', yang_name="srv6EndOtpForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndXForwTables(self):
    """
    Getter method for srv6EndXForwTables, mapped from YANG variable /segripv6/srv6EndXForwTables (container)

    YANG Description: Segment Routing IPv6 End.X Local-Sid list.
    """
    return self.__srv6EndXForwTables
      
  def _set_srv6EndXForwTables(self, v, load=False):
    """
    Setter method for srv6EndXForwTables, mapped from YANG variable /segripv6/srv6EndXForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndXForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndXForwTables() directly.

    YANG Description: Segment Routing IPv6 End.X Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndXForwTables_huawei_segripv6__segripv6_srv6EndXForwTables, is_container='container', yang_name="srv6EndXForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndXForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndXForwTables_huawei_segripv6__segripv6_srv6EndXForwTables, is_container='container', yang_name="srv6EndXForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndXForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndXForwTables(self):
    self.__srv6EndXForwTables = YANGDynClass(base=yc_srv6EndXForwTables_huawei_segripv6__segripv6_srv6EndXForwTables, is_container='container', yang_name="srv6EndXForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndDt4ForwTables(self):
    """
    Getter method for srv6EndDt4ForwTables, mapped from YANG variable /segripv6/srv6EndDt4ForwTables (container)

    YANG Description: Segment Routing IPv6 End.DT4 Local-Sid list.
    """
    return self.__srv6EndDt4ForwTables
      
  def _set_srv6EndDt4ForwTables(self, v, load=False):
    """
    Setter method for srv6EndDt4ForwTables, mapped from YANG variable /segripv6/srv6EndDt4ForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDt4ForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDt4ForwTables() directly.

    YANG Description: Segment Routing IPv6 End.DT4 Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndDt4ForwTables_huawei_segripv6__segripv6_srv6EndDt4ForwTables, is_container='container', yang_name="srv6EndDt4ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDt4ForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndDt4ForwTables_huawei_segripv6__segripv6_srv6EndDt4ForwTables, is_container='container', yang_name="srv6EndDt4ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndDt4ForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDt4ForwTables(self):
    self.__srv6EndDt4ForwTables = YANGDynClass(base=yc_srv6EndDt4ForwTables_huawei_segripv6__segripv6_srv6EndDt4ForwTables, is_container='container', yang_name="srv6EndDt4ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndDt6ForwTables(self):
    """
    Getter method for srv6EndDt6ForwTables, mapped from YANG variable /segripv6/srv6EndDt6ForwTables (container)

    YANG Description: Segment Routing IPv6 End.DT6 Local-Sid list.
    """
    return self.__srv6EndDt6ForwTables
      
  def _set_srv6EndDt6ForwTables(self, v, load=False):
    """
    Setter method for srv6EndDt6ForwTables, mapped from YANG variable /segripv6/srv6EndDt6ForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDt6ForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDt6ForwTables() directly.

    YANG Description: Segment Routing IPv6 End.DT6 Local-Sid list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndDt6ForwTables_huawei_segripv6__segripv6_srv6EndDt6ForwTables, is_container='container', yang_name="srv6EndDt6ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDt6ForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndDt6ForwTables_huawei_segripv6__segripv6_srv6EndDt6ForwTables, is_container='container', yang_name="srv6EndDt6ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndDt6ForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDt6ForwTables(self):
    self.__srv6EndDt6ForwTables = YANGDynClass(base=yc_srv6EndDt6ForwTables_huawei_segripv6__segripv6_srv6EndDt6ForwTables, is_container='container', yang_name="srv6EndDt6ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndDx2ForwTables(self):
    """
    Getter method for srv6EndDx2ForwTables, mapped from YANG variable /segripv6/srv6EndDx2ForwTables (container)
    """
    return self.__srv6EndDx2ForwTables
      
  def _set_srv6EndDx2ForwTables(self, v, load=False):
    """
    Setter method for srv6EndDx2ForwTables, mapped from YANG variable /segripv6/srv6EndDx2ForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDx2ForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDx2ForwTables() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndDx2ForwTables_huawei_segripv6__segripv6_srv6EndDx2ForwTables, is_container='container', yang_name="srv6EndDx2ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDx2ForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndDx2ForwTables_huawei_segripv6__segripv6_srv6EndDx2ForwTables, is_container='container', yang_name="srv6EndDx2ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndDx2ForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDx2ForwTables(self):
    self.__srv6EndDx2ForwTables = YANGDynClass(base=yc_srv6EndDx2ForwTables_huawei_segripv6__segripv6_srv6EndDx2ForwTables, is_container='container', yang_name="srv6EndDx2ForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)


  def _get_srv6EndDx2lForwTables(self):
    """
    Getter method for srv6EndDx2lForwTables, mapped from YANG variable /segripv6/srv6EndDx2lForwTables (container)
    """
    return self.__srv6EndDx2lForwTables
      
  def _set_srv6EndDx2lForwTables(self, v, load=False):
    """
    Setter method for srv6EndDx2lForwTables, mapped from YANG variable /segripv6/srv6EndDx2lForwTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srv6EndDx2lForwTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srv6EndDx2lForwTables() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_srv6EndDx2lForwTables_huawei_segripv6__segripv6_srv6EndDx2lForwTables, is_container='container', yang_name="srv6EndDx2lForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srv6EndDx2lForwTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_srv6EndDx2lForwTables_huawei_segripv6__segripv6_srv6EndDx2lForwTables, is_container='container', yang_name="srv6EndDx2lForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__srv6EndDx2lForwTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srv6EndDx2lForwTables(self):
    self.__srv6EndDx2lForwTables = YANGDynClass(base=yc_srv6EndDx2lForwTables_huawei_segripv6__segripv6_srv6EndDx2lForwTables, is_container='container', yang_name="srv6EndDx2lForwTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

  srv6Site = __builtin__.property(_get_srv6Site, _set_srv6Site) # type: yc_srv6Site_huawei_segripv6__segripv6_srv6Site
  srv6RemoteEndOtps = __builtin__.property(_get_srv6RemoteEndOtps, _set_srv6RemoteEndOtps) # type: yc_srv6RemoteEndOtps_huawei_segripv6__segripv6_srv6RemoteEndOtps
  srv6Locators = __builtin__.property(_get_srv6Locators, _set_srv6Locators) # type: yc_srv6Locators_huawei_segripv6__segripv6_srv6Locators
  srv6EndForwTables = __builtin__.property(_get_srv6EndForwTables, _set_srv6EndForwTables) # type: yc_srv6EndForwTables_huawei_segripv6__segripv6_srv6EndForwTables
  srv6EndOtpForwTables = __builtin__.property(_get_srv6EndOtpForwTables, _set_srv6EndOtpForwTables) # type: yc_srv6EndOtpForwTables_huawei_segripv6__segripv6_srv6EndOtpForwTables
  srv6EndXForwTables = __builtin__.property(_get_srv6EndXForwTables, _set_srv6EndXForwTables) # type: yc_srv6EndXForwTables_huawei_segripv6__segripv6_srv6EndXForwTables
  srv6EndDt4ForwTables = __builtin__.property(_get_srv6EndDt4ForwTables, _set_srv6EndDt4ForwTables) # type: yc_srv6EndDt4ForwTables_huawei_segripv6__segripv6_srv6EndDt4ForwTables
  srv6EndDt6ForwTables = __builtin__.property(_get_srv6EndDt6ForwTables, _set_srv6EndDt6ForwTables) # type: yc_srv6EndDt6ForwTables_huawei_segripv6__segripv6_srv6EndDt6ForwTables
  srv6EndDx2ForwTables = __builtin__.property(_get_srv6EndDx2ForwTables, _set_srv6EndDx2ForwTables) # type: yc_srv6EndDx2ForwTables_huawei_segripv6__segripv6_srv6EndDx2ForwTables
  srv6EndDx2lForwTables = __builtin__.property(_get_srv6EndDx2lForwTables, _set_srv6EndDx2lForwTables) # type: yc_srv6EndDx2lForwTables_huawei_segripv6__segripv6_srv6EndDx2lForwTables


  _pyangbind_elements = OrderedDict([('srv6Site', srv6Site), ('srv6RemoteEndOtps', srv6RemoteEndOtps), ('srv6Locators', srv6Locators), ('srv6EndForwTables', srv6EndForwTables), ('srv6EndOtpForwTables', srv6EndOtpForwTables), ('srv6EndXForwTables', srv6EndXForwTables), ('srv6EndDt4ForwTables', srv6EndDt4ForwTables), ('srv6EndDt6ForwTables', srv6EndDt6ForwTables), ('srv6EndDx2ForwTables', srv6EndDx2ForwTables), ('srv6EndDx2lForwTables', srv6EndDx2lForwTables), ])


class huawei_segripv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-segripv6 - based on the path /huawei-segripv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Segment Routing IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__segripv6',)

  _yang_name = 'huawei-segripv6'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-segripv6'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__segripv6 = YANGDynClass(base=yc_segripv6_huawei_segripv6__segripv6, is_container='container', yang_name="segripv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_segripv6(self):
    """
    Getter method for segripv6, mapped from YANG variable /segripv6 (container)

    YANG Description: Segment Routing IPv6.
    """
    return self.__segripv6
      
  def _set_segripv6(self, v, load=False):
    """
    Setter method for segripv6, mapped from YANG variable /segripv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segripv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segripv6() directly.

    YANG Description: Segment Routing IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_segripv6_huawei_segripv6__segripv6, is_container='container', yang_name="segripv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segripv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_segripv6_huawei_segripv6__segripv6, is_container='container', yang_name="segripv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)""",
        })

    self.__segripv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segripv6(self):
    self.__segripv6 = YANGDynClass(base=yc_segripv6_huawei_segripv6__segripv6, is_container='container', yang_name="segripv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-segripv6', defining_module='huawei-segripv6', yang_type='container', is_config=True)

  segripv6 = __builtin__.property(_get_segripv6, _set_segripv6) # type: yc_segripv6_huawei_segripv6__segripv6


  _pyangbind_elements = OrderedDict([('segripv6', segripv6), ])


