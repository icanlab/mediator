# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_bgpSite_huawei_bgp__bgp_bgpcomm_bgpSite(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpSite. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpVersion','__bgpEnable','__asNumber','__gracefulRestart','__timeWaitForRib','__asPathLimit','__checkFirstAs','__confedIdNumber','__confedNonstanded','__bgpRidAutoSel','__keepAllRoutes','__memoryLimit','__grPeerReset','__isShutdown','__pathAttrErrCap','__suppressInterval','__holdInterval','__clearInterval','__restartTime','__lowestPriority','__delayTime','__localIfnetMtu','__private4byteAs','__localCrossNoMed',)

  _yang_name = 'bgpSite'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpVersion = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    self.__bgpEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__asNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__gracefulRestart = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__timeWaitForRib = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__asPathLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__checkFirstAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__confedIdNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__confedNonstanded = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__bgpRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__memoryLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__grPeerReset = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isShutdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pathAttrErrCap = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathAttrErrCap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__suppressInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__clearInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__restartTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['3..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(150), is_leaf=True, yang_name="restartTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__lowestPriority = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__delayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..864000']}), is_leaf=True, yang_name="delayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__localIfnetMtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['46..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1500), is_leaf=True, yang_name="localIfnetMtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__private4byteAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__localCrossNoMed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localCrossNoMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpSite']

  def _get_bgpVersion(self):
    """
    Getter method for bgpVersion, mapped from YANG variable /bgp/bgpcomm/bgpSite/bgpVersion (uint8)

    YANG Description: BGP version, which is BGP-4 at present. BGP-4 provides a new mechanism to support Classless Inter-Domain Routing (CIDR). In this case, the network prefix-based advertisement is supported and the concept of class for a BGP network is canceled in the network prefix-supported advertisements. Another mechanism is also introduced to support route summarization, including the summarization of AS paths.
    """
    return self.__bgpVersion
      
  def _set_bgpVersion(self, v, load=False):
    """
    Setter method for bgpVersion, mapped from YANG variable /bgp/bgpcomm/bgpSite/bgpVersion (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpVersion() directly.

    YANG Description: BGP version, which is BGP-4 at present. BGP-4 provides a new mechanism to support Classless Inter-Domain Routing (CIDR). In this case, the network prefix-based advertisement is supported and the concept of class for a BGP network is canceled in the network prefix-supported advertisements. Another mechanism is also introduced to support route summarization, including the summarization of AS paths.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpVersion must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__bgpVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpVersion(self):
    self.__bgpVersion = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)


  def _get_bgpEnable(self):
    """
    Getter method for bgpEnable, mapped from YANG variable /bgp/bgpcomm/bgpSite/bgpEnable (boolean)

    YANG Description: Enable BGP. By default, BGP is disabled.
    """
    return self.__bgpEnable
      
  def _set_bgpEnable(self, v, load=False):
    """
    Setter method for bgpEnable, mapped from YANG variable /bgp/bgpcomm/bgpSite/bgpEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpEnable() directly.

    YANG Description: Enable BGP. By default, BGP is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bgpEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpEnable(self):
    self.__bgpEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_asNumber(self):
    """
    Getter method for asNumber, mapped from YANG variable /bgp/bgpcomm/bgpSite/asNumber (asNumberValidate)

    YANG Description: Local AS number, which can be in either of the two formats:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value ranging from 1 to 4294967295.
An AS consists of multiple routers managed based on the same techniques. Interior Gateway Protocol (IGP) and universal routing metric packets are used inside an AS, and Exterior Gateway Protocol (EGP) is used outside to send packets to other ASs. With the development of this definition, one AS usually uses multiple IGPs and metrics. Even though multiple IGPs and metrics are used, the routing plan and destination reachability of an AS are consistent with those of another AS. The local AS number cannot be configured same as the confederation sub-ASs.
    """
    return self.__asNumber
      
  def _set_asNumber(self, v, load=False):
    """
    Setter method for asNumber, mapped from YANG variable /bgp/bgpcomm/bgpSite/asNumber (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asNumber() directly.

    YANG Description: Local AS number, which can be in either of the two formats:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value ranging from 1 to 4294967295.
An AS consists of multiple routers managed based on the same techniques. Interior Gateway Protocol (IGP) and universal routing metric packets are used inside an AS, and Exterior Gateway Protocol (EGP) is used outside to send packets to other ASs. With the development of this definition, one AS usually uses multiple IGPs and metrics. Even though multiple IGPs and metrics are used, the routing plan and destination reachability of an AS are consistent with those of another AS. The local AS number cannot be configured same as the confederation sub-ASs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asNumber must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__asNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asNumber(self):
    self.__asNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_gracefulRestart(self):
    """
    Getter method for gracefulRestart, mapped from YANG variable /bgp/bgpcomm/bgpSite/gracefulRestart (boolean)

    YANG Description: Enable GR of the BGP speaker in the specified address family, peer address, or peer group. When GR is enabled, the BGP speaker enabled with GR keeps the forwarding state and sends the End-Of-RIB flag during the restart. In this case, however, the BGP speaker may not maintain the forwarding table. Enabling or disabling GR may delete and re-establish all sessions and instances.
    """
    return self.__gracefulRestart
      
  def _set_gracefulRestart(self, v, load=False):
    """
    Setter method for gracefulRestart, mapped from YANG variable /bgp/bgpcomm/bgpSite/gracefulRestart (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gracefulRestart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gracefulRestart() directly.

    YANG Description: Enable GR of the BGP speaker in the specified address family, peer address, or peer group. When GR is enabled, the BGP speaker enabled with GR keeps the forwarding state and sends the End-Of-RIB flag during the restart. In this case, however, the BGP speaker may not maintain the forwarding table. Enabling or disabling GR may delete and re-establish all sessions and instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gracefulRestart must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__gracefulRestart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gracefulRestart(self):
    self.__gracefulRestart = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_timeWaitForRib(self):
    """
    Getter method for timeWaitForRib, mapped from YANG variable /bgp/bgpcomm/bgpSite/timeWaitForRib (uint32)

    YANG Description: Period of waiting for the End-Of-RIB flag. The value is an integer in seconds. The default value is 600. When a BGP session is established or re-established, the router enabled with GR should receive the End-Of-RIB flag in this period. If the router does not receive the End-Of-RIB flag in this period, ensure that the router can exit from the GR process.
    """
    return self.__timeWaitForRib
      
  def _set_timeWaitForRib(self, v, load=False):
    """
    Setter method for timeWaitForRib, mapped from YANG variable /bgp/bgpcomm/bgpSite/timeWaitForRib (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeWaitForRib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeWaitForRib() directly.

    YANG Description: Period of waiting for the End-Of-RIB flag. The value is an integer in seconds. The default value is 600. When a BGP session is established or re-established, the router enabled with GR should receive the End-Of-RIB flag in this period. If the router does not receive the End-Of-RIB flag in this period, ensure that the router can exit from the GR process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeWaitForRib must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__timeWaitForRib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeWaitForRib(self):
    self.__timeWaitForRib = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_asPathLimit(self):
    """
    Getter method for asPathLimit, mapped from YANG variable /bgp/bgpcomm/bgpSite/asPathLimit (uint16)

    YANG Description: Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
    """
    return self.__asPathLimit
      
  def _set_asPathLimit(self, v, load=False):
    """
    Setter method for asPathLimit, mapped from YANG variable /bgp/bgpcomm/bgpSite/asPathLimit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asPathLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asPathLimit() directly.

    YANG Description: Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asPathLimit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__asPathLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asPathLimit(self):
    self.__asPathLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_checkFirstAs(self):
    """
    Getter method for checkFirstAs, mapped from YANG variable /bgp/bgpcomm/bgpSite/checkFirstAs (boolean)

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    return self.__checkFirstAs
      
  def _set_checkFirstAs(self, v, load=False):
    """
    Setter method for checkFirstAs, mapped from YANG variable /bgp/bgpcomm/bgpSite/checkFirstAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkFirstAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkFirstAs() directly.

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkFirstAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__checkFirstAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkFirstAs(self):
    self.__checkFirstAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_confedIdNumber(self):
    """
    Getter method for confedIdNumber, mapped from YANG variable /bgp/bgpcomm/bgpSite/confedIdNumber (asNumberValidate)

    YANG Description: Confederation ID.
    """
    return self.__confedIdNumber
      
  def _set_confedIdNumber(self, v, load=False):
    """
    Setter method for confedIdNumber, mapped from YANG variable /bgp/bgpcomm/bgpSite/confedIdNumber (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_confedIdNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_confedIdNumber() directly.

    YANG Description: Confederation ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """confedIdNumber must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__confedIdNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_confedIdNumber(self):
    self.__confedIdNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_confedNonstanded(self):
    """
    Getter method for confedNonstanded, mapped from YANG variable /bgp/bgpcomm/bgpSite/confedNonstanded (boolean)

    YANG Description: Configure the device to be compatible with devices in a nonstandard confederation.
    """
    return self.__confedNonstanded
      
  def _set_confedNonstanded(self, v, load=False):
    """
    Setter method for confedNonstanded, mapped from YANG variable /bgp/bgpcomm/bgpSite/confedNonstanded (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_confedNonstanded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_confedNonstanded() directly.

    YANG Description: Configure the device to be compatible with devices in a nonstandard confederation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """confedNonstanded must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__confedNonstanded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_confedNonstanded(self):
    self.__confedNonstanded = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_bgpRidAutoSel(self):
    """
    Getter method for bgpRidAutoSel, mapped from YANG variable /bgp/bgpcomm/bgpSite/bgpRidAutoSel (boolean)

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    return self.__bgpRidAutoSel
      
  def _set_bgpRidAutoSel(self, v, load=False):
    """
    Setter method for bgpRidAutoSel, mapped from YANG variable /bgp/bgpcomm/bgpSite/bgpRidAutoSel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpRidAutoSel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpRidAutoSel() directly.

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpRidAutoSel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bgpRidAutoSel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpRidAutoSel(self):
    self.__bgpRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_keepAllRoutes(self):
    """
    Getter method for keepAllRoutes, mapped from YANG variable /bgp/bgpcomm/bgpSite/keepAllRoutes (boolean)

    YANG Description: Save all the updated information about BGP routes from a peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, only the updated information about BGP routes from a specified peer is saved on condition that the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    return self.__keepAllRoutes
      
  def _set_keepAllRoutes(self, v, load=False):
    """
    Setter method for keepAllRoutes, mapped from YANG variable /bgp/bgpcomm/bgpSite/keepAllRoutes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAllRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAllRoutes() directly.

    YANG Description: Save all the updated information about BGP routes from a peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, only the updated information about BGP routes from a specified peer is saved on condition that the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAllRoutes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__keepAllRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAllRoutes(self):
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_memoryLimit(self):
    """
    Getter method for memoryLimit, mapped from YANG variable /bgp/bgpcomm/bgpSite/memoryLimit (boolean)

    YANG Description: Support BGP RIB memory protection. By default, the function is not enabled. With BGP RIB memory protection, routes are no longer received after the RIB memory is overloaded.
    """
    return self.__memoryLimit
      
  def _set_memoryLimit(self, v, load=False):
    """
    Setter method for memoryLimit, mapped from YANG variable /bgp/bgpcomm/bgpSite/memoryLimit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memoryLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memoryLimit() directly.

    YANG Description: Support BGP RIB memory protection. By default, the function is not enabled. With BGP RIB memory protection, routes are no longer received after the RIB memory is overloaded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memoryLimit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__memoryLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memoryLimit(self):
    self.__memoryLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_grPeerReset(self):
    """
    Getter method for grPeerReset, mapped from YANG variable /bgp/bgpcomm/bgpSite/grPeerReset (boolean)

    YANG Description: Peer disconnection through GR.
    """
    return self.__grPeerReset
      
  def _set_grPeerReset(self, v, load=False):
    """
    Setter method for grPeerReset, mapped from YANG variable /bgp/bgpcomm/bgpSite/grPeerReset (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grPeerReset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grPeerReset() directly.

    YANG Description: Peer disconnection through GR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grPeerReset must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__grPeerReset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grPeerReset(self):
    self.__grPeerReset = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isShutdown(self):
    """
    Getter method for isShutdown, mapped from YANG variable /bgp/bgpcomm/bgpSite/isShutdown (boolean)

    YANG Description: Interrupt BGP all neighbor.
    """
    return self.__isShutdown
      
  def _set_isShutdown(self, v, load=False):
    """
    Setter method for isShutdown, mapped from YANG variable /bgp/bgpcomm/bgpSite/isShutdown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isShutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isShutdown() directly.

    YANG Description: Interrupt BGP all neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isShutdown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isShutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isShutdown(self):
    self.__isShutdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pathAttrErrCap(self):
    """
    Getter method for pathAttrErrCap, mapped from YANG variable /bgp/bgpcomm/bgpSite/pathAttrErrCap (boolean)

    YANG Description: Discard the error route attribute
    """
    return self.__pathAttrErrCap
      
  def _set_pathAttrErrCap(self, v, load=False):
    """
    Setter method for pathAttrErrCap, mapped from YANG variable /bgp/bgpcomm/bgpSite/pathAttrErrCap (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrErrCap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrErrCap() directly.

    YANG Description: Discard the error route attribute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathAttrErrCap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrErrCap must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathAttrErrCap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__pathAttrErrCap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrErrCap(self):
    self.__pathAttrErrCap = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathAttrErrCap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_suppressInterval(self):
    """
    Getter method for suppressInterval, mapped from YANG variable /bgp/bgpcomm/bgpSite/suppressInterval (uint32)

    YANG Description: Specifies the reference period used to add penalty in case of next hop flapping in seconds. By default, the value is 60 seconds.
    """
    return self.__suppressInterval
      
  def _set_suppressInterval(self, v, load=False):
    """
    Setter method for suppressInterval, mapped from YANG variable /bgp/bgpcomm/bgpSite/suppressInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppressInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppressInterval() directly.

    YANG Description: Specifies the reference period used to add penalty in case of next hop flapping in seconds. By default, the value is 60 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppressInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__suppressInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppressInterval(self):
    self.__suppressInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdInterval(self):
    """
    Getter method for holdInterval, mapped from YANG variable /bgp/bgpcomm/bgpSite/holdInterval (uint32)

    YANG Description: Specifies the reference period used to hold penalty in case of next hop flapping in seconds. By default, the value is 120 seconds.
    """
    return self.__holdInterval
      
  def _set_holdInterval(self, v, load=False):
    """
    Setter method for holdInterval, mapped from YANG variable /bgp/bgpcomm/bgpSite/holdInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdInterval() directly.

    YANG Description: Specifies the reference period used to hold penalty in case of next hop flapping in seconds. By default, the value is 120 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdInterval(self):
    self.__holdInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_clearInterval(self):
    """
    Getter method for clearInterval, mapped from YANG variable /bgp/bgpcomm/bgpSite/clearInterval (uint32)

    YANG Description: Specifies the reference period used to clear penalty in case of next hop flapping in seconds. By default, the value is 600 seconds.
    """
    return self.__clearInterval
      
  def _set_clearInterval(self, v, load=False):
    """
    Setter method for clearInterval, mapped from YANG variable /bgp/bgpcomm/bgpSite/clearInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clearInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clearInterval() directly.

    YANG Description: Specifies the reference period used to clear penalty in case of next hop flapping in seconds. By default, the value is 600 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clearInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__clearInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clearInterval(self):
    self.__clearInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_restartTime(self):
    """
    Getter method for restartTime, mapped from YANG variable /bgp/bgpcomm/bgpSite/restartTime (uint16)

    YANG Description: Specifies the maximum time during which a peer waits for a BGP session reestablishment. It is an integer ranging from 3 to 3600, in seconds. By default, the value is 150 seconds.
    """
    return self.__restartTime
      
  def _set_restartTime(self, v, load=False):
    """
    Setter method for restartTime, mapped from YANG variable /bgp/bgpcomm/bgpSite/restartTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restartTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restartTime() directly.

    YANG Description: Specifies the maximum time during which a peer waits for a BGP session reestablishment. It is an integer ranging from 3 to 3600, in seconds. By default, the value is 150 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['3..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(150), is_leaf=True, yang_name="restartTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restartTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['3..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(150), is_leaf=True, yang_name="restartTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__restartTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restartTime(self):
    self.__restartTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['3..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(150), is_leaf=True, yang_name="restartTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_lowestPriority(self):
    """
    Getter method for lowestPriority, mapped from YANG variable /bgp/bgpcomm/bgpSite/lowestPriority (boolean)

    YANG Description: Reduce route priority to lowest.
    """
    return self.__lowestPriority
      
  def _set_lowestPriority(self, v, load=False):
    """
    Setter method for lowestPriority, mapped from YANG variable /bgp/bgpcomm/bgpSite/lowestPriority (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowestPriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowestPriority() directly.

    YANG Description: Reduce route priority to lowest.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowestPriority must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__lowestPriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowestPriority(self):
    self.__lowestPriority = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_delayTime(self):
    """
    Getter method for delayTime, mapped from YANG variable /bgp/bgpcomm/bgpSite/delayTime (uint32)

    YANG Description: Specifies the delayTime.
    """
    return self.__delayTime
      
  def _set_delayTime(self, v, load=False):
    """
    Setter method for delayTime, mapped from YANG variable /bgp/bgpcomm/bgpSite/delayTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delayTime() directly.

    YANG Description: Specifies the delayTime.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..864000']}), is_leaf=True, yang_name="delayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delayTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..864000']}), is_leaf=True, yang_name="delayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__delayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delayTime(self):
    self.__delayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..864000']}), is_leaf=True, yang_name="delayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_localIfnetMtu(self):
    """
    Getter method for localIfnetMtu, mapped from YANG variable /bgp/bgpcomm/bgpSite/localIfnetMtu (uint16)

    YANG Description: BGP LOCALIFNET MTU
    """
    return self.__localIfnetMtu
      
  def _set_localIfnetMtu(self, v, load=False):
    """
    Setter method for localIfnetMtu, mapped from YANG variable /bgp/bgpcomm/bgpSite/localIfnetMtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfnetMtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfnetMtu() directly.

    YANG Description: BGP LOCALIFNET MTU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['46..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1500), is_leaf=True, yang_name="localIfnetMtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfnetMtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['46..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1500), is_leaf=True, yang_name="localIfnetMtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__localIfnetMtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfnetMtu(self):
    self.__localIfnetMtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['46..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1500), is_leaf=True, yang_name="localIfnetMtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_private4byteAs(self):
    """
    Getter method for private4byteAs, mapped from YANG variable /bgp/bgpcomm/bgpSite/private4byteAs (boolean)

    YANG Description: Support BGP private 4 byte AS. By default, the BGP private as is from 64512 to 65535. With BGP private-4-byte-as, BGP private as is from 64512 to 65535 and from 4200000000 to 4294967294.
    """
    return self.__private4byteAs
      
  def _set_private4byteAs(self, v, load=False):
    """
    Setter method for private4byteAs, mapped from YANG variable /bgp/bgpcomm/bgpSite/private4byteAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_private4byteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_private4byteAs() directly.

    YANG Description: Support BGP private 4 byte AS. By default, the BGP private as is from 64512 to 65535. With BGP private-4-byte-as, BGP private as is from 64512 to 65535 and from 4200000000 to 4294967294.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """private4byteAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__private4byteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_private4byteAs(self):
    self.__private4byteAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_localCrossNoMed(self):
    """
    Getter method for localCrossNoMed, mapped from YANG variable /bgp/bgpcomm/bgpSite/localCrossNoMed (boolean)

    YANG Description: Local cross routing non-med.
    """
    return self.__localCrossNoMed
      
  def _set_localCrossNoMed(self, v, load=False):
    """
    Setter method for localCrossNoMed, mapped from YANG variable /bgp/bgpcomm/bgpSite/localCrossNoMed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localCrossNoMed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localCrossNoMed() directly.

    YANG Description: Local cross routing non-med.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localCrossNoMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localCrossNoMed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localCrossNoMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__localCrossNoMed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localCrossNoMed(self):
    self.__localCrossNoMed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localCrossNoMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  bgpVersion = __builtin__.property(_get_bgpVersion)
  bgpEnable = __builtin__.property(_get_bgpEnable, _set_bgpEnable)
  asNumber = __builtin__.property(_get_asNumber, _set_asNumber)
  gracefulRestart = __builtin__.property(_get_gracefulRestart, _set_gracefulRestart)
  timeWaitForRib = __builtin__.property(_get_timeWaitForRib, _set_timeWaitForRib)
  asPathLimit = __builtin__.property(_get_asPathLimit, _set_asPathLimit)
  checkFirstAs = __builtin__.property(_get_checkFirstAs, _set_checkFirstAs)
  confedIdNumber = __builtin__.property(_get_confedIdNumber, _set_confedIdNumber)
  confedNonstanded = __builtin__.property(_get_confedNonstanded, _set_confedNonstanded)
  bgpRidAutoSel = __builtin__.property(_get_bgpRidAutoSel, _set_bgpRidAutoSel)
  keepAllRoutes = __builtin__.property(_get_keepAllRoutes, _set_keepAllRoutes)
  memoryLimit = __builtin__.property(_get_memoryLimit, _set_memoryLimit)
  grPeerReset = __builtin__.property(_get_grPeerReset, _set_grPeerReset)
  isShutdown = __builtin__.property(_get_isShutdown, _set_isShutdown)
  pathAttrErrCap = __builtin__.property(_get_pathAttrErrCap, _set_pathAttrErrCap)
  suppressInterval = __builtin__.property(_get_suppressInterval, _set_suppressInterval)
  holdInterval = __builtin__.property(_get_holdInterval, _set_holdInterval)
  clearInterval = __builtin__.property(_get_clearInterval, _set_clearInterval)
  restartTime = __builtin__.property(_get_restartTime, _set_restartTime)
  lowestPriority = __builtin__.property(_get_lowestPriority, _set_lowestPriority)
  delayTime = __builtin__.property(_get_delayTime, _set_delayTime)
  localIfnetMtu = __builtin__.property(_get_localIfnetMtu, _set_localIfnetMtu)
  private4byteAs = __builtin__.property(_get_private4byteAs, _set_private4byteAs)
  localCrossNoMed = __builtin__.property(_get_localCrossNoMed, _set_localCrossNoMed)


  _pyangbind_elements = OrderedDict([('bgpVersion', bgpVersion), ('bgpEnable', bgpEnable), ('asNumber', asNumber), ('gracefulRestart', gracefulRestart), ('timeWaitForRib', timeWaitForRib), ('asPathLimit', asPathLimit), ('checkFirstAs', checkFirstAs), ('confedIdNumber', confedIdNumber), ('confedNonstanded', confedNonstanded), ('bgpRidAutoSel', bgpRidAutoSel), ('keepAllRoutes', keepAllRoutes), ('memoryLimit', memoryLimit), ('grPeerReset', grPeerReset), ('isShutdown', isShutdown), ('pathAttrErrCap', pathAttrErrCap), ('suppressInterval', suppressInterval), ('holdInterval', holdInterval), ('clearInterval', clearInterval), ('restartTime', restartTime), ('lowestPriority', lowestPriority), ('delayTime', delayTime), ('localIfnetMtu', localIfnetMtu), ('private4byteAs', private4byteAs), ('localCrossNoMed', localCrossNoMed), ])


class yc_peerMember_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers_peerMember(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers/peerMember. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Member in a peer group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerSession',)

  _yang_name = 'peerMember'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerSession = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peerSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups', 'bgpPeerGroup', 'peerMembers', 'peerMember']

  def _get_peerSession(self):
    """
    Getter method for peerSession, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers/peerMember/peerSession (string)

    YANG Description: Specify the address of the peer joining the peer group.
    """
    return self.__peerSession
      
  def _set_peerSession(self, v, load=False):
    """
    Setter method for peerSession, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers/peerMember/peerSession (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerSession is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerSession() directly.

    YANG Description: Specify the address of the peer joining the peer group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peerSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerSession must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peerSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)""",
        })

    self.__peerSession = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerSession(self):
    self.__peerSession = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peerSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)

  peerSession = __builtin__.property(_get_peerSession)


  _pyangbind_elements = OrderedDict([('peerSession', peerSession), ])


class yc_peerMembers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of members in a peer group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerMember',)

  _yang_name = 'peerMembers'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerMember = YANGDynClass(base=YANGListType("peerSession",yc_peerMember_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers_peerMember, yang_name="peerMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSession', extensions=None), is_container='list', yang_name="peerMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups', 'bgpPeerGroup', 'peerMembers']

  def _get_peerMember(self):
    """
    Getter method for peerMember, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers/peerMember (list)

    YANG Description: Member in a peer group.
    """
    return self.__peerMember
      
  def _set_peerMember(self, v, load=False):
    """
    Setter method for peerMember, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers/peerMember (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerMember is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerMember() directly.

    YANG Description: Member in a peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerSession",yc_peerMember_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers_peerMember, yang_name="peerMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSession', extensions=None), is_container='list', yang_name="peerMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerMember must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerSession",yc_peerMember_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers_peerMember, yang_name="peerMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSession', extensions=None), is_container='list', yang_name="peerMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)""",
        })

    self.__peerMember = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerMember(self):
    self.__peerMember = YANGDynClass(base=YANGListType("peerSession",yc_peerMember_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers_peerMember, yang_name="peerMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSession', extensions=None), is_container='list', yang_name="peerMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)

  peerMember = __builtin__.property(_get_peerMember) # type: yc_peerMember_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers_peerMember


  _pyangbind_elements = OrderedDict([('peerMember', peerMember), ])


class yc_peerGroupBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupBfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__multiplier','__isBfdEnable','__rxInterval','__txInterval','__isSingleHop','__bfdCompatible','__perLinkEcho',)

  _yang_name = 'peerGroupBfd'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__perLinkEcho = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups', 'bgpPeerGroup', 'peerGroupBfd']

  def _get_multiplier(self):
    """
    Getter method for multiplier, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/multiplier (uint32)

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    return self.__multiplier
      
  def _set_multiplier(self, v, load=False):
    """
    Setter method for multiplier, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/multiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multiplier() directly.

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multiplier(self):
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isBfdEnable(self):
    """
    Getter method for isBfdEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/isBfdEnable (boolean)

    YANG Description: Configure BFD.
    """
    return self.__isBfdEnable
      
  def _set_isBfdEnable(self, v, load=False):
    """
    Setter method for isBfdEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/isBfdEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBfdEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBfdEnable() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBfdEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isBfdEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBfdEnable(self):
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_rxInterval(self):
    """
    Getter method for rxInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/rxInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    return self.__rxInterval
      
  def _set_rxInterval(self, v, load=False):
    """
    Setter method for rxInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/rxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__rxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxInterval(self):
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_txInterval(self):
    """
    Getter method for txInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/txInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    return self.__txInterval
      
  def _set_txInterval(self, v, load=False):
    """
    Setter method for txInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/txInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_txInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_txInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """txInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__txInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_txInterval(self):
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isSingleHop(self):
    """
    Getter method for isSingleHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/isSingleHop (boolean)

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    return self.__isSingleHop
      
  def _set_isSingleHop(self, v, load=False):
    """
    Setter method for isSingleHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/isSingleHop (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSingleHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSingleHop() directly.

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSingleHop must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isSingleHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSingleHop(self):
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_bfdCompatible(self):
    """
    Getter method for bfdCompatible, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/bfdCompatible (boolean)

    YANG Description: Compatible.
    """
    return self.__bfdCompatible
      
  def _set_bfdCompatible(self, v, load=False):
    """
    Setter method for bfdCompatible, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/bfdCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdCompatible() directly.

    YANG Description: Compatible.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bfdCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdCompatible(self):
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_perLinkEcho(self):
    """
    Getter method for perLinkEcho, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/perLinkEcho (boolean)

    YANG Description: The per-link one-arm-echo mode is preferred during the BFD session establishment between IBGP peers.
    """
    return self.__perLinkEcho
      
  def _set_perLinkEcho(self, v, load=False):
    """
    Setter method for perLinkEcho, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd/perLinkEcho (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_perLinkEcho is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_perLinkEcho() directly.

    YANG Description: The per-link one-arm-echo mode is preferred during the BFD session establishment between IBGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """perLinkEcho must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__perLinkEcho = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_perLinkEcho(self):
    self.__perLinkEcho = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  multiplier = __builtin__.property(_get_multiplier, _set_multiplier)
  isBfdEnable = __builtin__.property(_get_isBfdEnable, _set_isBfdEnable)
  rxInterval = __builtin__.property(_get_rxInterval, _set_rxInterval)
  txInterval = __builtin__.property(_get_txInterval, _set_txInterval)
  isSingleHop = __builtin__.property(_get_isSingleHop, _set_isSingleHop)
  bfdCompatible = __builtin__.property(_get_bfdCompatible, _set_bfdCompatible)
  perLinkEcho = __builtin__.property(_get_perLinkEcho, _set_perLinkEcho)


  _pyangbind_elements = OrderedDict([('multiplier', multiplier), ('isBfdEnable', isBfdEnable), ('rxInterval', rxInterval), ('txInterval', txInterval), ('isSingleHop', isSingleHop), ('bfdCompatible', bfdCompatible), ('perLinkEcho', perLinkEcho), ])


class yc_peerGroupSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys_peerGroupSslPolicy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the ssl-policy of the peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__role','__sslCertificate','__sslPolicyName',)

  _yang_name = 'peerGroupSslPolicy'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupSslRoleType', is_config=True)
    self.__sslCertificate = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__sslPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups', 'bgpPeerGroup', 'peerGroupSslPolicys', 'peerGroupSslPolicy']

  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy/role (bgpcommGroupSslRoleType)

    YANG Description: ssl role.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy/role (bgpcommGroupSslRoleType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: ssl role.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupSslRoleType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with bgpcommGroupSslRoleType""",
          'defined-type': "huawei-bgp:bgpcommGroupSslRoleType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupSslRoleType', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupSslRoleType', is_config=True)


  def _get_sslCertificate(self):
    """
    Getter method for sslCertificate, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy/sslCertificate (boolean)

    YANG Description: ssl-server certificate.
    """
    return self.__sslCertificate
      
  def _set_sslCertificate(self, v, load=False):
    """
    Setter method for sslCertificate, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy/sslCertificate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sslCertificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sslCertificate() directly.

    YANG Description: ssl-server certificate.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sslCertificate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__sslCertificate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sslCertificate(self):
    self.__sslCertificate = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_sslPolicyName(self):
    """
    Getter method for sslPolicyName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy/sslPolicyName (string)

    YANG Description: ssl policy name.
    """
    return self.__sslPolicyName
      
  def _set_sslPolicyName(self, v, load=False):
    """
    Setter method for sslPolicyName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy/sslPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sslPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sslPolicyName() directly.

    YANG Description: ssl policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="sslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sslPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__sslPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sslPolicyName(self):
    self.__sslPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

  role = __builtin__.property(_get_role, _set_role)
  sslCertificate = __builtin__.property(_get_sslCertificate, _set_sslCertificate)
  sslPolicyName = __builtin__.property(_get_sslPolicyName, _set_sslPolicyName)


  _pyangbind_elements = OrderedDict([('role', role), ('sslCertificate', sslCertificate), ('sslPolicyName', sslPolicyName), ])


class yc_peerGroupSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the ssl-policy list of the peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerGroupSslPolicy',)

  _yang_name = 'peerGroupSslPolicys'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerGroupSslPolicy = YANGDynClass(base=yc_peerGroupSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys_peerGroupSslPolicy, is_container='container', yang_name="peerGroupSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups', 'bgpPeerGroup', 'peerGroupSslPolicys']

  def _get_peerGroupSslPolicy(self):
    """
    Getter method for peerGroupSslPolicy, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy (container)

    YANG Description: Specifies the ssl-policy of the peer.
    """
    return self.__peerGroupSslPolicy
      
  def _set_peerGroupSslPolicy(self, v, load=False):
    """
    Setter method for peerGroupSslPolicy, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys/peerGroupSslPolicy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupSslPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupSslPolicy() directly.

    YANG Description: Specifies the ssl-policy of the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerGroupSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys_peerGroupSslPolicy, is_container='container', yang_name="peerGroupSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupSslPolicy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerGroupSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys_peerGroupSslPolicy, is_container='container', yang_name="peerGroupSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerGroupSslPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupSslPolicy(self):
    self.__peerGroupSslPolicy = YANGDynClass(base=yc_peerGroupSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys_peerGroupSslPolicy, is_container='container', yang_name="peerGroupSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  peerGroupSslPolicy = __builtin__.property(_get_peerGroupSslPolicy, _set_peerGroupSslPolicy) # type: yc_peerGroupSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys_peerGroupSslPolicy


  _pyangbind_elements = OrderedDict([('peerGroupSslPolicy', peerGroupSslPolicy), ])


class yc_bgpPeerGroup_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about a BGP peer group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afType','__groupName','__groupType','__groupAs','__description','__fakeAs','__dualAs','__conventional','__routeRefresh','__fourByteAs','__isIgnore','__localIfName','__localIfAddress','__ebgpMaxHop','__validTtlHops','__connectMode','__isLogChange','__pswdType','__pswdCipherText','__keepAliveTime','__holdTime','__minHoldTime','__keyChainName','__pathMTUD','__trackingEnable','__trackDelayTime','__connRetryTime','__tcpMSS','__mplsLocalIfnetDisable','__prependGlobalAs','__prependFakeAs','__pathAttrDiscardIdMap','__pathAttrWithdrawIdMap','__checkFirstAs','__peerMembers','__peerGroupBfd','__peerGroupSslPolicys',)

  _yang_name = 'bgpPeerGroup'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupAddrFamily', is_config=True)
    self.__groupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__groupType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)
    self.__groupAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__pathMTUD = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pathAttrDiscardIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__pathAttrWithdrawIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    self.__peerMembers = YANGDynClass(base=yc_peerMembers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers, is_container='container', yang_name="peerMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peerGroupBfd = YANGDynClass(base=yc_peerGroupBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peerGroupSslPolicys = YANGDynClass(base=yc_peerGroupSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys, is_container='container', yang_name="peerGroupSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups', 'bgpPeerGroup']

  def _get_afType(self):
    """
    Getter method for afType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/afType (bgpcommGroupAddrFamily)

    YANG Description: Address family type of a peer group. For a public instance, this value cannot be modified. Since a VPN instance is related to its address family, you need to specify the address family type when creating a peer group in the VPN instance. For example, if you want to create an address family in a VPN instance of IPv4 unicast, choose IPv4 unicast as the address family type.
    """
    return self.__afType
      
  def _set_afType(self, v, load=False):
    """
    Setter method for afType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/afType (bgpcommGroupAddrFamily)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afType() directly.

    YANG Description: Address family type of a peer group. For a public instance, this value cannot be modified. Since a VPN instance is related to its address family, you need to specify the address family type when creating a peer group in the VPN instance. For example, if you want to create an address family in a VPN instance of IPv4 unicast, choose IPv4 unicast as the address family type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupAddrFamily', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afType must be of a type compatible with bgpcommGroupAddrFamily""",
          'defined-type': "huawei-bgp:bgpcommGroupAddrFamily",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupAddrFamily', is_config=True)""",
        })

    self.__afType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afType(self):
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommGroupAddrFamily', is_config=True)


  def _get_groupName(self):
    """
    Getter method for groupName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/groupName (string)

    YANG Description: Specify the name of a peer group. The value is a string of characters, spaces not supported.
    """
    return self.__groupName
      
  def _set_groupName(self, v, load=False):
    """
    Setter method for groupName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/groupName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupName() directly.

    YANG Description: Specify the name of a peer group. The value is a string of characters, spaces not supported.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__groupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupName(self):
    self.__groupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_groupType(self):
    """
    Getter method for groupType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/groupType (bgpcommPeerType)

    YANG Description: Specify the type of a peer group. The value can be IBGP or EBGP.The object cannot be modified.
    """
    return self.__groupType
      
  def _set_groupType(self, v, load=False):
    """
    Setter method for groupType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/groupType (bgpcommPeerType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupType() directly.

    YANG Description: Specify the type of a peer group. The value can be IBGP or EBGP.The object cannot be modified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupType must be of a type compatible with bgpcommPeerType""",
          'defined-type': "huawei-bgp:bgpcommPeerType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)""",
        })

    self.__groupType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupType(self):
    self.__groupType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)


  def _get_groupAs(self):
    """
    Getter method for groupAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/groupAs (asNumberValidate)

    YANG Description: Specify the AS number of a peer group. The AS number is in either a 2-byte or 4-byte format.
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    return self.__groupAs
      
  def _set_groupAs(self, v, load=False):
    """
    Setter method for groupAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/groupAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupAs() directly.

    YANG Description: Specify the AS number of a peer group. The AS number is in either a 2-byte or 4-byte format.
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__groupAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupAs(self):
    self.__groupAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/description (string)

    YANG Description: Specify the description of a peer group. The value is a string, which can be letters or digits, spaces supported. By default, no description is configured.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Specify the description of a peer group. The value is a string, which can be letters or digits, spaces supported. By default, no description is configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_fakeAs(self):
    """
    Getter method for fakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/fakeAs (asNumberValidate)

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    return self.__fakeAs
      
  def _set_fakeAs(self, v, load=False):
    """
    Setter method for fakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/fakeAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fakeAs() directly.

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fakeAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__fakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fakeAs(self):
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_dualAs(self):
    """
    Getter method for dualAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/dualAs (boolean)

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    return self.__dualAs
      
  def _set_dualAs(self, v, load=False):
    """
    Setter method for dualAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/dualAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dualAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dualAs() directly.

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dualAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__dualAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dualAs(self):
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_conventional(self):
    """
    Getter method for conventional, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/conventional (boolean)

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    return self.__conventional
      
  def _set_conventional(self, v, load=False):
    """
    Setter method for conventional, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/conventional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conventional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conventional() directly.

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conventional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__conventional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conventional(self):
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routeRefresh(self):
    """
    Getter method for routeRefresh, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/routeRefresh (boolean)

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    return self.__routeRefresh
      
  def _set_routeRefresh(self, v, load=False):
    """
    Setter method for routeRefresh, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/routeRefresh (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeRefresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeRefresh() directly.

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeRefresh must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__routeRefresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeRefresh(self):
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_fourByteAs(self):
    """
    Getter method for fourByteAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/fourByteAs (boolean)

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    return self.__fourByteAs
      
  def _set_fourByteAs(self, v, load=False):
    """
    Setter method for fourByteAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/fourByteAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fourByteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fourByteAs() directly.

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fourByteAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__fourByteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fourByteAs(self):
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isIgnore(self):
    """
    Getter method for isIgnore, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/isIgnore (boolean)

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    return self.__isIgnore
      
  def _set_isIgnore(self, v, load=False):
    """
    Setter method for isIgnore, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/isIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isIgnore() directly.

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isIgnore(self):
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_localIfName(self):
    """
    Getter method for localIfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/localIfName (string)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfName
      
  def _set_localIfName(self, v, load=False):
    """
    Setter method for localIfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/localIfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfName() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__localIfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfName(self):
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_localIfAddress(self):
    """
    Getter method for localIfAddress, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/localIfAddress (inet:ip-address-no-zone)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfAddress
      
  def _set_localIfAddress(self, v, load=False):
    """
    Setter method for localIfAddress, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/localIfAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfAddress() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__localIfAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfAddress(self):
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_ebgpMaxHop(self):
    """
    Getter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/ebgpMaxHop (uint32)

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.
    """
    return self.__ebgpMaxHop
      
  def _set_ebgpMaxHop(self, v, load=False):
    """
    Setter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/ebgpMaxHop (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgpMaxHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgpMaxHop() directly.

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgpMaxHop must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__ebgpMaxHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgpMaxHop(self):
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_validTtlHops(self):
    """
    Getter method for validTtlHops, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/validTtlHops (uint16)

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255].

    """
    return self.__validTtlHops
      
  def _set_validTtlHops(self, v, load=False):
    """
    Setter method for validTtlHops, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/validTtlHops (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_validTtlHops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_validTtlHops() directly.

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255].

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """validTtlHops must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__validTtlHops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_validTtlHops(self):
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connectMode(self):
    """
    Getter method for connectMode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/connectMode (bgpcommPeerConnectMode)

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    return self.__connectMode
      
  def _set_connectMode(self, v, load=False):
    """
    Setter method for connectMode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/connectMode (bgpcommPeerConnectMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectMode() directly.

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connectMode must be of a type compatible with bgpcommPeerConnectMode""",
          'defined-type': "huawei-bgp:bgpcommPeerConnectMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)""",
        })

    self.__connectMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connectMode(self):
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)


  def _get_isLogChange(self):
    """
    Getter method for isLogChange, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/isLogChange (boolean)

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    return self.__isLogChange
      
  def _set_isLogChange(self, v, load=False):
    """
    Setter method for isLogChange, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/isLogChange (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLogChange is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLogChange() directly.

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLogChange must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isLogChange = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLogChange(self):
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pswdType(self):
    """
    Getter method for pswdType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pswdType (bgpcommPasswordType)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    return self.__pswdType
      
  def _set_pswdType(self, v, load=False):
    """
    Setter method for pswdType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pswdType (bgpcommPasswordType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdType() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdType must be of a type compatible with bgpcommPasswordType""",
          'defined-type': "huawei-bgp:bgpcommPasswordType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)""",
        })

    self.__pswdType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdType(self):
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)


  def _get_pswdCipherText(self):
    """
    Getter method for pswdCipherText, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pswdCipherText (string)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 432. If the length is set to 0, no password is set.
    """
    return self.__pswdCipherText
      
  def _set_pswdCipherText(self, v, load=False):
    """
    Setter method for pswdCipherText, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pswdCipherText (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdCipherText is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdCipherText() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 432. If the length is set to 0, no password is set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdCipherText must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pswdCipherText = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdCipherText(self):
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_keepAliveTime(self):
    """
    Getter method for keepAliveTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/keepAliveTime (uint32)

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    return self.__keepAliveTime
      
  def _set_keepAliveTime(self, v, load=False):
    """
    Setter method for keepAliveTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/keepAliveTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAliveTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAliveTime() directly.

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAliveTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__keepAliveTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAliveTime(self):
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/holdTime (uint32)

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_minHoldTime(self):
    """
    Getter method for minHoldTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/minHoldTime (uint32)

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    return self.__minHoldTime
      
  def _set_minHoldTime(self, v, load=False):
    """
    Setter method for minHoldTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/minHoldTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minHoldTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minHoldTime() directly.

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minHoldTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__minHoldTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minHoldTime(self):
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_keyChainName(self):
    """
    Getter method for keyChainName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/keyChainName (string)

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    return self.__keyChainName
      
  def _set_keyChainName(self, v, load=False):
    """
    Setter method for keyChainName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/keyChainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyChainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyChainName() directly.

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyChainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__keyChainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyChainName(self):
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_pathMTUD(self):
    """
    Getter method for pathMTUD, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pathMTUD (boolean)

    YANG Description: path-mtu auto-discovery.
    """
    return self.__pathMTUD
      
  def _set_pathMTUD(self, v, load=False):
    """
    Setter method for pathMTUD, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pathMTUD (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathMTUD is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathMTUD() directly.

    YANG Description: path-mtu auto-discovery.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathMTUD must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__pathMTUD = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathMTUD(self):
    self.__pathMTUD = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_trackingEnable(self):
    """
    Getter method for trackingEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/trackingEnable (boolean)

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    return self.__trackingEnable
      
  def _set_trackingEnable(self, v, load=False):
    """
    Setter method for trackingEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/trackingEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackingEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackingEnable() directly.

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackingEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__trackingEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackingEnable(self):
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_trackDelayTime(self):
    """
    Getter method for trackDelayTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/trackDelayTime (uint16)

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    return self.__trackDelayTime
      
  def _set_trackDelayTime(self, v, load=False):
    """
    Setter method for trackDelayTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/trackDelayTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackDelayTime() directly.

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackDelayTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__trackDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackDelayTime(self):
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connRetryTime(self):
    """
    Getter method for connRetryTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/connRetryTime (uint16)

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    return self.__connRetryTime
      
  def _set_connRetryTime(self, v, load=False):
    """
    Setter method for connRetryTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/connRetryTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connRetryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connRetryTime() directly.

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connRetryTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connRetryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connRetryTime(self):
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_tcpMSS(self):
    """
    Getter method for tcpMSS, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/tcpMSS (uint16)

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer group. 
    """
    return self.__tcpMSS
      
  def _set_tcpMSS(self, v, load=False):
    """
    Setter method for tcpMSS, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/tcpMSS (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpMSS is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpMSS() directly.

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer group. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpMSS must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__tcpMSS = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpMSS(self):
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_mplsLocalIfnetDisable(self):
    """
    Getter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/mplsLocalIfnetDisable (boolean)

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    return self.__mplsLocalIfnetDisable
      
  def _set_mplsLocalIfnetDisable(self, v, load=False):
    """
    Setter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/mplsLocalIfnetDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mplsLocalIfnetDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mplsLocalIfnetDisable() directly.

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mplsLocalIfnetDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__mplsLocalIfnetDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mplsLocalIfnetDisable(self):
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependGlobalAs(self):
    """
    Getter method for prependGlobalAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/prependGlobalAs (boolean)

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    return self.__prependGlobalAs
      
  def _set_prependGlobalAs(self, v, load=False):
    """
    Setter method for prependGlobalAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/prependGlobalAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependGlobalAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependGlobalAs() directly.

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependGlobalAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependGlobalAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependGlobalAs(self):
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependFakeAs(self):
    """
    Getter method for prependFakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/prependFakeAs (boolean)

    YANG Description: Add the Fake AS number to received Update packets.
    """
    return self.__prependFakeAs
      
  def _set_prependFakeAs(self, v, load=False):
    """
    Setter method for prependFakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/prependFakeAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependFakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependFakeAs() directly.

    YANG Description: Add the Fake AS number to received Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependFakeAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependFakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependFakeAs(self):
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pathAttrDiscardIdMap(self):
    """
    Getter method for pathAttrDiscardIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pathAttrDiscardIdMap (string)

    YANG Description: Specify a discard attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    return self.__pathAttrDiscardIdMap
      
  def _set_pathAttrDiscardIdMap(self, v, load=False):
    """
    Setter method for pathAttrDiscardIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pathAttrDiscardIdMap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrDiscardIdMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrDiscardIdMap() directly.

    YANG Description: Specify a discard attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrDiscardIdMap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pathAttrDiscardIdMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrDiscardIdMap(self):
    self.__pathAttrDiscardIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_pathAttrWithdrawIdMap(self):
    """
    Getter method for pathAttrWithdrawIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pathAttrWithdrawIdMap (string)

    YANG Description: Specify a withdraw attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    return self.__pathAttrWithdrawIdMap
      
  def _set_pathAttrWithdrawIdMap(self, v, load=False):
    """
    Setter method for pathAttrWithdrawIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/pathAttrWithdrawIdMap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrWithdrawIdMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrWithdrawIdMap() directly.

    YANG Description: Specify a withdraw attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrWithdrawIdMap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pathAttrWithdrawIdMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrWithdrawIdMap(self):
    self.__pathAttrWithdrawIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_checkFirstAs(self):
    """
    Getter method for checkFirstAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/checkFirstAs (bgpCheckFirstAsTriState)

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    return self.__checkFirstAs
      
  def _set_checkFirstAs(self, v, load=False):
    """
    Setter method for checkFirstAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/checkFirstAs (bgpCheckFirstAsTriState)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkFirstAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkFirstAs() directly.

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkFirstAs must be of a type compatible with bgpCheckFirstAsTriState""",
          'defined-type': "huawei-bgp:bgpCheckFirstAsTriState",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)""",
        })

    self.__checkFirstAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkFirstAs(self):
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)


  def _get_peerMembers(self):
    """
    Getter method for peerMembers, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers (container)

    YANG Description: List of members in a peer group.
    """
    return self.__peerMembers
      
  def _set_peerMembers(self, v, load=False):
    """
    Setter method for peerMembers, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerMembers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerMembers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerMembers() directly.

    YANG Description: List of members in a peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerMembers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers, is_container='container', yang_name="peerMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerMembers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerMembers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers, is_container='container', yang_name="peerMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerMembers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerMembers(self):
    self.__peerMembers = YANGDynClass(base=yc_peerMembers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers, is_container='container', yang_name="peerMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peerGroupBfd(self):
    """
    Getter method for peerGroupBfd, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd (container)

    YANG Description: Configure BFD.
    """
    return self.__peerGroupBfd
      
  def _set_peerGroupBfd(self, v, load=False):
    """
    Setter method for peerGroupBfd, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupBfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupBfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupBfd() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerGroupBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupBfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerGroupBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerGroupBfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupBfd(self):
    self.__peerGroupBfd = YANGDynClass(base=yc_peerGroupBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peerGroupSslPolicys(self):
    """
    Getter method for peerGroupSslPolicys, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys (container)

    YANG Description: Specifies the ssl-policy list of the peer.
    """
    return self.__peerGroupSslPolicys
      
  def _set_peerGroupSslPolicys(self, v, load=False):
    """
    Setter method for peerGroupSslPolicys, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup/peerGroupSslPolicys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupSslPolicys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupSslPolicys() directly.

    YANG Description: Specifies the ssl-policy list of the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerGroupSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys, is_container='container', yang_name="peerGroupSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupSslPolicys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerGroupSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys, is_container='container', yang_name="peerGroupSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerGroupSslPolicys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupSslPolicys(self):
    self.__peerGroupSslPolicys = YANGDynClass(base=yc_peerGroupSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys, is_container='container', yang_name="peerGroupSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  afType = __builtin__.property(_get_afType, _set_afType)
  groupName = __builtin__.property(_get_groupName, _set_groupName)
  groupType = __builtin__.property(_get_groupType, _set_groupType)
  groupAs = __builtin__.property(_get_groupAs, _set_groupAs)
  description = __builtin__.property(_get_description, _set_description)
  fakeAs = __builtin__.property(_get_fakeAs, _set_fakeAs)
  dualAs = __builtin__.property(_get_dualAs, _set_dualAs)
  conventional = __builtin__.property(_get_conventional, _set_conventional)
  routeRefresh = __builtin__.property(_get_routeRefresh, _set_routeRefresh)
  fourByteAs = __builtin__.property(_get_fourByteAs, _set_fourByteAs)
  isIgnore = __builtin__.property(_get_isIgnore, _set_isIgnore)
  localIfName = __builtin__.property(_get_localIfName, _set_localIfName)
  localIfAddress = __builtin__.property(_get_localIfAddress, _set_localIfAddress)
  ebgpMaxHop = __builtin__.property(_get_ebgpMaxHop, _set_ebgpMaxHop)
  validTtlHops = __builtin__.property(_get_validTtlHops, _set_validTtlHops)
  connectMode = __builtin__.property(_get_connectMode, _set_connectMode)
  isLogChange = __builtin__.property(_get_isLogChange, _set_isLogChange)
  pswdType = __builtin__.property(_get_pswdType, _set_pswdType)
  pswdCipherText = __builtin__.property(_get_pswdCipherText, _set_pswdCipherText)
  keepAliveTime = __builtin__.property(_get_keepAliveTime, _set_keepAliveTime)
  holdTime = __builtin__.property(_get_holdTime, _set_holdTime)
  minHoldTime = __builtin__.property(_get_minHoldTime, _set_minHoldTime)
  keyChainName = __builtin__.property(_get_keyChainName, _set_keyChainName)
  pathMTUD = __builtin__.property(_get_pathMTUD, _set_pathMTUD)
  trackingEnable = __builtin__.property(_get_trackingEnable, _set_trackingEnable)
  trackDelayTime = __builtin__.property(_get_trackDelayTime, _set_trackDelayTime)
  connRetryTime = __builtin__.property(_get_connRetryTime, _set_connRetryTime)
  tcpMSS = __builtin__.property(_get_tcpMSS, _set_tcpMSS)
  mplsLocalIfnetDisable = __builtin__.property(_get_mplsLocalIfnetDisable, _set_mplsLocalIfnetDisable)
  prependGlobalAs = __builtin__.property(_get_prependGlobalAs, _set_prependGlobalAs)
  prependFakeAs = __builtin__.property(_get_prependFakeAs, _set_prependFakeAs)
  pathAttrDiscardIdMap = __builtin__.property(_get_pathAttrDiscardIdMap, _set_pathAttrDiscardIdMap)
  pathAttrWithdrawIdMap = __builtin__.property(_get_pathAttrWithdrawIdMap, _set_pathAttrWithdrawIdMap)
  checkFirstAs = __builtin__.property(_get_checkFirstAs, _set_checkFirstAs)
  peerMembers = __builtin__.property(_get_peerMembers, _set_peerMembers) # type: yc_peerMembers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerMembers
  peerGroupBfd = __builtin__.property(_get_peerGroupBfd, _set_peerGroupBfd) # type: yc_peerGroupBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupBfd
  peerGroupSslPolicys = __builtin__.property(_get_peerGroupSslPolicys, _set_peerGroupSslPolicys) # type: yc_peerGroupSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup_peerGroupSslPolicys


  _pyangbind_elements = OrderedDict([('afType', afType), ('groupName', groupName), ('groupType', groupType), ('groupAs', groupAs), ('description', description), ('fakeAs', fakeAs), ('dualAs', dualAs), ('conventional', conventional), ('routeRefresh', routeRefresh), ('fourByteAs', fourByteAs), ('isIgnore', isIgnore), ('localIfName', localIfName), ('localIfAddress', localIfAddress), ('ebgpMaxHop', ebgpMaxHop), ('validTtlHops', validTtlHops), ('connectMode', connectMode), ('isLogChange', isLogChange), ('pswdType', pswdType), ('pswdCipherText', pswdCipherText), ('keepAliveTime', keepAliveTime), ('holdTime', holdTime), ('minHoldTime', minHoldTime), ('keyChainName', keyChainName), ('pathMTUD', pathMTUD), ('trackingEnable', trackingEnable), ('trackDelayTime', trackDelayTime), ('connRetryTime', connRetryTime), ('tcpMSS', tcpMSS), ('mplsLocalIfnetDisable', mplsLocalIfnetDisable), ('prependGlobalAs', prependGlobalAs), ('prependFakeAs', prependFakeAs), ('pathAttrDiscardIdMap', pathAttrDiscardIdMap), ('pathAttrWithdrawIdMap', pathAttrWithdrawIdMap), ('checkFirstAs', checkFirstAs), ('peerMembers', peerMembers), ('peerGroupBfd', peerGroupBfd), ('peerGroupSslPolicys', peerGroupSslPolicys), ])


class yc_bgpPeerGroups_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peer groups. The BGP peer groups can help you simplify the configurations. If you want to perform the same configuration for several peers, you can create a peer group and then configure the peer group. After you add these peers to the peer group, all these peers will have the same configurations as the peer group. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpPeerGroup',)

  _yang_name = 'bgpPeerGroups'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpPeerGroup = YANGDynClass(base=YANGListType("afType groupName",yc_bgpPeerGroup_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup, yang_name="bgpPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeerGroups']

  def _get_bgpPeerGroup(self):
    """
    Getter method for bgpPeerGroup, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup (list)

    YANG Description: Information about a BGP peer group.
    """
    return self.__bgpPeerGroup
      
  def _set_bgpPeerGroup(self, v, load=False):
    """
    Setter method for bgpPeerGroup, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups/bgpPeerGroup (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpPeerGroup is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpPeerGroup() directly.

    YANG Description: Information about a BGP peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afType groupName",yc_bgpPeerGroup_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup, yang_name="bgpPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpPeerGroup must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afType groupName",yc_bgpPeerGroup_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup, yang_name="bgpPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpPeerGroup = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpPeerGroup(self):
    self.__bgpPeerGroup = YANGDynClass(base=YANGListType("afType groupName",yc_bgpPeerGroup_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup, yang_name="bgpPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpPeerGroup = __builtin__.property(_get_bgpPeerGroup, _set_bgpPeerGroup) # type: yc_bgpPeerGroup_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups_bgpPeerGroup


  _pyangbind_elements = OrderedDict([('bgpPeerGroup', bgpPeerGroup), ])


class yc_peerLogInfo_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos_peerLogInfo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer log information. After the log function is enabled on a peer, you can check the recorded log information about the peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__logIndex','__stateEvent','__errorCode','__errorSubCode','__notification','__logDateTime',)

  _yang_name = 'peerLogInfo'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__logIndex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="logIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=False)
    self.__stateEvent = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="stateEvent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    self.__errorCode = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    self.__errorSubCode = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorSubCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    self.__notification = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    self.__logDateTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="logDateTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'peerLogInfos', 'peerLogInfo']

  def _get_logIndex(self):
    """
    Getter method for logIndex, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/logIndex (uint32)

    YANG Description: Index of peer log information.
    """
    return self.__logIndex
      
  def _set_logIndex(self, v, load=False):
    """
    Setter method for logIndex, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/logIndex (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logIndex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logIndex() directly.

    YANG Description: Index of peer log information.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="logIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logIndex must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="logIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__logIndex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logIndex(self):
    self.__logIndex = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="logIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=False)


  def _get_stateEvent(self):
    """
    Getter method for stateEvent, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/stateEvent (string)

    YANG Description: Status of a peer when an event occurs.
    """
    return self.__stateEvent
      
  def _set_stateEvent(self, v, load=False):
    """
    Setter method for stateEvent, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/stateEvent (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stateEvent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stateEvent() directly.

    YANG Description: Status of a peer when an event occurs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="stateEvent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stateEvent must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="stateEvent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)""",
        })

    self.__stateEvent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stateEvent(self):
    self.__stateEvent = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="stateEvent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)


  def _get_errorCode(self):
    """
    Getter method for errorCode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/errorCode (uint8)

    YANG Description: Error code that triggers an event.
    """
    return self.__errorCode
      
  def _set_errorCode(self, v, load=False):
    """
    Setter method for errorCode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/errorCode (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errorCode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errorCode() directly.

    YANG Description: Error code that triggers an event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errorCode must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__errorCode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errorCode(self):
    self.__errorCode = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)


  def _get_errorSubCode(self):
    """
    Getter method for errorSubCode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/errorSubCode (uint8)

    YANG Description: Error subcode that triggers an event.
    """
    return self.__errorSubCode
      
  def _set_errorSubCode(self, v, load=False):
    """
    Setter method for errorSubCode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/errorSubCode (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_errorSubCode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_errorSubCode() directly.

    YANG Description: Error subcode that triggers an event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorSubCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """errorSubCode must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorSubCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__errorSubCode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_errorSubCode(self):
    self.__errorSubCode = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="errorSubCode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)


  def _get_notification(self):
    """
    Getter method for notification, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/notification (string)

    YANG Description: Sent or received notification messages.
    """
    return self.__notification
      
  def _set_notification(self, v, load=False):
    """
    Setter method for notification, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/notification (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_notification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_notification() directly.

    YANG Description: Sent or received notification messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """notification must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)""",
        })

    self.__notification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_notification(self):
    self.__notification = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)


  def _get_logDateTime(self):
    """
    Getter method for logDateTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/logDateTime (yang:date-and-time)

    YANG Description: Time when the log information was recorded.
    """
    return self.__logDateTime
      
  def _set_logDateTime(self, v, load=False):
    """
    Setter method for logDateTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo/logDateTime (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logDateTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logDateTime() directly.

    YANG Description: Time when the log information was recorded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="logDateTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logDateTime must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="logDateTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__logDateTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logDateTime(self):
    self.__logDateTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="logDateTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='yang:date-and-time', is_config=False)

  logIndex = __builtin__.property(_get_logIndex)
  stateEvent = __builtin__.property(_get_stateEvent)
  errorCode = __builtin__.property(_get_errorCode)
  errorSubCode = __builtin__.property(_get_errorSubCode)
  notification = __builtin__.property(_get_notification)
  logDateTime = __builtin__.property(_get_logDateTime)


  _pyangbind_elements = OrderedDict([('logIndex', logIndex), ('stateEvent', stateEvent), ('errorCode', errorCode), ('errorSubCode', errorSubCode), ('notification', notification), ('logDateTime', logDateTime), ])


class yc_peerLogInfos_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer log information list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerLogInfo',)

  _yang_name = 'peerLogInfos'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerLogInfo = YANGDynClass(base=YANGListType("logIndex",yc_peerLogInfo_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos_peerLogInfo, yang_name="peerLogInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logIndex', extensions=None), is_container='list', yang_name="peerLogInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'peerLogInfos']

  def _get_peerLogInfo(self):
    """
    Getter method for peerLogInfo, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo (list)

    YANG Description: Peer log information. After the log function is enabled on a peer, you can check the recorded log information about the peer.
    """
    return self.__peerLogInfo
      
  def _set_peerLogInfo(self, v, load=False):
    """
    Setter method for peerLogInfo, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos/peerLogInfo (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerLogInfo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerLogInfo() directly.

    YANG Description: Peer log information. After the log function is enabled on a peer, you can check the recorded log information about the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("logIndex",yc_peerLogInfo_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos_peerLogInfo, yang_name="peerLogInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logIndex', extensions=None), is_container='list', yang_name="peerLogInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerLogInfo must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("logIndex",yc_peerLogInfo_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos_peerLogInfo, yang_name="peerLogInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logIndex', extensions=None), is_container='list', yang_name="peerLogInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)""",
        })

    self.__peerLogInfo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerLogInfo(self):
    self.__peerLogInfo = YANGDynClass(base=YANGListType("logIndex",yc_peerLogInfo_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos_peerLogInfo, yang_name="peerLogInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logIndex', extensions=None), is_container='list', yang_name="peerLogInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)

  peerLogInfo = __builtin__.property(_get_peerLogInfo) # type: yc_peerLogInfo_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos_peerLogInfo


  _pyangbind_elements = OrderedDict([('peerLogInfo', peerLogInfo), ])


class yc_peerBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerBfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isBfdBlock','__multiplier','__isBfdEnable','__rxInterval','__txInterval','__isSingleHop','__bfdCompatible','__perLinkEcho',)

  _yang_name = 'peerBfd'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isBfdBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__perLinkEcho = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'peerBfd']

  def _get_isBfdBlock(self):
    """
    Getter method for isBfdBlock, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/isBfdBlock (boolean)

    YANG Description: Prevent  a BGP peer from inheriting the BFD configuration of the BGP peer group.
    """
    return self.__isBfdBlock
      
  def _set_isBfdBlock(self, v, load=False):
    """
    Setter method for isBfdBlock, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/isBfdBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBfdBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBfdBlock() directly.

    YANG Description: Prevent  a BGP peer from inheriting the BFD configuration of the BGP peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBfdBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isBfdBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBfdBlock(self):
    self.__isBfdBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_multiplier(self):
    """
    Getter method for multiplier, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/multiplier (uint32)

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    return self.__multiplier
      
  def _set_multiplier(self, v, load=False):
    """
    Setter method for multiplier, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/multiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multiplier() directly.

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multiplier(self):
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isBfdEnable(self):
    """
    Getter method for isBfdEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/isBfdEnable (boolean)

    YANG Description: Enable BFD.
    """
    return self.__isBfdEnable
      
  def _set_isBfdEnable(self, v, load=False):
    """
    Setter method for isBfdEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/isBfdEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBfdEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBfdEnable() directly.

    YANG Description: Enable BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBfdEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isBfdEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBfdEnable(self):
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_rxInterval(self):
    """
    Getter method for rxInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/rxInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    return self.__rxInterval
      
  def _set_rxInterval(self, v, load=False):
    """
    Setter method for rxInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/rxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__rxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxInterval(self):
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_txInterval(self):
    """
    Getter method for txInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/txInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    return self.__txInterval
      
  def _set_txInterval(self, v, load=False):
    """
    Setter method for txInterval, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/txInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_txInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_txInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """txInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__txInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_txInterval(self):
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isSingleHop(self):
    """
    Getter method for isSingleHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/isSingleHop (boolean)

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    return self.__isSingleHop
      
  def _set_isSingleHop(self, v, load=False):
    """
    Setter method for isSingleHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/isSingleHop (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSingleHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSingleHop() directly.

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSingleHop must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isSingleHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSingleHop(self):
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_bfdCompatible(self):
    """
    Getter method for bfdCompatible, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/bfdCompatible (boolean)

    YANG Description: Compatible.
    """
    return self.__bfdCompatible
      
  def _set_bfdCompatible(self, v, load=False):
    """
    Setter method for bfdCompatible, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/bfdCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdCompatible() directly.

    YANG Description: Compatible.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bfdCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdCompatible(self):
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_perLinkEcho(self):
    """
    Getter method for perLinkEcho, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/perLinkEcho (boolean)

    YANG Description: The per-link one-arm-echo mode is preferred during the BFD session establishment between IBGP peers.
    """
    return self.__perLinkEcho
      
  def _set_perLinkEcho(self, v, load=False):
    """
    Setter method for perLinkEcho, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd/perLinkEcho (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_perLinkEcho is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_perLinkEcho() directly.

    YANG Description: The per-link one-arm-echo mode is preferred during the BFD session establishment between IBGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """perLinkEcho must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__perLinkEcho = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_perLinkEcho(self):
    self.__perLinkEcho = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="perLinkEcho", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  isBfdBlock = __builtin__.property(_get_isBfdBlock, _set_isBfdBlock)
  multiplier = __builtin__.property(_get_multiplier, _set_multiplier)
  isBfdEnable = __builtin__.property(_get_isBfdEnable, _set_isBfdEnable)
  rxInterval = __builtin__.property(_get_rxInterval, _set_rxInterval)
  txInterval = __builtin__.property(_get_txInterval, _set_txInterval)
  isSingleHop = __builtin__.property(_get_isSingleHop, _set_isSingleHop)
  bfdCompatible = __builtin__.property(_get_bfdCompatible, _set_bfdCompatible)
  perLinkEcho = __builtin__.property(_get_perLinkEcho, _set_perLinkEcho)


  _pyangbind_elements = OrderedDict([('isBfdBlock', isBfdBlock), ('multiplier', multiplier), ('isBfdEnable', isBfdEnable), ('rxInterval', rxInterval), ('txInterval', txInterval), ('isSingleHop', isSingleHop), ('bfdCompatible', bfdCompatible), ('perLinkEcho', perLinkEcho), ])


class yc_relyStateInterface_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces_relyStateInterface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces/relyStateInterface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the information of the check interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__relyIfName',)

  _yang_name = 'relyStateInterface'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__relyIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relyIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'relyStateInterfaces', 'relyStateInterface']

  def _get_relyIfName(self):
    """
    Getter method for relyIfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces/relyStateInterface/relyIfName (string)

    YANG Description: Specifies the name of the check interface.
    """
    return self.__relyIfName
      
  def _set_relyIfName(self, v, load=False):
    """
    Setter method for relyIfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces/relyStateInterface/relyIfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relyIfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relyIfName() directly.

    YANG Description: Specifies the name of the check interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="relyIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relyIfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relyIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__relyIfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relyIfName(self):
    self.__relyIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relyIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

  relyIfName = __builtin__.property(_get_relyIfName, _set_relyIfName)


  _pyangbind_elements = OrderedDict([('relyIfName', relyIfName), ])


class yc_relyStateInterfaces_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the name list of the check interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__relyStateInterface',)

  _yang_name = 'relyStateInterfaces'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__relyStateInterface = YANGDynClass(base=YANGListType("relyIfName",yc_relyStateInterface_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces_relyStateInterface, yang_name="relyStateInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='relyIfName', extensions=None), is_container='list', yang_name="relyStateInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'relyStateInterfaces']

  def _get_relyStateInterface(self):
    """
    Getter method for relyStateInterface, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces/relyStateInterface (list)

    YANG Description: Specifies the information of the check interface.
    """
    return self.__relyStateInterface
      
  def _set_relyStateInterface(self, v, load=False):
    """
    Setter method for relyStateInterface, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces/relyStateInterface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relyStateInterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relyStateInterface() directly.

    YANG Description: Specifies the information of the check interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("relyIfName",yc_relyStateInterface_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces_relyStateInterface, yang_name="relyStateInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='relyIfName', extensions=None), is_container='list', yang_name="relyStateInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relyStateInterface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("relyIfName",yc_relyStateInterface_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces_relyStateInterface, yang_name="relyStateInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='relyIfName', extensions=None), is_container='list', yang_name="relyStateInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__relyStateInterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relyStateInterface(self):
    self.__relyStateInterface = YANGDynClass(base=YANGListType("relyIfName",yc_relyStateInterface_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces_relyStateInterface, yang_name="relyStateInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='relyIfName', extensions=None), is_container='list', yang_name="relyStateInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  relyStateInterface = __builtin__.property(_get_relyStateInterface, _set_relyStateInterface) # type: yc_relyStateInterface_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces_relyStateInterface


  _pyangbind_elements = OrderedDict([('relyStateInterface', relyStateInterface), ])


class yc_peerSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys_peerSslPolicy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the ssl-policy of the peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__role','__effectRole','__sslCertificate','__effectSslCertificate','__configSslPolicyName','__effectSslPolicyName',)

  _yang_name = 'peerSslPolicy'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=True)
    self.__effectRole = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), is_leaf=True, yang_name="effectRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=False)
    self.__sslCertificate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConfigType', is_config=True)
    self.__effectSslCertificate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="effectSslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=False)
    self.__configSslPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="configSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__effectSslPolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..23']}), is_leaf=True, yang_name="effectSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'peerSslPolicys', 'peerSslPolicy']

  def _get_role(self):
    """
    Getter method for role, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/role (bgpcommSslRoleType)

    YANG Description: ssl role.
    """
    return self.__role
      
  def _set_role(self, v, load=False):
    """
    Setter method for role, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/role (bgpcommSslRoleType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: ssl role.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role must be of a type compatible with bgpcommSslRoleType""",
          'defined-type': "huawei-bgp:bgpcommSslRoleType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=True)""",
        })

    self.__role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role(self):
    self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=True)


  def _get_effectRole(self):
    """
    Getter method for effectRole, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/effectRole (bgpcommSslRoleType)

    YANG Description: ssl effect role.
    """
    return self.__effectRole
      
  def _set_effectRole(self, v, load=False):
    """
    Setter method for effectRole, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/effectRole (bgpcommSslRoleType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effectRole is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effectRole() directly.

    YANG Description: ssl effect role.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), is_leaf=True, yang_name="effectRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effectRole must be of a type compatible with bgpcommSslRoleType""",
          'defined-type': "huawei-bgp:bgpcommSslRoleType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), is_leaf=True, yang_name="effectRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=False)""",
        })

    self.__effectRole = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effectRole(self):
    self.__effectRole = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'client': {}, 'server': {}, 'disable': {}},), is_leaf=True, yang_name="effectRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSslRoleType', is_config=False)


  def _get_sslCertificate(self):
    """
    Getter method for sslCertificate, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/sslCertificate (bgpcommPeerConfigType)

    YANG Description: ssl-server certificate.
    """
    return self.__sslCertificate
      
  def _set_sslCertificate(self, v, load=False):
    """
    Setter method for sslCertificate, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/sslCertificate (bgpcommPeerConfigType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sslCertificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sslCertificate() directly.

    YANG Description: ssl-server certificate.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConfigType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sslCertificate must be of a type compatible with bgpcommPeerConfigType""",
          'defined-type': "huawei-bgp:bgpcommPeerConfigType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConfigType', is_config=True)""",
        })

    self.__sslCertificate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sslCertificate(self):
    self.__sslCertificate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="sslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConfigType', is_config=True)


  def _get_effectSslCertificate(self):
    """
    Getter method for effectSslCertificate, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/effectSslCertificate (boolean)

    YANG Description: ssl-server effect certificate.
    """
    return self.__effectSslCertificate
      
  def _set_effectSslCertificate(self, v, load=False):
    """
    Setter method for effectSslCertificate, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/effectSslCertificate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effectSslCertificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effectSslCertificate() directly.

    YANG Description: ssl-server effect certificate.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="effectSslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effectSslCertificate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="effectSslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__effectSslCertificate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effectSslCertificate(self):
    self.__effectSslCertificate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="effectSslCertificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=False)


  def _get_configSslPolicyName(self):
    """
    Getter method for configSslPolicyName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/configSslPolicyName (string)

    YANG Description: ssl config policy name.
    """
    return self.__configSslPolicyName
      
  def _set_configSslPolicyName(self, v, load=False):
    """
    Setter method for configSslPolicyName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/configSslPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configSslPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configSslPolicyName() directly.

    YANG Description: ssl config policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="configSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configSslPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="configSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__configSslPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configSslPolicyName(self):
    self.__configSslPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="configSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_effectSslPolicyName(self):
    """
    Getter method for effectSslPolicyName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/effectSslPolicyName (string)

    YANG Description: ssl effect policy name.
    """
    return self.__effectSslPolicyName
      
  def _set_effectSslPolicyName(self, v, load=False):
    """
    Setter method for effectSslPolicyName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy/effectSslPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effectSslPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effectSslPolicyName() directly.

    YANG Description: ssl effect policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..23']}), is_leaf=True, yang_name="effectSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effectSslPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..23']}), is_leaf=True, yang_name="effectSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)""",
        })

    self.__effectSslPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effectSslPolicyName(self):
    self.__effectSslPolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..23']}), is_leaf=True, yang_name="effectSslPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)

  role = __builtin__.property(_get_role, _set_role)
  effectRole = __builtin__.property(_get_effectRole)
  sslCertificate = __builtin__.property(_get_sslCertificate, _set_sslCertificate)
  effectSslCertificate = __builtin__.property(_get_effectSslCertificate)
  configSslPolicyName = __builtin__.property(_get_configSslPolicyName, _set_configSslPolicyName)
  effectSslPolicyName = __builtin__.property(_get_effectSslPolicyName)


  _pyangbind_elements = OrderedDict([('role', role), ('effectRole', effectRole), ('sslCertificate', sslCertificate), ('effectSslCertificate', effectSslCertificate), ('configSslPolicyName', configSslPolicyName), ('effectSslPolicyName', effectSslPolicyName), ])


class yc_peerSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the ssl-policy list of the peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerSslPolicy',)

  _yang_name = 'peerSslPolicys'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerSslPolicy = YANGDynClass(base=yc_peerSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys_peerSslPolicy, is_container='container', yang_name="peerSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer', 'peerSslPolicys']

  def _get_peerSslPolicy(self):
    """
    Getter method for peerSslPolicy, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy (container)

    YANG Description: Specifies the ssl-policy of the peer.
    """
    return self.__peerSslPolicy
      
  def _set_peerSslPolicy(self, v, load=False):
    """
    Setter method for peerSslPolicy, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys/peerSslPolicy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerSslPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerSslPolicy() directly.

    YANG Description: Specifies the ssl-policy of the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys_peerSslPolicy, is_container='container', yang_name="peerSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerSslPolicy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys_peerSslPolicy, is_container='container', yang_name="peerSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerSslPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerSslPolicy(self):
    self.__peerSslPolicy = YANGDynClass(base=yc_peerSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys_peerSslPolicy, is_container='container', yang_name="peerSslPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  peerSslPolicy = __builtin__.property(_get_peerSslPolicy, _set_peerSslPolicy) # type: yc_peerSslPolicy_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys_peerSslPolicy


  _pyangbind_elements = OrderedDict([('peerSslPolicy', peerSslPolicy), ])


class yc_bgpPeer_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurations of a single BGP peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerAddr','__groupName','__remoteAs','__description','__fakeAs','__dualAs','__conventional','__routeRefresh','__fourByteAs','__isIgnore','__localIfName','__localIfAddress','__ebgpMaxHop','__validTtlHops','__connectMode','__isLogChange','__pswdType','__pswdCipherText','__keepAliveTime','__holdTime','__minHoldTime','__keyChainName','__pathMTUD','__trackingEnable','__trackDelayTime','__connRetryTime','__tcpMSS','__mplsLocalIfnetDisable','__prependGlobalAs','__prependFakeAs','__pathAttrDiscardIdMap','__pathAttrWithdrawIdMap','__checkFirstAs','__egressEngineer','__peerLogInfos','__peerBfd','__relyStateInterfaces','__peerSslPolicys',)

  _yang_name = 'bgpPeer'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerAddr = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__groupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__remoteAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__pathMTUD = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pathAttrDiscardIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__pathAttrWithdrawIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    self.__egressEngineer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="egressEngineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpEpeState', is_config=True)
    self.__peerLogInfos = YANGDynClass(base=yc_peerLogInfos_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos, is_container='container', yang_name="peerLogInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peerBfd = YANGDynClass(base=yc_peerBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__relyStateInterfaces = YANGDynClass(base=yc_relyStateInterfaces_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces, is_container='container', yang_name="relyStateInterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peerSslPolicys = YANGDynClass(base=yc_peerSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys, is_container='container', yang_name="peerSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers', 'bgpPeer']

  def _get_peerAddr(self):
    """
    Getter method for peerAddr, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerAddr (inet:ip-address-no-zone)

    YANG Description: Connection address of a peer, which can be an IPv4 or IPv6 address.
    """
    return self.__peerAddr
      
  def _set_peerAddr(self, v, load=False):
    """
    Setter method for peerAddr, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerAddr (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAddr() directly.

    YANG Description: Connection address of a peer, which can be an IPv4 or IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAddr must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__peerAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAddr(self):
    self.__peerAddr = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_groupName(self):
    """
    Getter method for groupName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/groupName (leafref)

    YANG Description: Specify the name of a peer group that BGP peers need to join. That must be selected group name or AS when creating, and the value is a string, spaces not supported. By default, BGP peers join no peer group. BGP peers distinguish the peer group type when joining a peer group. IBGP peers cannot join an EBGP peer group.  BGP peers will be deleted when they leave a peer group. 
    """
    return self.__groupName
      
  def _set_groupName(self, v, load=False):
    """
    Setter method for groupName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/groupName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupName() directly.

    YANG Description: Specify the name of a peer group that BGP peers need to join. That must be selected group name or AS when creating, and the value is a string, spaces not supported. By default, BGP peers join no peer group. BGP peers distinguish the peer group type when joining a peer group. IBGP peers cannot join an EBGP peer group.  BGP peers will be deleted when they leave a peer group. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__groupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupName(self):
    self.__groupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_remoteAs(self):
    """
    Getter method for remoteAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/remoteAs (asNumberValidate)

    YANG Description: AS number of a peer, which must be selected or group name when creating, and which can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
This node cannot be deleted or updated.
    """
    return self.__remoteAs
      
  def _set_remoteAs(self, v, load=False):
    """
    Setter method for remoteAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/remoteAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remoteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remoteAs() directly.

    YANG Description: AS number of a peer, which must be selected or group name when creating, and which can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
This node cannot be deleted or updated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remoteAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__remoteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remoteAs(self):
    self.__remoteAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/description (string)

    YANG Description: Description of a peer, which can be letters or digits. The description is a string of 1 to 80 characters, with spaces supported. By default, no description is configured for a peer.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of a peer, which can be letters or digits. The description is a string of 1 to 80 characters, with spaces supported. By default, no description is configured for a peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..255']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_fakeAs(self):
    """
    Getter method for fakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/fakeAs (asNumberValidate)

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    return self.__fakeAs
      
  def _set_fakeAs(self, v, load=False):
    """
    Setter method for fakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/fakeAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fakeAs() directly.

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fakeAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__fakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fakeAs(self):
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_dualAs(self):
    """
    Getter method for dualAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/dualAs (boolean)

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    return self.__dualAs
      
  def _set_dualAs(self, v, load=False):
    """
    Setter method for dualAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/dualAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dualAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dualAs() directly.

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dualAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__dualAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dualAs(self):
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_conventional(self):
    """
    Getter method for conventional, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/conventional (boolean)

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    return self.__conventional
      
  def _set_conventional(self, v, load=False):
    """
    Setter method for conventional, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/conventional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conventional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conventional() directly.

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conventional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__conventional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conventional(self):
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routeRefresh(self):
    """
    Getter method for routeRefresh, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/routeRefresh (boolean)

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    return self.__routeRefresh
      
  def _set_routeRefresh(self, v, load=False):
    """
    Setter method for routeRefresh, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/routeRefresh (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeRefresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeRefresh() directly.

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeRefresh must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__routeRefresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeRefresh(self):
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_fourByteAs(self):
    """
    Getter method for fourByteAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/fourByteAs (boolean)

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    return self.__fourByteAs
      
  def _set_fourByteAs(self, v, load=False):
    """
    Setter method for fourByteAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/fourByteAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fourByteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fourByteAs() directly.

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fourByteAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__fourByteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fourByteAs(self):
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isIgnore(self):
    """
    Getter method for isIgnore, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/isIgnore (boolean)

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    return self.__isIgnore
      
  def _set_isIgnore(self, v, load=False):
    """
    Setter method for isIgnore, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/isIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isIgnore() directly.

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isIgnore(self):
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_localIfName(self):
    """
    Getter method for localIfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/localIfName (string)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfName
      
  def _set_localIfName(self, v, load=False):
    """
    Setter method for localIfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/localIfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfName() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__localIfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfName(self):
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_localIfAddress(self):
    """
    Getter method for localIfAddress, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/localIfAddress (inet:ip-address-no-zone)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfAddress
      
  def _set_localIfAddress(self, v, load=False):
    """
    Setter method for localIfAddress, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/localIfAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfAddress() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__localIfAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfAddress(self):
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_ebgpMaxHop(self):
    """
    Getter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/ebgpMaxHop (uint32)

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.By default,value is determined by the neighbor type,the default value of EBGP is 1 and the default value of IBGP is 0.
    """
    return self.__ebgpMaxHop
      
  def _set_ebgpMaxHop(self, v, load=False):
    """
    Setter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/ebgpMaxHop (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgpMaxHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgpMaxHop() directly.

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.By default,value is determined by the neighbor type,the default value of EBGP is 1 and the default value of IBGP is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgpMaxHop must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__ebgpMaxHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgpMaxHop(self):
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_validTtlHops(self):
    """
    Getter method for validTtlHops, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/validTtlHops (uint16)

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255]. 
    """
    return self.__validTtlHops
      
  def _set_validTtlHops(self, v, load=False):
    """
    Setter method for validTtlHops, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/validTtlHops (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_validTtlHops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_validTtlHops() directly.

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255]. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """validTtlHops must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__validTtlHops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_validTtlHops(self):
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connectMode(self):
    """
    Getter method for connectMode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/connectMode (bgpcommPeerConnectMode)

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    return self.__connectMode
      
  def _set_connectMode(self, v, load=False):
    """
    Setter method for connectMode, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/connectMode (bgpcommPeerConnectMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectMode() directly.

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connectMode must be of a type compatible with bgpcommPeerConnectMode""",
          'defined-type': "huawei-bgp:bgpcommPeerConnectMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)""",
        })

    self.__connectMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connectMode(self):
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)


  def _get_isLogChange(self):
    """
    Getter method for isLogChange, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/isLogChange (boolean)

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    return self.__isLogChange
      
  def _set_isLogChange(self, v, load=False):
    """
    Setter method for isLogChange, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/isLogChange (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLogChange is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLogChange() directly.

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLogChange must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isLogChange = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLogChange(self):
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pswdType(self):
    """
    Getter method for pswdType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pswdType (bgpcommPasswordType)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    return self.__pswdType
      
  def _set_pswdType(self, v, load=False):
    """
    Setter method for pswdType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pswdType (bgpcommPasswordType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdType() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdType must be of a type compatible with bgpcommPasswordType""",
          'defined-type': "huawei-bgp:bgpcommPasswordType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)""",
        })

    self.__pswdType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdType(self):
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)


  def _get_pswdCipherText(self):
    """
    Getter method for pswdCipherText, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pswdCipherText (string)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 432. If the length is set to 0, no password is set.
    """
    return self.__pswdCipherText
      
  def _set_pswdCipherText(self, v, load=False):
    """
    Setter method for pswdCipherText, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pswdCipherText (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdCipherText is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdCipherText() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 432. If the length is set to 0, no password is set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdCipherText must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pswdCipherText = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdCipherText(self):
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_keepAliveTime(self):
    """
    Getter method for keepAliveTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/keepAliveTime (uint32)

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    return self.__keepAliveTime
      
  def _set_keepAliveTime(self, v, load=False):
    """
    Setter method for keepAliveTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/keepAliveTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAliveTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAliveTime() directly.

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAliveTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__keepAliveTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAliveTime(self):
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/holdTime (uint32)

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_minHoldTime(self):
    """
    Getter method for minHoldTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/minHoldTime (uint32)

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.


    """
    return self.__minHoldTime
      
  def _set_minHoldTime(self, v, load=False):
    """
    Setter method for minHoldTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/minHoldTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minHoldTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minHoldTime() directly.

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.


    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minHoldTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__minHoldTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minHoldTime(self):
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_keyChainName(self):
    """
    Getter method for keyChainName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/keyChainName (string)

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    return self.__keyChainName
      
  def _set_keyChainName(self, v, load=False):
    """
    Setter method for keyChainName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/keyChainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyChainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyChainName() directly.

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyChainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__keyChainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyChainName(self):
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_pathMTUD(self):
    """
    Getter method for pathMTUD, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pathMTUD (boolean)

    YANG Description: path-mtu auto-discovery.
    """
    return self.__pathMTUD
      
  def _set_pathMTUD(self, v, load=False):
    """
    Setter method for pathMTUD, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pathMTUD (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathMTUD is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathMTUD() directly.

    YANG Description: path-mtu auto-discovery.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathMTUD must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__pathMTUD = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathMTUD(self):
    self.__pathMTUD = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pathMTUD", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_trackingEnable(self):
    """
    Getter method for trackingEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/trackingEnable (boolean)

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    return self.__trackingEnable
      
  def _set_trackingEnable(self, v, load=False):
    """
    Setter method for trackingEnable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/trackingEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackingEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackingEnable() directly.

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackingEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__trackingEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackingEnable(self):
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_trackDelayTime(self):
    """
    Getter method for trackDelayTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/trackDelayTime (uint16)

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    return self.__trackDelayTime
      
  def _set_trackDelayTime(self, v, load=False):
    """
    Setter method for trackDelayTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/trackDelayTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackDelayTime() directly.

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackDelayTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__trackDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackDelayTime(self):
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connRetryTime(self):
    """
    Getter method for connRetryTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/connRetryTime (uint16)

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    return self.__connRetryTime
      
  def _set_connRetryTime(self, v, load=False):
    """
    Setter method for connRetryTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/connRetryTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connRetryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connRetryTime() directly.

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connRetryTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connRetryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connRetryTime(self):
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_tcpMSS(self):
    """
    Getter method for tcpMSS, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/tcpMSS (uint16)

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer. 
    """
    return self.__tcpMSS
      
  def _set_tcpMSS(self, v, load=False):
    """
    Setter method for tcpMSS, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/tcpMSS (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpMSS is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpMSS() directly.

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpMSS must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__tcpMSS = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpMSS(self):
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_mplsLocalIfnetDisable(self):
    """
    Getter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/mplsLocalIfnetDisable (boolean)

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    return self.__mplsLocalIfnetDisable
      
  def _set_mplsLocalIfnetDisable(self, v, load=False):
    """
    Setter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/mplsLocalIfnetDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mplsLocalIfnetDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mplsLocalIfnetDisable() directly.

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mplsLocalIfnetDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__mplsLocalIfnetDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mplsLocalIfnetDisable(self):
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependGlobalAs(self):
    """
    Getter method for prependGlobalAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/prependGlobalAs (boolean)

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    return self.__prependGlobalAs
      
  def _set_prependGlobalAs(self, v, load=False):
    """
    Setter method for prependGlobalAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/prependGlobalAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependGlobalAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependGlobalAs() directly.

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependGlobalAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependGlobalAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependGlobalAs(self):
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependFakeAs(self):
    """
    Getter method for prependFakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/prependFakeAs (boolean)

    YANG Description: Add the Fake AS number to received Update packets.
    """
    return self.__prependFakeAs
      
  def _set_prependFakeAs(self, v, load=False):
    """
    Setter method for prependFakeAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/prependFakeAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependFakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependFakeAs() directly.

    YANG Description: Add the Fake AS number to received Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependFakeAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependFakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependFakeAs(self):
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pathAttrDiscardIdMap(self):
    """
    Getter method for pathAttrDiscardIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pathAttrDiscardIdMap (string)

    YANG Description: Specify a discard attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    return self.__pathAttrDiscardIdMap
      
  def _set_pathAttrDiscardIdMap(self, v, load=False):
    """
    Setter method for pathAttrDiscardIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pathAttrDiscardIdMap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrDiscardIdMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrDiscardIdMap() directly.

    YANG Description: Specify a discard attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrDiscardIdMap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pathAttrDiscardIdMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrDiscardIdMap(self):
    self.__pathAttrDiscardIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_pathAttrWithdrawIdMap(self):
    """
    Getter method for pathAttrWithdrawIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pathAttrWithdrawIdMap (string)

    YANG Description: Specify a withdraw attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    return self.__pathAttrWithdrawIdMap
      
  def _set_pathAttrWithdrawIdMap(self, v, load=False):
    """
    Setter method for pathAttrWithdrawIdMap, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/pathAttrWithdrawIdMap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrWithdrawIdMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrWithdrawIdMap() directly.

    YANG Description: Specify a withdraw attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrWithdrawIdMap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pathAttrWithdrawIdMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrWithdrawIdMap(self):
    self.__pathAttrWithdrawIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_checkFirstAs(self):
    """
    Getter method for checkFirstAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/checkFirstAs (bgpCheckFirstAsTriState)

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    return self.__checkFirstAs
      
  def _set_checkFirstAs(self, v, load=False):
    """
    Setter method for checkFirstAs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/checkFirstAs (bgpCheckFirstAsTriState)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkFirstAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkFirstAs() directly.

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkFirstAs must be of a type compatible with bgpCheckFirstAsTriState""",
          'defined-type': "huawei-bgp:bgpCheckFirstAsTriState",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)""",
        })

    self.__checkFirstAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkFirstAs(self):
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)


  def _get_egressEngineer(self):
    """
    Getter method for egressEngineer, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/egressEngineer (bgpEpeState)

    YANG Description: BGP Egress Peer Engineering (BGP-EPE) is enable or disable. The default value is default(The function is disable,If the neighbor joins the group, the function is Inheritance group).
    """
    return self.__egressEngineer
      
  def _set_egressEngineer(self, v, load=False):
    """
    Setter method for egressEngineer, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/egressEngineer (bgpEpeState)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_egressEngineer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_egressEngineer() directly.

    YANG Description: BGP Egress Peer Engineering (BGP-EPE) is enable or disable. The default value is default(The function is disable,If the neighbor joins the group, the function is Inheritance group).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="egressEngineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpEpeState', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """egressEngineer must be of a type compatible with bgpEpeState""",
          'defined-type': "huawei-bgp:bgpEpeState",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="egressEngineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpEpeState', is_config=True)""",
        })

    self.__egressEngineer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_egressEngineer(self):
    self.__egressEngineer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="egressEngineer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpEpeState', is_config=True)


  def _get_peerLogInfos(self):
    """
    Getter method for peerLogInfos, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos (container)

    YANG Description: Peer log information list.
    """
    return self.__peerLogInfos
      
  def _set_peerLogInfos(self, v, load=False):
    """
    Setter method for peerLogInfos, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerLogInfos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerLogInfos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerLogInfos() directly.

    YANG Description: Peer log information list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerLogInfos_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos, is_container='container', yang_name="peerLogInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerLogInfos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerLogInfos_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos, is_container='container', yang_name="peerLogInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerLogInfos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerLogInfos(self):
    self.__peerLogInfos = YANGDynClass(base=yc_peerLogInfos_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos, is_container='container', yang_name="peerLogInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peerBfd(self):
    """
    Getter method for peerBfd, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd (container)

    YANG Description: Configure BFD.
    """
    return self.__peerBfd
      
  def _set_peerBfd(self, v, load=False):
    """
    Setter method for peerBfd, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerBfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerBfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerBfd() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerBfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerBfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerBfd(self):
    self.__peerBfd = YANGDynClass(base=yc_peerBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_relyStateInterfaces(self):
    """
    Getter method for relyStateInterfaces, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces (container)

    YANG Description: Specifies the name list of the check interface.
    """
    return self.__relyStateInterfaces
      
  def _set_relyStateInterfaces(self, v, load=False):
    """
    Setter method for relyStateInterfaces, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/relyStateInterfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relyStateInterfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relyStateInterfaces() directly.

    YANG Description: Specifies the name list of the check interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_relyStateInterfaces_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces, is_container='container', yang_name="relyStateInterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relyStateInterfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_relyStateInterfaces_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces, is_container='container', yang_name="relyStateInterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__relyStateInterfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relyStateInterfaces(self):
    self.__relyStateInterfaces = YANGDynClass(base=yc_relyStateInterfaces_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces, is_container='container', yang_name="relyStateInterfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peerSslPolicys(self):
    """
    Getter method for peerSslPolicys, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys (container)

    YANG Description: Specifies the ssl-policy list of the peer.
    """
    return self.__peerSslPolicys
      
  def _set_peerSslPolicys(self, v, load=False):
    """
    Setter method for peerSslPolicys, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer/peerSslPolicys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerSslPolicys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerSslPolicys() directly.

    YANG Description: Specifies the ssl-policy list of the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys, is_container='container', yang_name="peerSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerSslPolicys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys, is_container='container', yang_name="peerSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerSslPolicys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerSslPolicys(self):
    self.__peerSslPolicys = YANGDynClass(base=yc_peerSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys, is_container='container', yang_name="peerSslPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  peerAddr = __builtin__.property(_get_peerAddr, _set_peerAddr)
  groupName = __builtin__.property(_get_groupName, _set_groupName)
  remoteAs = __builtin__.property(_get_remoteAs, _set_remoteAs)
  description = __builtin__.property(_get_description, _set_description)
  fakeAs = __builtin__.property(_get_fakeAs, _set_fakeAs)
  dualAs = __builtin__.property(_get_dualAs, _set_dualAs)
  conventional = __builtin__.property(_get_conventional, _set_conventional)
  routeRefresh = __builtin__.property(_get_routeRefresh, _set_routeRefresh)
  fourByteAs = __builtin__.property(_get_fourByteAs, _set_fourByteAs)
  isIgnore = __builtin__.property(_get_isIgnore, _set_isIgnore)
  localIfName = __builtin__.property(_get_localIfName, _set_localIfName)
  localIfAddress = __builtin__.property(_get_localIfAddress, _set_localIfAddress)
  ebgpMaxHop = __builtin__.property(_get_ebgpMaxHop, _set_ebgpMaxHop)
  validTtlHops = __builtin__.property(_get_validTtlHops, _set_validTtlHops)
  connectMode = __builtin__.property(_get_connectMode, _set_connectMode)
  isLogChange = __builtin__.property(_get_isLogChange, _set_isLogChange)
  pswdType = __builtin__.property(_get_pswdType, _set_pswdType)
  pswdCipherText = __builtin__.property(_get_pswdCipherText, _set_pswdCipherText)
  keepAliveTime = __builtin__.property(_get_keepAliveTime, _set_keepAliveTime)
  holdTime = __builtin__.property(_get_holdTime, _set_holdTime)
  minHoldTime = __builtin__.property(_get_minHoldTime, _set_minHoldTime)
  keyChainName = __builtin__.property(_get_keyChainName, _set_keyChainName)
  pathMTUD = __builtin__.property(_get_pathMTUD, _set_pathMTUD)
  trackingEnable = __builtin__.property(_get_trackingEnable, _set_trackingEnable)
  trackDelayTime = __builtin__.property(_get_trackDelayTime, _set_trackDelayTime)
  connRetryTime = __builtin__.property(_get_connRetryTime, _set_connRetryTime)
  tcpMSS = __builtin__.property(_get_tcpMSS, _set_tcpMSS)
  mplsLocalIfnetDisable = __builtin__.property(_get_mplsLocalIfnetDisable, _set_mplsLocalIfnetDisable)
  prependGlobalAs = __builtin__.property(_get_prependGlobalAs, _set_prependGlobalAs)
  prependFakeAs = __builtin__.property(_get_prependFakeAs, _set_prependFakeAs)
  pathAttrDiscardIdMap = __builtin__.property(_get_pathAttrDiscardIdMap, _set_pathAttrDiscardIdMap)
  pathAttrWithdrawIdMap = __builtin__.property(_get_pathAttrWithdrawIdMap, _set_pathAttrWithdrawIdMap)
  checkFirstAs = __builtin__.property(_get_checkFirstAs, _set_checkFirstAs)
  egressEngineer = __builtin__.property(_get_egressEngineer, _set_egressEngineer)
  peerLogInfos = __builtin__.property(_get_peerLogInfos, _set_peerLogInfos) # type: yc_peerLogInfos_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerLogInfos
  peerBfd = __builtin__.property(_get_peerBfd, _set_peerBfd) # type: yc_peerBfd_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerBfd
  relyStateInterfaces = __builtin__.property(_get_relyStateInterfaces, _set_relyStateInterfaces) # type: yc_relyStateInterfaces_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_relyStateInterfaces
  peerSslPolicys = __builtin__.property(_get_peerSslPolicys, _set_peerSslPolicys) # type: yc_peerSslPolicys_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer_peerSslPolicys


  _pyangbind_elements = OrderedDict([('peerAddr', peerAddr), ('groupName', groupName), ('remoteAs', remoteAs), ('description', description), ('fakeAs', fakeAs), ('dualAs', dualAs), ('conventional', conventional), ('routeRefresh', routeRefresh), ('fourByteAs', fourByteAs), ('isIgnore', isIgnore), ('localIfName', localIfName), ('localIfAddress', localIfAddress), ('ebgpMaxHop', ebgpMaxHop), ('validTtlHops', validTtlHops), ('connectMode', connectMode), ('isLogChange', isLogChange), ('pswdType', pswdType), ('pswdCipherText', pswdCipherText), ('keepAliveTime', keepAliveTime), ('holdTime', holdTime), ('minHoldTime', minHoldTime), ('keyChainName', keyChainName), ('pathMTUD', pathMTUD), ('trackingEnable', trackingEnable), ('trackDelayTime', trackDelayTime), ('connRetryTime', connRetryTime), ('tcpMSS', tcpMSS), ('mplsLocalIfnetDisable', mplsLocalIfnetDisable), ('prependGlobalAs', prependGlobalAs), ('prependFakeAs', prependFakeAs), ('pathAttrDiscardIdMap', pathAttrDiscardIdMap), ('pathAttrWithdrawIdMap', pathAttrWithdrawIdMap), ('checkFirstAs', checkFirstAs), ('egressEngineer', egressEngineer), ('peerLogInfos', peerLogInfos), ('peerBfd', peerBfd), ('relyStateInterfaces', relyStateInterfaces), ('peerSslPolicys', peerSslPolicys), ])


class yc_bgpPeers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpPeer',)

  _yang_name = 'bgpPeers'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpPeer = YANGDynClass(base=YANGListType("peerAddr",yc_bgpPeer_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer, yang_name="bgpPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpPeers']

  def _get_bgpPeer(self):
    """
    Getter method for bgpPeer, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer (list)

    YANG Description: Configurations of a single BGP peer.
    """
    return self.__bgpPeer
      
  def _set_bgpPeer(self, v, load=False):
    """
    Setter method for bgpPeer, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers/bgpPeer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpPeer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpPeer() directly.

    YANG Description: Configurations of a single BGP peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerAddr",yc_bgpPeer_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer, yang_name="bgpPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpPeer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerAddr",yc_bgpPeer_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer, yang_name="bgpPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpPeer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpPeer(self):
    self.__bgpPeer = YANGDynClass(base=YANGListType("peerAddr",yc_bgpPeer_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer, yang_name="bgpPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpPeer = __builtin__.property(_get_bgpPeer, _set_bgpPeer) # type: yc_bgpPeer_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers_bgpPeer


  _pyangbind_elements = OrderedDict([('bgpPeer', bgpPeer), ])


class yc_locator_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators_locator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Locator for BGP Import.
  """
  __slots__ = ('_path_helper', '_extmethods', '__locatorName','__autoSid',)

  _yang_name = 'locator'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__locatorName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__autoSid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpVrfAFs', 'bgpVrfAF', 'locators', 'locator']

  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator/locatorName (leafref)

    YANG Description: Locator name for BGP Import.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator/locatorName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Locator name for BGP Import.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_autoSid(self):
    """
    Getter method for autoSid, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator/autoSid (boolean)

    YANG Description: SID automatic allocation ability.
    """
    return self.__autoSid
      
  def _set_autoSid(self, v, load=False):
    """
    Setter method for autoSid, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator/autoSid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoSid() directly.

    YANG Description: SID automatic allocation ability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoSid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__autoSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoSid(self):
    self.__autoSid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  locatorName = __builtin__.property(_get_locatorName, _set_locatorName)
  autoSid = __builtin__.property(_get_autoSid, _set_autoSid)


  _pyangbind_elements = OrderedDict([('locatorName', locatorName), ('autoSid', autoSid), ])


class yc_locators_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of locators used by segment-routing IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__locator',)

  _yang_name = 'locators'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__locator = YANGDynClass(base=YANGListType("locatorName",yc_locator_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators_locator, yang_name="locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpVrfAFs', 'bgpVrfAF', 'locators']

  def _get_locator(self):
    """
    Getter method for locator, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator (list)

    YANG Description: Locator for BGP Import.
    """
    return self.__locator
      
  def _set_locator(self, v, load=False):
    """
    Setter method for locator, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators/locator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locator() directly.

    YANG Description: Locator for BGP Import.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("locatorName",yc_locator_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators_locator, yang_name="locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locator must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("locatorName",yc_locator_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators_locator, yang_name="locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__locator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locator(self):
    self.__locator = YANGDynClass(base=YANGListType("locatorName",yc_locator_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators_locator, yang_name="locator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='locatorName', extensions=None), is_container='list', yang_name="locator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  locator = __builtin__.property(_get_locator, _set_locator) # type: yc_locator_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators_locator


  _pyangbind_elements = OrderedDict([('locator', locator), ])


class yc_bgpVrfAF_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP address family instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afType','__locators',)

  _yang_name = 'bgpVrfAF'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv4multi': {}, 'ipv4vpn': {}, 'ipv6uni': {}, 'ipv6vpn': {}, 'ipv4flow': {}, 'l2vpnad': {}, 'mvpn': {}, 'vpntarget': {}, 'evpn': {}, 'ipv4vpnmcast': {}, 'ls': {}, 'mdt': {}, 'ipv6flow': {}, 'vpnv4flow': {}, 'vpnv6flow': {}, 'ipv4labeluni': {}, 'mvpnv6': {}, 'rpd': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPrefixType', is_config=True)
    self.__locators = YANGDynClass(base=yc_locators_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators, is_container='container', yang_name="locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpVrfAFs', 'bgpVrfAF']

  def _get_afType(self):
    """
    Getter method for afType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/afType (bgpcommPrefixType)

    YANG Description: Address family type of a BGP instance. 
    """
    return self.__afType
      
  def _set_afType(self, v, load=False):
    """
    Setter method for afType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/afType (bgpcommPrefixType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afType() directly.

    YANG Description: Address family type of a BGP instance. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv4multi': {}, 'ipv4vpn': {}, 'ipv6uni': {}, 'ipv6vpn': {}, 'ipv4flow': {}, 'l2vpnad': {}, 'mvpn': {}, 'vpntarget': {}, 'evpn': {}, 'ipv4vpnmcast': {}, 'ls': {}, 'mdt': {}, 'ipv6flow': {}, 'vpnv4flow': {}, 'vpnv6flow': {}, 'ipv4labeluni': {}, 'mvpnv6': {}, 'rpd': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPrefixType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afType must be of a type compatible with bgpcommPrefixType""",
          'defined-type': "huawei-bgp:bgpcommPrefixType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv4multi': {}, 'ipv4vpn': {}, 'ipv6uni': {}, 'ipv6vpn': {}, 'ipv4flow': {}, 'l2vpnad': {}, 'mvpn': {}, 'vpntarget': {}, 'evpn': {}, 'ipv4vpnmcast': {}, 'ls': {}, 'mdt': {}, 'ipv6flow': {}, 'vpnv4flow': {}, 'vpnv6flow': {}, 'ipv4labeluni': {}, 'mvpnv6': {}, 'rpd': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPrefixType', is_config=True)""",
        })

    self.__afType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afType(self):
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv4multi': {}, 'ipv4vpn': {}, 'ipv6uni': {}, 'ipv6vpn': {}, 'ipv4flow': {}, 'l2vpnad': {}, 'mvpn': {}, 'vpntarget': {}, 'evpn': {}, 'ipv4vpnmcast': {}, 'ls': {}, 'mdt': {}, 'ipv6flow': {}, 'vpnv4flow': {}, 'vpnv6flow': {}, 'ipv4labeluni': {}, 'mvpnv6': {}, 'rpd': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPrefixType', is_config=True)


  def _get_locators(self):
    """
    Getter method for locators, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators (container)

    YANG Description: List of locators used by segment-routing IPv6.
    """
    return self.__locators
      
  def _set_locators(self, v, load=False):
    """
    Setter method for locators, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF/locators (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locators is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locators() directly.

    YANG Description: List of locators used by segment-routing IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_locators_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators, is_container='container', yang_name="locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locators must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_locators_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators, is_container='container', yang_name="locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__locators = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locators(self):
    self.__locators = YANGDynClass(base=yc_locators_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators, is_container='container', yang_name="locators", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  afType = __builtin__.property(_get_afType, _set_afType)
  locators = __builtin__.property(_get_locators, _set_locators) # type: yc_locators_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF_locators


  _pyangbind_elements = OrderedDict([('afType', afType), ('locators', locators), ])


class yc_bgpVrfAFs_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP address family instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpVrfAF',)

  _yang_name = 'bgpVrfAFs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpVrfAF = YANGDynClass(base=YANGListType("afType",yc_bgpVrfAF_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF, yang_name="bgpVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf', 'bgpVrfAFs']

  def _get_bgpVrfAF(self):
    """
    Getter method for bgpVrfAF, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF (list)

    YANG Description: BGP address family instance.
    """
    return self.__bgpVrfAF
      
  def _set_bgpVrfAF(self, v, load=False):
    """
    Setter method for bgpVrfAF, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs/bgpVrfAF (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpVrfAF is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpVrfAF() directly.

    YANG Description: BGP address family instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afType",yc_bgpVrfAF_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF, yang_name="bgpVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpVrfAF must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afType",yc_bgpVrfAF_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF, yang_name="bgpVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpVrfAF = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpVrfAF(self):
    self.__bgpVrfAF = YANGDynClass(base=YANGListType("afType",yc_bgpVrfAF_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF, yang_name="bgpVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpVrfAF = __builtin__.property(_get_bgpVrfAF, _set_bgpVrfAF) # type: yc_bgpVrfAF_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs_bgpVrfAF


  _pyangbind_elements = OrderedDict([('bgpVrfAF', bgpVrfAF), ])


class yc_bgpVrf_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs/bgpVrf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Create a BGP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vrfName','__vrfSession','__vrfRidAutoSel','__routerId','__effectRouterId','__keepaliveTime','__holdTime','__minHoldTime','__connRetryTime','__defaultAfType','__bgpPeerGroups','__bgpPeers','__bgpVrfAFs',)

  _yang_name = 'bgpVrf'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vrfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__vrfSession = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__vrfRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routerId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__effectRouterId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__keepaliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__defaultAfType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommVrfPrefixType', is_config=True)
    self.__bgpPeerGroups = YANGDynClass(base=yc_bgpPeerGroups_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups, is_container='container', yang_name="bgpPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpPeers = YANGDynClass(base=yc_bgpPeers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers, is_container='container', yang_name="bgpPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpVrfAFs = YANGDynClass(base=yc_bgpVrfAFs_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs, is_container='container', yang_name="bgpVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs', 'bgpVrf']

  def _get_vrfName(self):
    """
    Getter method for vrfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/vrfName (string)

    YANG Description: VPN name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. 
    """
    return self.__vrfName
      
  def _set_vrfName(self, v, load=False):
    """
    Setter method for vrfName, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/vrfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfName() directly.

    YANG Description: VPN name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__vrfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfName(self):
    self.__vrfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_vrfSession(self):
    """
    Getter method for vrfSession, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/vrfSession (boolean)

    YANG Description: Create Vpn session View. This node cannot be deleted or modified.
    """
    return self.__vrfSession
      
  def _set_vrfSession(self, v, load=False):
    """
    Setter method for vrfSession, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/vrfSession (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfSession is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfSession() directly.

    YANG Description: Create Vpn session View. This node cannot be deleted or modified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfSession must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__vrfSession = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfSession(self):
    self.__vrfSession = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_vrfRidAutoSel(self):
    """
    Getter method for vrfRidAutoSel, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/vrfRidAutoSel (boolean)

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    return self.__vrfRidAutoSel
      
  def _set_vrfRidAutoSel(self, v, load=False):
    """
    Setter method for vrfRidAutoSel, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/vrfRidAutoSel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfRidAutoSel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfRidAutoSel() directly.

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfRidAutoSel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__vrfRidAutoSel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfRidAutoSel(self):
    self.__vrfRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routerId(self):
    """
    Getter method for routerId, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/routerId (inet:ipv4-address-no-zone)

    YANG Description: ID of a router that is in IPv4 address format. Certain dynamic routing protocols require a router ID. If no router ID is specified for a router when these protocols are enabled, the router ID in the RM module is used by default. The default router ID in the RM module is 0.0.0.0 when the router is not configured with any interface.
The rules for selecting a router ID are as follows:
1. If you set a router ID through this configuration, the set router ID is used. If the router ID is not set, you need to select a router ID according to the following rules:
(1) If loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the loopback interfaces is selected as the router ID.
(2) If no loopback interface configured with an IP address exists, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
The router ID is reselected only when the interface address that is selected as the router ID is deleted or changed. The router ID is not reselected in any of the following cases:
a. The interface is Down.
b. A loopback interface is configured when the IP address of a non-loopback interface is selected as the router ID.
c. A larger IP address of an interface is configured.
2. Each VPN instance selects the router ID from the addresses of the interfaces of the VPN instance according to the preceding rules.
3. When both the AMB and SMB exist on the router, the system backs up the router ID set through the related command and the router ID that is selected from IP addresses of the interfaces. After the active/standby switchover is performed, the system checks the validity of the router ID selected from the interface addresses. If the router ID is invalid, the system reselects a router ID.
    """
    return self.__routerId
      
  def _set_routerId(self, v, load=False):
    """
    Setter method for routerId, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/routerId (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routerId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routerId() directly.

    YANG Description: ID of a router that is in IPv4 address format. Certain dynamic routing protocols require a router ID. If no router ID is specified for a router when these protocols are enabled, the router ID in the RM module is used by default. The default router ID in the RM module is 0.0.0.0 when the router is not configured with any interface.
The rules for selecting a router ID are as follows:
1. If you set a router ID through this configuration, the set router ID is used. If the router ID is not set, you need to select a router ID according to the following rules:
(1) If loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the loopback interfaces is selected as the router ID.
(2) If no loopback interface configured with an IP address exists, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
The router ID is reselected only when the interface address that is selected as the router ID is deleted or changed. The router ID is not reselected in any of the following cases:
a. The interface is Down.
b. A loopback interface is configured when the IP address of a non-loopback interface is selected as the router ID.
c. A larger IP address of an interface is configured.
2. Each VPN instance selects the router ID from the addresses of the interfaces of the VPN instance according to the preceding rules.
3. When both the AMB and SMB exist on the router, the system backs up the router ID set through the related command and the router ID that is selected from IP addresses of the interfaces. After the active/standby switchover is performed, the system checks the validity of the router ID selected from the interface addresses. If the router ID is invalid, the system reselects a router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routerId must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__routerId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routerId(self):
    self.__routerId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_effectRouterId(self):
    """
    Getter method for effectRouterId, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/effectRouterId (inet:ipv4-address-no-zone)

    YANG Description: Router ID that takes effect.
    """
    return self.__effectRouterId
      
  def _set_effectRouterId(self, v, load=False):
    """
    Setter method for effectRouterId, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/effectRouterId (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effectRouterId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effectRouterId() directly.

    YANG Description: Router ID that takes effect.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effectRouterId must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__effectRouterId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effectRouterId(self):
    self.__effectRouterId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_keepaliveTime(self):
    """
    Getter method for keepaliveTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/keepaliveTime (uint32)

    YANG Description: If the value of a timer changes, the BGP peer relationship between the routers is disconnected. This is because the peers need to re-negotiate the Keepalive time and hold time. Therefore, confirm the action before you change the value of the timer. The Keepalive time should be at least three times of the hold time.
    """
    return self.__keepaliveTime
      
  def _set_keepaliveTime(self, v, load=False):
    """
    Setter method for keepaliveTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/keepaliveTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepaliveTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepaliveTime() directly.

    YANG Description: If the value of a timer changes, the BGP peer relationship between the routers is disconnected. This is because the peers need to re-negotiate the Keepalive time and hold time. Therefore, confirm the action before you change the value of the timer. The Keepalive time should be at least three times of the hold time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepaliveTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__keepaliveTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepaliveTime(self):
    self.__keepaliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/holdTime (uint32)

    YANG Description: Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535. When setting keepalive-time and hold-time, note the following:
1. The values of keepalive-time and hold-time cannot both be 0. Otherwise, the BGP timer becomes invalid. That is, BGP does not detect link faults according to the timer.
2. The value of hold-time is much greater than that of keepalive-time, such as, keepalive 1 and hold 65535. If the value of hold-time is too large, BGP cannot detect link faults timely.
The priority of a timer is lower than that of a peer timer.
After a connection is established between peers, the values of keepalive-time and hold-time are negotiated by the peers. The smaller value of hold-time contained in Open packets of both peers is taken as the value of hold-time. The smaller value of the locally set value of keepalive-time and one third of the value of hold-time is taken as the value of keepalive-time.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535. When setting keepalive-time and hold-time, note the following:
1. The values of keepalive-time and hold-time cannot both be 0. Otherwise, the BGP timer becomes invalid. That is, BGP does not detect link faults according to the timer.
2. The value of hold-time is much greater than that of keepalive-time, such as, keepalive 1 and hold 65535. If the value of hold-time is too large, BGP cannot detect link faults timely.
The priority of a timer is lower than that of a peer timer.
After a connection is established between peers, the values of keepalive-time and hold-time are negotiated by the peers. The smaller value of hold-time contained in Open packets of both peers is taken as the value of hold-time. The smaller value of the locally set value of keepalive-time and one third of the value of hold-time is taken as the value of keepalive-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_minHoldTime(self):
    """
    Getter method for minHoldTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/minHoldTime (uint32)

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    return self.__minHoldTime
      
  def _set_minHoldTime(self, v, load=False):
    """
    Setter method for minHoldTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/minHoldTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minHoldTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minHoldTime() directly.

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minHoldTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__minHoldTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minHoldTime(self):
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_connRetryTime(self):
    """
    Getter method for connRetryTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/connRetryTime (uint16)

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    return self.__connRetryTime
      
  def _set_connRetryTime(self, v, load=False):
    """
    Setter method for connRetryTime, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/connRetryTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connRetryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connRetryTime() directly.

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connRetryTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connRetryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connRetryTime(self):
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_defaultAfType(self):
    """
    Getter method for defaultAfType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/defaultAfType (bgpcommVrfPrefixType)

    YANG Description: Type of a created address family, which can be IPv4 unicast or IPv6 unicast. The default type is IPv4 unicast. This option takes effect only when a BGP instance is created for the first time. This node cannot be deleted or modified.
    """
    return self.__defaultAfType
      
  def _set_defaultAfType(self, v, load=False):
    """
    Setter method for defaultAfType, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/defaultAfType (bgpcommVrfPrefixType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultAfType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultAfType() directly.

    YANG Description: Type of a created address family, which can be IPv4 unicast or IPv6 unicast. The default type is IPv4 unicast. This option takes effect only when a BGP instance is created for the first time. This node cannot be deleted or modified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommVrfPrefixType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultAfType must be of a type compatible with bgpcommVrfPrefixType""",
          'defined-type': "huawei-bgp:bgpcommVrfPrefixType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommVrfPrefixType', is_config=True)""",
        })

    self.__defaultAfType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultAfType(self):
    self.__defaultAfType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommVrfPrefixType', is_config=True)


  def _get_bgpPeerGroups(self):
    """
    Getter method for bgpPeerGroups, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups (container)

    YANG Description: List of BGP peer groups. The BGP peer groups can help you simplify the configurations. If you want to perform the same configuration for several peers, you can create a peer group and then configure the peer group. After you add these peers to the peer group, all these peers will have the same configurations as the peer group. 
    """
    return self.__bgpPeerGroups
      
  def _set_bgpPeerGroups(self, v, load=False):
    """
    Setter method for bgpPeerGroups, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeerGroups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpPeerGroups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpPeerGroups() directly.

    YANG Description: List of BGP peer groups. The BGP peer groups can help you simplify the configurations. If you want to perform the same configuration for several peers, you can create a peer group and then configure the peer group. After you add these peers to the peer group, all these peers will have the same configurations as the peer group. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpPeerGroups_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups, is_container='container', yang_name="bgpPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpPeerGroups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpPeerGroups_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups, is_container='container', yang_name="bgpPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpPeerGroups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpPeerGroups(self):
    self.__bgpPeerGroups = YANGDynClass(base=yc_bgpPeerGroups_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups, is_container='container', yang_name="bgpPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpPeers(self):
    """
    Getter method for bgpPeers, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers (container)

    YANG Description: List of BGP peers.
    """
    return self.__bgpPeers
      
  def _set_bgpPeers(self, v, load=False):
    """
    Setter method for bgpPeers, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpPeers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpPeers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpPeers() directly.

    YANG Description: List of BGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpPeers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers, is_container='container', yang_name="bgpPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpPeers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpPeers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers, is_container='container', yang_name="bgpPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpPeers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpPeers(self):
    self.__bgpPeers = YANGDynClass(base=yc_bgpPeers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers, is_container='container', yang_name="bgpPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpVrfAFs(self):
    """
    Getter method for bgpVrfAFs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs (container)

    YANG Description: List of BGP address family instances.
    """
    return self.__bgpVrfAFs
      
  def _set_bgpVrfAFs(self, v, load=False):
    """
    Setter method for bgpVrfAFs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf/bgpVrfAFs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpVrfAFs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpVrfAFs() directly.

    YANG Description: List of BGP address family instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpVrfAFs_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs, is_container='container', yang_name="bgpVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpVrfAFs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpVrfAFs_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs, is_container='container', yang_name="bgpVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpVrfAFs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpVrfAFs(self):
    self.__bgpVrfAFs = YANGDynClass(base=yc_bgpVrfAFs_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs, is_container='container', yang_name="bgpVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  vrfName = __builtin__.property(_get_vrfName, _set_vrfName)
  vrfSession = __builtin__.property(_get_vrfSession, _set_vrfSession)
  vrfRidAutoSel = __builtin__.property(_get_vrfRidAutoSel, _set_vrfRidAutoSel)
  routerId = __builtin__.property(_get_routerId, _set_routerId)
  effectRouterId = __builtin__.property(_get_effectRouterId)
  keepaliveTime = __builtin__.property(_get_keepaliveTime, _set_keepaliveTime)
  holdTime = __builtin__.property(_get_holdTime, _set_holdTime)
  minHoldTime = __builtin__.property(_get_minHoldTime, _set_minHoldTime)
  connRetryTime = __builtin__.property(_get_connRetryTime, _set_connRetryTime)
  defaultAfType = __builtin__.property(_get_defaultAfType, _set_defaultAfType)
  bgpPeerGroups = __builtin__.property(_get_bgpPeerGroups, _set_bgpPeerGroups) # type: yc_bgpPeerGroups_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeerGroups
  bgpPeers = __builtin__.property(_get_bgpPeers, _set_bgpPeers) # type: yc_bgpPeers_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpPeers
  bgpVrfAFs = __builtin__.property(_get_bgpVrfAFs, _set_bgpVrfAFs) # type: yc_bgpVrfAFs_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf_bgpVrfAFs


  _pyangbind_elements = OrderedDict([('vrfName', vrfName), ('vrfSession', vrfSession), ('vrfRidAutoSel', vrfRidAutoSel), ('routerId', routerId), ('effectRouterId', effectRouterId), ('keepaliveTime', keepaliveTime), ('holdTime', holdTime), ('minHoldTime', minHoldTime), ('connRetryTime', connRetryTime), ('defaultAfType', defaultAfType), ('bgpPeerGroups', bgpPeerGroups), ('bgpPeers', bgpPeers), ('bgpVrfAFs', bgpVrfAFs), ])


class yc_bgpVrfs_huawei_bgp__bgp_bgpcomm_bgpVrfs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm/bgpVrfs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the list of all BGP instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpVrf',)

  _yang_name = 'bgpVrfs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpVrf = YANGDynClass(base=YANGListType("vrfName",yc_bgpVrf_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf, yang_name="bgpVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrfName', extensions=None), is_container='list', yang_name="bgpVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm', 'bgpVrfs']

  def _get_bgpVrf(self):
    """
    Getter method for bgpVrf, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf (list)

    YANG Description: Create a BGP instance.
    """
    return self.__bgpVrf
      
  def _set_bgpVrf(self, v, load=False):
    """
    Setter method for bgpVrf, mapped from YANG variable /bgp/bgpcomm/bgpVrfs/bgpVrf (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpVrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpVrf() directly.

    YANG Description: Create a BGP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vrfName",yc_bgpVrf_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf, yang_name="bgpVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrfName', extensions=None), is_container='list', yang_name="bgpVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpVrf must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vrfName",yc_bgpVrf_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf, yang_name="bgpVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrfName', extensions=None), is_container='list', yang_name="bgpVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpVrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpVrf(self):
    self.__bgpVrf = YANGDynClass(base=YANGListType("vrfName",yc_bgpVrf_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf, yang_name="bgpVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vrfName', extensions=None), is_container='list', yang_name="bgpVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpVrf = __builtin__.property(_get_bgpVrf, _set_bgpVrf) # type: yc_bgpVrf_huawei_bgp__bgp_bgpcomm_bgpVrfs_bgpVrf


  _pyangbind_elements = OrderedDict([('bgpVrf', bgpVrf), ])


class yc_bgpcomm_huawei_bgp__bgp_bgpcomm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpcomm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Universal BGP configurations that contain the basic BGP configurations and the query information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpSite','__bgpVrfs',)

  _yang_name = 'bgpcomm'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpSite = YANGDynClass(base=yc_bgpSite_huawei_bgp__bgp_bgpcomm_bgpSite, is_container='container', yang_name="bgpSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpVrfs = YANGDynClass(base=yc_bgpVrfs_huawei_bgp__bgp_bgpcomm_bgpVrfs, is_container='container', yang_name="bgpVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpcomm']

  def _get_bgpSite(self):
    """
    Getter method for bgpSite, mapped from YANG variable /bgp/bgpcomm/bgpSite (container)

    YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
    """
    return self.__bgpSite
      
  def _set_bgpSite(self, v, load=False):
    """
    Setter method for bgpSite, mapped from YANG variable /bgp/bgpcomm/bgpSite (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpSite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpSite() directly.

    YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpSite_huawei_bgp__bgp_bgpcomm_bgpSite, is_container='container', yang_name="bgpSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpSite must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpSite_huawei_bgp__bgp_bgpcomm_bgpSite, is_container='container', yang_name="bgpSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpSite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpSite(self):
    self.__bgpSite = YANGDynClass(base=yc_bgpSite_huawei_bgp__bgp_bgpcomm_bgpSite, is_container='container', yang_name="bgpSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpVrfs(self):
    """
    Getter method for bgpVrfs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs (container)

    YANG Description: Configure the list of all BGP instances.
    """
    return self.__bgpVrfs
      
  def _set_bgpVrfs(self, v, load=False):
    """
    Setter method for bgpVrfs, mapped from YANG variable /bgp/bgpcomm/bgpVrfs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpVrfs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpVrfs() directly.

    YANG Description: Configure the list of all BGP instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpVrfs_huawei_bgp__bgp_bgpcomm_bgpVrfs, is_container='container', yang_name="bgpVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpVrfs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpVrfs_huawei_bgp__bgp_bgpcomm_bgpVrfs, is_container='container', yang_name="bgpVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpVrfs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpVrfs(self):
    self.__bgpVrfs = YANGDynClass(base=yc_bgpVrfs_huawei_bgp__bgp_bgpcomm_bgpVrfs, is_container='container', yang_name="bgpVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  bgpSite = __builtin__.property(_get_bgpSite, _set_bgpSite) # type: yc_bgpSite_huawei_bgp__bgp_bgpcomm_bgpSite
  bgpVrfs = __builtin__.property(_get_bgpVrfs, _set_bgpVrfs) # type: yc_bgpVrfs_huawei_bgp__bgp_bgpcomm_bgpVrfs


  _pyangbind_elements = OrderedDict([('bgpSite', bgpSite), ('bgpVrfs', bgpVrfs), ])


class yc_bgpMultiSite_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites_bgpMultiSite(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiSiteName','__bgpVersion','__asNumber','__gracefulRestart','__timeWaitForRib','__asPathLimit','__checkFirstAs','__confedIdNumber','__confedNonstanded','__bgpRidAutoSel','__keepAllRoutes','__memoryLimit','__grPeerReset','__isShutdown','__suppressInterval','__holdInterval','__clearInterval','__private4byteAs',)

  _yang_name = 'bgpMultiSite'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiSiteName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__bgpVersion = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    self.__asNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__gracefulRestart = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__timeWaitForRib = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__asPathLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__checkFirstAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__confedIdNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__confedNonstanded = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__bgpRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__memoryLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__grPeerReset = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isShutdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__suppressInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__clearInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__private4byteAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiSites', 'bgpMultiSite']

  def _get_bgpMultiSiteName(self):
    """
    Getter method for bgpMultiSiteName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/bgpMultiSiteName (string)

    YANG Description: Name of BGP Site.
    """
    return self.__bgpMultiSiteName
      
  def _set_bgpMultiSiteName(self, v, load=False):
    """
    Setter method for bgpMultiSiteName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/bgpMultiSiteName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiSiteName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiSiteName() directly.

    YANG Description: Name of BGP Site.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiSiteName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__bgpMultiSiteName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiSiteName(self):
    self.__bgpMultiSiteName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_bgpVersion(self):
    """
    Getter method for bgpVersion, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/bgpVersion (uint8)

    YANG Description: BGP version, which is BGP-4 at present. BGP-4 provides a new mechanism to support Classless Inter-Domain Routing (CIDR). In this case, the network prefix-based advertisement is supported and the concept of class for a BGP network is canceled in the network prefix-supported advertisements. Another mechanism is also introduced to support route summarization, including the summarization of AS paths.
    """
    return self.__bgpVersion
      
  def _set_bgpVersion(self, v, load=False):
    """
    Setter method for bgpVersion, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/bgpVersion (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpVersion() directly.

    YANG Description: BGP version, which is BGP-4 at present. BGP-4 provides a new mechanism to support Classless Inter-Domain Routing (CIDR). In this case, the network prefix-based advertisement is supported and the concept of class for a BGP network is canceled in the network prefix-supported advertisements. Another mechanism is also introduced to support route summarization, including the summarization of AS paths.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpVersion must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__bgpVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpVersion(self):
    self.__bgpVersion = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bgpVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=False)


  def _get_asNumber(self):
    """
    Getter method for asNumber, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/asNumber (asNumberValidate)

    YANG Description: Local AS number, which can be in either of the two formats:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value ranging from 1 to 4294967295.
An AS consists of multiple routers managed based on the same techniques. Interior Gateway Protocol (IGP) and universal routing metric packets are used inside an AS, and Exterior Gateway Protocol (EGP) is used outside to send packets to other ASs. With the development of this definition, one AS usually uses multiple IGPs and metrics. Even though multiple IGPs and metrics are used, the routing plan and destination reachability of an AS are consistent with those of another AS. The local AS number cannot be configured same as the confederation sub-ASs.
    """
    return self.__asNumber
      
  def _set_asNumber(self, v, load=False):
    """
    Setter method for asNumber, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/asNumber (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asNumber() directly.

    YANG Description: Local AS number, which can be in either of the two formats:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value ranging from 1 to 4294967295.
An AS consists of multiple routers managed based on the same techniques. Interior Gateway Protocol (IGP) and universal routing metric packets are used inside an AS, and Exterior Gateway Protocol (EGP) is used outside to send packets to other ASs. With the development of this definition, one AS usually uses multiple IGPs and metrics. Even though multiple IGPs and metrics are used, the routing plan and destination reachability of an AS are consistent with those of another AS. The local AS number cannot be configured same as the confederation sub-ASs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asNumber must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__asNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asNumber(self):
    self.__asNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="asNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_gracefulRestart(self):
    """
    Getter method for gracefulRestart, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/gracefulRestart (boolean)

    YANG Description: Enable GR of the BGP speaker in the specified address family, peer address, or peer group. When GR is enabled, the BGP speaker enabled with GR keeps the forwarding state and sends the End-Of-RIB flag during the restart. In this case, however, the BGP speaker may not maintain the forwarding table. Enabling or disabling GR may delete and re-establish all sessions and instances.
    """
    return self.__gracefulRestart
      
  def _set_gracefulRestart(self, v, load=False):
    """
    Setter method for gracefulRestart, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/gracefulRestart (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gracefulRestart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gracefulRestart() directly.

    YANG Description: Enable GR of the BGP speaker in the specified address family, peer address, or peer group. When GR is enabled, the BGP speaker enabled with GR keeps the forwarding state and sends the End-Of-RIB flag during the restart. In this case, however, the BGP speaker may not maintain the forwarding table. Enabling or disabling GR may delete and re-establish all sessions and instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gracefulRestart must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__gracefulRestart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gracefulRestart(self):
    self.__gracefulRestart = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="gracefulRestart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_timeWaitForRib(self):
    """
    Getter method for timeWaitForRib, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/timeWaitForRib (uint32)

    YANG Description: Period of waiting for the End-Of-RIB flag. The value is an integer in seconds. The default value is 600. When a BGP session is established or re-established, the router enabled with GR should receive the End-Of-RIB flag in this period. If the router does not receive the End-Of-RIB flag in this period, ensure that the router can exit from the GR process.
    """
    return self.__timeWaitForRib
      
  def _set_timeWaitForRib(self, v, load=False):
    """
    Setter method for timeWaitForRib, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/timeWaitForRib (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeWaitForRib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeWaitForRib() directly.

    YANG Description: Period of waiting for the End-Of-RIB flag. The value is an integer in seconds. The default value is 600. When a BGP session is established or re-established, the router enabled with GR should receive the End-Of-RIB flag in this period. If the router does not receive the End-Of-RIB flag in this period, ensure that the router can exit from the GR process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeWaitForRib must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__timeWaitForRib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeWaitForRib(self):
    self.__timeWaitForRib = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..3000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="timeWaitForRib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_asPathLimit(self):
    """
    Getter method for asPathLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/asPathLimit (uint16)

    YANG Description: Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
    """
    return self.__asPathLimit
      
  def _set_asPathLimit(self, v, load=False):
    """
    Setter method for asPathLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/asPathLimit (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asPathLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asPathLimit() directly.

    YANG Description: Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asPathLimit must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__asPathLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asPathLimit(self):
    self.__asPathLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..2000']}), is_leaf=True, yang_name="asPathLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_checkFirstAs(self):
    """
    Getter method for checkFirstAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/checkFirstAs (boolean)

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    return self.__checkFirstAs
      
  def _set_checkFirstAs(self, v, load=False):
    """
    Setter method for checkFirstAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/checkFirstAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkFirstAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkFirstAs() directly.

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkFirstAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__checkFirstAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkFirstAs(self):
    self.__checkFirstAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_confedIdNumber(self):
    """
    Getter method for confedIdNumber, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/confedIdNumber (asNumberValidate)

    YANG Description: Confederation ID.
    """
    return self.__confedIdNumber
      
  def _set_confedIdNumber(self, v, load=False):
    """
    Setter method for confedIdNumber, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/confedIdNumber (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_confedIdNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_confedIdNumber() directly.

    YANG Description: Confederation ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """confedIdNumber must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__confedIdNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_confedIdNumber(self):
    self.__confedIdNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="confedIdNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_confedNonstanded(self):
    """
    Getter method for confedNonstanded, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/confedNonstanded (boolean)

    YANG Description: Configure the device to be compatible with devices in a nonstandard confederation.
    """
    return self.__confedNonstanded
      
  def _set_confedNonstanded(self, v, load=False):
    """
    Setter method for confedNonstanded, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/confedNonstanded (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_confedNonstanded is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_confedNonstanded() directly.

    YANG Description: Configure the device to be compatible with devices in a nonstandard confederation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """confedNonstanded must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__confedNonstanded = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_confedNonstanded(self):
    self.__confedNonstanded = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="confedNonstanded", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_bgpRidAutoSel(self):
    """
    Getter method for bgpRidAutoSel, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/bgpRidAutoSel (boolean)

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    return self.__bgpRidAutoSel
      
  def _set_bgpRidAutoSel(self, v, load=False):
    """
    Setter method for bgpRidAutoSel, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/bgpRidAutoSel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpRidAutoSel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpRidAutoSel() directly.

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpRidAutoSel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bgpRidAutoSel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpRidAutoSel(self):
    self.__bgpRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bgpRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_keepAllRoutes(self):
    """
    Getter method for keepAllRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/keepAllRoutes (boolean)

    YANG Description: Save all the updated information about BGP routes from a peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, only the updated information about BGP routes from a specified peer is saved on condition that the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    return self.__keepAllRoutes
      
  def _set_keepAllRoutes(self, v, load=False):
    """
    Setter method for keepAllRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/keepAllRoutes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAllRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAllRoutes() directly.

    YANG Description: Save all the updated information about BGP routes from a peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, only the updated information about BGP routes from a specified peer is saved on condition that the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAllRoutes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__keepAllRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAllRoutes(self):
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_memoryLimit(self):
    """
    Getter method for memoryLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/memoryLimit (boolean)

    YANG Description: Support BGP RIB memory protection. By default, the function is not enabled. With BGP RIB memory protection, routes are no longer received after the RIB memory is overloaded.
    """
    return self.__memoryLimit
      
  def _set_memoryLimit(self, v, load=False):
    """
    Setter method for memoryLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/memoryLimit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memoryLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memoryLimit() directly.

    YANG Description: Support BGP RIB memory protection. By default, the function is not enabled. With BGP RIB memory protection, routes are no longer received after the RIB memory is overloaded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memoryLimit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__memoryLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memoryLimit(self):
    self.__memoryLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="memoryLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_grPeerReset(self):
    """
    Getter method for grPeerReset, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/grPeerReset (boolean)

    YANG Description: Peer disconnection through GR.
    """
    return self.__grPeerReset
      
  def _set_grPeerReset(self, v, load=False):
    """
    Setter method for grPeerReset, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/grPeerReset (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grPeerReset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grPeerReset() directly.

    YANG Description: Peer disconnection through GR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grPeerReset must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__grPeerReset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grPeerReset(self):
    self.__grPeerReset = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="grPeerReset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isShutdown(self):
    """
    Getter method for isShutdown, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/isShutdown (boolean)

    YANG Description: Interrupt BGP all neighbor
    """
    return self.__isShutdown
      
  def _set_isShutdown(self, v, load=False):
    """
    Setter method for isShutdown, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/isShutdown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isShutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isShutdown() directly.

    YANG Description: Interrupt BGP all neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isShutdown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isShutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isShutdown(self):
    self.__isShutdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isShutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_suppressInterval(self):
    """
    Getter method for suppressInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/suppressInterval (uint32)

    YANG Description: Specifies the reference period used to add penalty in case of next hop flapping in seconds. By default, the value is 60 seconds.
    """
    return self.__suppressInterval
      
  def _set_suppressInterval(self, v, load=False):
    """
    Setter method for suppressInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/suppressInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppressInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppressInterval() directly.

    YANG Description: Specifies the reference period used to add penalty in case of next hop flapping in seconds. By default, the value is 60 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppressInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__suppressInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppressInterval(self):
    self.__suppressInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="suppressInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdInterval(self):
    """
    Getter method for holdInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/holdInterval (uint32)

    YANG Description: Specifies the reference period used to hold penalty in case of next hop flapping in seconds. By default, the value is 120 seconds.
    """
    return self.__holdInterval
      
  def _set_holdInterval(self, v, load=False):
    """
    Setter method for holdInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/holdInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdInterval() directly.

    YANG Description: Specifies the reference period used to hold penalty in case of next hop flapping in seconds. By default, the value is 120 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdInterval(self):
    self.__holdInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="holdInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_clearInterval(self):
    """
    Getter method for clearInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/clearInterval (uint32)

    YANG Description: Specifies the reference period used to clear penalty in case of next hop flapping in seconds. By default, the value is 600 seconds.
    """
    return self.__clearInterval
      
  def _set_clearInterval(self, v, load=False):
    """
    Setter method for clearInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/clearInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clearInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clearInterval() directly.

    YANG Description: Specifies the reference period used to clear penalty in case of next hop flapping in seconds. By default, the value is 600 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clearInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__clearInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clearInterval(self):
    self.__clearInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="clearInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_private4byteAs(self):
    """
    Getter method for private4byteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/private4byteAs (boolean)

    YANG Description: Support BGP private 4 byte AS. By default, the BGP private as is from 64512 to 65535. With BGP private-4-byte-as, BGP private as is from 64512 to 65535 and from 4200000000 to 4294967294.
    """
    return self.__private4byteAs
      
  def _set_private4byteAs(self, v, load=False):
    """
    Setter method for private4byteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite/private4byteAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_private4byteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_private4byteAs() directly.

    YANG Description: Support BGP private 4 byte AS. By default, the BGP private as is from 64512 to 65535. With BGP private-4-byte-as, BGP private as is from 64512 to 65535 and from 4200000000 to 4294967294.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """private4byteAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__private4byteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_private4byteAs(self):
    self.__private4byteAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="private4byteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  bgpMultiSiteName = __builtin__.property(_get_bgpMultiSiteName, _set_bgpMultiSiteName)
  bgpVersion = __builtin__.property(_get_bgpVersion)
  asNumber = __builtin__.property(_get_asNumber, _set_asNumber)
  gracefulRestart = __builtin__.property(_get_gracefulRestart, _set_gracefulRestart)
  timeWaitForRib = __builtin__.property(_get_timeWaitForRib, _set_timeWaitForRib)
  asPathLimit = __builtin__.property(_get_asPathLimit, _set_asPathLimit)
  checkFirstAs = __builtin__.property(_get_checkFirstAs, _set_checkFirstAs)
  confedIdNumber = __builtin__.property(_get_confedIdNumber, _set_confedIdNumber)
  confedNonstanded = __builtin__.property(_get_confedNonstanded, _set_confedNonstanded)
  bgpRidAutoSel = __builtin__.property(_get_bgpRidAutoSel, _set_bgpRidAutoSel)
  keepAllRoutes = __builtin__.property(_get_keepAllRoutes, _set_keepAllRoutes)
  memoryLimit = __builtin__.property(_get_memoryLimit, _set_memoryLimit)
  grPeerReset = __builtin__.property(_get_grPeerReset, _set_grPeerReset)
  isShutdown = __builtin__.property(_get_isShutdown, _set_isShutdown)
  suppressInterval = __builtin__.property(_get_suppressInterval, _set_suppressInterval)
  holdInterval = __builtin__.property(_get_holdInterval, _set_holdInterval)
  clearInterval = __builtin__.property(_get_clearInterval, _set_clearInterval)
  private4byteAs = __builtin__.property(_get_private4byteAs, _set_private4byteAs)


  _pyangbind_elements = OrderedDict([('bgpMultiSiteName', bgpMultiSiteName), ('bgpVersion', bgpVersion), ('asNumber', asNumber), ('gracefulRestart', gracefulRestart), ('timeWaitForRib', timeWaitForRib), ('asPathLimit', asPathLimit), ('checkFirstAs', checkFirstAs), ('confedIdNumber', confedIdNumber), ('confedNonstanded', confedNonstanded), ('bgpRidAutoSel', bgpRidAutoSel), ('keepAllRoutes', keepAllRoutes), ('memoryLimit', memoryLimit), ('grPeerReset', grPeerReset), ('isShutdown', isShutdown), ('suppressInterval', suppressInterval), ('holdInterval', holdInterval), ('clearInterval', clearInterval), ('private4byteAs', private4byteAs), ])


class yc_bgpMultiSites_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiSites. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiSite',)

  _yang_name = 'bgpMultiSites'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiSite = YANGDynClass(base=YANGListType("bgpMultiSiteName",yc_bgpMultiSite_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites_bgpMultiSite, yang_name="bgpMultiSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName', extensions=None), is_container='list', yang_name="bgpMultiSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiSites']

  def _get_bgpMultiSite(self):
    """
    Getter method for bgpMultiSite, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite (list)

    YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
    """
    return self.__bgpMultiSite
      
  def _set_bgpMultiSite(self, v, load=False):
    """
    Setter method for bgpMultiSite, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites/bgpMultiSite (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiSite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiSite() directly.

    YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bgpMultiSiteName",yc_bgpMultiSite_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites_bgpMultiSite, yang_name="bgpMultiSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName', extensions=None), is_container='list', yang_name="bgpMultiSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiSite must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bgpMultiSiteName",yc_bgpMultiSite_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites_bgpMultiSite, yang_name="bgpMultiSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName', extensions=None), is_container='list', yang_name="bgpMultiSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpMultiSite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiSite(self):
    self.__bgpMultiSite = YANGDynClass(base=YANGListType("bgpMultiSiteName",yc_bgpMultiSite_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites_bgpMultiSite, yang_name="bgpMultiSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName', extensions=None), is_container='list', yang_name="bgpMultiSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpMultiSite = __builtin__.property(_get_bgpMultiSite, _set_bgpMultiSite) # type: yc_bgpMultiSite_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites_bgpMultiSite


  _pyangbind_elements = OrderedDict([('bgpMultiSite', bgpMultiSite), ])


class yc_peerGroupBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup_peerGroupBfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__multiplier','__isBfdEnable','__rxInterval','__txInterval','__isSingleHop','__bfdCompatible',)

  _yang_name = 'peerGroupBfd'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiPeerGroups', 'bgpMultiPeerGroup', 'peerGroupBfd']

  def _get_multiplier(self):
    """
    Getter method for multiplier, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/multiplier (uint32)

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    return self.__multiplier
      
  def _set_multiplier(self, v, load=False):
    """
    Setter method for multiplier, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/multiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multiplier() directly.

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multiplier(self):
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isBfdEnable(self):
    """
    Getter method for isBfdEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/isBfdEnable (boolean)

    YANG Description: Configure BFD.
    """
    return self.__isBfdEnable
      
  def _set_isBfdEnable(self, v, load=False):
    """
    Setter method for isBfdEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/isBfdEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBfdEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBfdEnable() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBfdEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isBfdEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBfdEnable(self):
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_rxInterval(self):
    """
    Getter method for rxInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/rxInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    return self.__rxInterval
      
  def _set_rxInterval(self, v, load=False):
    """
    Setter method for rxInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/rxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__rxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxInterval(self):
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_txInterval(self):
    """
    Getter method for txInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/txInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    return self.__txInterval
      
  def _set_txInterval(self, v, load=False):
    """
    Setter method for txInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/txInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_txInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_txInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """txInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__txInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_txInterval(self):
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isSingleHop(self):
    """
    Getter method for isSingleHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/isSingleHop (boolean)

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    return self.__isSingleHop
      
  def _set_isSingleHop(self, v, load=False):
    """
    Setter method for isSingleHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/isSingleHop (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSingleHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSingleHop() directly.

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSingleHop must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isSingleHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSingleHop(self):
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_bfdCompatible(self):
    """
    Getter method for bfdCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/bfdCompatible (boolean)

    YANG Description: Compatible.
    """
    return self.__bfdCompatible
      
  def _set_bfdCompatible(self, v, load=False):
    """
    Setter method for bfdCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd/bfdCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdCompatible() directly.

    YANG Description: Compatible.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bfdCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdCompatible(self):
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  multiplier = __builtin__.property(_get_multiplier, _set_multiplier)
  isBfdEnable = __builtin__.property(_get_isBfdEnable, _set_isBfdEnable)
  rxInterval = __builtin__.property(_get_rxInterval, _set_rxInterval)
  txInterval = __builtin__.property(_get_txInterval, _set_txInterval)
  isSingleHop = __builtin__.property(_get_isSingleHop, _set_isSingleHop)
  bfdCompatible = __builtin__.property(_get_bfdCompatible, _set_bfdCompatible)


  _pyangbind_elements = OrderedDict([('multiplier', multiplier), ('isBfdEnable', isBfdEnable), ('rxInterval', rxInterval), ('txInterval', txInterval), ('isSingleHop', isSingleHop), ('bfdCompatible', bfdCompatible), ])


class yc_bgpMultiPeerGroup_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about a BGP peer group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afType','__groupName','__groupType','__groupAs','__description','__fakeAs','__dualAs','__conventional','__routeRefresh','__fourByteAs','__isIgnore','__localIfName','__localIfAddress','__ebgpMaxHop','__validTtlHops','__connectMode','__isLogChange','__pswdType','__pswdCipherText','__keepAliveTime','__holdTime','__minHoldTime','__checkFirstAs','__keyChainName','__trackingEnable','__trackDelayTime','__connRetryTime','__tcpMSS','__mplsLocalIfnetDisable','__prependGlobalAs','__prependFakeAs','__pathAttrDiscardIdMap','__pathAttrWithdrawIdMap','__peerGroupBfd',)

  _yang_name = 'bgpMultiPeerGroup'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommGroupAddrFamily', is_config=True)
    self.__groupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__groupType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)
    self.__groupAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pathAttrDiscardIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__pathAttrWithdrawIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__peerGroupBfd = YANGDynClass(base=yc_peerGroupBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiPeerGroups', 'bgpMultiPeerGroup']

  def _get_afType(self):
    """
    Getter method for afType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/afType (bgpmultiinstcommGroupAddrFamily)

    YANG Description: Address family type of a peer group. For a public instance, this value cannot be modified. Since a VPN instance is related to its address family, you need to specify the address family type when creating a peer group in the VPN instance. For example, if you want to create an address family in a VPN instance of IPv4 unicast, choose IPv4 unicast as the address family type.
    """
    return self.__afType
      
  def _set_afType(self, v, load=False):
    """
    Setter method for afType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/afType (bgpmultiinstcommGroupAddrFamily)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afType() directly.

    YANG Description: Address family type of a peer group. For a public instance, this value cannot be modified. Since a VPN instance is related to its address family, you need to specify the address family type when creating a peer group in the VPN instance. For example, if you want to create an address family in a VPN instance of IPv4 unicast, choose IPv4 unicast as the address family type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommGroupAddrFamily', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afType must be of a type compatible with bgpmultiinstcommGroupAddrFamily""",
          'defined-type': "huawei-bgp:bgpmultiinstcommGroupAddrFamily",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommGroupAddrFamily', is_config=True)""",
        })

    self.__afType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afType(self):
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'public': {}, 'ipv4uni': {}, 'ipv6uni': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommGroupAddrFamily', is_config=True)


  def _get_groupName(self):
    """
    Getter method for groupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/groupName (string)

    YANG Description: Specify the name of a peer group. The value is a string of characters, spaces not supported.
    """
    return self.__groupName
      
  def _set_groupName(self, v, load=False):
    """
    Setter method for groupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/groupName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupName() directly.

    YANG Description: Specify the name of a peer group. The value is a string of characters, spaces not supported.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__groupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupName(self):
    self.__groupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^\\? ]+)', 'length': ['1..47']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_groupType(self):
    """
    Getter method for groupType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/groupType (bgpcommPeerType)

    YANG Description: Specify the type of a peer group. The value can be IBGP or EBGP.
    """
    return self.__groupType
      
  def _set_groupType(self, v, load=False):
    """
    Setter method for groupType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/groupType (bgpcommPeerType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupType() directly.

    YANG Description: Specify the type of a peer group. The value can be IBGP or EBGP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupType must be of a type compatible with bgpcommPeerType""",
          'defined-type': "huawei-bgp:bgpcommPeerType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)""",
        })

    self.__groupType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupType(self):
    self.__groupType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)


  def _get_groupAs(self):
    """
    Getter method for groupAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/groupAs (asNumberValidate)

    YANG Description: Specify the AS number of a peer group. The AS number is in either a 2-byte or 4-byte format.
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    return self.__groupAs
      
  def _set_groupAs(self, v, load=False):
    """
    Setter method for groupAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/groupAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupAs() directly.

    YANG Description: Specify the AS number of a peer group. The AS number is in either a 2-byte or 4-byte format.
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__groupAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupAs(self):
    self.__groupAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="groupAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/description (string)

    YANG Description: Specify the description of a peer group. The value is a string, which can be letters or digits, spaces supported. By default, no description is configured.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Specify the description of a peer group. The value is a string, which can be letters or digits, spaces supported. By default, no description is configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_fakeAs(self):
    """
    Getter method for fakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/fakeAs (asNumberValidate)

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    return self.__fakeAs
      
  def _set_fakeAs(self, v, load=False):
    """
    Setter method for fakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/fakeAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fakeAs() directly.

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fakeAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__fakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fakeAs(self):
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_dualAs(self):
    """
    Getter method for dualAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/dualAs (boolean)

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    return self.__dualAs
      
  def _set_dualAs(self, v, load=False):
    """
    Setter method for dualAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/dualAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dualAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dualAs() directly.

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dualAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__dualAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dualAs(self):
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_conventional(self):
    """
    Getter method for conventional, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/conventional (boolean)

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    return self.__conventional
      
  def _set_conventional(self, v, load=False):
    """
    Setter method for conventional, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/conventional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conventional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conventional() directly.

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conventional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__conventional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conventional(self):
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routeRefresh(self):
    """
    Getter method for routeRefresh, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/routeRefresh (boolean)

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    return self.__routeRefresh
      
  def _set_routeRefresh(self, v, load=False):
    """
    Setter method for routeRefresh, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/routeRefresh (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeRefresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeRefresh() directly.

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeRefresh must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__routeRefresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeRefresh(self):
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_fourByteAs(self):
    """
    Getter method for fourByteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/fourByteAs (boolean)

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    return self.__fourByteAs
      
  def _set_fourByteAs(self, v, load=False):
    """
    Setter method for fourByteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/fourByteAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fourByteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fourByteAs() directly.

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fourByteAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__fourByteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fourByteAs(self):
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isIgnore(self):
    """
    Getter method for isIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/isIgnore (boolean)

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    return self.__isIgnore
      
  def _set_isIgnore(self, v, load=False):
    """
    Setter method for isIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/isIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isIgnore() directly.

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isIgnore(self):
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_localIfName(self):
    """
    Getter method for localIfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/localIfName (string)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfName
      
  def _set_localIfName(self, v, load=False):
    """
    Setter method for localIfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/localIfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfName() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__localIfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfName(self):
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_localIfAddress(self):
    """
    Getter method for localIfAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/localIfAddress (inet:ip-address-no-zone)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfAddress
      
  def _set_localIfAddress(self, v, load=False):
    """
    Setter method for localIfAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/localIfAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfAddress() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__localIfAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfAddress(self):
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_ebgpMaxHop(self):
    """
    Getter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/ebgpMaxHop (uint32)

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.
    """
    return self.__ebgpMaxHop
      
  def _set_ebgpMaxHop(self, v, load=False):
    """
    Setter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/ebgpMaxHop (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgpMaxHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgpMaxHop() directly.

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgpMaxHop must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__ebgpMaxHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgpMaxHop(self):
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_validTtlHops(self):
    """
    Getter method for validTtlHops, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/validTtlHops (uint16)

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255]. 
    """
    return self.__validTtlHops
      
  def _set_validTtlHops(self, v, load=False):
    """
    Setter method for validTtlHops, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/validTtlHops (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_validTtlHops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_validTtlHops() directly.

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255]. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """validTtlHops must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__validTtlHops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_validTtlHops(self):
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connectMode(self):
    """
    Getter method for connectMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/connectMode (bgpcommPeerConnectMode)

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    return self.__connectMode
      
  def _set_connectMode(self, v, load=False):
    """
    Setter method for connectMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/connectMode (bgpcommPeerConnectMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectMode() directly.

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connectMode must be of a type compatible with bgpcommPeerConnectMode""",
          'defined-type': "huawei-bgp:bgpcommPeerConnectMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)""",
        })

    self.__connectMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connectMode(self):
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)


  def _get_isLogChange(self):
    """
    Getter method for isLogChange, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/isLogChange (boolean)

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    return self.__isLogChange
      
  def _set_isLogChange(self, v, load=False):
    """
    Setter method for isLogChange, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/isLogChange (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLogChange is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLogChange() directly.

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLogChange must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isLogChange = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLogChange(self):
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pswdType(self):
    """
    Getter method for pswdType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pswdType (bgpcommPasswordType)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    return self.__pswdType
      
  def _set_pswdType(self, v, load=False):
    """
    Setter method for pswdType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pswdType (bgpcommPasswordType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdType() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdType must be of a type compatible with bgpcommPasswordType""",
          'defined-type': "huawei-bgp:bgpcommPasswordType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)""",
        })

    self.__pswdType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdType(self):
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)


  def _get_pswdCipherText(self):
    """
    Getter method for pswdCipherText, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pswdCipherText (string)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 392. If the length is set to 0, no password is set.
    """
    return self.__pswdCipherText
      
  def _set_pswdCipherText(self, v, load=False):
    """
    Setter method for pswdCipherText, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pswdCipherText (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdCipherText is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdCipherText() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 392. If the length is set to 0, no password is set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdCipherText must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pswdCipherText = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdCipherText(self):
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_keepAliveTime(self):
    """
    Getter method for keepAliveTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/keepAliveTime (uint32)

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    return self.__keepAliveTime
      
  def _set_keepAliveTime(self, v, load=False):
    """
    Setter method for keepAliveTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/keepAliveTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAliveTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAliveTime() directly.

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAliveTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__keepAliveTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAliveTime(self):
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/holdTime (uint32)

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_minHoldTime(self):
    """
    Getter method for minHoldTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/minHoldTime (uint32)

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    return self.__minHoldTime
      
  def _set_minHoldTime(self, v, load=False):
    """
    Setter method for minHoldTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/minHoldTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minHoldTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minHoldTime() directly.

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minHoldTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__minHoldTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minHoldTime(self):
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_checkFirstAs(self):
    """
    Getter method for checkFirstAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/checkFirstAs (bgpCheckFirstAsTriState)

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    return self.__checkFirstAs
      
  def _set_checkFirstAs(self, v, load=False):
    """
    Setter method for checkFirstAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/checkFirstAs (bgpCheckFirstAsTriState)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkFirstAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkFirstAs() directly.

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkFirstAs must be of a type compatible with bgpCheckFirstAsTriState""",
          'defined-type': "huawei-bgp:bgpCheckFirstAsTriState",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)""",
        })

    self.__checkFirstAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkFirstAs(self):
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)


  def _get_keyChainName(self):
    """
    Getter method for keyChainName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/keyChainName (string)

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    return self.__keyChainName
      
  def _set_keyChainName(self, v, load=False):
    """
    Setter method for keyChainName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/keyChainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyChainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyChainName() directly.

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyChainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__keyChainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyChainName(self):
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_trackingEnable(self):
    """
    Getter method for trackingEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/trackingEnable (boolean)

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    return self.__trackingEnable
      
  def _set_trackingEnable(self, v, load=False):
    """
    Setter method for trackingEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/trackingEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackingEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackingEnable() directly.

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackingEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__trackingEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackingEnable(self):
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_trackDelayTime(self):
    """
    Getter method for trackDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/trackDelayTime (uint16)

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    return self.__trackDelayTime
      
  def _set_trackDelayTime(self, v, load=False):
    """
    Setter method for trackDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/trackDelayTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackDelayTime() directly.

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackDelayTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__trackDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackDelayTime(self):
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connRetryTime(self):
    """
    Getter method for connRetryTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/connRetryTime (uint16)

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    return self.__connRetryTime
      
  def _set_connRetryTime(self, v, load=False):
    """
    Setter method for connRetryTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/connRetryTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connRetryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connRetryTime() directly.

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connRetryTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connRetryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connRetryTime(self):
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_tcpMSS(self):
    """
    Getter method for tcpMSS, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/tcpMSS (uint16)

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer group. 
    """
    return self.__tcpMSS
      
  def _set_tcpMSS(self, v, load=False):
    """
    Setter method for tcpMSS, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/tcpMSS (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpMSS is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpMSS() directly.

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer group. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpMSS must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__tcpMSS = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpMSS(self):
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_mplsLocalIfnetDisable(self):
    """
    Getter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/mplsLocalIfnetDisable (boolean)

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    return self.__mplsLocalIfnetDisable
      
  def _set_mplsLocalIfnetDisable(self, v, load=False):
    """
    Setter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/mplsLocalIfnetDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mplsLocalIfnetDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mplsLocalIfnetDisable() directly.

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mplsLocalIfnetDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__mplsLocalIfnetDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mplsLocalIfnetDisable(self):
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependGlobalAs(self):
    """
    Getter method for prependGlobalAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/prependGlobalAs (boolean)

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    return self.__prependGlobalAs
      
  def _set_prependGlobalAs(self, v, load=False):
    """
    Setter method for prependGlobalAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/prependGlobalAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependGlobalAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependGlobalAs() directly.

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependGlobalAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependGlobalAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependGlobalAs(self):
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependFakeAs(self):
    """
    Getter method for prependFakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/prependFakeAs (boolean)

    YANG Description: Add the Fake AS number to received Update packets.
    """
    return self.__prependFakeAs
      
  def _set_prependFakeAs(self, v, load=False):
    """
    Setter method for prependFakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/prependFakeAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependFakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependFakeAs() directly.

    YANG Description: Add the Fake AS number to received Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependFakeAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependFakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependFakeAs(self):
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pathAttrDiscardIdMap(self):
    """
    Getter method for pathAttrDiscardIdMap, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pathAttrDiscardIdMap (string)

    YANG Description: Specify a discard attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    return self.__pathAttrDiscardIdMap
      
  def _set_pathAttrDiscardIdMap(self, v, load=False):
    """
    Setter method for pathAttrDiscardIdMap, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pathAttrDiscardIdMap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrDiscardIdMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrDiscardIdMap() directly.

    YANG Description: Specify a discard attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrDiscardIdMap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pathAttrDiscardIdMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrDiscardIdMap(self):
    self.__pathAttrDiscardIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrDiscardIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_pathAttrWithdrawIdMap(self):
    """
    Getter method for pathAttrWithdrawIdMap, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pathAttrWithdrawIdMap (string)

    YANG Description: Specify a withdraw attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    return self.__pathAttrWithdrawIdMap
      
  def _set_pathAttrWithdrawIdMap(self, v, load=False):
    """
    Setter method for pathAttrWithdrawIdMap, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/pathAttrWithdrawIdMap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pathAttrWithdrawIdMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pathAttrWithdrawIdMap() directly.

    YANG Description: Specify a withdraw attrId list.The format of a list is as follows:20-30,55.No support the attribute ids as follows:
IBGP peer or CONFEDERATION EBGP peer or CONFEDERATION IBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),5(LOCALPREF),8(COMMUNITY),9(ORIGINATOR),10(CLUSTER-ID),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY),
EBGP peer: 1(ORIGIN),2(AS_PATH),3(NEXT_HOP),4(MED),8(COMMUNITY),14(MP_NLRI),15(MP_UNLRI),16(EXTCOMMUNITY)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pathAttrWithdrawIdMap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pathAttrWithdrawIdMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pathAttrWithdrawIdMap(self):
    self.__pathAttrWithdrawIdMap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pathAttrWithdrawIdMap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_peerGroupBfd(self):
    """
    Getter method for peerGroupBfd, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd (container)

    YANG Description: Configure BFD.
    """
    return self.__peerGroupBfd
      
  def _set_peerGroupBfd(self, v, load=False):
    """
    Setter method for peerGroupBfd, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup/peerGroupBfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupBfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupBfd() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerGroupBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupBfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerGroupBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerGroupBfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupBfd(self):
    self.__peerGroupBfd = YANGDynClass(base=yc_peerGroupBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup_peerGroupBfd, is_container='container', yang_name="peerGroupBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  afType = __builtin__.property(_get_afType, _set_afType)
  groupName = __builtin__.property(_get_groupName, _set_groupName)
  groupType = __builtin__.property(_get_groupType, _set_groupType)
  groupAs = __builtin__.property(_get_groupAs, _set_groupAs)
  description = __builtin__.property(_get_description, _set_description)
  fakeAs = __builtin__.property(_get_fakeAs, _set_fakeAs)
  dualAs = __builtin__.property(_get_dualAs, _set_dualAs)
  conventional = __builtin__.property(_get_conventional, _set_conventional)
  routeRefresh = __builtin__.property(_get_routeRefresh, _set_routeRefresh)
  fourByteAs = __builtin__.property(_get_fourByteAs, _set_fourByteAs)
  isIgnore = __builtin__.property(_get_isIgnore, _set_isIgnore)
  localIfName = __builtin__.property(_get_localIfName, _set_localIfName)
  localIfAddress = __builtin__.property(_get_localIfAddress, _set_localIfAddress)
  ebgpMaxHop = __builtin__.property(_get_ebgpMaxHop, _set_ebgpMaxHop)
  validTtlHops = __builtin__.property(_get_validTtlHops, _set_validTtlHops)
  connectMode = __builtin__.property(_get_connectMode, _set_connectMode)
  isLogChange = __builtin__.property(_get_isLogChange, _set_isLogChange)
  pswdType = __builtin__.property(_get_pswdType, _set_pswdType)
  pswdCipherText = __builtin__.property(_get_pswdCipherText, _set_pswdCipherText)
  keepAliveTime = __builtin__.property(_get_keepAliveTime, _set_keepAliveTime)
  holdTime = __builtin__.property(_get_holdTime, _set_holdTime)
  minHoldTime = __builtin__.property(_get_minHoldTime, _set_minHoldTime)
  checkFirstAs = __builtin__.property(_get_checkFirstAs, _set_checkFirstAs)
  keyChainName = __builtin__.property(_get_keyChainName, _set_keyChainName)
  trackingEnable = __builtin__.property(_get_trackingEnable, _set_trackingEnable)
  trackDelayTime = __builtin__.property(_get_trackDelayTime, _set_trackDelayTime)
  connRetryTime = __builtin__.property(_get_connRetryTime, _set_connRetryTime)
  tcpMSS = __builtin__.property(_get_tcpMSS, _set_tcpMSS)
  mplsLocalIfnetDisable = __builtin__.property(_get_mplsLocalIfnetDisable, _set_mplsLocalIfnetDisable)
  prependGlobalAs = __builtin__.property(_get_prependGlobalAs, _set_prependGlobalAs)
  prependFakeAs = __builtin__.property(_get_prependFakeAs, _set_prependFakeAs)
  pathAttrDiscardIdMap = __builtin__.property(_get_pathAttrDiscardIdMap, _set_pathAttrDiscardIdMap)
  pathAttrWithdrawIdMap = __builtin__.property(_get_pathAttrWithdrawIdMap, _set_pathAttrWithdrawIdMap)
  peerGroupBfd = __builtin__.property(_get_peerGroupBfd, _set_peerGroupBfd) # type: yc_peerGroupBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup_peerGroupBfd


  _pyangbind_elements = OrderedDict([('afType', afType), ('groupName', groupName), ('groupType', groupType), ('groupAs', groupAs), ('description', description), ('fakeAs', fakeAs), ('dualAs', dualAs), ('conventional', conventional), ('routeRefresh', routeRefresh), ('fourByteAs', fourByteAs), ('isIgnore', isIgnore), ('localIfName', localIfName), ('localIfAddress', localIfAddress), ('ebgpMaxHop', ebgpMaxHop), ('validTtlHops', validTtlHops), ('connectMode', connectMode), ('isLogChange', isLogChange), ('pswdType', pswdType), ('pswdCipherText', pswdCipherText), ('keepAliveTime', keepAliveTime), ('holdTime', holdTime), ('minHoldTime', minHoldTime), ('checkFirstAs', checkFirstAs), ('keyChainName', keyChainName), ('trackingEnable', trackingEnable), ('trackDelayTime', trackDelayTime), ('connRetryTime', connRetryTime), ('tcpMSS', tcpMSS), ('mplsLocalIfnetDisable', mplsLocalIfnetDisable), ('prependGlobalAs', prependGlobalAs), ('prependFakeAs', prependFakeAs), ('pathAttrDiscardIdMap', pathAttrDiscardIdMap), ('pathAttrWithdrawIdMap', pathAttrWithdrawIdMap), ('peerGroupBfd', peerGroupBfd), ])


class yc_bgpMultiPeerGroups_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peer groups. The BGP peer groups can help you simplify the configurations. If you want to perform the same configuration for several peers, you can create a peer group and then configure the peer group. After you add these peers to the peer group, all these peers will have the same configurations as the peer group. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiPeerGroup',)

  _yang_name = 'bgpMultiPeerGroups'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiPeerGroup = YANGDynClass(base=YANGListType("afType groupName",yc_bgpMultiPeerGroup_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup, yang_name="bgpMultiPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpMultiPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiPeerGroups']

  def _get_bgpMultiPeerGroup(self):
    """
    Getter method for bgpMultiPeerGroup, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup (list)

    YANG Description: Information about a BGP peer group.
    """
    return self.__bgpMultiPeerGroup
      
  def _set_bgpMultiPeerGroup(self, v, load=False):
    """
    Setter method for bgpMultiPeerGroup, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups/bgpMultiPeerGroup (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiPeerGroup is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiPeerGroup() directly.

    YANG Description: Information about a BGP peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afType groupName",yc_bgpMultiPeerGroup_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup, yang_name="bgpMultiPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpMultiPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiPeerGroup must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afType groupName",yc_bgpMultiPeerGroup_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup, yang_name="bgpMultiPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpMultiPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpMultiPeerGroup = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiPeerGroup(self):
    self.__bgpMultiPeerGroup = YANGDynClass(base=YANGListType("afType groupName",yc_bgpMultiPeerGroup_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup, yang_name="bgpMultiPeerGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType groupName', extensions=None), is_container='list', yang_name="bgpMultiPeerGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpMultiPeerGroup = __builtin__.property(_get_bgpMultiPeerGroup, _set_bgpMultiPeerGroup) # type: yc_bgpMultiPeerGroup_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups_bgpMultiPeerGroup


  _pyangbind_elements = OrderedDict([('bgpMultiPeerGroup', bgpMultiPeerGroup), ])


class yc_peerBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer_peerBfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isBfdBlock','__multiplier','__isBfdEnable','__rxInterval','__txInterval','__isSingleHop','__bfdCompatible',)

  _yang_name = 'peerBfd'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isBfdBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiPeers', 'bgpMultiPeer', 'peerBfd']

  def _get_isBfdBlock(self):
    """
    Getter method for isBfdBlock, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/isBfdBlock (boolean)

    YANG Description: Prevent  a BGP peer from inheriting the BFD configuration of the BGP peer group.
    """
    return self.__isBfdBlock
      
  def _set_isBfdBlock(self, v, load=False):
    """
    Setter method for isBfdBlock, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/isBfdBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBfdBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBfdBlock() directly.

    YANG Description: Prevent  a BGP peer from inheriting the BFD configuration of the BGP peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBfdBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isBfdBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBfdBlock(self):
    self.__isBfdBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_multiplier(self):
    """
    Getter method for multiplier, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/multiplier (uint32)

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    return self.__multiplier
      
  def _set_multiplier(self, v, load=False):
    """
    Setter method for multiplier, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/multiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multiplier() directly.

    YANG Description: Specify the detection multiplier. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multiplier(self):
    self.__multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isBfdEnable(self):
    """
    Getter method for isBfdEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/isBfdEnable (boolean)

    YANG Description: Enable BFD.
    """
    return self.__isBfdEnable
      
  def _set_isBfdEnable(self, v, load=False):
    """
    Setter method for isBfdEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/isBfdEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBfdEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBfdEnable() directly.

    YANG Description: Enable BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBfdEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isBfdEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBfdEnable(self):
    self.__isBfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isBfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_rxInterval(self):
    """
    Getter method for rxInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/rxInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    return self.__rxInterval
      
  def _set_rxInterval(self, v, load=False):
    """
    Setter method for rxInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/rxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are received. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__rxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxInterval(self):
    self.__rxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="rxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_txInterval(self):
    """
    Getter method for txInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/txInterval (uint32)

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    return self.__txInterval
      
  def _set_txInterval(self, v, load=False):
    """
    Setter method for txInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/txInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_txInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_txInterval() directly.

    YANG Description: Specify the minimum interval at which BFD packets are sent. By default, the value is determined by the PAF file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """txInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__txInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_txInterval(self):
    self.__txInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), is_leaf=True, yang_name="txInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_isSingleHop(self):
    """
    Getter method for isSingleHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/isSingleHop (boolean)

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    return self.__isSingleHop
      
  def _set_isSingleHop(self, v, load=False):
    """
    Setter method for isSingleHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/isSingleHop (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSingleHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSingleHop() directly.

    YANG Description: The single hop mode is preferred during the BFD session establishment between IBGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSingleHop must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isSingleHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSingleHop(self):
    self.__isSingleHop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSingleHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_bfdCompatible(self):
    """
    Getter method for bfdCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/bfdCompatible (boolean)

    YANG Description: Compatible.
    """
    return self.__bfdCompatible
      
  def _set_bfdCompatible(self, v, load=False):
    """
    Setter method for bfdCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd/bfdCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdCompatible() directly.

    YANG Description: Compatible.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__bfdCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdCompatible(self):
    self.__bfdCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  isBfdBlock = __builtin__.property(_get_isBfdBlock, _set_isBfdBlock)
  multiplier = __builtin__.property(_get_multiplier, _set_multiplier)
  isBfdEnable = __builtin__.property(_get_isBfdEnable, _set_isBfdEnable)
  rxInterval = __builtin__.property(_get_rxInterval, _set_rxInterval)
  txInterval = __builtin__.property(_get_txInterval, _set_txInterval)
  isSingleHop = __builtin__.property(_get_isSingleHop, _set_isSingleHop)
  bfdCompatible = __builtin__.property(_get_bfdCompatible, _set_bfdCompatible)


  _pyangbind_elements = OrderedDict([('isBfdBlock', isBfdBlock), ('multiplier', multiplier), ('isBfdEnable', isBfdEnable), ('rxInterval', rxInterval), ('txInterval', txInterval), ('isSingleHop', isSingleHop), ('bfdCompatible', bfdCompatible), ])


class yc_bgpMultiPeer_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurations of a single BGP peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerAddr','__groupName','__remoteAs','__description','__fakeAs','__dualAs','__conventional','__routeRefresh','__fourByteAs','__isIgnore','__localIfName','__localIfAddress','__ebgpMaxHop','__validTtlHops','__connectMode','__isLogChange','__pswdType','__pswdCipherText','__keepAliveTime','__holdTime','__minHoldTime','__checkFirstAs','__keyChainName','__trackingEnable','__trackDelayTime','__connRetryTime','__tcpMSS','__mplsLocalIfnetDisable','__prependGlobalAs','__prependFakeAs','__peerBfd',)

  _yang_name = 'bgpMultiPeer'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerAddr = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__groupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__remoteAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__peerBfd = YANGDynClass(base=yc_peerBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiPeers', 'bgpMultiPeer']

  def _get_peerAddr(self):
    """
    Getter method for peerAddr, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerAddr (inet:ip-address-no-zone)

    YANG Description: Connection address of a peer, which can be an IPv4 or IPv6 address.
    """
    return self.__peerAddr
      
  def _set_peerAddr(self, v, load=False):
    """
    Setter method for peerAddr, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerAddr (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAddr() directly.

    YANG Description: Connection address of a peer, which can be an IPv4 or IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAddr must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__peerAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAddr(self):
    self.__peerAddr = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_groupName(self):
    """
    Getter method for groupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/groupName (leafref)

    YANG Description: Specify the name of a peer group that BGP peers need to join. That must be selected group name or AS when creating, and the value is a string, spaces not supported. By default, BGP peers join no peer group. BGP peers distinguish the peer group type when joining a peer group. IBGP peers cannot join an EBGP peer group.  BGP peers will be deleted when they leave a peer group. 
    """
    return self.__groupName
      
  def _set_groupName(self, v, load=False):
    """
    Setter method for groupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/groupName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupName() directly.

    YANG Description: Specify the name of a peer group that BGP peers need to join. That must be selected group name or AS when creating, and the value is a string, spaces not supported. By default, BGP peers join no peer group. BGP peers distinguish the peer group type when joining a peer group. IBGP peers cannot join an EBGP peer group.  BGP peers will be deleted when they leave a peer group. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__groupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupName(self):
    self.__groupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_remoteAs(self):
    """
    Getter method for remoteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/remoteAs (asNumberValidate)

    YANG Description: AS number of a peer, which must be selected or group name when creating, and which can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
This node cannot be deleted or updated.
    """
    return self.__remoteAs
      
  def _set_remoteAs(self, v, load=False):
    """
    Setter method for remoteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/remoteAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remoteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remoteAs() directly.

    YANG Description: AS number of a peer, which must be selected or group name when creating, and which can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
This node cannot be deleted or updated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remoteAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__remoteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remoteAs(self):
    self.__remoteAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remoteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/description (string)

    YANG Description: Description of a peer, which can be letters or digits. The description is a string of 1 to 80 characters, with spaces supported. By default, no description is configured for a peer.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of a peer, which can be letters or digits. The description is a string of 1 to 80 characters, with spaces supported. By default, no description is configured for a peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_fakeAs(self):
    """
    Getter method for fakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/fakeAs (asNumberValidate)

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    return self.__fakeAs
      
  def _set_fakeAs(self, v, load=False):
    """
    Setter method for fakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/fakeAs (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fakeAs() directly.

    YANG Description: Fake AS number that is specified for a local peer. By default, a peer uses the actual AS number of the local end.
An AS number can be in either two-byte format or four-byte format:
The two-byte format is X. X is an integer ranging from 1 to 65535.
The four-byte format is X.Y and X. When the format is X.Y, X and Y are both integers, with the value of X ranging from 1 to 65535, and the value of Y ranging from 0 to 65535; when the format is X, X is an interger, with the value of X ranging from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fakeAs must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__fakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fakeAs(self):
    self.__fakeAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="fakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_dualAs(self):
    """
    Getter method for dualAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/dualAs (boolean)

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    return self.__dualAs
      
  def _set_dualAs(self, v, load=False):
    """
    Setter method for dualAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/dualAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dualAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dualAs() directly.

    YANG Description: By default, dual AS is not enabled, and the remote EBGP peer uses the fake AS number when specifying the AS number for a local peer.
After dual AS is enabled, the remote EBGP peer can use the actual or fake AS number when specifying the AS number for a local peer. The local peer uses the fake and actual AS numbers to establish a BGP peer relationship with the remote end and identifies the AS number configured by the remote end through the error code (OPEN Message Error) and sub-error code (Bad Peer AS) of the Notification message from the remote end.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dualAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__dualAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dualAs(self):
    self.__dualAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dualAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_conventional(self):
    """
    Getter method for conventional, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/conventional (boolean)

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    return self.__conventional
      
  def _set_conventional(self, v, load=False):
    """
    Setter method for conventional, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/conventional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conventional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conventional() directly.

    YANG Description: Enable general router functions on peers. In conventional mode, not all the extended router functions, such as, route refreshing, GR, and multi-address family negotiation, are available. Therefore, the router of a new version can be compatible with the routers of earlier versions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conventional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__conventional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conventional(self):
    self.__conventional = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conventional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routeRefresh(self):
    """
    Getter method for routeRefresh, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/routeRefresh (boolean)

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    return self.__routeRefresh
      
  def _set_routeRefresh(self, v, load=False):
    """
    Setter method for routeRefresh, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/routeRefresh (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeRefresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeRefresh() directly.

    YANG Description: Enable BGP to advertise Refresh messages to peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeRefresh must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__routeRefresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeRefresh(self):
    self.__routeRefresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="routeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_fourByteAs(self):
    """
    Getter method for fourByteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/fourByteAs (boolean)

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    return self.__fourByteAs
      
  def _set_fourByteAs(self, v, load=False):
    """
    Setter method for fourByteAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/fourByteAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fourByteAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fourByteAs() directly.

    YANG Description: Enables BGP to advertise routes carrying 4-byte AS numbers to peers. By default, the function is enabled. After the 4-byte AS number function is disabled, Open packets will not carry 4-byte AS number capability flag, and peer ends will not know that local ends have the 4-byte AS number function. The 4-byte AS number function cannot be disabled from peers (peer groups) if a 4-byte AS number, fake AS number, or confederation ID is configured on a router and the AS number of a peer is 4-byte.  If the 4-byte AS number function is disabled in such a situation, BGP sessions may fail to be established, and route transmission may be affected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fourByteAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__fourByteAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fourByteAs(self):
    self.__fourByteAs = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="fourByteAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isIgnore(self):
    """
    Getter method for isIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/isIgnore (boolean)

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    return self.__isIgnore
      
  def _set_isIgnore(self, v, load=False):
    """
    Setter method for isIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/isIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isIgnore() directly.

    YANG Description: Tear down sessions between peers and clear all related routing information. By default, this function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isIgnore(self):
    self.__isIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_localIfName(self):
    """
    Getter method for localIfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/localIfName (string)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfName
      
  def _set_localIfName(self, v, load=False):
    """
    Setter method for localIfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/localIfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfName() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__localIfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfName(self):
    self.__localIfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localIfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_localIfAddress(self):
    """
    Getter method for localIfAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/localIfAddress (inet:ip-address-no-zone)

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    return self.__localIfAddress
      
  def _set_localIfAddress(self, v, load=False):
    """
    Setter method for localIfAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/localIfAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIfAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIfAddress() directly.

    YANG Description: Name of a source interface that sends BGP packets. By default, the outbound interface of a BGP packet serves as the source interface of a BGP packet. To ensure that a router can send BGP packets when a physical interface fails, you can configure the source interface that sends BGP packets as a loopback interface. When using the loopback interface as the source interface, note the following points:
1. The address of the loopback interface of the BGP peer must be reachable.
2. For an EBGP connection, configure the maximum number of hops and allow EBGP peer relationships to be established in indirect mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIfAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__localIfAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIfAddress(self):
    self.__localIfAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIfAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_ebgpMaxHop(self):
    """
    Getter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/ebgpMaxHop (uint32)

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.
    """
    return self.__ebgpMaxHop
      
  def _set_ebgpMaxHop(self, v, load=False):
    """
    Setter method for ebgpMaxHop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/ebgpMaxHop (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgpMaxHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgpMaxHop() directly.

    YANG Description: Maximum number of hops in an indirect EBGP connection. By default, EBGP connections can be established only between directly connected peers. The function must be configured on both ends.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgpMaxHop must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__ebgpMaxHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgpMaxHop(self):
    self.__ebgpMaxHop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="ebgpMaxHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_validTtlHops(self):
    """
    Getter method for validTtlHops, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/validTtlHops (uint16)

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255]. 
    """
    return self.__validTtlHops
      
  def _set_validTtlHops(self, v, load=False):
    """
    Setter method for validTtlHops, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/validTtlHops (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_validTtlHops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_validTtlHops() directly.

    YANG Description: Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. If the value is configured as hops, the valid TTL range of the detected packet is [255-hops+1, 255]. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """validTtlHops must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__validTtlHops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_validTtlHops(self):
    self.__validTtlHops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="validTtlHops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connectMode(self):
    """
    Getter method for connectMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/connectMode (bgpcommPeerConnectMode)

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    return self.__connectMode
      
  def _set_connectMode(self, v, load=False):
    """
    Setter method for connectMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/connectMode (bgpcommPeerConnectMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectMode() directly.

    YANG Description: The value can be Connect-only, Listen-only, or Both. If the value is Connect-only, the specified peer or peer group only initiatively sends connection requests, instead of listening to connection requests. If the value is Listen-only, the specified peer or peer group only listens to connection requests, instead of initiatively sending connection requests. If the value is Both, the specified peer or peer group not only initiatively sends connection requests, but also listens to connection requests. The default value is Both.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connectMode must be of a type compatible with bgpcommPeerConnectMode""",
          'defined-type': "huawei-bgp:bgpcommPeerConnectMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)""",
        })

    self.__connectMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connectMode(self):
    self.__connectMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'listenOnly': {}, 'connectOnly': {}, 'null': {}},), default=six.text_type("null"), is_leaf=True, yang_name="connectMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerConnectMode', is_config=True)


  def _get_isLogChange(self):
    """
    Getter method for isLogChange, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/isLogChange (boolean)

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    return self.__isLogChange
      
  def _set_isLogChange(self, v, load=False):
    """
    Setter method for isLogChange, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/isLogChange (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLogChange is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLogChange() directly.

    YANG Description: Enable BGP to record the session status and events of the specified peer or peer group. By default, the function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLogChange must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isLogChange = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLogChange(self):
    self.__isLogChange = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLogChange", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_pswdType(self):
    """
    Getter method for pswdType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/pswdType (bgpcommPasswordType)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    return self.__pswdType
      
  def _set_pswdType(self, v, load=False):
    """
    Setter method for pswdType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/pswdType (bgpcommPasswordType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdType() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. Plaintexts and ciphertexts are supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdType must be of a type compatible with bgpcommPasswordType""",
          'defined-type': "huawei-bgp:bgpcommPasswordType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)""",
        })

    self.__pswdType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdType(self):
    self.__pswdType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'cipher': {}, 'simple': {}},), default=six.text_type("null"), is_leaf=True, yang_name="pswdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPasswordType', is_config=True)


  def _get_pswdCipherText(self):
    """
    Getter method for pswdCipherText, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/pswdCipherText (string)

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 392. If the length is set to 0, no password is set.
    """
    return self.__pswdCipherText
      
  def _set_pswdCipherText(self, v, load=False):
    """
    Setter method for pswdCipherText, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/pswdCipherText (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pswdCipherText is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pswdCipherText() directly.

    YANG Description: Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages. The character string in a password identifies the contents of the password, spaces not supported. The TCP connection can be established only when the same MD5 authentication password is set on both ends. If a plaintext is used, the maximum password length is 255. If a ciphertext is used, the maximum password length is 392. If the length is set to 0, no password is set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pswdCipherText must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__pswdCipherText = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pswdCipherText(self):
    self.__pswdCipherText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pswdCipherText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_keepAliveTime(self):
    """
    Getter method for keepAliveTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/keepAliveTime (uint32)

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    return self.__keepAliveTime
      
  def _set_keepAliveTime(self, v, load=False):
    """
    Setter method for keepAliveTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/keepAliveTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAliveTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAliveTime() directly.

    YANG Description: Specify the Keepalive time of a peer or peer group. The value is an integer, in seconds. If the value of a timer changes, the peers need to re-negotiate the interval value for the keepalive-time and hold-time. This disconnects the BGP peer relationship between the routers. Therefore, you need to double check whether it is a must to change the value of the timer. Ensure that the hold time is at least three times longer than the keepalive time when you configure the BGP timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAliveTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__keepAliveTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAliveTime(self):
    self.__keepAliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepAliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/holdTime (uint32)

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Specify the Hold time of a peer or peer group. The value is either 0 or an integer ranging from 0 to 65535, in seconds. When setting the timer values of keepalive-time and hold-time, avoid the following settings: 1.The interval values of keepalive-time and hold-time are both set to 0. This will cause BGP timer to become invalid, and BGP will not detect link faults based on the timer.
2. The interval value of hold-time is much greater than that of keepalive-time. For example, the interval value of keepalive-time is 1, and that of hold-time is 65535. If the interval value of hold-time is too large, BGP will not be able to detect link faults in time. The priority of the timer configured here is lower than that of timer configured with interval values of keepalive-time and hold-time of a peer. After a connection is established between peers, the interval values of keepalive-time and hold-time are negotiated by the peers. The smaller interval value of hold-time contained in Open packets of both peers is taken as the interval value of hold-time. The smaller interval value of one third of the interval value of hold-time and the locally set interval value of keepalive-time is taken as the interval value of keepalive-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_minHoldTime(self):
    """
    Getter method for minHoldTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/minHoldTime (uint32)

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.


    """
    return self.__minHoldTime
      
  def _set_minHoldTime(self, v, load=False):
    """
    Setter method for minHoldTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/minHoldTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minHoldTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minHoldTime() directly.

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.


    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minHoldTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__minHoldTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minHoldTime(self):
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_checkFirstAs(self):
    """
    Getter method for checkFirstAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/checkFirstAs (bgpCheckFirstAsTriState)

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    return self.__checkFirstAs
      
  def _set_checkFirstAs(self, v, load=False):
    """
    Setter method for checkFirstAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/checkFirstAs (bgpCheckFirstAsTriState)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkFirstAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkFirstAs() directly.

    YANG Description: Check the first AS in the AS_Path of the update messages from EBGP peers. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkFirstAs must be of a type compatible with bgpCheckFirstAsTriState""",
          'defined-type': "huawei-bgp:bgpCheckFirstAsTriState",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)""",
        })

    self.__checkFirstAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkFirstAs(self):
    self.__checkFirstAs = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'enable': {}, 'disable': {}},), default=six.text_type("default"), is_leaf=True, yang_name="checkFirstAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpCheckFirstAsTriState', is_config=True)


  def _get_keyChainName(self):
    """
    Getter method for keyChainName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/keyChainName (string)

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    return self.__keyChainName
      
  def _set_keyChainName(self, v, load=False):
    """
    Setter method for keyChainName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/keyChainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyChainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyChainName() directly.

    YANG Description: Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string, spaces not supported. By default, the Keychain authentication is not configured. Keychain authentication mode and password authentication mode are mutually exclusive. Configuring Keychain authentication can enhance the security of the TCP connections between BGP peers. Keychain authentication using the same encryption algorithm and password must be configured on the two ends of BGP peers to establish a TCP connection and exchange BGP packets. Before configuring BGP Keychain authentication, you need to configure Keychain according to keychain name. Otherwise, the TCP connections between the BGP peers cannot be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyChainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__keyChainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyChainName(self):
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_trackingEnable(self):
    """
    Getter method for trackingEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/trackingEnable (boolean)

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    return self.__trackingEnable
      
  def _set_trackingEnable(self, v, load=False):
    """
    Setter method for trackingEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/trackingEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackingEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackingEnable() directly.

    YANG Description: Enable peer tracking, After peer tracking is enabled, the device can fast detect the unreachability of a peer and reset the session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackingEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__trackingEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackingEnable(self):
    self.__trackingEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="trackingEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_trackDelayTime(self):
    """
    Getter method for trackDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/trackDelayTime (uint16)

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    return self.__trackDelayTime
      
  def _set_trackDelayTime(self, v, load=False):
    """
    Setter method for trackDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/trackDelayTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trackDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trackDelayTime() directly.

    YANG Description: Specify the delay to reset the session, in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trackDelayTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__trackDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trackDelayTime(self):
    self.__trackDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="trackDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_connRetryTime(self):
    """
    Getter method for connRetryTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/connRetryTime (uint16)

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    return self.__connRetryTime
      
  def _set_connRetryTime(self, v, load=False):
    """
    Setter method for connRetryTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/connRetryTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connRetryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connRetryTime() directly.

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connRetryTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connRetryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connRetryTime(self):
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_tcpMSS(self):
    """
    Getter method for tcpMSS, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/tcpMSS (uint16)

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer. 
    """
    return self.__tcpMSS
      
  def _set_tcpMSS(self, v, load=False):
    """
    Setter method for tcpMSS, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/tcpMSS (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcpMSS is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcpMSS() directly.

    YANG Description: Maximum TCP MSS value used for TCP connection establishment for a peer. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcpMSS must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__tcpMSS = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcpMSS(self):
    self.__tcpMSS = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['176..4096']}), is_leaf=True, yang_name="tcpMSS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_mplsLocalIfnetDisable(self):
    """
    Getter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/mplsLocalIfnetDisable (boolean)

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    return self.__mplsLocalIfnetDisable
      
  def _set_mplsLocalIfnetDisable(self, v, load=False):
    """
    Setter method for mplsLocalIfnetDisable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/mplsLocalIfnetDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mplsLocalIfnetDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mplsLocalIfnetDisable() directly.

    YANG Description: Disable MPLS local IFNET tunnel creation. By default, MPLS local IFNET tunnels can be created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mplsLocalIfnetDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__mplsLocalIfnetDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mplsLocalIfnetDisable(self):
    self.__mplsLocalIfnetDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mplsLocalIfnetDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependGlobalAs(self):
    """
    Getter method for prependGlobalAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/prependGlobalAs (boolean)

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    return self.__prependGlobalAs
      
  def _set_prependGlobalAs(self, v, load=False):
    """
    Setter method for prependGlobalAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/prependGlobalAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependGlobalAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependGlobalAs() directly.

    YANG Description: Add the global AS number to the Update packets to be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependGlobalAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependGlobalAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependGlobalAs(self):
    self.__prependGlobalAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependGlobalAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_prependFakeAs(self):
    """
    Getter method for prependFakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/prependFakeAs (boolean)

    YANG Description: Add the Fake AS number to received Update packets.
    """
    return self.__prependFakeAs
      
  def _set_prependFakeAs(self, v, load=False):
    """
    Setter method for prependFakeAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/prependFakeAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prependFakeAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prependFakeAs() directly.

    YANG Description: Add the Fake AS number to received Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prependFakeAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__prependFakeAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prependFakeAs(self):
    self.__prependFakeAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="prependFakeAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_peerBfd(self):
    """
    Getter method for peerBfd, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd (container)

    YANG Description: Configure BFD.
    """
    return self.__peerBfd
      
  def _set_peerBfd(self, v, load=False):
    """
    Setter method for peerBfd, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer/peerBfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerBfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerBfd() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerBfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerBfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerBfd(self):
    self.__peerBfd = YANGDynClass(base=yc_peerBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer_peerBfd, is_container='container', yang_name="peerBfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  peerAddr = __builtin__.property(_get_peerAddr, _set_peerAddr)
  groupName = __builtin__.property(_get_groupName, _set_groupName)
  remoteAs = __builtin__.property(_get_remoteAs, _set_remoteAs)
  description = __builtin__.property(_get_description, _set_description)
  fakeAs = __builtin__.property(_get_fakeAs, _set_fakeAs)
  dualAs = __builtin__.property(_get_dualAs, _set_dualAs)
  conventional = __builtin__.property(_get_conventional, _set_conventional)
  routeRefresh = __builtin__.property(_get_routeRefresh, _set_routeRefresh)
  fourByteAs = __builtin__.property(_get_fourByteAs, _set_fourByteAs)
  isIgnore = __builtin__.property(_get_isIgnore, _set_isIgnore)
  localIfName = __builtin__.property(_get_localIfName, _set_localIfName)
  localIfAddress = __builtin__.property(_get_localIfAddress, _set_localIfAddress)
  ebgpMaxHop = __builtin__.property(_get_ebgpMaxHop, _set_ebgpMaxHop)
  validTtlHops = __builtin__.property(_get_validTtlHops, _set_validTtlHops)
  connectMode = __builtin__.property(_get_connectMode, _set_connectMode)
  isLogChange = __builtin__.property(_get_isLogChange, _set_isLogChange)
  pswdType = __builtin__.property(_get_pswdType, _set_pswdType)
  pswdCipherText = __builtin__.property(_get_pswdCipherText, _set_pswdCipherText)
  keepAliveTime = __builtin__.property(_get_keepAliveTime, _set_keepAliveTime)
  holdTime = __builtin__.property(_get_holdTime, _set_holdTime)
  minHoldTime = __builtin__.property(_get_minHoldTime, _set_minHoldTime)
  checkFirstAs = __builtin__.property(_get_checkFirstAs, _set_checkFirstAs)
  keyChainName = __builtin__.property(_get_keyChainName, _set_keyChainName)
  trackingEnable = __builtin__.property(_get_trackingEnable, _set_trackingEnable)
  trackDelayTime = __builtin__.property(_get_trackDelayTime, _set_trackDelayTime)
  connRetryTime = __builtin__.property(_get_connRetryTime, _set_connRetryTime)
  tcpMSS = __builtin__.property(_get_tcpMSS, _set_tcpMSS)
  mplsLocalIfnetDisable = __builtin__.property(_get_mplsLocalIfnetDisable, _set_mplsLocalIfnetDisable)
  prependGlobalAs = __builtin__.property(_get_prependGlobalAs, _set_prependGlobalAs)
  prependFakeAs = __builtin__.property(_get_prependFakeAs, _set_prependFakeAs)
  peerBfd = __builtin__.property(_get_peerBfd, _set_peerBfd) # type: yc_peerBfd_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer_peerBfd


  _pyangbind_elements = OrderedDict([('peerAddr', peerAddr), ('groupName', groupName), ('remoteAs', remoteAs), ('description', description), ('fakeAs', fakeAs), ('dualAs', dualAs), ('conventional', conventional), ('routeRefresh', routeRefresh), ('fourByteAs', fourByteAs), ('isIgnore', isIgnore), ('localIfName', localIfName), ('localIfAddress', localIfAddress), ('ebgpMaxHop', ebgpMaxHop), ('validTtlHops', validTtlHops), ('connectMode', connectMode), ('isLogChange', isLogChange), ('pswdType', pswdType), ('pswdCipherText', pswdCipherText), ('keepAliveTime', keepAliveTime), ('holdTime', holdTime), ('minHoldTime', minHoldTime), ('checkFirstAs', checkFirstAs), ('keyChainName', keyChainName), ('trackingEnable', trackingEnable), ('trackDelayTime', trackDelayTime), ('connRetryTime', connRetryTime), ('tcpMSS', tcpMSS), ('mplsLocalIfnetDisable', mplsLocalIfnetDisable), ('prependGlobalAs', prependGlobalAs), ('prependFakeAs', prependFakeAs), ('peerBfd', peerBfd), ])


class yc_bgpMultiPeers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiPeer',)

  _yang_name = 'bgpMultiPeers'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiPeer = YANGDynClass(base=YANGListType("peerAddr",yc_bgpMultiPeer_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer, yang_name="bgpMultiPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpMultiPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiPeers']

  def _get_bgpMultiPeer(self):
    """
    Getter method for bgpMultiPeer, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer (list)

    YANG Description: Configurations of a single BGP peer.
    """
    return self.__bgpMultiPeer
      
  def _set_bgpMultiPeer(self, v, load=False):
    """
    Setter method for bgpMultiPeer, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers/bgpMultiPeer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiPeer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiPeer() directly.

    YANG Description: Configurations of a single BGP peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerAddr",yc_bgpMultiPeer_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer, yang_name="bgpMultiPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpMultiPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiPeer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerAddr",yc_bgpMultiPeer_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer, yang_name="bgpMultiPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpMultiPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpMultiPeer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiPeer(self):
    self.__bgpMultiPeer = YANGDynClass(base=YANGListType("peerAddr",yc_bgpMultiPeer_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer, yang_name="bgpMultiPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerAddr', extensions=None), is_container='list', yang_name="bgpMultiPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpMultiPeer = __builtin__.property(_get_bgpMultiPeer, _set_bgpMultiPeer) # type: yc_bgpMultiPeer_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers_bgpMultiPeer


  _pyangbind_elements = OrderedDict([('bgpMultiPeer', bgpMultiPeer), ])


class yc_peerGroupAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres_peerGroupAFCraPre(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the matching condition for default route advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defaultRtAddress','__defaultRtMask',)

  _yang_name = 'peerGroupAFCraPre'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defaultRtAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__defaultRtMask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerGroupAFs', 'peerGroupAF', 'peerGroupAFCraPres', 'peerGroupAFCraPre']

  def _get_defaultRtAddress(self):
    """
    Getter method for defaultRtAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre/defaultRtAddress (inet:ipv4-address-no-zone)

    YANG Description: Configure a prefix that is used to match default routes.
    """
    return self.__defaultRtAddress
      
  def _set_defaultRtAddress(self, v, load=False):
    """
    Setter method for defaultRtAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre/defaultRtAddress (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtAddress() directly.

    YANG Description: Configure a prefix that is used to match default routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtAddress must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__defaultRtAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtAddress(self):
    self.__defaultRtAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_defaultRtMask(self):
    """
    Getter method for defaultRtMask, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre/defaultRtMask (uint32)

    YANG Description: Configure a mask that is used to match default routes.
    """
    return self.__defaultRtMask
      
  def _set_defaultRtMask(self, v, load=False):
    """
    Setter method for defaultRtMask, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre/defaultRtMask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtMask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtMask() directly.

    YANG Description: Configure a mask that is used to match default routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtMask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__defaultRtMask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtMask(self):
    self.__defaultRtMask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)

  defaultRtAddress = __builtin__.property(_get_defaultRtAddress, _set_defaultRtAddress)
  defaultRtMask = __builtin__.property(_get_defaultRtMask, _set_defaultRtMask)


  _pyangbind_elements = OrderedDict([('defaultRtAddress', defaultRtAddress), ('defaultRtMask', defaultRtMask), ])


class yc_peerGroupAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the matching conditions for default route advertisement. (Only the default routes that match the conditions can be advertised.)
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerGroupAFCraPre',)

  _yang_name = 'peerGroupAFCraPres'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerGroupAFCraPre = YANGDynClass(base=YANGListType("defaultRtAddress defaultRtMask",yc_peerGroupAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres_peerGroupAFCraPre, yang_name="peerGroupAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerGroupAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerGroupAFs', 'peerGroupAF', 'peerGroupAFCraPres']

  def _get_peerGroupAFCraPre(self):
    """
    Getter method for peerGroupAFCraPre, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre (list)

    YANG Description: Configure the matching condition for default route advertisement.
    """
    return self.__peerGroupAFCraPre
      
  def _set_peerGroupAFCraPre(self, v, load=False):
    """
    Setter method for peerGroupAFCraPre, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres/peerGroupAFCraPre (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupAFCraPre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupAFCraPre() directly.

    YANG Description: Configure the matching condition for default route advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("defaultRtAddress defaultRtMask",yc_peerGroupAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres_peerGroupAFCraPre, yang_name="peerGroupAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerGroupAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupAFCraPre must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("defaultRtAddress defaultRtMask",yc_peerGroupAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres_peerGroupAFCraPre, yang_name="peerGroupAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerGroupAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__peerGroupAFCraPre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupAFCraPre(self):
    self.__peerGroupAFCraPre = YANGDynClass(base=YANGListType("defaultRtAddress defaultRtMask",yc_peerGroupAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres_peerGroupAFCraPre, yang_name="peerGroupAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerGroupAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  peerGroupAFCraPre = __builtin__.property(_get_peerGroupAFCraPre, _set_peerGroupAFCraPre) # type: yc_peerGroupAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres_peerGroupAFCraPre


  _pyangbind_elements = OrderedDict([('peerGroupAFCraPre', peerGroupAFCraPre), ])


class yc_peerAFMember_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers_peerAFMember(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers/peerAFMember. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer in the peer address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer',)

  _yang_name = 'peerAFMember'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerGroupAFs', 'peerGroupAF', 'peerAFMembers', 'peerAFMember']

  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers/peerAFMember/peer (string)

    YANG Description: Peer address in the peer address family.
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers/peerAFMember/peer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.

    YANG Description: Peer address in the peer address family.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=False)

  peer = __builtin__.property(_get_peer)


  _pyangbind_elements = OrderedDict([('peer', peer), ])


class yc_peerAFMembers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of peers in the peer address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerAFMember',)

  _yang_name = 'peerAFMembers'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerAFMember = YANGDynClass(base=YANGListType("peer",yc_peerAFMember_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers_peerAFMember, yang_name="peerAFMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer', extensions=None), is_container='list', yang_name="peerAFMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerGroupAFs', 'peerGroupAF', 'peerAFMembers']

  def _get_peerAFMember(self):
    """
    Getter method for peerAFMember, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers/peerAFMember (list)

    YANG Description: Peer in the peer address family.
    """
    return self.__peerAFMember
      
  def _set_peerAFMember(self, v, load=False):
    """
    Setter method for peerAFMember, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers/peerAFMember (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAFMember is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAFMember() directly.

    YANG Description: Peer in the peer address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer",yc_peerAFMember_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers_peerAFMember, yang_name="peerAFMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer', extensions=None), is_container='list', yang_name="peerAFMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAFMember must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer",yc_peerAFMember_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers_peerAFMember, yang_name="peerAFMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer', extensions=None), is_container='list', yang_name="peerAFMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)""",
        })

    self.__peerAFMember = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAFMember(self):
    self.__peerAFMember = YANGDynClass(base=YANGListType("peer",yc_peerAFMember_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers_peerAFMember, yang_name="peerAFMember", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer', extensions=None), is_container='list', yang_name="peerAFMember", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=False)

  peerAFMember = __builtin__.property(_get_peerAFMember) # type: yc_peerAFMember_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers_peerAFMember


  _pyangbind_elements = OrderedDict([('peerAFMember', peerAFMember), ])


class yc_peerGroupAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer group enabled in a specified address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__groupName','__groupType','__advertiseRemoteNexthop','__advertiseCommunity','__advertiseExtCommunity','__discardExtCommunity','__allowAsLoopEnable','__allowAsLoopLimit','__keepAllRoutes','__nextHopConfigure','__preferredValue','__publicAsOnly','__publicAsOnlyForce','__publicAsOnlyLimited','__publicAsOnlyReplace','__publicAsOnlySkipPeerAs','__routeLimit','__routeLimitPercent','__routeLimitType','__routeLimitIdleTimeout','__rtUpdtInterval','__reflectClient','__substituteAsEnable','__importRtPolicyName','__exportRtPolicyName','__importPrefFiltName','__exportPrefFiltName','__importAsPathNameOrNum','__exportAsPathNameOrNum','__importAclNameOrNum','__exportAclNameOrNum','__ipprefixOrfEnable','__isNonstdIpprefixMod','__orftype','__orfMode','__soostring','__defaultRtAdvEnable','__defaultRtAdvPolicy','__defaultRtMatchMode','__labelRouteCapability','__addPathMode','__advAddPathNum','__originAsValid','__updatePktStandardCompatible','__advertiseIrb','__advertiseArp','__splitGroupName','__advertiseIrbv6','__advertiseND','__peerGroupAFCraPres','__peerAFMembers',)

  _yang_name = 'peerGroupAF'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__groupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__groupType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)
    self.__advertiseRemoteNexthop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__discardExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__allowAsLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__allowAsLoopLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__nextHopConfigure = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), default=six.text_type("null"), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)
    self.__preferredValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__publicAsOnly = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlyForce = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlyLimited = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlyReplace = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlySkipPeerAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routeLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__routeLimitPercent = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__routeLimitType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)
    self.__routeLimitIdleTimeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__rtUpdtInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__reflectClient = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__substituteAsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__importRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__importPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__importAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__importAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__ipprefixOrfEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isNonstdIpprefixMod = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__orftype = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__orfMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)
    self.__soostring = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__defaultRtAdvEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__defaultRtAdvPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__defaultRtMatchMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)
    self.__labelRouteCapability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__addPathMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)
    self.__advAddPathNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__originAsValid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__updatePktStandardCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseIrb = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseArp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__splitGroupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__advertiseIrbv6 = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseND = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__peerGroupAFCraPres = YANGDynClass(base=yc_peerGroupAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres, is_container='container', yang_name="peerGroupAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peerAFMembers = YANGDynClass(base=yc_peerAFMembers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers, is_container='container', yang_name="peerAFMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerGroupAFs', 'peerGroupAF']

  def _get_groupName(self):
    """
    Getter method for groupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/groupName (leafref)

    YANG Description: Configure a name for a peer group. The value is a string, spaces not supported.
    """
    return self.__groupName
      
  def _set_groupName(self, v, load=False):
    """
    Setter method for groupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/groupName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupName() directly.

    YANG Description: Configure a name for a peer group. The value is a string, spaces not supported.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__groupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupName(self):
    self.__groupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_groupType(self):
    """
    Getter method for groupType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/groupType (bgpcommPeerType)

    YANG Description: Configure a peer group type: IBGP or EBGP. The type must be consistent with the peer group type.
    """
    return self.__groupType
      
  def _set_groupType(self, v, load=False):
    """
    Setter method for groupType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/groupType (bgpcommPeerType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupType() directly.

    YANG Description: Configure a peer group type: IBGP or EBGP. The type must be consistent with the peer group type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupType must be of a type compatible with bgpcommPeerType""",
          'defined-type': "huawei-bgp:bgpcommPeerType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)""",
        })

    self.__groupType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupType(self):
    self.__groupType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ebgp': {}, 'ibgp': {}},), is_leaf=True, yang_name="groupType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommPeerType', is_config=True)


  def _get_advertiseRemoteNexthop(self):
    """
    Getter method for advertiseRemoteNexthop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseRemoteNexthop (boolean)

    YANG Description: Advertise the remote nexthop to a peer or a peer group. By default, the remote nexthop attribute is not advertised to any peer.
    """
    return self.__advertiseRemoteNexthop
      
  def _set_advertiseRemoteNexthop(self, v, load=False):
    """
    Setter method for advertiseRemoteNexthop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseRemoteNexthop (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseRemoteNexthop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseRemoteNexthop() directly.

    YANG Description: Advertise the remote nexthop to a peer or a peer group. By default, the remote nexthop attribute is not advertised to any peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseRemoteNexthop must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseRemoteNexthop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseRemoteNexthop(self):
    self.__advertiseRemoteNexthop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseCommunity(self):
    """
    Getter method for advertiseCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseCommunity (boolean)

    YANG Description: Advertise the community attribute to a peer or a peer group. By default, the community attribute is not advertised to any peer.
    """
    return self.__advertiseCommunity
      
  def _set_advertiseCommunity(self, v, load=False):
    """
    Setter method for advertiseCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseCommunity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseCommunity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseCommunity() directly.

    YANG Description: Advertise the community attribute to a peer or a peer group. By default, the community attribute is not advertised to any peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseCommunity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseCommunity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseCommunity(self):
    self.__advertiseCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseExtCommunity(self):
    """
    Getter method for advertiseExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseExtCommunity (boolean)

    YANG Description: Advertise the extended community attribute to a peer or a peer group. By default, the extended community attribute is not advertised to any peer.
    """
    return self.__advertiseExtCommunity
      
  def _set_advertiseExtCommunity(self, v, load=False):
    """
    Setter method for advertiseExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseExtCommunity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseExtCommunity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseExtCommunity() directly.

    YANG Description: Advertise the extended community attribute to a peer or a peer group. By default, the extended community attribute is not advertised to any peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseExtCommunity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseExtCommunity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseExtCommunity(self):
    self.__advertiseExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_discardExtCommunity(self):
    """
    Getter method for discardExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/discardExtCommunity (boolean)

    YANG Description: Discard the extended community attribute in the routes learned from a specified peer. By default, the extended community attribute is not discarded. 
    """
    return self.__discardExtCommunity
      
  def _set_discardExtCommunity(self, v, load=False):
    """
    Setter method for discardExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/discardExtCommunity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discardExtCommunity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discardExtCommunity() directly.

    YANG Description: Discard the extended community attribute in the routes learned from a specified peer. By default, the extended community attribute is not discarded. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discardExtCommunity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__discardExtCommunity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discardExtCommunity(self):
    self.__discardExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_allowAsLoopEnable(self):
    """
    Getter method for allowAsLoopEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/allowAsLoopEnable (boolean)

    YANG Description: Allow the repetitive local AS numbers. By default, local AS numbers cannot be repeated.
    """
    return self.__allowAsLoopEnable
      
  def _set_allowAsLoopEnable(self, v, load=False):
    """
    Setter method for allowAsLoopEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/allowAsLoopEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowAsLoopEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowAsLoopEnable() directly.

    YANG Description: Allow the repetitive local AS numbers. By default, local AS numbers cannot be repeated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowAsLoopEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allowAsLoopEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowAsLoopEnable(self):
    self.__allowAsLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_allowAsLoopLimit(self):
    """
    Getter method for allowAsLoopLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/allowAsLoopLimit (uint32)

    YANG Description: Configure the number of allowed AS number repetition times. The value is an integer. The default value is 1.
    """
    return self.__allowAsLoopLimit
      
  def _set_allowAsLoopLimit(self, v, load=False):
    """
    Setter method for allowAsLoopLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/allowAsLoopLimit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowAsLoopLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowAsLoopLimit() directly.

    YANG Description: Configure the number of allowed AS number repetition times. The value is an integer. The default value is 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowAsLoopLimit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__allowAsLoopLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowAsLoopLimit(self):
    self.__allowAsLoopLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_keepAllRoutes(self):
    """
    Getter method for keepAllRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/keepAllRoutes (boolean)

    YANG Description: Save all the updated information about BGP routes from a specified peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, the updated information about BGP routes from a specified peer is saved only when the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    return self.__keepAllRoutes
      
  def _set_keepAllRoutes(self, v, load=False):
    """
    Setter method for keepAllRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/keepAllRoutes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAllRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAllRoutes() directly.

    YANG Description: Save all the updated information about BGP routes from a specified peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, the updated information about BGP routes from a specified peer is saved only when the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAllRoutes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__keepAllRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAllRoutes(self):
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_nextHopConfigure(self):
    """
    Getter method for nextHopConfigure, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/nextHopConfigure (bgpcommNextHopCfg)

    YANG Description: Both the next-hop-local mode and next-hop-invariable mode are available when the peer address family is the VPNv4/VPNV6/L2VPN AD address family. Only the next-hop-local mode is available when the peer address family is not VPNv4/VPNV6/L2VPN AD address family. In next-hop-local mode, you can configure a BGP speaker to set its IP address of as the next hop of the routes to be advertised to IBGP peers or IBGP peer groups. In next-hop-invariable mode, you can configure PEs in different ASs not to change the next hop of routes when the PEs advertise the routes to their EBGP peers and use the next hop addresses of IGP routes to advertise imported IGP routes to IBGP peers. By default, when a BGP speaker advertises routes to EBGP peers and imported IGP routes to IBGP peers, the BGP speaker changes the next hop to its interface address. 
    """
    return self.__nextHopConfigure
      
  def _set_nextHopConfigure(self, v, load=False):
    """
    Setter method for nextHopConfigure, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/nextHopConfigure (bgpcommNextHopCfg)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHopConfigure is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHopConfigure() directly.

    YANG Description: Both the next-hop-local mode and next-hop-invariable mode are available when the peer address family is the VPNv4/VPNV6/L2VPN AD address family. Only the next-hop-local mode is available when the peer address family is not VPNv4/VPNV6/L2VPN AD address family. In next-hop-local mode, you can configure a BGP speaker to set its IP address of as the next hop of the routes to be advertised to IBGP peers or IBGP peer groups. In next-hop-invariable mode, you can configure PEs in different ASs not to change the next hop of routes when the PEs advertise the routes to their EBGP peers and use the next hop addresses of IGP routes to advertise imported IGP routes to IBGP peers. By default, when a BGP speaker advertises routes to EBGP peers and imported IGP routes to IBGP peers, the BGP speaker changes the next hop to its interface address. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), default=six.text_type("null"), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHopConfigure must be of a type compatible with bgpcommNextHopCfg""",
          'defined-type': "huawei-bgp:bgpcommNextHopCfg",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), default=six.text_type("null"), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)""",
        })

    self.__nextHopConfigure = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHopConfigure(self):
    self.__nextHopConfigure = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), default=six.text_type("null"), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)


  def _get_preferredValue(self):
    """
    Getter method for preferredValue, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/preferredValue (uint32)

    YANG Description: Assign a preferred value for the routes learned from a specified peer. The value is an integer. By default, the preferred value of the route learnt from BGP peers is 0. After a preferred value is configured for the routes learned from a specified peer, all the routes that learnt from this peer will use this preferred value. When multiple routes reach the same address prefix, the route with the largest preferred value will be selected.
    """
    return self.__preferredValue
      
  def _set_preferredValue(self, v, load=False):
    """
    Setter method for preferredValue, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/preferredValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferredValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferredValue() directly.

    YANG Description: Assign a preferred value for the routes learned from a specified peer. The value is an integer. By default, the preferred value of the route learnt from BGP peers is 0. After a preferred value is configured for the routes learned from a specified peer, all the routes that learnt from this peer will use this preferred value. When multiple routes reach the same address prefix, the route with the largest preferred value will be selected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferredValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__preferredValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferredValue(self):
    self.__preferredValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_publicAsOnly(self):
    """
    Getter method for publicAsOnly, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnly (boolean)

    YANG Description: Configure BGP to send Update packets carrying only public AS numbers. By default, private AS numbers can be carried in BGP Update packets.
    """
    return self.__publicAsOnly
      
  def _set_publicAsOnly(self, v, load=False):
    """
    Setter method for publicAsOnly, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnly (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnly is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnly() directly.

    YANG Description: Configure BGP to send Update packets carrying only public AS numbers. By default, private AS numbers can be carried in BGP Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnly must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnly = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnly(self):
    self.__publicAsOnly = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlyForce(self):
    """
    Getter method for publicAsOnlyForce, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlyForce (boolean)

    YANG Description: Configures BGP to carry only the public AS number instead of the private AS number when BGP sends Update packets. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlyForce
      
  def _set_publicAsOnlyForce(self, v, load=False):
    """
    Setter method for publicAsOnlyForce, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlyForce (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlyForce is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlyForce() directly.

    YANG Description: Configures BGP to carry only the public AS number instead of the private AS number when BGP sends Update packets. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlyForce must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlyForce = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlyForce(self):
    self.__publicAsOnlyForce = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlyLimited(self):
    """
    Getter method for publicAsOnlyLimited, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlyLimited (boolean)

    YANG Description: When the BGP sends update packets, the left ends of both the local AS and public AS do not carry the private AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlyLimited
      
  def _set_publicAsOnlyLimited(self, v, load=False):
    """
    Setter method for publicAsOnlyLimited, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlyLimited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlyLimited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlyLimited() directly.

    YANG Description: When the BGP sends update packets, the left ends of both the local AS and public AS do not carry the private AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlyLimited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlyLimited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlyLimited(self):
    self.__publicAsOnlyLimited = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlyReplace(self):
    """
    Getter method for publicAsOnlyReplace, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlyReplace (boolean)

    YANG Description: When the BGP sends update packets, the private AS is replaced by the local AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlyReplace
      
  def _set_publicAsOnlyReplace(self, v, load=False):
    """
    Setter method for publicAsOnlyReplace, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlyReplace (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlyReplace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlyReplace() directly.

    YANG Description: When the BGP sends update packets, the private AS is replaced by the local AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlyReplace must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlyReplace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlyReplace(self):
    self.__publicAsOnlyReplace = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlySkipPeerAs(self):
    """
    Getter method for publicAsOnlySkipPeerAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlySkipPeerAs (boolean)

    YANG Description: When the BGP sends update packets, the neigbour AS is not processed. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlySkipPeerAs
      
  def _set_publicAsOnlySkipPeerAs(self, v, load=False):
    """
    Setter method for publicAsOnlySkipPeerAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/publicAsOnlySkipPeerAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlySkipPeerAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlySkipPeerAs() directly.

    YANG Description: When the BGP sends update packets, the neigbour AS is not processed. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlySkipPeerAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlySkipPeerAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlySkipPeerAs(self):
    self.__publicAsOnlySkipPeerAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routeLimit(self):
    """
    Getter method for routeLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimit (uint32)

    YANG Description: Configure the maximum number of routes that can be accepted from a peer. 
    """
    return self.__routeLimit
      
  def _set_routeLimit(self, v, load=False):
    """
    Setter method for routeLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimit() directly.

    YANG Description: Configure the maximum number of routes that can be accepted from a peer. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__routeLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimit(self):
    self.__routeLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_routeLimitPercent(self):
    """
    Getter method for routeLimitPercent, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimitPercent (uint8)

    YANG Description: Specify the percentage of routes when a router starts to generate an alarm. The default value is 75.
    """
    return self.__routeLimitPercent
      
  def _set_routeLimitPercent(self, v, load=False):
    """
    Setter method for routeLimitPercent, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimitPercent (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimitPercent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimitPercent() directly.

    YANG Description: Specify the percentage of routes when a router starts to generate an alarm. The default value is 75.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimitPercent must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__routeLimitPercent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimitPercent(self):
    self.__routeLimitPercent = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_routeLimitType(self):
    """
    Getter method for routeLimitType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimitType (bgpcommRouteLmtType)

    YANG Description: Set the processing method as alert-only, idle-forever, or idle-timeout when the number of routes exceeds the set threshold. When alert-only is used, only an alarm is generated when the number of routes exceeds the threshold. In this case, new routes are no longer accepted. When idle-forever is used, connections are not automatically reestablished after being cut off until BGP connections are reset if the number of routes exceeds the set threshold. When idle-timeout is used and the idle-timeout timer is specified, the connections are automatically reestablished after being cut off if the number of routes exceeds the set threshold. You can reset BGP connections to reestablish the connections before the idle-timeout times expires.
    """
    return self.__routeLimitType
      
  def _set_routeLimitType(self, v, load=False):
    """
    Setter method for routeLimitType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimitType (bgpcommRouteLmtType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimitType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimitType() directly.

    YANG Description: Set the processing method as alert-only, idle-forever, or idle-timeout when the number of routes exceeds the set threshold. When alert-only is used, only an alarm is generated when the number of routes exceeds the threshold. In this case, new routes are no longer accepted. When idle-forever is used, connections are not automatically reestablished after being cut off until BGP connections are reset if the number of routes exceeds the set threshold. When idle-timeout is used and the idle-timeout timer is specified, the connections are automatically reestablished after being cut off if the number of routes exceeds the set threshold. You can reset BGP connections to reestablish the connections before the idle-timeout times expires.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimitType must be of a type compatible with bgpcommRouteLmtType""",
          'defined-type': "huawei-bgp:bgpcommRouteLmtType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)""",
        })

    self.__routeLimitType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimitType(self):
    self.__routeLimitType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)


  def _get_routeLimitIdleTimeout(self):
    """
    Getter method for routeLimitIdleTimeout, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimitIdleTimeout (uint16)

    YANG Description: Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold.
    """
    return self.__routeLimitIdleTimeout
      
  def _set_routeLimitIdleTimeout(self, v, load=False):
    """
    Setter method for routeLimitIdleTimeout, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/routeLimitIdleTimeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimitIdleTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimitIdleTimeout() directly.

    YANG Description: Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimitIdleTimeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__routeLimitIdleTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimitIdleTimeout(self):
    self.__routeLimitIdleTimeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_rtUpdtInterval(self):
    """
    Getter method for rtUpdtInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/rtUpdtInterval (uint16)

    YANG Description: Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. By default, the interval at which Update packets are sent to IBGP peers is 15s, and the interval at which Update packets are sent to EBGP peers is 30s. When routes change, a router will send Update packets to notify its peers. If a route changes frequently, you can set an interval at which Update packets are sent to prevent the router from sending Update packets each time the route changes. This configuration is valid only to the routes learned from peers. 
    """
    return self.__rtUpdtInterval
      
  def _set_rtUpdtInterval(self, v, load=False):
    """
    Setter method for rtUpdtInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/rtUpdtInterval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rtUpdtInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rtUpdtInterval() directly.

    YANG Description: Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. By default, the interval at which Update packets are sent to IBGP peers is 15s, and the interval at which Update packets are sent to EBGP peers is 30s. When routes change, a router will send Update packets to notify its peers. If a route changes frequently, you can set an interval at which Update packets are sent to prevent the router from sending Update packets each time the route changes. This configuration is valid only to the routes learned from peers. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rtUpdtInterval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__rtUpdtInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rtUpdtInterval(self):
    self.__rtUpdtInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_reflectClient(self):
    """
    Getter method for reflectClient, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/reflectClient (boolean)

    YANG Description: Configure the local device as a route reflector (RR) and a peer or peer group as its client. By default, the RR and its client are not configured. This configuration is applicable between IBGP peers only. The configurations of RRs and its clients in an address family are valid only in this address family. Therefore, it is recommended to configure RRs and its clients in the specified address family that is required.
    """
    return self.__reflectClient
      
  def _set_reflectClient(self, v, load=False):
    """
    Setter method for reflectClient, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/reflectClient (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reflectClient is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reflectClient() directly.

    YANG Description: Configure the local device as a route reflector (RR) and a peer or peer group as its client. By default, the RR and its client are not configured. This configuration is applicable between IBGP peers only. The configurations of RRs and its clients in an address family are valid only in this address family. Therefore, it is recommended to configure RRs and its clients in the specified address family that is required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reflectClient must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__reflectClient = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reflectClient(self):
    self.__reflectClient = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_substituteAsEnable(self):
    """
    Getter method for substituteAsEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/substituteAsEnable (boolean)

    YANG Description: Replace the AS number of a specified peer in the AS_Path attribute with the local AS number. By default, the AS number replacement is disabled. On a PE where AS number replacement is enabled, if an AS number in the AS_Path attribute of a route is same as that of the CE to which the PE advertises the route, the PE replaces the AS number with its own AS number before advertising the route.
    """
    return self.__substituteAsEnable
      
  def _set_substituteAsEnable(self, v, load=False):
    """
    Setter method for substituteAsEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/substituteAsEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_substituteAsEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_substituteAsEnable() directly.

    YANG Description: Replace the AS number of a specified peer in the AS_Path attribute with the local AS number. By default, the AS number replacement is disabled. On a PE where AS number replacement is enabled, if an AS number in the AS_Path attribute of a route is same as that of the CE to which the PE advertises the route, the PE replaces the AS number with its own AS number before advertising the route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """substituteAsEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__substituteAsEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_substituteAsEnable(self):
    self.__substituteAsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_importRtPolicyName(self):
    """
    Getter method for importRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importRtPolicyName (string)

    YANG Description: Specify the filtering policy applied to the routes learned from a peer. By default, no such policy is specified.
    """
    return self.__importRtPolicyName
      
  def _set_importRtPolicyName(self, v, load=False):
    """
    Setter method for importRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importRtPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importRtPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importRtPolicyName() directly.

    YANG Description: Specify the filtering policy applied to the routes learned from a peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importRtPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importRtPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importRtPolicyName(self):
    self.__importRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportRtPolicyName(self):
    """
    Getter method for exportRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportRtPolicyName (string)

    YANG Description: Specify the filtering policy applied to the routes to be advertised to a peer. By default, no such policy is specified.
    """
    return self.__exportRtPolicyName
      
  def _set_exportRtPolicyName(self, v, load=False):
    """
    Setter method for exportRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportRtPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportRtPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportRtPolicyName() directly.

    YANG Description: Specify the filtering policy applied to the routes to be advertised to a peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportRtPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportRtPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportRtPolicyName(self):
    self.__exportRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_importPrefFiltName(self):
    """
    Getter method for importPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importPrefFiltName (string)

    YANG Description: Specify the IPv4 filtering policy applied to the routes received from a specified peer. By default, no such policy is specified.
    """
    return self.__importPrefFiltName
      
  def _set_importPrefFiltName(self, v, load=False):
    """
    Setter method for importPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importPrefFiltName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importPrefFiltName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importPrefFiltName() directly.

    YANG Description: Specify the IPv4 filtering policy applied to the routes received from a specified peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importPrefFiltName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importPrefFiltName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importPrefFiltName(self):
    self.__importPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportPrefFiltName(self):
    """
    Getter method for exportPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportPrefFiltName (string)

    YANG Description: Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. By default, no such policy is specified.
    """
    return self.__exportPrefFiltName
      
  def _set_exportPrefFiltName(self, v, load=False):
    """
    Setter method for exportPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportPrefFiltName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportPrefFiltName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportPrefFiltName() directly.

    YANG Description: Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportPrefFiltName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportPrefFiltName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportPrefFiltName(self):
    self.__exportPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_importAsPathNameOrNum(self):
    """
    Getter method for importAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importAsPathNameOrNum (string)

    YANG Description: Apply an AS_Path-based filtering policy to the routes received from a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    return self.__importAsPathNameOrNum
      
  def _set_importAsPathNameOrNum(self, v, load=False):
    """
    Setter method for importAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importAsPathNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importAsPathNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importAsPathNameOrNum() directly.

    YANG Description: Apply an AS_Path-based filtering policy to the routes received from a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importAsPathNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importAsPathNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importAsPathNameOrNum(self):
    self.__importAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportAsPathNameOrNum(self):
    """
    Getter method for exportAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportAsPathNameOrNum (string)

    YANG Description: Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    return self.__exportAsPathNameOrNum
      
  def _set_exportAsPathNameOrNum(self, v, load=False):
    """
    Setter method for exportAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportAsPathNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportAsPathNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportAsPathNameOrNum() directly.

    YANG Description: Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportAsPathNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportAsPathNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportAsPathNameOrNum(self):
    self.__exportAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_importAclNameOrNum(self):
    """
    Getter method for importAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importAclNameOrNum (string)

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    return self.__importAclNameOrNum
      
  def _set_importAclNameOrNum(self, v, load=False):
    """
    Setter method for importAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/importAclNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importAclNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importAclNameOrNum() directly.

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importAclNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importAclNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importAclNameOrNum(self):
    self.__importAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportAclNameOrNum(self):
    """
    Getter method for exportAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportAclNameOrNum (string)

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    return self.__exportAclNameOrNum
      
  def _set_exportAclNameOrNum(self, v, load=False):
    """
    Setter method for exportAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/exportAclNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportAclNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportAclNameOrNum() directly.

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportAclNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportAclNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportAclNameOrNum(self):
    self.__exportAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_ipprefixOrfEnable(self):
    """
    Getter method for ipprefixOrfEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/ipprefixOrfEnable (boolean)

    YANG Description: Enable Prefix-based BGP outbound route filtering (ORF). By default, this function is not enabled. ORF enables a BGP device to use the import policy of a peer as the local export policy so that unwanted routes are filtered out during route advertisement.
    """
    return self.__ipprefixOrfEnable
      
  def _set_ipprefixOrfEnable(self, v, load=False):
    """
    Setter method for ipprefixOrfEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/ipprefixOrfEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipprefixOrfEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipprefixOrfEnable() directly.

    YANG Description: Enable Prefix-based BGP outbound route filtering (ORF). By default, this function is not enabled. ORF enables a BGP device to use the import policy of a peer as the local export policy so that unwanted routes are filtered out during route advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipprefixOrfEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ipprefixOrfEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipprefixOrfEnable(self):
    self.__ipprefixOrfEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isNonstdIpprefixMod(self):
    """
    Getter method for isNonstdIpprefixMod, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/isNonstdIpprefixMod (boolean)

    YANG Description: Enable Huawei routers to be compatible with Nonstandard routers. The ORF capability codes supported by Nonstandard devices are different from that defined by the associated RFC standard. After the option is selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code supported by Nonstandard devices. If the option is not selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code specified by the RFC standard.
    """
    return self.__isNonstdIpprefixMod
      
  def _set_isNonstdIpprefixMod(self, v, load=False):
    """
    Setter method for isNonstdIpprefixMod, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/isNonstdIpprefixMod (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNonstdIpprefixMod is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNonstdIpprefixMod() directly.

    YANG Description: Enable Huawei routers to be compatible with Nonstandard routers. The ORF capability codes supported by Nonstandard devices are different from that defined by the associated RFC standard. After the option is selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code supported by Nonstandard devices. If the option is not selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code specified by the RFC standard.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNonstdIpprefixMod must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isNonstdIpprefixMod = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNonstdIpprefixMod(self):
    self.__isNonstdIpprefixMod = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_orftype(self):
    """
    Getter method for orftype, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/orftype (uint16)

    YANG Description: ORF Type.
    """
    return self.__orftype
      
  def _set_orftype(self, v, load=False):
    """
    Setter method for orftype, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/orftype (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_orftype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_orftype() directly.

    YANG Description: ORF Type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """orftype must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__orftype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_orftype(self):
    self.__orftype = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_orfMode(self):
    """
    Getter method for orfMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/orfMode (bgpcommonOrfMode)

    YANG Description: Configure an outbound route filtering (ORF) mode, which can be Receive, Send, or Both, and the default ORF mode is Both. 
    """
    return self.__orfMode
      
  def _set_orfMode(self, v, load=False):
    """
    Setter method for orfMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/orfMode (bgpcommonOrfMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_orfMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_orfMode() directly.

    YANG Description: Configure an outbound route filtering (ORF) mode, which can be Receive, Send, or Both, and the default ORF mode is Both. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """orfMode must be of a type compatible with bgpcommonOrfMode""",
          'defined-type': "huawei-bgp:bgpcommonOrfMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)""",
        })

    self.__orfMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_orfMode(self):
    self.__orfMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)


  def _get_soostring(self):
    """
    Getter method for soostring, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/soostring (string)

    YANG Description: Configure the Site-of-Origin (SoO) extended community attribute. This attribute can be expressed in the following formats: X.X.X.X:number<0-65535>, number<0-65535>:number<0-4294967295>, or number<0-65535>.number<0-65535>:number<0-65535>  or <65536-4294967295>:<0-65535>. 0:0 or 0.0:0 is not supported.
Two CEs are in the same site and can advertise routes to each other, and they are connected to a VPN through PEs. If the local routes of a CE are advertised to the other CE over the VPN, a routing loop may occur.
The SoO feature can prevent a route advertised by a site from being sent back to the site, preventing routing loops. After SoO is enabled and a PE receives a route from a CE, the specified SoO attribute will be added to the route. Before advertising the route to the other CE, the PE checks the SoO attribute. If the SoO attribute is the same as the locally configured SoO attribute, the PE does not advertise the route, preventing routing loops. 
    """
    return self.__soostring
      
  def _set_soostring(self, v, load=False):
    """
    Setter method for soostring, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/soostring (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soostring is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soostring() directly.

    YANG Description: Configure the Site-of-Origin (SoO) extended community attribute. This attribute can be expressed in the following formats: X.X.X.X:number<0-65535>, number<0-65535>:number<0-4294967295>, or number<0-65535>.number<0-65535>:number<0-65535>  or <65536-4294967295>:<0-65535>. 0:0 or 0.0:0 is not supported.
Two CEs are in the same site and can advertise routes to each other, and they are connected to a VPN through PEs. If the local routes of a CE are advertised to the other CE over the VPN, a routing loop may occur.
The SoO feature can prevent a route advertised by a site from being sent back to the site, preventing routing loops. After SoO is enabled and a PE receives a route from a CE, the specified SoO attribute will be added to the route. Before advertising the route to the other CE, the PE checks the SoO attribute. If the SoO attribute is the same as the locally configured SoO attribute, the PE does not advertise the route, preventing routing loops. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soostring must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__soostring = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soostring(self):
    self.__soostring = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_defaultRtAdvEnable(self):
    """
    Getter method for defaultRtAdvEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/defaultRtAdvEnable (boolean)

    YANG Description: Enable a device to advertise the default route to its peers. By default, the device does not advertise the default route to any peer or peer group. This option enables a device to send a default route with the device as the next hop address to its peers, regardless of whether there is a default route in the local routing table.
    """
    return self.__defaultRtAdvEnable
      
  def _set_defaultRtAdvEnable(self, v, load=False):
    """
    Setter method for defaultRtAdvEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/defaultRtAdvEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtAdvEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtAdvEnable() directly.

    YANG Description: Enable a device to advertise the default route to its peers. By default, the device does not advertise the default route to any peer or peer group. This option enables a device to send a default route with the device as the next hop address to its peers, regardless of whether there is a default route in the local routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtAdvEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__defaultRtAdvEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtAdvEnable(self):
    self.__defaultRtAdvEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_defaultRtAdvPolicy(self):
    """
    Getter method for defaultRtAdvPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/defaultRtAdvPolicy (string)

    YANG Description: Specify the name of a used policy. The value is a string.
    """
    return self.__defaultRtAdvPolicy
      
  def _set_defaultRtAdvPolicy(self, v, load=False):
    """
    Setter method for defaultRtAdvPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/defaultRtAdvPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtAdvPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtAdvPolicy() directly.

    YANG Description: Specify the name of a used policy. The value is a string.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtAdvPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__defaultRtAdvPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtAdvPolicy(self):
    self.__defaultRtAdvPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_defaultRtMatchMode(self):
    """
    Getter method for defaultRtMatchMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/defaultRtMatchMode (bgpcommonCraMatchMode)

    YANG Description: Configure the matching mode of default route advertisement, which can be disabling of route advertisement conditions, enabling of all route advertisement conditions, and enabling of part route advertisement conditions. Enabling of all route advertisement conditions indicates that a default route can be advertised only when it matches all the conditions. Enabling of part route advertisement conditions indicates that a default route can be advertised only when it matches one condition.
    """
    return self.__defaultRtMatchMode
      
  def _set_defaultRtMatchMode(self, v, load=False):
    """
    Setter method for defaultRtMatchMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/defaultRtMatchMode (bgpcommonCraMatchMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtMatchMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtMatchMode() directly.

    YANG Description: Configure the matching mode of default route advertisement, which can be disabling of route advertisement conditions, enabling of all route advertisement conditions, and enabling of part route advertisement conditions. Enabling of all route advertisement conditions indicates that a default route can be advertised only when it matches all the conditions. Enabling of part route advertisement conditions indicates that a default route can be advertised only when it matches one condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtMatchMode must be of a type compatible with bgpcommonCraMatchMode""",
          'defined-type': "huawei-bgp:bgpcommonCraMatchMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)""",
        })

    self.__defaultRtMatchMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtMatchMode(self):
    self.__defaultRtMatchMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)


  def _get_labelRouteCapability(self):
    """
    Getter method for labelRouteCapability, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/labelRouteCapability (boolean)

    YANG Description: Enable a device to exchange labeled routes
    """
    return self.__labelRouteCapability
      
  def _set_labelRouteCapability(self, v, load=False):
    """
    Setter method for labelRouteCapability, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/labelRouteCapability (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labelRouteCapability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labelRouteCapability() directly.

    YANG Description: Enable a device to exchange labeled routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labelRouteCapability must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__labelRouteCapability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labelRouteCapability(self):
    self.__labelRouteCapability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_addPathMode(self):
    """
    Getter method for addPathMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/addPathMode (bgpcommAddPathCapType)

    YANG Description: Enable Add-Path route advertisement to a peer group.
    """
    return self.__addPathMode
      
  def _set_addPathMode(self, v, load=False):
    """
    Setter method for addPathMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/addPathMode (bgpcommAddPathCapType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addPathMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addPathMode() directly.

    YANG Description: Enable Add-Path route advertisement to a peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addPathMode must be of a type compatible with bgpcommAddPathCapType""",
          'defined-type': "huawei-bgp:bgpcommAddPathCapType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)""",
        })

    self.__addPathMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addPathMode(self):
    self.__addPathMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)


  def _get_advAddPathNum(self):
    """
    Getter method for advAddPathNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advAddPathNum (uint8)

    YANG Description: Number of Add-Path routes that can be advertised to a peer group.
    """
    return self.__advAddPathNum
      
  def _set_advAddPathNum(self, v, load=False):
    """
    Setter method for advAddPathNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advAddPathNum (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advAddPathNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advAddPathNum() directly.

    YANG Description: Number of Add-Path routes that can be advertised to a peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advAddPathNum must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__advAddPathNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advAddPathNum(self):
    self.__advAddPathNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_originAsValid(self):
    """
    Getter method for originAsValid, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/originAsValid (boolean)

    YANG Description: Advertises the BGP origin AS validation result to the specified BGP peer or peer group.
    """
    return self.__originAsValid
      
  def _set_originAsValid(self, v, load=False):
    """
    Setter method for originAsValid, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/originAsValid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originAsValid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originAsValid() directly.

    YANG Description: Advertises the BGP origin AS validation result to the specified BGP peer or peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originAsValid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__originAsValid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originAsValid(self):
    self.__originAsValid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_updatePktStandardCompatible(self):
    """
    Getter method for updatePktStandardCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/updatePktStandardCompatible (boolean)

    YANG Description: Compatible Standard update packet
    """
    return self.__updatePktStandardCompatible
      
  def _set_updatePktStandardCompatible(self, v, load=False):
    """
    Setter method for updatePktStandardCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/updatePktStandardCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updatePktStandardCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updatePktStandardCompatible() directly.

    YANG Description: Compatible Standard update packet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updatePktStandardCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__updatePktStandardCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updatePktStandardCompatible(self):
    self.__updatePktStandardCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseIrb(self):
    """
    Getter method for advertiseIrb, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseIrb (boolean)

    YANG Description: Adervertise IRB Route when its value is true.  The default value is false.
    """
    return self.__advertiseIrb
      
  def _set_advertiseIrb(self, v, load=False):
    """
    Setter method for advertiseIrb, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseIrb (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseIrb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseIrb() directly.

    YANG Description: Adervertise IRB Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseIrb must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseIrb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseIrb(self):
    self.__advertiseIrb = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseArp(self):
    """
    Getter method for advertiseArp, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseArp (boolean)

    YANG Description: Adervertise ARP Route when its value is true.  The default value is false.
    """
    return self.__advertiseArp
      
  def _set_advertiseArp(self, v, load=False):
    """
    Setter method for advertiseArp, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseArp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseArp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseArp() directly.

    YANG Description: Adervertise ARP Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseArp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseArp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseArp(self):
    self.__advertiseArp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_splitGroupName(self):
    """
    Getter method for splitGroupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/splitGroupName (string)

    YANG Description: Split group name.
    """
    return self.__splitGroupName
      
  def _set_splitGroupName(self, v, load=False):
    """
    Setter method for splitGroupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/splitGroupName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_splitGroupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_splitGroupName() directly.

    YANG Description: Split group name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """splitGroupName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__splitGroupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_splitGroupName(self):
    self.__splitGroupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_advertiseIrbv6(self):
    """
    Getter method for advertiseIrbv6, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseIrbv6 (boolean)

    YANG Description: Adervertise IRBv6 Route when its value is true.  The default value is false.
    """
    return self.__advertiseIrbv6
      
  def _set_advertiseIrbv6(self, v, load=False):
    """
    Setter method for advertiseIrbv6, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseIrbv6 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseIrbv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseIrbv6() directly.

    YANG Description: Adervertise IRBv6 Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseIrbv6 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseIrbv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseIrbv6(self):
    self.__advertiseIrbv6 = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseND(self):
    """
    Getter method for advertiseND, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseND (boolean)

    YANG Description: Adervertise ND Route when its value is true.  The default value is false.
    """
    return self.__advertiseND
      
  def _set_advertiseND(self, v, load=False):
    """
    Setter method for advertiseND, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/advertiseND (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseND is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseND() directly.

    YANG Description: Adervertise ND Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseND must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseND = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseND(self):
    self.__advertiseND = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_peerGroupAFCraPres(self):
    """
    Getter method for peerGroupAFCraPres, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres (container)

    YANG Description: Configure the matching conditions for default route advertisement. (Only the default routes that match the conditions can be advertised.)
    """
    return self.__peerGroupAFCraPres
      
  def _set_peerGroupAFCraPres(self, v, load=False):
    """
    Setter method for peerGroupAFCraPres, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerGroupAFCraPres (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupAFCraPres is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupAFCraPres() directly.

    YANG Description: Configure the matching conditions for default route advertisement. (Only the default routes that match the conditions can be advertised.)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerGroupAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres, is_container='container', yang_name="peerGroupAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupAFCraPres must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerGroupAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres, is_container='container', yang_name="peerGroupAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerGroupAFCraPres = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupAFCraPres(self):
    self.__peerGroupAFCraPres = YANGDynClass(base=yc_peerGroupAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres, is_container='container', yang_name="peerGroupAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peerAFMembers(self):
    """
    Getter method for peerAFMembers, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers (container)

    YANG Description: List of peers in the peer address family.
    """
    return self.__peerAFMembers
      
  def _set_peerAFMembers(self, v, load=False):
    """
    Setter method for peerAFMembers, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF/peerAFMembers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAFMembers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAFMembers() directly.

    YANG Description: List of peers in the peer address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerAFMembers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers, is_container='container', yang_name="peerAFMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAFMembers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerAFMembers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers, is_container='container', yang_name="peerAFMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerAFMembers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAFMembers(self):
    self.__peerAFMembers = YANGDynClass(base=yc_peerAFMembers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers, is_container='container', yang_name="peerAFMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  groupName = __builtin__.property(_get_groupName, _set_groupName)
  groupType = __builtin__.property(_get_groupType, _set_groupType)
  advertiseRemoteNexthop = __builtin__.property(_get_advertiseRemoteNexthop, _set_advertiseRemoteNexthop)
  advertiseCommunity = __builtin__.property(_get_advertiseCommunity, _set_advertiseCommunity)
  advertiseExtCommunity = __builtin__.property(_get_advertiseExtCommunity, _set_advertiseExtCommunity)
  discardExtCommunity = __builtin__.property(_get_discardExtCommunity, _set_discardExtCommunity)
  allowAsLoopEnable = __builtin__.property(_get_allowAsLoopEnable, _set_allowAsLoopEnable)
  allowAsLoopLimit = __builtin__.property(_get_allowAsLoopLimit, _set_allowAsLoopLimit)
  keepAllRoutes = __builtin__.property(_get_keepAllRoutes, _set_keepAllRoutes)
  nextHopConfigure = __builtin__.property(_get_nextHopConfigure, _set_nextHopConfigure)
  preferredValue = __builtin__.property(_get_preferredValue, _set_preferredValue)
  publicAsOnly = __builtin__.property(_get_publicAsOnly, _set_publicAsOnly)
  publicAsOnlyForce = __builtin__.property(_get_publicAsOnlyForce, _set_publicAsOnlyForce)
  publicAsOnlyLimited = __builtin__.property(_get_publicAsOnlyLimited, _set_publicAsOnlyLimited)
  publicAsOnlyReplace = __builtin__.property(_get_publicAsOnlyReplace, _set_publicAsOnlyReplace)
  publicAsOnlySkipPeerAs = __builtin__.property(_get_publicAsOnlySkipPeerAs, _set_publicAsOnlySkipPeerAs)
  routeLimit = __builtin__.property(_get_routeLimit, _set_routeLimit)
  routeLimitPercent = __builtin__.property(_get_routeLimitPercent, _set_routeLimitPercent)
  routeLimitType = __builtin__.property(_get_routeLimitType, _set_routeLimitType)
  routeLimitIdleTimeout = __builtin__.property(_get_routeLimitIdleTimeout, _set_routeLimitIdleTimeout)
  rtUpdtInterval = __builtin__.property(_get_rtUpdtInterval, _set_rtUpdtInterval)
  reflectClient = __builtin__.property(_get_reflectClient, _set_reflectClient)
  substituteAsEnable = __builtin__.property(_get_substituteAsEnable, _set_substituteAsEnable)
  importRtPolicyName = __builtin__.property(_get_importRtPolicyName, _set_importRtPolicyName)
  exportRtPolicyName = __builtin__.property(_get_exportRtPolicyName, _set_exportRtPolicyName)
  importPrefFiltName = __builtin__.property(_get_importPrefFiltName, _set_importPrefFiltName)
  exportPrefFiltName = __builtin__.property(_get_exportPrefFiltName, _set_exportPrefFiltName)
  importAsPathNameOrNum = __builtin__.property(_get_importAsPathNameOrNum, _set_importAsPathNameOrNum)
  exportAsPathNameOrNum = __builtin__.property(_get_exportAsPathNameOrNum, _set_exportAsPathNameOrNum)
  importAclNameOrNum = __builtin__.property(_get_importAclNameOrNum, _set_importAclNameOrNum)
  exportAclNameOrNum = __builtin__.property(_get_exportAclNameOrNum, _set_exportAclNameOrNum)
  ipprefixOrfEnable = __builtin__.property(_get_ipprefixOrfEnable, _set_ipprefixOrfEnable)
  isNonstdIpprefixMod = __builtin__.property(_get_isNonstdIpprefixMod, _set_isNonstdIpprefixMod)
  orftype = __builtin__.property(_get_orftype, _set_orftype)
  orfMode = __builtin__.property(_get_orfMode, _set_orfMode)
  soostring = __builtin__.property(_get_soostring, _set_soostring)
  defaultRtAdvEnable = __builtin__.property(_get_defaultRtAdvEnable, _set_defaultRtAdvEnable)
  defaultRtAdvPolicy = __builtin__.property(_get_defaultRtAdvPolicy, _set_defaultRtAdvPolicy)
  defaultRtMatchMode = __builtin__.property(_get_defaultRtMatchMode, _set_defaultRtMatchMode)
  labelRouteCapability = __builtin__.property(_get_labelRouteCapability, _set_labelRouteCapability)
  addPathMode = __builtin__.property(_get_addPathMode, _set_addPathMode)
  advAddPathNum = __builtin__.property(_get_advAddPathNum, _set_advAddPathNum)
  originAsValid = __builtin__.property(_get_originAsValid, _set_originAsValid)
  updatePktStandardCompatible = __builtin__.property(_get_updatePktStandardCompatible, _set_updatePktStandardCompatible)
  advertiseIrb = __builtin__.property(_get_advertiseIrb, _set_advertiseIrb)
  advertiseArp = __builtin__.property(_get_advertiseArp, _set_advertiseArp)
  splitGroupName = __builtin__.property(_get_splitGroupName, _set_splitGroupName)
  advertiseIrbv6 = __builtin__.property(_get_advertiseIrbv6, _set_advertiseIrbv6)
  advertiseND = __builtin__.property(_get_advertiseND, _set_advertiseND)
  peerGroupAFCraPres = __builtin__.property(_get_peerGroupAFCraPres, _set_peerGroupAFCraPres) # type: yc_peerGroupAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerGroupAFCraPres
  peerAFMembers = __builtin__.property(_get_peerAFMembers, _set_peerAFMembers) # type: yc_peerAFMembers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF_peerAFMembers


  _pyangbind_elements = OrderedDict([('groupName', groupName), ('groupType', groupType), ('advertiseRemoteNexthop', advertiseRemoteNexthop), ('advertiseCommunity', advertiseCommunity), ('advertiseExtCommunity', advertiseExtCommunity), ('discardExtCommunity', discardExtCommunity), ('allowAsLoopEnable', allowAsLoopEnable), ('allowAsLoopLimit', allowAsLoopLimit), ('keepAllRoutes', keepAllRoutes), ('nextHopConfigure', nextHopConfigure), ('preferredValue', preferredValue), ('publicAsOnly', publicAsOnly), ('publicAsOnlyForce', publicAsOnlyForce), ('publicAsOnlyLimited', publicAsOnlyLimited), ('publicAsOnlyReplace', publicAsOnlyReplace), ('publicAsOnlySkipPeerAs', publicAsOnlySkipPeerAs), ('routeLimit', routeLimit), ('routeLimitPercent', routeLimitPercent), ('routeLimitType', routeLimitType), ('routeLimitIdleTimeout', routeLimitIdleTimeout), ('rtUpdtInterval', rtUpdtInterval), ('reflectClient', reflectClient), ('substituteAsEnable', substituteAsEnable), ('importRtPolicyName', importRtPolicyName), ('exportRtPolicyName', exportRtPolicyName), ('importPrefFiltName', importPrefFiltName), ('exportPrefFiltName', exportPrefFiltName), ('importAsPathNameOrNum', importAsPathNameOrNum), ('exportAsPathNameOrNum', exportAsPathNameOrNum), ('importAclNameOrNum', importAclNameOrNum), ('exportAclNameOrNum', exportAclNameOrNum), ('ipprefixOrfEnable', ipprefixOrfEnable), ('isNonstdIpprefixMod', isNonstdIpprefixMod), ('orftype', orftype), ('orfMode', orfMode), ('soostring', soostring), ('defaultRtAdvEnable', defaultRtAdvEnable), ('defaultRtAdvPolicy', defaultRtAdvPolicy), ('defaultRtMatchMode', defaultRtMatchMode), ('labelRouteCapability', labelRouteCapability), ('addPathMode', addPathMode), ('advAddPathNum', advAddPathNum), ('originAsValid', originAsValid), ('updatePktStandardCompatible', updatePktStandardCompatible), ('advertiseIrb', advertiseIrb), ('advertiseArp', advertiseArp), ('splitGroupName', splitGroupName), ('advertiseIrbv6', advertiseIrbv6), ('advertiseND', advertiseND), ('peerGroupAFCraPres', peerGroupAFCraPres), ('peerAFMembers', peerAFMembers), ])


class yc_peerGroupAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of all peer groups that are enabled in a specified address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerGroupAF',)

  _yang_name = 'peerGroupAFs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerGroupAF = YANGDynClass(base=YANGListType("groupName",yc_peerGroupAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF, yang_name="peerGroupAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="peerGroupAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerGroupAFs']

  def _get_peerGroupAF(self):
    """
    Getter method for peerGroupAF, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF (list)

    YANG Description: Peer group enabled in a specified address family.
    """
    return self.__peerGroupAF
      
  def _set_peerGroupAF(self, v, load=False):
    """
    Setter method for peerGroupAF, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs/peerGroupAF (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupAF is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupAF() directly.

    YANG Description: Peer group enabled in a specified address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("groupName",yc_peerGroupAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF, yang_name="peerGroupAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="peerGroupAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupAF must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("groupName",yc_peerGroupAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF, yang_name="peerGroupAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="peerGroupAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__peerGroupAF = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupAF(self):
    self.__peerGroupAF = YANGDynClass(base=YANGListType("groupName",yc_peerGroupAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF, yang_name="peerGroupAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="peerGroupAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  peerGroupAF = __builtin__.property(_get_peerGroupAF, _set_peerGroupAF) # type: yc_peerGroupAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs_peerGroupAF


  _pyangbind_elements = OrderedDict([('peerGroupAF', peerGroupAF), ])


class yc_peerAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres_peerAFCraPre(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the matching condition for default route advertisement.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defaultRtAddress','__defaultRtMask',)

  _yang_name = 'peerAFCraPre'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defaultRtAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__defaultRtMask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerAFs', 'peerAF', 'peerAFCraPres', 'peerAFCraPre']

  def _get_defaultRtAddress(self):
    """
    Getter method for defaultRtAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre/defaultRtAddress (inet:ipv4-address-no-zone)

    YANG Description: Configure a prefix that is used to match default routes.
    """
    return self.__defaultRtAddress
      
  def _set_defaultRtAddress(self, v, load=False):
    """
    Setter method for defaultRtAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre/defaultRtAddress (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtAddress() directly.

    YANG Description: Configure a prefix that is used to match default routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtAddress must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__defaultRtAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtAddress(self):
    self.__defaultRtAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="defaultRtAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_defaultRtMask(self):
    """
    Getter method for defaultRtMask, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre/defaultRtMask (uint32)

    YANG Description: Configure a mask that is used to match default routes.
    """
    return self.__defaultRtMask
      
  def _set_defaultRtMask(self, v, load=False):
    """
    Setter method for defaultRtMask, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre/defaultRtMask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtMask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtMask() directly.

    YANG Description: Configure a mask that is used to match default routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtMask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__defaultRtMask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtMask(self):
    self.__defaultRtMask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="defaultRtMask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)

  defaultRtAddress = __builtin__.property(_get_defaultRtAddress, _set_defaultRtAddress)
  defaultRtMask = __builtin__.property(_get_defaultRtMask, _set_defaultRtMask)


  _pyangbind_elements = OrderedDict([('defaultRtAddress', defaultRtAddress), ('defaultRtMask', defaultRtMask), ])


class yc_peerAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the matching conditions for default route advertisement. (Only the default routes that match the conditions can be advertised.)
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerAFCraPre',)

  _yang_name = 'peerAFCraPres'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerAFCraPre = YANGDynClass(base=YANGListType("defaultRtAddress defaultRtMask",yc_peerAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres_peerAFCraPre, yang_name="peerAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerAFs', 'peerAF', 'peerAFCraPres']

  def _get_peerAFCraPre(self):
    """
    Getter method for peerAFCraPre, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre (list)

    YANG Description: Configure the matching condition for default route advertisement.
    """
    return self.__peerAFCraPre
      
  def _set_peerAFCraPre(self, v, load=False):
    """
    Setter method for peerAFCraPre, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres/peerAFCraPre (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAFCraPre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAFCraPre() directly.

    YANG Description: Configure the matching condition for default route advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("defaultRtAddress defaultRtMask",yc_peerAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres_peerAFCraPre, yang_name="peerAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAFCraPre must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("defaultRtAddress defaultRtMask",yc_peerAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres_peerAFCraPre, yang_name="peerAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__peerAFCraPre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAFCraPre(self):
    self.__peerAFCraPre = YANGDynClass(base=YANGListType("defaultRtAddress defaultRtMask",yc_peerAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres_peerAFCraPre, yang_name="peerAFCraPre", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='defaultRtAddress defaultRtMask', extensions=None), is_container='list', yang_name="peerAFCraPre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  peerAFCraPre = __builtin__.property(_get_peerAFCraPre, _set_peerAFCraPre) # type: yc_peerAFCraPre_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres_peerAFCraPre


  _pyangbind_elements = OrderedDict([('peerAFCraPre', peerAFCraPre), ])


class yc_peerAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer in a specified address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remoteAddress','__peerGroupName','__labelRouteCapability','__advertiseIrb','__advertiseArp','__advertiseIrbv6','__advertiseND','__staticGrTimerValue','__advertiseRemoteNexthop','__advertiseCommunity','__advertiseExtCommunity','__discardExtCommunity','__allowAsLoopEnable','__allowAsLoopLimit','__keepAllRoutes','__nextHopConfigure','__preferredValue','__publicAsOnly','__publicAsOnlyForce','__publicAsOnlyLimited','__publicAsOnlyReplace','__publicAsOnlySkipPeerAs','__routeLimit','__routeLimitPercent','__routeLimitType','__routeLimitIdleTimeout','__rtUpdtInterval','__redirectIP','__redirectIPVaildation','__reflectClient','__substituteAsEnable','__importRtPolicyName','__exportRtPolicyName','__importPrefFiltName','__exportPrefFiltName','__importAsPathNameOrNum','__exportAsPathNameOrNum','__importAclNameOrNum','__exportAclNameOrNum','__ipprefixOrfEnable','__isNonstdIpprefixMod','__orftype','__orfMode','__soostring','__defaultRtAdvEnable','__defaultRtAdvPolicy','__defaultRtMatchMode','__addPathMode','__advAddPathNum','__originAsValid','__updatePktStandardCompatible','__reoriginatedRtEnableDc','__ipRtEnableDc','__splitGroupName','__peerAFCraPres',)

  _yang_name = 'peerAF'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remoteAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remoteAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__peerGroupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__labelRouteCapability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseIrb = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseArp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseIrbv6 = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseND = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__staticGrTimerValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3600..86400']}), is_leaf=True, yang_name="staticGrTimerValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__advertiseRemoteNexthop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advertiseExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__discardExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__allowAsLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__allowAsLoopLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__nextHopConfigure = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)
    self.__preferredValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__publicAsOnly = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlyForce = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlyLimited = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlyReplace = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__publicAsOnlySkipPeerAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routeLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__routeLimitPercent = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__routeLimitType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)
    self.__routeLimitIdleTimeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__rtUpdtInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__redirectIP = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__redirectIPVaildation = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIPVaildation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__reflectClient = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__substituteAsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__importRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__importPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__importAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__importAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__exportAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__ipprefixOrfEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__isNonstdIpprefixMod = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__orftype = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__orfMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)
    self.__soostring = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__defaultRtAdvEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__defaultRtAdvPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__defaultRtMatchMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)
    self.__addPathMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)
    self.__advAddPathNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__originAsValid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__updatePktStandardCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__reoriginatedRtEnableDc = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reoriginatedRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__ipRtEnableDc = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__splitGroupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__peerAFCraPres = YANGDynClass(base=yc_peerAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres, is_container='container', yang_name="peerAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerAFs', 'peerAF']

  def _get_remoteAddress(self):
    """
    Getter method for remoteAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/remoteAddress (leafref)

    YANG Description: IPv4 or IPv6 peer connection address.
    """
    return self.__remoteAddress
      
  def _set_remoteAddress(self, v, load=False):
    """
    Setter method for remoteAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/remoteAddress (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remoteAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remoteAddress() directly.

    YANG Description: IPv4 or IPv6 peer connection address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remoteAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remoteAddress must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remoteAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__remoteAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remoteAddress(self):
    self.__remoteAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remoteAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_peerGroupName(self):
    """
    Getter method for peerGroupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerGroupName (leafref)

    YANG Description: Configure a name for a peer group. After a peer is deleted from the peer group, the peer is disabled from the address family.
    """
    return self.__peerGroupName
      
  def _set_peerGroupName(self, v, load=False):
    """
    Setter method for peerGroupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerGroupName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupName() directly.

    YANG Description: Configure a name for a peer group. After a peer is deleted from the peer group, the peer is disabled from the address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="peerGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__peerGroupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupName(self):
    self.__peerGroupName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_labelRouteCapability(self):
    """
    Getter method for labelRouteCapability, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/labelRouteCapability (boolean)

    YANG Description: Enable a device to exchange labeled routes
    """
    return self.__labelRouteCapability
      
  def _set_labelRouteCapability(self, v, load=False):
    """
    Setter method for labelRouteCapability, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/labelRouteCapability (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labelRouteCapability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labelRouteCapability() directly.

    YANG Description: Enable a device to exchange labeled routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labelRouteCapability must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__labelRouteCapability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labelRouteCapability(self):
    self.__labelRouteCapability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="labelRouteCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseIrb(self):
    """
    Getter method for advertiseIrb, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseIrb (boolean)

    YANG Description: Adervertise IRB Route when its value is true.  The default value is false.
    """
    return self.__advertiseIrb
      
  def _set_advertiseIrb(self, v, load=False):
    """
    Setter method for advertiseIrb, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseIrb (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseIrb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseIrb() directly.

    YANG Description: Adervertise IRB Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseIrb must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseIrb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseIrb(self):
    self.__advertiseIrb = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseArp(self):
    """
    Getter method for advertiseArp, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseArp (boolean)

    YANG Description: Adervertise ARP Route when its value is true.  The default value is false.
    """
    return self.__advertiseArp
      
  def _set_advertiseArp(self, v, load=False):
    """
    Setter method for advertiseArp, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseArp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseArp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseArp() directly.

    YANG Description: Adervertise ARP Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseArp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseArp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseArp(self):
    self.__advertiseArp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseArp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseIrbv6(self):
    """
    Getter method for advertiseIrbv6, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseIrbv6 (boolean)

    YANG Description: Adervertise IRBv6 Route when its value is true.  The default value is false.
    """
    return self.__advertiseIrbv6
      
  def _set_advertiseIrbv6(self, v, load=False):
    """
    Setter method for advertiseIrbv6, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseIrbv6 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseIrbv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseIrbv6() directly.

    YANG Description: Adervertise IRBv6 Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseIrbv6 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseIrbv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseIrbv6(self):
    self.__advertiseIrbv6 = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseIrbv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseND(self):
    """
    Getter method for advertiseND, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseND (boolean)

    YANG Description: Adervertise ND Route when its value is true.  The default value is false.
    """
    return self.__advertiseND
      
  def _set_advertiseND(self, v, load=False):
    """
    Setter method for advertiseND, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseND (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseND is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseND() directly.

    YANG Description: Adervertise ND Route when its value is true.  The default value is false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseND must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseND = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseND(self):
    self.__advertiseND = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseND", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_staticGrTimerValue(self):
    """
    Getter method for staticGrTimerValue, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/staticGrTimerValue (uint32)

    YANG Description: Specifies the maximum time during which a peer waits for a BGP session reestablishment. in seconds.
    """
    return self.__staticGrTimerValue
      
  def _set_staticGrTimerValue(self, v, load=False):
    """
    Setter method for staticGrTimerValue, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/staticGrTimerValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_staticGrTimerValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_staticGrTimerValue() directly.

    YANG Description: Specifies the maximum time during which a peer waits for a BGP session reestablishment. in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3600..86400']}), is_leaf=True, yang_name="staticGrTimerValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """staticGrTimerValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3600..86400']}), is_leaf=True, yang_name="staticGrTimerValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__staticGrTimerValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_staticGrTimerValue(self):
    self.__staticGrTimerValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3600..86400']}), is_leaf=True, yang_name="staticGrTimerValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_advertiseRemoteNexthop(self):
    """
    Getter method for advertiseRemoteNexthop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseRemoteNexthop (boolean)

    YANG Description: Advertise the remote nexthop to a peer or peer group. By default, the remote nexthop attribute is not advertised to any peer or peer group.
    """
    return self.__advertiseRemoteNexthop
      
  def _set_advertiseRemoteNexthop(self, v, load=False):
    """
    Setter method for advertiseRemoteNexthop, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseRemoteNexthop (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseRemoteNexthop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseRemoteNexthop() directly.

    YANG Description: Advertise the remote nexthop to a peer or peer group. By default, the remote nexthop attribute is not advertised to any peer or peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseRemoteNexthop must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseRemoteNexthop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseRemoteNexthop(self):
    self.__advertiseRemoteNexthop = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseRemoteNexthop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseCommunity(self):
    """
    Getter method for advertiseCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseCommunity (boolean)

    YANG Description: Advertise the community attribute to a peer or peer group. By default, the community attribute is not advertised to any peer or peer group.
    """
    return self.__advertiseCommunity
      
  def _set_advertiseCommunity(self, v, load=False):
    """
    Setter method for advertiseCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseCommunity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseCommunity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseCommunity() directly.

    YANG Description: Advertise the community attribute to a peer or peer group. By default, the community attribute is not advertised to any peer or peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseCommunity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseCommunity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseCommunity(self):
    self.__advertiseCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advertiseExtCommunity(self):
    """
    Getter method for advertiseExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseExtCommunity (boolean)

    YANG Description: Advertise the extended community attribute to a peer or peer group. By default, the extended community attribute is not advertised to any peer or peer group.
    """
    return self.__advertiseExtCommunity
      
  def _set_advertiseExtCommunity(self, v, load=False):
    """
    Setter method for advertiseExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advertiseExtCommunity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertiseExtCommunity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertiseExtCommunity() directly.

    YANG Description: Advertise the extended community attribute to a peer or peer group. By default, the extended community attribute is not advertised to any peer or peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertiseExtCommunity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertiseExtCommunity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertiseExtCommunity(self):
    self.__advertiseExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertiseExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_discardExtCommunity(self):
    """
    Getter method for discardExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/discardExtCommunity (boolean)

    YANG Description: Discard the extended community attribute in the routing information about a specified peer. By default, the extended community attribute in the routing information about a specified peer is not discarded.
    """
    return self.__discardExtCommunity
      
  def _set_discardExtCommunity(self, v, load=False):
    """
    Setter method for discardExtCommunity, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/discardExtCommunity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discardExtCommunity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discardExtCommunity() directly.

    YANG Description: Discard the extended community attribute in the routing information about a specified peer. By default, the extended community attribute in the routing information about a specified peer is not discarded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discardExtCommunity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__discardExtCommunity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discardExtCommunity(self):
    self.__discardExtCommunity = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discardExtCommunity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_allowAsLoopEnable(self):
    """
    Getter method for allowAsLoopEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/allowAsLoopEnable (boolean)

    YANG Description: Allow repetitive local AS numbers. By default, repetitive local AS numbers are not allowed.
    """
    return self.__allowAsLoopEnable
      
  def _set_allowAsLoopEnable(self, v, load=False):
    """
    Setter method for allowAsLoopEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/allowAsLoopEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowAsLoopEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowAsLoopEnable() directly.

    YANG Description: Allow repetitive local AS numbers. By default, repetitive local AS numbers are not allowed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowAsLoopEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allowAsLoopEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowAsLoopEnable(self):
    self.__allowAsLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowAsLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_allowAsLoopLimit(self):
    """
    Getter method for allowAsLoopLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/allowAsLoopLimit (uint32)

    YANG Description: Set the maximum number of repetitive local AS number. The default value is 1.
    """
    return self.__allowAsLoopLimit
      
  def _set_allowAsLoopLimit(self, v, load=False):
    """
    Setter method for allowAsLoopLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/allowAsLoopLimit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowAsLoopLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowAsLoopLimit() directly.

    YANG Description: Set the maximum number of repetitive local AS number. The default value is 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowAsLoopLimit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__allowAsLoopLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowAsLoopLimit(self):
    self.__allowAsLoopLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="allowAsLoopLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_keepAllRoutes(self):
    """
    Getter method for keepAllRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/keepAllRoutes (boolean)

    YANG Description: Save all the updated information about BGP routes from a specified peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, the updated information about BGP routes from a specified peer is saved only when the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    return self.__keepAllRoutes
      
  def _set_keepAllRoutes(self, v, load=False):
    """
    Setter method for keepAllRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/keepAllRoutes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepAllRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepAllRoutes() directly.

    YANG Description: Save all the updated information about BGP routes from a specified peer or peer group after a BGP connection is established, even though these BGP routes fail to match the routing policy on the ingress. By default, the updated information about BGP routes from a specified peer is saved only when the routes match the routing policy on the ingress. If a router supports route refreshing, this option is not required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepAllRoutes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__keepAllRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepAllRoutes(self):
    self.__keepAllRoutes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="keepAllRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_nextHopConfigure(self):
    """
    Getter method for nextHopConfigure, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/nextHopConfigure (bgpcommNextHopCfg)

    YANG Description: Both the next-hop-local mode and next-hop-invariable mode are available when the peer address family is the VPNv4/VPNV6/L2VPN AD address family. Only the next-hop-local mode is available when the peer address family is not VPNv4/VPNV6/L2VPN AD address family. In next-hop-local mode, you can configure a BGP speaker to set its IP address of as the next hop of the routes to be advertised to IBGP peers or IBGP peer groups. In next-hop-invariable mode, you can configure PEs in different ASs not to change the next hop of routes when the PEs advertise the routes to their EBGP peers and use the next hop addresses of IGP routes to advertise imported IGP routes to IBGP peers. By default, when a BGP speaker advertises routes to EBGP peers and imported IGP routes to IBGP peers, the BGP speaker changes the next hop to its interface address. 
    """
    return self.__nextHopConfigure
      
  def _set_nextHopConfigure(self, v, load=False):
    """
    Setter method for nextHopConfigure, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/nextHopConfigure (bgpcommNextHopCfg)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHopConfigure is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHopConfigure() directly.

    YANG Description: Both the next-hop-local mode and next-hop-invariable mode are available when the peer address family is the VPNv4/VPNV6/L2VPN AD address family. Only the next-hop-local mode is available when the peer address family is not VPNv4/VPNV6/L2VPN AD address family. In next-hop-local mode, you can configure a BGP speaker to set its IP address of as the next hop of the routes to be advertised to IBGP peers or IBGP peer groups. In next-hop-invariable mode, you can configure PEs in different ASs not to change the next hop of routes when the PEs advertise the routes to their EBGP peers and use the next hop addresses of IGP routes to advertise imported IGP routes to IBGP peers. By default, when a BGP speaker advertises routes to EBGP peers and imported IGP routes to IBGP peers, the BGP speaker changes the next hop to its interface address. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHopConfigure must be of a type compatible with bgpcommNextHopCfg""",
          'defined-type': "huawei-bgp:bgpcommNextHopCfg",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)""",
        })

    self.__nextHopConfigure = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHopConfigure(self):
    self.__nextHopConfigure = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'local': {}, 'invariable': {}},), is_leaf=True, yang_name="nextHopConfigure", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommNextHopCfg', is_config=True)


  def _get_preferredValue(self):
    """
    Getter method for preferredValue, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/preferredValue (uint32)

    YANG Description: Assign a preferred value for the routes learned from a specified peer. The value is an integer. By default, the preferred value of the route learnt from BGP peers is 0. After a preferred value is configured for the routes learned from a specified peer, all the routes that learnt from this peer will use this preferred value. When multiple routes reach the same address prefix, the route with the largest preferred value will be selected.
    """
    return self.__preferredValue
      
  def _set_preferredValue(self, v, load=False):
    """
    Setter method for preferredValue, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/preferredValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferredValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferredValue() directly.

    YANG Description: Assign a preferred value for the routes learned from a specified peer. The value is an integer. By default, the preferred value of the route learnt from BGP peers is 0. After a preferred value is configured for the routes learned from a specified peer, all the routes that learnt from this peer will use this preferred value. When multiple routes reach the same address prefix, the route with the largest preferred value will be selected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferredValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__preferredValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferredValue(self):
    self.__preferredValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="preferredValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_publicAsOnly(self):
    """
    Getter method for publicAsOnly, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnly (boolean)

    YANG Description: Configure BGP to send Update packets carrying only public AS numbers. By default, private AS numbers can be carried in BGP Update packets.
    """
    return self.__publicAsOnly
      
  def _set_publicAsOnly(self, v, load=False):
    """
    Setter method for publicAsOnly, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnly (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnly is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnly() directly.

    YANG Description: Configure BGP to send Update packets carrying only public AS numbers. By default, private AS numbers can be carried in BGP Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnly must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnly = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnly(self):
    self.__publicAsOnly = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlyForce(self):
    """
    Getter method for publicAsOnlyForce, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlyForce (boolean)

    YANG Description: Configures BGP to carry only the public AS number instead of the private AS number when BGP sends Update packets. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlyForce
      
  def _set_publicAsOnlyForce(self, v, load=False):
    """
    Setter method for publicAsOnlyForce, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlyForce (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlyForce is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlyForce() directly.

    YANG Description: Configures BGP to carry only the public AS number instead of the private AS number when BGP sends Update packets. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlyForce must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlyForce = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlyForce(self):
    self.__publicAsOnlyForce = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyForce", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlyLimited(self):
    """
    Getter method for publicAsOnlyLimited, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlyLimited (boolean)

    YANG Description: When the BGP sends update packets, the left ends of both the local AS and public AS do not carry the private AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlyLimited
      
  def _set_publicAsOnlyLimited(self, v, load=False):
    """
    Setter method for publicAsOnlyLimited, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlyLimited (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlyLimited is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlyLimited() directly.

    YANG Description: When the BGP sends update packets, the left ends of both the local AS and public AS do not carry the private AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlyLimited must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlyLimited = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlyLimited(self):
    self.__publicAsOnlyLimited = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyLimited", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlyReplace(self):
    """
    Getter method for publicAsOnlyReplace, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlyReplace (boolean)

    YANG Description: When the BGP sends update packets, the private AS is replaced by the local AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlyReplace
      
  def _set_publicAsOnlyReplace(self, v, load=False):
    """
    Setter method for publicAsOnlyReplace, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlyReplace (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlyReplace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlyReplace() directly.

    YANG Description: When the BGP sends update packets, the private AS is replaced by the local AS. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlyReplace must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlyReplace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlyReplace(self):
    self.__publicAsOnlyReplace = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlyReplace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_publicAsOnlySkipPeerAs(self):
    """
    Getter method for publicAsOnlySkipPeerAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlySkipPeerAs (boolean)

    YANG Description: When the BGP sends update packets, the neigbour AS is not processed. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    return self.__publicAsOnlySkipPeerAs
      
  def _set_publicAsOnlySkipPeerAs(self, v, load=False):
    """
    Setter method for publicAsOnlySkipPeerAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/publicAsOnlySkipPeerAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_publicAsOnlySkipPeerAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_publicAsOnlySkipPeerAs() directly.

    YANG Description: When the BGP sends update packets, the neigbour AS is not processed. By default, BGP can carry the private AS number when BGP sends Update packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """publicAsOnlySkipPeerAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__publicAsOnlySkipPeerAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_publicAsOnlySkipPeerAs(self):
    self.__publicAsOnlySkipPeerAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="publicAsOnlySkipPeerAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routeLimit(self):
    """
    Getter method for routeLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimit (uint32)

    YANG Description: Configure the maximum number of routes that can be accepted from a peer. 
    """
    return self.__routeLimit
      
  def _set_routeLimit(self, v, load=False):
    """
    Setter method for routeLimit, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimit() directly.

    YANG Description: Configure the maximum number of routes that can be accepted from a peer. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__routeLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimit(self):
    self.__routeLimit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="routeLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_routeLimitPercent(self):
    """
    Getter method for routeLimitPercent, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimitPercent (uint8)

    YANG Description: Specify the percentage of routes when a router starts to generate an alarm. The default value is 75.
    """
    return self.__routeLimitPercent
      
  def _set_routeLimitPercent(self, v, load=False):
    """
    Setter method for routeLimitPercent, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimitPercent (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimitPercent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimitPercent() directly.

    YANG Description: Specify the percentage of routes when a router starts to generate an alarm. The default value is 75.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimitPercent must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__routeLimitPercent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimitPercent(self):
    self.__routeLimitPercent = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(75), is_leaf=True, yang_name="routeLimitPercent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_routeLimitType(self):
    """
    Getter method for routeLimitType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimitType (bgpcommRouteLmtType)

    YANG Description: Set the processing method as alert-only, idle-forever, or idle-timeout when the number of routes exceeds the set threshold. When alert-only is used, only an alarm is generated when the number of routes exceeds the threshold. In this case, new routes are no longer accepted. When idle-forever is used, connections are not automatically reestablished after being cut off until BGP connections are reset if the number of routes exceeds the set threshold. When idle-timeout is used and the idle-timeout timer is specified, the connections are automatically reestablished after being cut off if the number of routes exceeds the set threshold. You can reset BGP connections to reestablish the connections before the idle-timeout times expires.
    """
    return self.__routeLimitType
      
  def _set_routeLimitType(self, v, load=False):
    """
    Setter method for routeLimitType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimitType (bgpcommRouteLmtType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimitType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimitType() directly.

    YANG Description: Set the processing method as alert-only, idle-forever, or idle-timeout when the number of routes exceeds the set threshold. When alert-only is used, only an alarm is generated when the number of routes exceeds the threshold. In this case, new routes are no longer accepted. When idle-forever is used, connections are not automatically reestablished after being cut off until BGP connections are reset if the number of routes exceeds the set threshold. When idle-timeout is used and the idle-timeout timer is specified, the connections are automatically reestablished after being cut off if the number of routes exceeds the set threshold. You can reset BGP connections to reestablish the connections before the idle-timeout times expires.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimitType must be of a type compatible with bgpcommRouteLmtType""",
          'defined-type': "huawei-bgp:bgpcommRouteLmtType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)""",
        })

    self.__routeLimitType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimitType(self):
    self.__routeLimitType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noparameter': {}, 'alertOnly': {}, 'idleForever': {}, 'idleTimeout': {}},), default=six.text_type("noparameter"), is_leaf=True, yang_name="routeLimitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommRouteLmtType', is_config=True)


  def _get_routeLimitIdleTimeout(self):
    """
    Getter method for routeLimitIdleTimeout, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimitIdleTimeout (uint16)

    YANG Description: Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold.
    """
    return self.__routeLimitIdleTimeout
      
  def _set_routeLimitIdleTimeout(self, v, load=False):
    """
    Setter method for routeLimitIdleTimeout, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/routeLimitIdleTimeout (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeLimitIdleTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeLimitIdleTimeout() directly.

    YANG Description: Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeLimitIdleTimeout must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__routeLimitIdleTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeLimitIdleTimeout(self):
    self.__routeLimitIdleTimeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..1200']}), is_leaf=True, yang_name="routeLimitIdleTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_rtUpdtInterval(self):
    """
    Getter method for rtUpdtInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/rtUpdtInterval (uint16)

    YANG Description: Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. By default, the interval at which Update packets are sent to IBGP peers is 15s, and the interval at which Update packets are sent to EBGP peers is 30s. When routes change, a router will send Update packets to notify its peers. If a route changes frequently, you can set an interval at which Update packets are sent to prevent the router from sending Update packets each time the route changes. This configuration is valid only to the routes learned from peers. 
    """
    return self.__rtUpdtInterval
      
  def _set_rtUpdtInterval(self, v, load=False):
    """
    Setter method for rtUpdtInterval, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/rtUpdtInterval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rtUpdtInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rtUpdtInterval() directly.

    YANG Description: Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. By default, the interval at which Update packets are sent to IBGP peers is 15s, and the interval at which Update packets are sent to EBGP peers is 30s. When routes change, a router will send Update packets to notify its peers. If a route changes frequently, you can set an interval at which Update packets are sent to prevent the router from sending Update packets each time the route changes. This configuration is valid only to the routes learned from peers. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rtUpdtInterval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__rtUpdtInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rtUpdtInterval(self):
    self.__rtUpdtInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..600']}), is_leaf=True, yang_name="rtUpdtInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_redirectIP(self):
    """
    Getter method for redirectIP, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/redirectIP (boolean)

    YANG Description: After configuration commands, peer can handle the extended community attribute redirect-ip.
    """
    return self.__redirectIP
      
  def _set_redirectIP(self, v, load=False):
    """
    Setter method for redirectIP, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/redirectIP (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redirectIP is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redirectIP() directly.

    YANG Description: After configuration commands, peer can handle the extended community attribute redirect-ip.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redirectIP must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__redirectIP = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redirectIP(self):
    self.__redirectIP = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_redirectIPVaildation(self):
    """
    Getter method for redirectIPVaildation, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/redirectIPVaildation (boolean)

    YANG Description: Indicate whether validation redirect ip, and this command only support ipv4-family flow address family
    """
    return self.__redirectIPVaildation
      
  def _set_redirectIPVaildation(self, v, load=False):
    """
    Setter method for redirectIPVaildation, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/redirectIPVaildation (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redirectIPVaildation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redirectIPVaildation() directly.

    YANG Description: Indicate whether validation redirect ip, and this command only support ipv4-family flow address family
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIPVaildation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redirectIPVaildation must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIPVaildation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__redirectIPVaildation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redirectIPVaildation(self):
    self.__redirectIPVaildation = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="redirectIPVaildation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_reflectClient(self):
    """
    Getter method for reflectClient, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/reflectClient (boolean)

    YANG Description: Configure the local device as a route reflector (RR) and a peer or peer group as its client. By default, the RR and its client are not configured. This configuration is applicable between IBGP peers only. The configurations of RRs and its clients in an address family are valid only in this address family. Therefore, it is recommended to configure RRs and its clients in the specified address family that is required.
    """
    return self.__reflectClient
      
  def _set_reflectClient(self, v, load=False):
    """
    Setter method for reflectClient, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/reflectClient (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reflectClient is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reflectClient() directly.

    YANG Description: Configure the local device as a route reflector (RR) and a peer or peer group as its client. By default, the RR and its client are not configured. This configuration is applicable between IBGP peers only. The configurations of RRs and its clients in an address family are valid only in this address family. Therefore, it is recommended to configure RRs and its clients in the specified address family that is required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reflectClient must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__reflectClient = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reflectClient(self):
    self.__reflectClient = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_substituteAsEnable(self):
    """
    Getter method for substituteAsEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/substituteAsEnable (boolean)

    YANG Description: Replace the AS number of a specified peer in the AS_Path attribute with the local AS number. By default, the AS number replacement is disabled. On a PE where AS number replacement is enabled, if an AS number in the AS_Path attribute of a route is same as that of the CE to which the PE advertises the route, the PE replaces the AS number with its own AS number before advertising the route.
    """
    return self.__substituteAsEnable
      
  def _set_substituteAsEnable(self, v, load=False):
    """
    Setter method for substituteAsEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/substituteAsEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_substituteAsEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_substituteAsEnable() directly.

    YANG Description: Replace the AS number of a specified peer in the AS_Path attribute with the local AS number. By default, the AS number replacement is disabled. On a PE where AS number replacement is enabled, if an AS number in the AS_Path attribute of a route is same as that of the CE to which the PE advertises the route, the PE replaces the AS number with its own AS number before advertising the route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """substituteAsEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__substituteAsEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_substituteAsEnable(self):
    self.__substituteAsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="substituteAsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_importRtPolicyName(self):
    """
    Getter method for importRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importRtPolicyName (string)

    YANG Description: Specify the filtering policy applied to the routes learned from a peer. By default, no such policy is specified.
    """
    return self.__importRtPolicyName
      
  def _set_importRtPolicyName(self, v, load=False):
    """
    Setter method for importRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importRtPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importRtPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importRtPolicyName() directly.

    YANG Description: Specify the filtering policy applied to the routes learned from a peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importRtPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importRtPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importRtPolicyName(self):
    self.__importRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportRtPolicyName(self):
    """
    Getter method for exportRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportRtPolicyName (string)

    YANG Description: Specify the filtering policy applied to the routes to be advertised to a peer. By default, no such policy is specified.
    """
    return self.__exportRtPolicyName
      
  def _set_exportRtPolicyName(self, v, load=False):
    """
    Setter method for exportRtPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportRtPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportRtPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportRtPolicyName() directly.

    YANG Description: Specify the filtering policy applied to the routes to be advertised to a peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportRtPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportRtPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportRtPolicyName(self):
    self.__exportRtPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportRtPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_importPrefFiltName(self):
    """
    Getter method for importPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importPrefFiltName (string)

    YANG Description: Specify the IPv4 filtering policy applied to the routes received from a specified peer. By default, no such policy is specified.
    """
    return self.__importPrefFiltName
      
  def _set_importPrefFiltName(self, v, load=False):
    """
    Setter method for importPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importPrefFiltName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importPrefFiltName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importPrefFiltName() directly.

    YANG Description: Specify the IPv4 filtering policy applied to the routes received from a specified peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importPrefFiltName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importPrefFiltName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importPrefFiltName(self):
    self.__importPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportPrefFiltName(self):
    """
    Getter method for exportPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportPrefFiltName (string)

    YANG Description: Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. By default, no such policy is specified.
    """
    return self.__exportPrefFiltName
      
  def _set_exportPrefFiltName(self, v, load=False):
    """
    Setter method for exportPrefFiltName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportPrefFiltName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportPrefFiltName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportPrefFiltName() directly.

    YANG Description: Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. By default, no such policy is specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportPrefFiltName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportPrefFiltName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportPrefFiltName(self):
    self.__exportPrefFiltName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportPrefFiltName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_importAsPathNameOrNum(self):
    """
    Getter method for importAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importAsPathNameOrNum (string)

    YANG Description: Apply an AS_Path-based filtering policy to the routes received from a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    return self.__importAsPathNameOrNum
      
  def _set_importAsPathNameOrNum(self, v, load=False):
    """
    Setter method for importAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importAsPathNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importAsPathNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importAsPathNameOrNum() directly.

    YANG Description: Apply an AS_Path-based filtering policy to the routes received from a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importAsPathNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importAsPathNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importAsPathNameOrNum(self):
    self.__importAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportAsPathNameOrNum(self):
    """
    Getter method for exportAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportAsPathNameOrNum (string)

    YANG Description: Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    return self.__exportAsPathNameOrNum
      
  def _set_exportAsPathNameOrNum(self, v, load=False):
    """
    Setter method for exportAsPathNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportAsPathNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportAsPathNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportAsPathNameOrNum() directly.

    YANG Description: Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The policy can be identified with a name or number, and the number ranges from 1 to 256. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportAsPathNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportAsPathNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportAsPathNameOrNum(self):
    self.__exportAsPathNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAsPathNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_importAclNameOrNum(self):
    """
    Getter method for importAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importAclNameOrNum (string)

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    return self.__importAclNameOrNum
      
  def _set_importAclNameOrNum(self, v, load=False):
    """
    Setter method for importAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/importAclNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importAclNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importAclNameOrNum() directly.

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be accepted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importAclNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importAclNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importAclNameOrNum(self):
    self.__importAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_exportAclNameOrNum(self):
    """
    Getter method for exportAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportAclNameOrNum (string)

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    return self.__exportAclNameOrNum
      
  def _set_exportAclNameOrNum(self, v, load=False):
    """
    Setter method for exportAclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/exportAclNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exportAclNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exportAclNameOrNum() directly.

    YANG Description: Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The ACL number ranges from 2000 to 2999, and the name must start with a letter. By default, no such policy is specified. Therefore, all BGP routes can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exportAclNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__exportAclNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exportAclNameOrNum(self):
    self.__exportAclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="exportAclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_ipprefixOrfEnable(self):
    """
    Getter method for ipprefixOrfEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/ipprefixOrfEnable (boolean)

    YANG Description: Enable Prefix-based BGP outbound route filtering (ORF). By default, this function is not enabled. ORF enables a BGP device to use the import policy of a peer as the local export policy so that unwanted routes are filtered out during route advertisement.
    """
    return self.__ipprefixOrfEnable
      
  def _set_ipprefixOrfEnable(self, v, load=False):
    """
    Setter method for ipprefixOrfEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/ipprefixOrfEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipprefixOrfEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipprefixOrfEnable() directly.

    YANG Description: Enable Prefix-based BGP outbound route filtering (ORF). By default, this function is not enabled. ORF enables a BGP device to use the import policy of a peer as the local export policy so that unwanted routes are filtered out during route advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipprefixOrfEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ipprefixOrfEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipprefixOrfEnable(self):
    self.__ipprefixOrfEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipprefixOrfEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_isNonstdIpprefixMod(self):
    """
    Getter method for isNonstdIpprefixMod, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/isNonstdIpprefixMod (boolean)

    YANG Description: Enable Huawei routers to be compatible with Nonstandard routers. The ORF capability codes supported by Nonstandard devices are different from that defined by the associated RFC standard. After the option is selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code supported by Nonstandard devices. If the option is not selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code specified by the RFC standard.
    """
    return self.__isNonstdIpprefixMod
      
  def _set_isNonstdIpprefixMod(self, v, load=False):
    """
    Setter method for isNonstdIpprefixMod, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/isNonstdIpprefixMod (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNonstdIpprefixMod is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNonstdIpprefixMod() directly.

    YANG Description: Enable Huawei routers to be compatible with Nonstandard routers. The ORF capability codes supported by Nonstandard devices are different from that defined by the associated RFC standard. After the option is selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code supported by Nonstandard devices. If the option is not selected, Huawei devices and Nonstandard devices negotiate ORF capability based on the ORF capability code specified by the RFC standard.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNonstdIpprefixMod must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__isNonstdIpprefixMod = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNonstdIpprefixMod(self):
    self.__isNonstdIpprefixMod = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isNonstdIpprefixMod", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_orftype(self):
    """
    Getter method for orftype, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/orftype (uint16)

    YANG Description: ORF Type.
    """
    return self.__orftype
      
  def _set_orftype(self, v, load=False):
    """
    Setter method for orftype, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/orftype (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_orftype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_orftype() directly.

    YANG Description: ORF Type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """orftype must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__orftype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_orftype(self):
    self.__orftype = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="orftype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_orfMode(self):
    """
    Getter method for orfMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/orfMode (bgpcommonOrfMode)

    YANG Description: Configure an outbound route filtering (ORF) mode, which can be Receive, Send, or Both, and the default ORF mode is Both. 
    """
    return self.__orfMode
      
  def _set_orfMode(self, v, load=False):
    """
    Setter method for orfMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/orfMode (bgpcommonOrfMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_orfMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_orfMode() directly.

    YANG Description: Configure an outbound route filtering (ORF) mode, which can be Receive, Send, or Both, and the default ORF mode is Both. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """orfMode must be of a type compatible with bgpcommonOrfMode""",
          'defined-type': "huawei-bgp:bgpcommonOrfMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)""",
        })

    self.__orfMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_orfMode(self):
    self.__orfMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="orfMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonOrfMode', is_config=True)


  def _get_soostring(self):
    """
    Getter method for soostring, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/soostring (string)

    YANG Description: Configure the Site-of-Origin (SoO) extended community attribute. This attribute can be expressed in the following formats: X.X.X.X:number<0-65535>, number<0-65535>:number<0-4294967295>, or number<0-65535>.number<0-65535>:number<0-65535>  or <65536-4294967295>:<0-65535>. 0:0 or 0.0:0 is not supported.
Two CEs are in the same site and can advertise routes to each other, and they are connected to a VPN through PEs. If the local routes of a CE are advertised to the other CE over the VPN, a routing loop may occur.
The SoO feature can prevent a route advertised by a site from being sent back to the site, preventing routing loops. After SoO is enabled and a PE receives a route from a CE, the specified SoO attribute will be added to the route. Before advertising the route to the other CE, the PE checks the SoO attribute. If the SoO attribute is the same as the locally configured SoO attribute, the PE does not advertise the route, preventing routing loops. 
    """
    return self.__soostring
      
  def _set_soostring(self, v, load=False):
    """
    Setter method for soostring, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/soostring (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soostring is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soostring() directly.

    YANG Description: Configure the Site-of-Origin (SoO) extended community attribute. This attribute can be expressed in the following formats: X.X.X.X:number<0-65535>, number<0-65535>:number<0-4294967295>, or number<0-65535>.number<0-65535>:number<0-65535>  or <65536-4294967295>:<0-65535>. 0:0 or 0.0:0 is not supported.
Two CEs are in the same site and can advertise routes to each other, and they are connected to a VPN through PEs. If the local routes of a CE are advertised to the other CE over the VPN, a routing loop may occur.
The SoO feature can prevent a route advertised by a site from being sent back to the site, preventing routing loops. After SoO is enabled and a PE receives a route from a CE, the specified SoO attribute will be added to the route. Before advertising the route to the other CE, the PE checks the SoO attribute. If the SoO attribute is the same as the locally configured SoO attribute, the PE does not advertise the route, preventing routing loops. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soostring must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__soostring = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soostring(self):
    self.__soostring = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="soostring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_defaultRtAdvEnable(self):
    """
    Getter method for defaultRtAdvEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/defaultRtAdvEnable (boolean)

    YANG Description: Enable a device to advertise the default route to its peers. By default, the device does not advertise the default route to any peer or peer group. This option enables a device to send a default route with the device as the next hop address to its peers, regardless of whether there is a default route in the local routing table.
    """
    return self.__defaultRtAdvEnable
      
  def _set_defaultRtAdvEnable(self, v, load=False):
    """
    Setter method for defaultRtAdvEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/defaultRtAdvEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtAdvEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtAdvEnable() directly.

    YANG Description: Enable a device to advertise the default route to its peers. By default, the device does not advertise the default route to any peer or peer group. This option enables a device to send a default route with the device as the next hop address to its peers, regardless of whether there is a default route in the local routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtAdvEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__defaultRtAdvEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtAdvEnable(self):
    self.__defaultRtAdvEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtAdvEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_defaultRtAdvPolicy(self):
    """
    Getter method for defaultRtAdvPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/defaultRtAdvPolicy (string)

    YANG Description: Specify the name of a used policy. The value is a string.
    """
    return self.__defaultRtAdvPolicy
      
  def _set_defaultRtAdvPolicy(self, v, load=False):
    """
    Setter method for defaultRtAdvPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/defaultRtAdvPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtAdvPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtAdvPolicy() directly.

    YANG Description: Specify the name of a used policy. The value is a string.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtAdvPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__defaultRtAdvPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtAdvPolicy(self):
    self.__defaultRtAdvPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="defaultRtAdvPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_defaultRtMatchMode(self):
    """
    Getter method for defaultRtMatchMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/defaultRtMatchMode (bgpcommonCraMatchMode)

    YANG Description: Configure the matching mode of default route advertisement, which can be disabling of route advertisement conditions, enabling of all route advertisement conditions, and enabling of part route advertisement conditions. Enabling of all route advertisement conditions indicates that a default route can be advertised only when it matches all the conditions. Enabling of part route advertisement conditions indicates that a default route can be advertised only when it matches one condition.
    """
    return self.__defaultRtMatchMode
      
  def _set_defaultRtMatchMode(self, v, load=False):
    """
    Setter method for defaultRtMatchMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/defaultRtMatchMode (bgpcommonCraMatchMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtMatchMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtMatchMode() directly.

    YANG Description: Configure the matching mode of default route advertisement, which can be disabling of route advertisement conditions, enabling of all route advertisement conditions, and enabling of part route advertisement conditions. Enabling of all route advertisement conditions indicates that a default route can be advertised only when it matches all the conditions. Enabling of part route advertisement conditions indicates that a default route can be advertised only when it matches one condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtMatchMode must be of a type compatible with bgpcommonCraMatchMode""",
          'defined-type': "huawei-bgp:bgpcommonCraMatchMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)""",
        })

    self.__defaultRtMatchMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtMatchMode(self):
    self.__defaultRtMatchMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'matchall': {}, 'matchany': {}},), default=six.text_type("null"), is_leaf=True, yang_name="defaultRtMatchMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommonCraMatchMode', is_config=True)


  def _get_addPathMode(self):
    """
    Getter method for addPathMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/addPathMode (bgpcommAddPathCapType)

    YANG Description: Enable Add-Path route advertisement to a peer.
    """
    return self.__addPathMode
      
  def _set_addPathMode(self, v, load=False):
    """
    Setter method for addPathMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/addPathMode (bgpcommAddPathCapType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addPathMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addPathMode() directly.

    YANG Description: Enable Add-Path route advertisement to a peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addPathMode must be of a type compatible with bgpcommAddPathCapType""",
          'defined-type': "huawei-bgp:bgpcommAddPathCapType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)""",
        })

    self.__addPathMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addPathMode(self):
    self.__addPathMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {}, 'receive': {}, 'send': {}, 'both': {}},), default=six.text_type("null"), is_leaf=True, yang_name="addPathMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAddPathCapType', is_config=True)


  def _get_advAddPathNum(self):
    """
    Getter method for advAddPathNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advAddPathNum (uint8)

    YANG Description: Number of Add-Path routes that can be advertised to a peer.
    """
    return self.__advAddPathNum
      
  def _set_advAddPathNum(self, v, load=False):
    """
    Setter method for advAddPathNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/advAddPathNum (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advAddPathNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advAddPathNum() directly.

    YANG Description: Number of Add-Path routes that can be advertised to a peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advAddPathNum must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__advAddPathNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advAddPathNum(self):
    self.__advAddPathNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="advAddPathNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_originAsValid(self):
    """
    Getter method for originAsValid, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/originAsValid (boolean)

    YANG Description: Advertises the BGP origin AS validation result to the specified BGP peer or peer group.
    """
    return self.__originAsValid
      
  def _set_originAsValid(self, v, load=False):
    """
    Setter method for originAsValid, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/originAsValid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originAsValid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originAsValid() directly.

    YANG Description: Advertises the BGP origin AS validation result to the specified BGP peer or peer group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originAsValid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__originAsValid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originAsValid(self):
    self.__originAsValid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_updatePktStandardCompatible(self):
    """
    Getter method for updatePktStandardCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/updatePktStandardCompatible (boolean)

    YANG Description: Compatible Standard update packet
    """
    return self.__updatePktStandardCompatible
      
  def _set_updatePktStandardCompatible(self, v, load=False):
    """
    Setter method for updatePktStandardCompatible, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/updatePktStandardCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updatePktStandardCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updatePktStandardCompatible() directly.

    YANG Description: Compatible Standard update packet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updatePktStandardCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__updatePktStandardCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updatePktStandardCompatible(self):
    self.__updatePktStandardCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="updatePktStandardCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_reoriginatedRtEnableDc(self):
    """
    Getter method for reoriginatedRtEnableDc, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/reoriginatedRtEnableDc (boolean)

    YANG Description: Change nexthop when forming equal cost multiple paths
    """
    return self.__reoriginatedRtEnableDc
      
  def _set_reoriginatedRtEnableDc(self, v, load=False):
    """
    Setter method for reoriginatedRtEnableDc, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/reoriginatedRtEnableDc (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reoriginatedRtEnableDc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reoriginatedRtEnableDc() directly.

    YANG Description: Change nexthop when forming equal cost multiple paths
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reoriginatedRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reoriginatedRtEnableDc must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reoriginatedRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__reoriginatedRtEnableDc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reoriginatedRtEnableDc(self):
    self.__reoriginatedRtEnableDc = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reoriginatedRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_ipRtEnableDc(self):
    """
    Getter method for ipRtEnableDc, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/ipRtEnableDc (boolean)

    YANG Description: Enable advertising this type route.
    """
    return self.__ipRtEnableDc
      
  def _set_ipRtEnableDc(self, v, load=False):
    """
    Setter method for ipRtEnableDc, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/ipRtEnableDc (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipRtEnableDc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipRtEnableDc() directly.

    YANG Description: Enable advertising this type route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipRtEnableDc must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ipRtEnableDc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipRtEnableDc(self):
    self.__ipRtEnableDc = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipRtEnableDc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_splitGroupName(self):
    """
    Getter method for splitGroupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/splitGroupName (string)

    YANG Description: Split group name.
    """
    return self.__splitGroupName
      
  def _set_splitGroupName(self, v, load=False):
    """
    Setter method for splitGroupName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/splitGroupName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_splitGroupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_splitGroupName() directly.

    YANG Description: Split group name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """splitGroupName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__splitGroupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_splitGroupName(self):
    self.__splitGroupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="splitGroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_peerAFCraPres(self):
    """
    Getter method for peerAFCraPres, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres (container)

    YANG Description: Configure the matching conditions for default route advertisement. (Only the default routes that match the conditions can be advertised.)
    """
    return self.__peerAFCraPres
      
  def _set_peerAFCraPres(self, v, load=False):
    """
    Setter method for peerAFCraPres, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF/peerAFCraPres (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAFCraPres is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAFCraPres() directly.

    YANG Description: Configure the matching conditions for default route advertisement. (Only the default routes that match the conditions can be advertised.)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres, is_container='container', yang_name="peerAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAFCraPres must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres, is_container='container', yang_name="peerAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerAFCraPres = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAFCraPres(self):
    self.__peerAFCraPres = YANGDynClass(base=yc_peerAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres, is_container='container', yang_name="peerAFCraPres", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  remoteAddress = __builtin__.property(_get_remoteAddress, _set_remoteAddress)
  peerGroupName = __builtin__.property(_get_peerGroupName, _set_peerGroupName)
  labelRouteCapability = __builtin__.property(_get_labelRouteCapability, _set_labelRouteCapability)
  advertiseIrb = __builtin__.property(_get_advertiseIrb, _set_advertiseIrb)
  advertiseArp = __builtin__.property(_get_advertiseArp, _set_advertiseArp)
  advertiseIrbv6 = __builtin__.property(_get_advertiseIrbv6, _set_advertiseIrbv6)
  advertiseND = __builtin__.property(_get_advertiseND, _set_advertiseND)
  staticGrTimerValue = __builtin__.property(_get_staticGrTimerValue, _set_staticGrTimerValue)
  advertiseRemoteNexthop = __builtin__.property(_get_advertiseRemoteNexthop, _set_advertiseRemoteNexthop)
  advertiseCommunity = __builtin__.property(_get_advertiseCommunity, _set_advertiseCommunity)
  advertiseExtCommunity = __builtin__.property(_get_advertiseExtCommunity, _set_advertiseExtCommunity)
  discardExtCommunity = __builtin__.property(_get_discardExtCommunity, _set_discardExtCommunity)
  allowAsLoopEnable = __builtin__.property(_get_allowAsLoopEnable, _set_allowAsLoopEnable)
  allowAsLoopLimit = __builtin__.property(_get_allowAsLoopLimit, _set_allowAsLoopLimit)
  keepAllRoutes = __builtin__.property(_get_keepAllRoutes, _set_keepAllRoutes)
  nextHopConfigure = __builtin__.property(_get_nextHopConfigure, _set_nextHopConfigure)
  preferredValue = __builtin__.property(_get_preferredValue, _set_preferredValue)
  publicAsOnly = __builtin__.property(_get_publicAsOnly, _set_publicAsOnly)
  publicAsOnlyForce = __builtin__.property(_get_publicAsOnlyForce, _set_publicAsOnlyForce)
  publicAsOnlyLimited = __builtin__.property(_get_publicAsOnlyLimited, _set_publicAsOnlyLimited)
  publicAsOnlyReplace = __builtin__.property(_get_publicAsOnlyReplace, _set_publicAsOnlyReplace)
  publicAsOnlySkipPeerAs = __builtin__.property(_get_publicAsOnlySkipPeerAs, _set_publicAsOnlySkipPeerAs)
  routeLimit = __builtin__.property(_get_routeLimit, _set_routeLimit)
  routeLimitPercent = __builtin__.property(_get_routeLimitPercent, _set_routeLimitPercent)
  routeLimitType = __builtin__.property(_get_routeLimitType, _set_routeLimitType)
  routeLimitIdleTimeout = __builtin__.property(_get_routeLimitIdleTimeout, _set_routeLimitIdleTimeout)
  rtUpdtInterval = __builtin__.property(_get_rtUpdtInterval, _set_rtUpdtInterval)
  redirectIP = __builtin__.property(_get_redirectIP, _set_redirectIP)
  redirectIPVaildation = __builtin__.property(_get_redirectIPVaildation, _set_redirectIPVaildation)
  reflectClient = __builtin__.property(_get_reflectClient, _set_reflectClient)
  substituteAsEnable = __builtin__.property(_get_substituteAsEnable, _set_substituteAsEnable)
  importRtPolicyName = __builtin__.property(_get_importRtPolicyName, _set_importRtPolicyName)
  exportRtPolicyName = __builtin__.property(_get_exportRtPolicyName, _set_exportRtPolicyName)
  importPrefFiltName = __builtin__.property(_get_importPrefFiltName, _set_importPrefFiltName)
  exportPrefFiltName = __builtin__.property(_get_exportPrefFiltName, _set_exportPrefFiltName)
  importAsPathNameOrNum = __builtin__.property(_get_importAsPathNameOrNum, _set_importAsPathNameOrNum)
  exportAsPathNameOrNum = __builtin__.property(_get_exportAsPathNameOrNum, _set_exportAsPathNameOrNum)
  importAclNameOrNum = __builtin__.property(_get_importAclNameOrNum, _set_importAclNameOrNum)
  exportAclNameOrNum = __builtin__.property(_get_exportAclNameOrNum, _set_exportAclNameOrNum)
  ipprefixOrfEnable = __builtin__.property(_get_ipprefixOrfEnable, _set_ipprefixOrfEnable)
  isNonstdIpprefixMod = __builtin__.property(_get_isNonstdIpprefixMod, _set_isNonstdIpprefixMod)
  orftype = __builtin__.property(_get_orftype, _set_orftype)
  orfMode = __builtin__.property(_get_orfMode, _set_orfMode)
  soostring = __builtin__.property(_get_soostring, _set_soostring)
  defaultRtAdvEnable = __builtin__.property(_get_defaultRtAdvEnable, _set_defaultRtAdvEnable)
  defaultRtAdvPolicy = __builtin__.property(_get_defaultRtAdvPolicy, _set_defaultRtAdvPolicy)
  defaultRtMatchMode = __builtin__.property(_get_defaultRtMatchMode, _set_defaultRtMatchMode)
  addPathMode = __builtin__.property(_get_addPathMode, _set_addPathMode)
  advAddPathNum = __builtin__.property(_get_advAddPathNum, _set_advAddPathNum)
  originAsValid = __builtin__.property(_get_originAsValid, _set_originAsValid)
  updatePktStandardCompatible = __builtin__.property(_get_updatePktStandardCompatible, _set_updatePktStandardCompatible)
  reoriginatedRtEnableDc = __builtin__.property(_get_reoriginatedRtEnableDc, _set_reoriginatedRtEnableDc)
  ipRtEnableDc = __builtin__.property(_get_ipRtEnableDc, _set_ipRtEnableDc)
  splitGroupName = __builtin__.property(_get_splitGroupName, _set_splitGroupName)
  peerAFCraPres = __builtin__.property(_get_peerAFCraPres, _set_peerAFCraPres) # type: yc_peerAFCraPres_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF_peerAFCraPres


  _pyangbind_elements = OrderedDict([('remoteAddress', remoteAddress), ('peerGroupName', peerGroupName), ('labelRouteCapability', labelRouteCapability), ('advertiseIrb', advertiseIrb), ('advertiseArp', advertiseArp), ('advertiseIrbv6', advertiseIrbv6), ('advertiseND', advertiseND), ('staticGrTimerValue', staticGrTimerValue), ('advertiseRemoteNexthop', advertiseRemoteNexthop), ('advertiseCommunity', advertiseCommunity), ('advertiseExtCommunity', advertiseExtCommunity), ('discardExtCommunity', discardExtCommunity), ('allowAsLoopEnable', allowAsLoopEnable), ('allowAsLoopLimit', allowAsLoopLimit), ('keepAllRoutes', keepAllRoutes), ('nextHopConfigure', nextHopConfigure), ('preferredValue', preferredValue), ('publicAsOnly', publicAsOnly), ('publicAsOnlyForce', publicAsOnlyForce), ('publicAsOnlyLimited', publicAsOnlyLimited), ('publicAsOnlyReplace', publicAsOnlyReplace), ('publicAsOnlySkipPeerAs', publicAsOnlySkipPeerAs), ('routeLimit', routeLimit), ('routeLimitPercent', routeLimitPercent), ('routeLimitType', routeLimitType), ('routeLimitIdleTimeout', routeLimitIdleTimeout), ('rtUpdtInterval', rtUpdtInterval), ('redirectIP', redirectIP), ('redirectIPVaildation', redirectIPVaildation), ('reflectClient', reflectClient), ('substituteAsEnable', substituteAsEnable), ('importRtPolicyName', importRtPolicyName), ('exportRtPolicyName', exportRtPolicyName), ('importPrefFiltName', importPrefFiltName), ('exportPrefFiltName', exportPrefFiltName), ('importAsPathNameOrNum', importAsPathNameOrNum), ('exportAsPathNameOrNum', exportAsPathNameOrNum), ('importAclNameOrNum', importAclNameOrNum), ('exportAclNameOrNum', exportAclNameOrNum), ('ipprefixOrfEnable', ipprefixOrfEnable), ('isNonstdIpprefixMod', isNonstdIpprefixMod), ('orftype', orftype), ('orfMode', orfMode), ('soostring', soostring), ('defaultRtAdvEnable', defaultRtAdvEnable), ('defaultRtAdvPolicy', defaultRtAdvPolicy), ('defaultRtMatchMode', defaultRtMatchMode), ('addPathMode', addPathMode), ('advAddPathNum', advAddPathNum), ('originAsValid', originAsValid), ('updatePktStandardCompatible', updatePktStandardCompatible), ('reoriginatedRtEnableDc', reoriginatedRtEnableDc), ('ipRtEnableDc', ipRtEnableDc), ('splitGroupName', splitGroupName), ('peerAFCraPres', peerAFCraPres), ])


class yc_peerAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peers in a specified address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerAF',)

  _yang_name = 'peerAFs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerAF = YANGDynClass(base=YANGListType("remoteAddress",yc_peerAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF, yang_name="peerAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteAddress', extensions=None), is_container='list', yang_name="peerAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'peerAFs']

  def _get_peerAF(self):
    """
    Getter method for peerAF, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF (list)

    YANG Description: Peer in a specified address family.
    """
    return self.__peerAF
      
  def _set_peerAF(self, v, load=False):
    """
    Setter method for peerAF, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs/peerAF (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAF is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAF() directly.

    YANG Description: Peer in a specified address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("remoteAddress",yc_peerAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF, yang_name="peerAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteAddress', extensions=None), is_container='list', yang_name="peerAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAF must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("remoteAddress",yc_peerAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF, yang_name="peerAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteAddress', extensions=None), is_container='list', yang_name="peerAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__peerAF = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAF(self):
    self.__peerAF = YANGDynClass(base=YANGListType("remoteAddress",yc_peerAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF, yang_name="peerAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remoteAddress', extensions=None), is_container='list', yang_name="peerAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  peerAF = __builtin__.property(_get_peerAF, _set_peerAF) # type: yc_peerAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs_peerAF


  _pyangbind_elements = OrderedDict([('peerAF', peerAF), ])


class yc_importRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes_importRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route import. Routes of other protocol types can be imported by BGP. By default, BGP does not import routes of other protocol types.
  """
  __slots__ = ('_path_helper', '_extmethods', '__importProtocol','__importProcessId','__importRoutePolicy','__medNew',)

  _yang_name = 'importRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__importProtocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="importProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommImRouteProtocol', is_config=True)
    self.__importProcessId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="importProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__importRoutePolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRoutePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__medNew = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="medNew", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'importRoutes', 'importRoute']

  def _get_importProtocol(self):
    """
    Getter method for importProtocol, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/importProtocol (bgpcommImRouteProtocol)

    YANG Description: Routing protocol from which routes can be imported. The routing protocol can be IS-IS, OSPF, static, direct, or RIP for an IPv4 unicast address family or an IPv4 multicast address family. The routing protocol can be IS-IS, OSPFv3, static, direct, or RIPng for an IPv6 uincast address family.
    """
    return self.__importProtocol
      
  def _set_importProtocol(self, v, load=False):
    """
    Setter method for importProtocol, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/importProtocol (bgpcommImRouteProtocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importProtocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importProtocol() directly.

    YANG Description: Routing protocol from which routes can be imported. The routing protocol can be IS-IS, OSPF, static, direct, or RIP for an IPv4 unicast address family or an IPv4 multicast address family. The routing protocol can be IS-IS, OSPFv3, static, direct, or RIPng for an IPv6 uincast address family.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="importProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommImRouteProtocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importProtocol must be of a type compatible with bgpcommImRouteProtocol""",
          'defined-type': "huawei-bgp:bgpcommImRouteProtocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="importProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommImRouteProtocol', is_config=True)""",
        })

    self.__importProtocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importProtocol(self):
    self.__importProtocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="importProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommImRouteProtocol', is_config=True)


  def _get_importProcessId(self):
    """
    Getter method for importProcessId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/importProcessId (uint32)

    YANG Description: Process ID of an imported routing protocol. The process ID must be specified if the imported routing protocol is RIP, OSPF, RIPng, or OSPFv3.
    """
    return self.__importProcessId
      
  def _set_importProcessId(self, v, load=False):
    """
    Setter method for importProcessId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/importProcessId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importProcessId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importProcessId() directly.

    YANG Description: Process ID of an imported routing protocol. The process ID must be specified if the imported routing protocol is RIP, OSPF, RIPng, or OSPFv3.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="importProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importProcessId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="importProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__importProcessId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importProcessId(self):
    self.__importProcessId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="importProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_importRoutePolicy(self):
    """
    Getter method for importRoutePolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/importRoutePolicy (string)

    YANG Description: When routes are imported from other routing protocols, the route-policy filter can be used to filter the routes and change route attributes.
    """
    return self.__importRoutePolicy
      
  def _set_importRoutePolicy(self, v, load=False):
    """
    Setter method for importRoutePolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/importRoutePolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importRoutePolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importRoutePolicy() directly.

    YANG Description: When routes are imported from other routing protocols, the route-policy filter can be used to filter the routes and change route attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="importRoutePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importRoutePolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRoutePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__importRoutePolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importRoutePolicy(self):
    self.__importRoutePolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="importRoutePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_medNew(self):
    """
    Getter method for medNew, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/medNew (uint64)

    YANG Description: Specify the MED of imported routes.
    """
    return self.__medNew
      
  def _set_medNew(self, v, load=False):
    """
    Setter method for medNew, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute/medNew (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_medNew is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_medNew() directly.

    YANG Description: Specify the MED of imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="medNew", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """medNew must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="medNew", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint64', is_config=True)""",
        })

    self.__medNew = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_medNew(self):
    self.__medNew = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="medNew", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint64', is_config=True)

  importProtocol = __builtin__.property(_get_importProtocol, _set_importProtocol)
  importProcessId = __builtin__.property(_get_importProcessId, _set_importProcessId)
  importRoutePolicy = __builtin__.property(_get_importRoutePolicy, _set_importRoutePolicy)
  medNew = __builtin__.property(_get_medNew, _set_medNew)


  _pyangbind_elements = OrderedDict([('importProtocol', importProtocol), ('importProcessId', importProcessId), ('importRoutePolicy', importRoutePolicy), ('medNew', medNew), ])


class yc_importRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of imported routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__importRoute',)

  _yang_name = 'importRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__importRoute = YANGDynClass(base=YANGListType("importProtocol importProcessId",yc_importRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes_importRoute, yang_name="importRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='importProtocol importProcessId', extensions=None), is_container='list', yang_name="importRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'importRoutes']

  def _get_importRoute(self):
    """
    Getter method for importRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute (list)

    YANG Description: Route import. Routes of other protocol types can be imported by BGP. By default, BGP does not import routes of other protocol types.
    """
    return self.__importRoute
      
  def _set_importRoute(self, v, load=False):
    """
    Setter method for importRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes/importRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importRoute() directly.

    YANG Description: Route import. Routes of other protocol types can be imported by BGP. By default, BGP does not import routes of other protocol types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("importProtocol importProcessId",yc_importRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes_importRoute, yang_name="importRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='importProtocol importProcessId', extensions=None), is_container='list', yang_name="importRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("importProtocol importProcessId",yc_importRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes_importRoute, yang_name="importRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='importProtocol importProcessId', extensions=None), is_container='list', yang_name="importRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__importRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importRoute(self):
    self.__importRoute = YANGDynClass(base=YANGListType("importProtocol importProcessId",yc_importRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes_importRoute, yang_name="importRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='importProtocol importProcessId', extensions=None), is_container='list', yang_name="importRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  importRoute = __builtin__.property(_get_importRoute, _set_importRoute) # type: yc_importRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes_importRoute


  _pyangbind_elements = OrderedDict([('importRoute', importRoute), ])


class yc_networkRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes_networkRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the local routes that can be advertised by BGP. That is, add the routes in the local routing table to the BGP routing table in static mode and send them to the peer end. By default, BGP does not advertise any local route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__networkAddress','__maskLen','__networkPolicy',)

  _yang_name = 'networkRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__networkAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="networkAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__maskLen = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__networkPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="networkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'networkRoutes', 'networkRoute']

  def _get_networkAddress(self):
    """
    Getter method for networkAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute/networkAddress (inet:ip-address-no-zone)

    YANG Description: Specify the IP address advertised by BGP. An IPv4 address can be configured in the IPv4 address family, in dotted decimal notation, and an IPv6 routes can be configured in the IPv6 address family. Note: During the configuration of a network route, the IP address is adjusted based on the mask. It is recommended that you click Synchronize All after creating a network route.
    """
    return self.__networkAddress
      
  def _set_networkAddress(self, v, load=False):
    """
    Setter method for networkAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute/networkAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networkAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networkAddress() directly.

    YANG Description: Specify the IP address advertised by BGP. An IPv4 address can be configured in the IPv4 address family, in dotted decimal notation, and an IPv6 routes can be configured in the IPv6 address family. Note: During the configuration of a network route, the IP address is adjusted based on the mask. It is recommended that you click Synchronize All after creating a network route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="networkAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networkAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="networkAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__networkAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networkAddress(self):
    self.__networkAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="networkAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_maskLen(self):
    """
    Getter method for maskLen, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute/maskLen (uint8)

    YANG Description: Specify the mask length of an IP address. The mask length ranges from 0 to 32 for an IPv4 address, and ranges from 0 to 128 for an IPv6 address.
    """
    return self.__maskLen
      
  def _set_maskLen(self, v, load=False):
    """
    Setter method for maskLen, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute/maskLen (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maskLen is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maskLen() directly.

    YANG Description: Specify the mask length of an IP address. The mask length ranges from 0 to 32 for an IPv4 address, and ranges from 0 to 128 for an IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maskLen must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__maskLen = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maskLen(self):
    self.__maskLen = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_networkPolicy(self):
    """
    Getter method for networkPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute/networkPolicy (string)

    YANG Description: Specify the route-policy for route advertisement. The value is a string.
    """
    return self.__networkPolicy
      
  def _set_networkPolicy(self, v, load=False):
    """
    Setter method for networkPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute/networkPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networkPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networkPolicy() directly.

    YANG Description: Specify the route-policy for route advertisement. The value is a string.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="networkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networkPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="networkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__networkPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networkPolicy(self):
    self.__networkPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="networkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

  networkAddress = __builtin__.property(_get_networkAddress, _set_networkAddress)
  maskLen = __builtin__.property(_get_maskLen, _set_maskLen)
  networkPolicy = __builtin__.property(_get_networkPolicy, _set_networkPolicy)


  _pyangbind_elements = OrderedDict([('networkAddress', networkAddress), ('maskLen', maskLen), ('networkPolicy', networkPolicy), ])


class yc_networkRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of advertised routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__networkRoute',)

  _yang_name = 'networkRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__networkRoute = YANGDynClass(base=YANGListType("networkAddress maskLen",yc_networkRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes_networkRoute, yang_name="networkRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='networkAddress maskLen', extensions=None), is_container='list', yang_name="networkRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'networkRoutes']

  def _get_networkRoute(self):
    """
    Getter method for networkRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute (list)

    YANG Description: Configure the local routes that can be advertised by BGP. That is, add the routes in the local routing table to the BGP routing table in static mode and send them to the peer end. By default, BGP does not advertise any local route.
    """
    return self.__networkRoute
      
  def _set_networkRoute(self, v, load=False):
    """
    Setter method for networkRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes/networkRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networkRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networkRoute() directly.

    YANG Description: Configure the local routes that can be advertised by BGP. That is, add the routes in the local routing table to the BGP routing table in static mode and send them to the peer end. By default, BGP does not advertise any local route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("networkAddress maskLen",yc_networkRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes_networkRoute, yang_name="networkRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='networkAddress maskLen', extensions=None), is_container='list', yang_name="networkRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networkRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("networkAddress maskLen",yc_networkRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes_networkRoute, yang_name="networkRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='networkAddress maskLen', extensions=None), is_container='list', yang_name="networkRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__networkRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networkRoute(self):
    self.__networkRoute = YANGDynClass(base=YANGListType("networkAddress maskLen",yc_networkRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes_networkRoute, yang_name="networkRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='networkAddress maskLen', extensions=None), is_container='list', yang_name="networkRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  networkRoute = __builtin__.property(_get_networkRoute, _set_networkRoute) # type: yc_networkRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes_networkRoute


  _pyangbind_elements = OrderedDict([('networkRoute', networkRoute), ])


class yc_aggregateRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes_aggregateRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Create a summarized route in the BGP routing table. The local outbound interface of the summarized route is Null0. When another router receives the route, the route adds an outbound interface to the route. By default, route summarization is not performed. If the Origin attributes of the specific routes for the route summarization are different, the Origin attribute of the summarized route is that with the highest priority. Origin attributes are arranged in the priority order of  complete > egp > igp. A summarized route carries the community attribute of each specific route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__aggreAddress','__maskLength','__asSetEnable','__detailSuppressed','__attributePolicy','__originPolicy','__suppressPolicy',)

  _yang_name = 'aggregateRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aggreAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="aggreAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__asSetEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asSetEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__detailSuppressed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="detailSuppressed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__attributePolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attributePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__originPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="originPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__suppressPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="suppressPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'aggregateRoutes', 'aggregateRoute']

  def _get_aggreAddress(self):
    """
    Getter method for aggreAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/aggreAddress (inet:ip-address-no-zone)

    YANG Description: Specify the IPv4 address or IPv6 address of a summarized route. Only IPv4 summarized routes can be configured in the IPv4 address family and only IPv6 summarized routes can be configured in the IPv6 address family.
    """
    return self.__aggreAddress
      
  def _set_aggreAddress(self, v, load=False):
    """
    Setter method for aggreAddress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/aggreAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggreAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggreAddress() directly.

    YANG Description: Specify the IPv4 address or IPv6 address of a summarized route. Only IPv4 summarized routes can be configured in the IPv4 address family and only IPv6 summarized routes can be configured in the IPv6 address family.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="aggreAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggreAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="aggreAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__aggreAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggreAddress(self):
    self.__aggreAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="aggreAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_maskLength(self):
    """
    Getter method for maskLength, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/maskLength (uint8)

    YANG Description: Specify the mask length of a summarized address. The mask length ranges from 0 to 32 for an IPv4 address, and ranges from 0 to 128 for an IPv6 address.
    """
    return self.__maskLength
      
  def _set_maskLength(self, v, load=False):
    """
    Setter method for maskLength, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/maskLength (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maskLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maskLength() directly.

    YANG Description: Specify the mask length of a summarized address. The mask length ranges from 0 to 32 for an IPv4 address, and ranges from 0 to 128 for an IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maskLength must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__maskLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maskLength(self):
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_asSetEnable(self):
    """
    Getter method for asSetEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/asSetEnable (boolean)

    YANG Description: Generate routes with the AS-SET attribute. This option can be used to create a summarized route. The AS_Path attribute of the summarized route contains the AS-Path attributes of the specific routes for the route summarization. Exercise caution when using this option if multiple AS_Paths need to be summarized to prevent route flapping. 
    """
    return self.__asSetEnable
      
  def _set_asSetEnable(self, v, load=False):
    """
    Setter method for asSetEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/asSetEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asSetEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asSetEnable() directly.

    YANG Description: Generate routes with the AS-SET attribute. This option can be used to create a summarized route. The AS_Path attribute of the summarized route contains the AS-Path attributes of the specific routes for the route summarization. Exercise caution when using this option if multiple AS_Paths need to be summarized to prevent route flapping. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asSetEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asSetEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asSetEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__asSetEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asSetEnable(self):
    self.__asSetEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asSetEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_detailSuppressed(self):
    """
    Getter method for detailSuppressed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/detailSuppressed (boolean)

    YANG Description: Suppress the advertisement of specific routes for the route summarization. Only the summarized route is advertised.
    """
    return self.__detailSuppressed
      
  def _set_detailSuppressed(self, v, load=False):
    """
    Setter method for detailSuppressed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/detailSuppressed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detailSuppressed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detailSuppressed() directly.

    YANG Description: Suppress the advertisement of specific routes for the route summarization. Only the summarized route is advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="detailSuppressed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detailSuppressed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="detailSuppressed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__detailSuppressed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detailSuppressed(self):
    self.__detailSuppressed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="detailSuppressed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_attributePolicy(self):
    """
    Getter method for attributePolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/attributePolicy (string)

    YANG Description: Specify an attribute of summarized routes. If apply as-path is used to configure the AS_Path attribute that is used in the route Summarization policy, and the as-set keyword is set, the AS_Path attribute in the policy does not take effect.
    """
    return self.__attributePolicy
      
  def _set_attributePolicy(self, v, load=False):
    """
    Setter method for attributePolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/attributePolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attributePolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attributePolicy() directly.

    YANG Description: Specify an attribute of summarized routes. If apply as-path is used to configure the AS_Path attribute that is used in the route Summarization policy, and the as-set keyword is set, the AS_Path attribute in the policy does not take effect.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attributePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attributePolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attributePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__attributePolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attributePolicy(self):
    self.__attributePolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attributePolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_originPolicy(self):
    """
    Getter method for originPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/originPolicy (string)

    YANG Description: Specify the name of a policy for generating summarized routes. Summarized routes are generated only when the routes match route-policy.
    """
    return self.__originPolicy
      
  def _set_originPolicy(self, v, load=False):
    """
    Setter method for originPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/originPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originPolicy() directly.

    YANG Description: Specify the name of a policy for generating summarized routes. Summarized routes are generated only when the routes match route-policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="originPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="originPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__originPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originPolicy(self):
    self.__originPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="originPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_suppressPolicy(self):
    """
    Getter method for suppressPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/suppressPolicy (string)

    YANG Description: Specify a policy for suppressing the advertisement of specified routes. The routes matching the policy are not advertised, and other routes are advertised.
    """
    return self.__suppressPolicy
      
  def _set_suppressPolicy(self, v, load=False):
    """
    Setter method for suppressPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute/suppressPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppressPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppressPolicy() directly.

    YANG Description: Specify a policy for suppressing the advertisement of specified routes. The routes matching the policy are not advertised, and other routes are advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="suppressPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppressPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="suppressPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__suppressPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppressPolicy(self):
    self.__suppressPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="suppressPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

  aggreAddress = __builtin__.property(_get_aggreAddress, _set_aggreAddress)
  maskLength = __builtin__.property(_get_maskLength, _set_maskLength)
  asSetEnable = __builtin__.property(_get_asSetEnable, _set_asSetEnable)
  detailSuppressed = __builtin__.property(_get_detailSuppressed, _set_detailSuppressed)
  attributePolicy = __builtin__.property(_get_attributePolicy, _set_attributePolicy)
  originPolicy = __builtin__.property(_get_originPolicy, _set_originPolicy)
  suppressPolicy = __builtin__.property(_get_suppressPolicy, _set_suppressPolicy)


  _pyangbind_elements = OrderedDict([('aggreAddress', aggreAddress), ('maskLength', maskLength), ('asSetEnable', asSetEnable), ('detailSuppressed', detailSuppressed), ('attributePolicy', attributePolicy), ('originPolicy', originPolicy), ('suppressPolicy', suppressPolicy), ])


class yc_aggregateRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of summarized routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__aggregateRoute',)

  _yang_name = 'aggregateRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aggregateRoute = YANGDynClass(base=YANGListType("aggreAddress maskLength",yc_aggregateRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes_aggregateRoute, yang_name="aggregateRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='aggreAddress maskLength', extensions=None), is_container='list', yang_name="aggregateRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'aggregateRoutes']

  def _get_aggregateRoute(self):
    """
    Getter method for aggregateRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute (list)

    YANG Description: Create a summarized route in the BGP routing table. The local outbound interface of the summarized route is Null0. When another router receives the route, the route adds an outbound interface to the route. By default, route summarization is not performed. If the Origin attributes of the specific routes for the route summarization are different, the Origin attribute of the summarized route is that with the highest priority. Origin attributes are arranged in the priority order of  complete > egp > igp. A summarized route carries the community attribute of each specific route.
    """
    return self.__aggregateRoute
      
  def _set_aggregateRoute(self, v, load=False):
    """
    Setter method for aggregateRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes/aggregateRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregateRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregateRoute() directly.

    YANG Description: Create a summarized route in the BGP routing table. The local outbound interface of the summarized route is Null0. When another router receives the route, the route adds an outbound interface to the route. By default, route summarization is not performed. If the Origin attributes of the specific routes for the route summarization are different, the Origin attribute of the summarized route is that with the highest priority. Origin attributes are arranged in the priority order of  complete > egp > igp. A summarized route carries the community attribute of each specific route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("aggreAddress maskLength",yc_aggregateRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes_aggregateRoute, yang_name="aggregateRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='aggreAddress maskLength', extensions=None), is_container='list', yang_name="aggregateRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregateRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("aggreAddress maskLength",yc_aggregateRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes_aggregateRoute, yang_name="aggregateRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='aggreAddress maskLength', extensions=None), is_container='list', yang_name="aggregateRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__aggregateRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregateRoute(self):
    self.__aggregateRoute = YANGDynClass(base=YANGListType("aggreAddress maskLength",yc_aggregateRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes_aggregateRoute, yang_name="aggregateRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='aggreAddress maskLength', extensions=None), is_container='list', yang_name="aggregateRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  aggregateRoute = __builtin__.property(_get_aggregateRoute, _set_aggregateRoute) # type: yc_aggregateRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes_aggregateRoute


  _pyangbind_elements = OrderedDict([('aggregateRoute', aggregateRoute), ])


class yc_dampRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes_dampRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable BGP route dampening or modify various BGP route dampening parameters. By default, route dampening is not configured. If a suppression policy for route dampening is configured, routes are preferentially matched against the suppression parameters defined in the suppression policy. If no parameter is configured, the default value of each parameter is used. The four route dampening parameters are mutually dependent. If you configure one of the parameters, the other parameters also need to be configured. When you configure BGP route dampening, the values of reuse threshold, suppress threshold, and penalty ceiling must meet the inequality of reuse threshold < suppress threshold < penalty ceiling. If Maximum suppression time obtained by using the formula of Maximum suppression time = Half life (of reachable routes) x 60 x (ln(Penalty ceiling/Reuse threshold)/ln(2)) is smaller than 1, suppression cannot be performed. Ensure that the value of the maximum suppression time is equal to or greater than 1. This means that the value of the penalty ceiling/reuse threshold must be great enough.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerType','__halfLifeReachTime','__reuse','__suppress','__ceiling','__dampPolicyName','__updateStandard',)

  _yang_name = 'dampRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerType = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="peerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__halfLifeReachTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="halfLifeReachTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__ceiling = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1001..20000']}), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__dampPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dampPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__updateStandard = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="updateStandard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'dampRoutes', 'dampRoute']

  def _get_peerType(self):
    """
    Getter method for peerType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/peerType (uint8)

    YANG Description: Configure the peer type. The value of the penalty ceiling is an integer. The default value is 0(0:EBGP, 1:IBGP).
    """
    return self.__peerType
      
  def _set_peerType(self, v, load=False):
    """
    Setter method for peerType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/peerType (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerType() directly.

    YANG Description: Configure the peer type. The value of the penalty ceiling is an integer. The default value is 0(0:EBGP, 1:IBGP).
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="peerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerType must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="peerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__peerType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerType(self):
    self.__peerType = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="peerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_halfLifeReachTime(self):
    """
    Getter method for halfLifeReachTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/halfLifeReachTime (uint16)

    YANG Description: Configure a half-life for reachable routes. The value is an integer, in minutes. The default value is 15.
    """
    return self.__halfLifeReachTime
      
  def _set_halfLifeReachTime(self, v, load=False):
    """
    Setter method for halfLifeReachTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/halfLifeReachTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_halfLifeReachTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_halfLifeReachTime() directly.

    YANG Description: Configure a half-life for reachable routes. The value is an integer, in minutes. The default value is 15.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="halfLifeReachTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """halfLifeReachTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="halfLifeReachTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__halfLifeReachTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_halfLifeReachTime(self):
    self.__halfLifeReachTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..45']}), is_leaf=True, yang_name="halfLifeReachTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/reuse (uint16)

    YANG Description: Configure a threshold for a route to be unsuppressed. If the penalty value of the route falls below the threshold, the route is reused. The threshold value is an integer. The default value is 750.  
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/reuse (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: Configure a threshold for a route to be unsuppressed. If the penalty value of the route falls below the threshold, the route is reused. The threshold value is an integer. The default value is 750.  
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/suppress (uint16)

    YANG Description: Configure a threshold for a route to be suppressed.  When the penalty value of the route exceeds the suppression threshold, the route is suppressed.  The configured suppression threshold must be greater than the reuse threshold. The value of the suppression threshold is an integer. The default value is 2000.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/suppress (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: Configure a threshold for a route to be suppressed.  When the penalty value of the route exceeds the suppression threshold, the route is suppressed.  The configured suppression threshold must be greater than the reuse threshold. The value of the suppression threshold is an integer. The default value is 2000.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_ceiling(self):
    """
    Getter method for ceiling, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/ceiling (uint16)

    YANG Description: Configure the penalty ceiling. The configured threshold must be greater than the suppression threshold. The value of the penalty ceiling is an integer. The default value is 16000.
    """
    return self.__ceiling
      
  def _set_ceiling(self, v, load=False):
    """
    Setter method for ceiling, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/ceiling (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ceiling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ceiling() directly.

    YANG Description: Configure the penalty ceiling. The configured threshold must be greater than the suppression threshold. The value of the penalty ceiling is an integer. The default value is 16000.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1001..20000']}), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ceiling must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1001..20000']}), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__ceiling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ceiling(self):
    self.__ceiling = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1001..20000']}), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_dampPolicyName(self):
    """
    Getter method for dampPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/dampPolicyName (string)

    YANG Description: Configure a suppression policy for route dampening. You can use a routing policy to select the routes to be suppressed.
    """
    return self.__dampPolicyName
      
  def _set_dampPolicyName(self, v, load=False):
    """
    Setter method for dampPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/dampPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampPolicyName() directly.

    YANG Description: Configure a suppression policy for route dampening. You can use a routing policy to select the routes to be suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dampPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dampPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__dampPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampPolicyName(self):
    self.__dampPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dampPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_updateStandard(self):
    """
    Getter method for updateStandard, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/updateStandard (boolean)

    YANG Description: Update Standard.
    """
    return self.__updateStandard
      
  def _set_updateStandard(self, v, load=False):
    """
    Setter method for updateStandard, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute/updateStandard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updateStandard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updateStandard() directly.

    YANG Description: Update Standard.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="updateStandard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updateStandard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="updateStandard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__updateStandard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updateStandard(self):
    self.__updateStandard = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="updateStandard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  peerType = __builtin__.property(_get_peerType, _set_peerType)
  halfLifeReachTime = __builtin__.property(_get_halfLifeReachTime, _set_halfLifeReachTime)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  suppress = __builtin__.property(_get_suppress, _set_suppress)
  ceiling = __builtin__.property(_get_ceiling, _set_ceiling)
  dampPolicyName = __builtin__.property(_get_dampPolicyName, _set_dampPolicyName)
  updateStandard = __builtin__.property(_get_updateStandard, _set_updateStandard)


  _pyangbind_elements = OrderedDict([('peerType', peerType), ('halfLifeReachTime', halfLifeReachTime), ('reuse', reuse), ('suppress', suppress), ('ceiling', ceiling), ('dampPolicyName', dampPolicyName), ('updateStandard', updateStandard), ])


class yc_dampRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of route dampening.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dampRoute',)

  _yang_name = 'dampRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dampRoute = YANGDynClass(base=YANGListType("peerType halfLifeReachTime reuse suppress ceiling",yc_dampRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes_dampRoute, yang_name="dampRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerType halfLifeReachTime reuse suppress ceiling', extensions=None), is_container='list', yang_name="dampRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'dampRoutes']

  def _get_dampRoute(self):
    """
    Getter method for dampRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute (list)

    YANG Description: Enable BGP route dampening or modify various BGP route dampening parameters. By default, route dampening is not configured. If a suppression policy for route dampening is configured, routes are preferentially matched against the suppression parameters defined in the suppression policy. If no parameter is configured, the default value of each parameter is used. The four route dampening parameters are mutually dependent. If you configure one of the parameters, the other parameters also need to be configured. When you configure BGP route dampening, the values of reuse threshold, suppress threshold, and penalty ceiling must meet the inequality of reuse threshold < suppress threshold < penalty ceiling. If Maximum suppression time obtained by using the formula of Maximum suppression time = Half life (of reachable routes) x 60 x (ln(Penalty ceiling/Reuse threshold)/ln(2)) is smaller than 1, suppression cannot be performed. Ensure that the value of the maximum suppression time is equal to or greater than 1. This means that the value of the penalty ceiling/reuse threshold must be great enough.
    """
    return self.__dampRoute
      
  def _set_dampRoute(self, v, load=False):
    """
    Setter method for dampRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes/dampRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampRoute() directly.

    YANG Description: Enable BGP route dampening or modify various BGP route dampening parameters. By default, route dampening is not configured. If a suppression policy for route dampening is configured, routes are preferentially matched against the suppression parameters defined in the suppression policy. If no parameter is configured, the default value of each parameter is used. The four route dampening parameters are mutually dependent. If you configure one of the parameters, the other parameters also need to be configured. When you configure BGP route dampening, the values of reuse threshold, suppress threshold, and penalty ceiling must meet the inequality of reuse threshold < suppress threshold < penalty ceiling. If Maximum suppression time obtained by using the formula of Maximum suppression time = Half life (of reachable routes) x 60 x (ln(Penalty ceiling/Reuse threshold)/ln(2)) is smaller than 1, suppression cannot be performed. Ensure that the value of the maximum suppression time is equal to or greater than 1. This means that the value of the penalty ceiling/reuse threshold must be great enough.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerType halfLifeReachTime reuse suppress ceiling",yc_dampRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes_dampRoute, yang_name="dampRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerType halfLifeReachTime reuse suppress ceiling', extensions=None), is_container='list', yang_name="dampRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerType halfLifeReachTime reuse suppress ceiling",yc_dampRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes_dampRoute, yang_name="dampRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerType halfLifeReachTime reuse suppress ceiling', extensions=None), is_container='list', yang_name="dampRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__dampRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampRoute(self):
    self.__dampRoute = YANGDynClass(base=YANGListType("peerType halfLifeReachTime reuse suppress ceiling",yc_dampRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes_dampRoute, yang_name="dampRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerType halfLifeReachTime reuse suppress ceiling', extensions=None), is_container='list', yang_name="dampRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  dampRoute = __builtin__.property(_get_dampRoute, _set_dampRoute) # type: yc_dampRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes_dampRoute


  _pyangbind_elements = OrderedDict([('dampRoute', dampRoute), ])


class yc_filterPolicy_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys_filterPolicy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specify a filtering policy. It is used to filter the routes received from a peer and the routes to be advertised to the peer. By default, routes are not filtered.
  """
  __slots__ = ('_path_helper', '_extmethods', '__filterProtocol','__filterProcessId','__import_','__export','__aclNameOrNum','__preFlt4Name',)

  _yang_name = 'filterPolicy'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__filterProtocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noprotocol': {}, 'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="filterProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommFilterProtocol', is_config=True)
    self.__filterProcessId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="filterProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__import_ = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__export = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__aclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__preFlt4Name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preFlt4Name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'filterPolicys', 'filterPolicy']

  def _get_filterProtocol(self):
    """
    Getter method for filterProtocol, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/filterProtocol (bgpcommFilterProtocol)

    YANG Description: Specify the name of a routing protocol. The routing protocol takes effect only on the routes to be advertised. The IPv4 address family supports the direct, IS-IS, OSPF, RIP, and static routing protocols. The IPv6 unicast address family of a public network instance supports the direct, IS-IS, OSPFv3, RIPng, and static routing protocols. The IPv6 address family of a VPNv6 instance supports the direct, IS-IS, RIPng, and static routing protocols.
    """
    return self.__filterProtocol
      
  def _set_filterProtocol(self, v, load=False):
    """
    Setter method for filterProtocol, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/filterProtocol (bgpcommFilterProtocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filterProtocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filterProtocol() directly.

    YANG Description: Specify the name of a routing protocol. The routing protocol takes effect only on the routes to be advertised. The IPv4 address family supports the direct, IS-IS, OSPF, RIP, and static routing protocols. The IPv6 unicast address family of a public network instance supports the direct, IS-IS, OSPFv3, RIPng, and static routing protocols. The IPv6 address family of a VPNv6 instance supports the direct, IS-IS, RIPng, and static routing protocols.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noprotocol': {}, 'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="filterProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommFilterProtocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filterProtocol must be of a type compatible with bgpcommFilterProtocol""",
          'defined-type': "huawei-bgp:bgpcommFilterProtocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noprotocol': {}, 'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="filterProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommFilterProtocol', is_config=True)""",
        })

    self.__filterProtocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filterProtocol(self):
    self.__filterProtocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'noprotocol': {}, 'direct': {}, 'ospf': {}, 'isis': {}, 'static': {}, 'rip': {}, 'ospfv3': {}, 'ripng': {}, 'unr': {}, 'op-route': {}},), is_leaf=True, yang_name="filterProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommFilterProtocol', is_config=True)


  def _get_filterProcessId(self):
    """
    Getter method for filterProcessId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/filterProcessId (uint32)

    YANG Description: Specify the process ID required to be matched. The value is an integer ranging from 1 to 65535. If direct or static routes need to be filtered, no process ID is required.
    """
    return self.__filterProcessId
      
  def _set_filterProcessId(self, v, load=False):
    """
    Setter method for filterProcessId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/filterProcessId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filterProcessId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filterProcessId() directly.

    YANG Description: Specify the process ID required to be matched. The value is an integer ranging from 1 to 65535. If direct or static routes need to be filtered, no process ID is required.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="filterProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filterProcessId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="filterProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__filterProcessId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filterProcessId(self):
    self.__filterProcessId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="filterProcessId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_import_(self):
    """
    Getter method for import_, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/import (boolean)

    YANG Description: Filter received routes. Only the routes that match the policy can be added to the BGP routing table. When a rule is configured for a named ACL, only the source address range specified by the source parameter and the time period specified by the time-range parameter take effect.
    """
    return self.__import_
      
  def _set_import_(self, v, load=False):
    """
    Setter method for import_, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/import (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_() directly.

    YANG Description: Filter received routes. Only the routes that match the policy can be added to the BGP routing table. When a rule is configured for a named ACL, only the source address range specified by the source parameter and the time period specified by the time-range parameter take effect.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_ must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__import_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_(self):
    self.__import_ = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_export(self):
    """
    Getter method for export, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/export (boolean)

    YANG Description: Filter routes to be advertised. Only the routes that match the policy can be advertised by BGP. After the filtering function is configured, routes are filtered before being imported by BGP. Only the routes that match the policy can be added to the local BGP routing table and advertised by BGP. If a routing protocol is specified, only the routes of this protocol are filtered, and the routes of other protocols are not filtered. If no routing protocol is specified, all protocol routes are filtered. When a rule is configured for a named ACL, only the source address range specified by the source parameter and the time period specified by the time-range parameter take effect.
    """
    return self.__export
      
  def _set_export(self, v, load=False):
    """
    Setter method for export, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/export (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export() directly.

    YANG Description: Filter routes to be advertised. Only the routes that match the policy can be advertised by BGP. After the filtering function is configured, routes are filtered before being imported by BGP. Only the routes that match the policy can be added to the local BGP routing table and advertised by BGP. If a routing protocol is specified, only the routes of this protocol are filtered, and the routes of other protocols are not filtered. If no routing protocol is specified, all protocol routes are filtered. When a rule is configured for a named ACL, only the source address range specified by the source parameter and the time period specified by the time-range parameter take effect.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__export = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export(self):
    self.__export = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_aclNameOrNum(self):
    """
    Getter method for aclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/aclNameOrNum (string)

    YANG Description: Specify the name or number of an ACL Rule. The number value ranges from 2000 to 2999 and is used by basic ACL rules. The name must start with a letter, and the name is case-sensitive.
    """
    return self.__aclNameOrNum
      
  def _set_aclNameOrNum(self, v, load=False):
    """
    Setter method for aclNameOrNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/aclNameOrNum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aclNameOrNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aclNameOrNum() directly.

    YANG Description: Specify the name or number of an ACL Rule. The number value ranges from 2000 to 2999 and is used by basic ACL rules. The name must start with a letter, and the name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aclNameOrNum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__aclNameOrNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aclNameOrNum(self):
    self.__aclNameOrNum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNameOrNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_preFlt4Name(self):
    """
    Getter method for preFlt4Name, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/preFlt4Name (string)

    YANG Description: Specify the IPv4 prefix list name.
    """
    return self.__preFlt4Name
      
  def _set_preFlt4Name(self, v, load=False):
    """
    Setter method for preFlt4Name, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy/preFlt4Name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preFlt4Name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preFlt4Name() directly.

    YANG Description: Specify the IPv4 prefix list name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="preFlt4Name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preFlt4Name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preFlt4Name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__preFlt4Name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preFlt4Name(self):
    self.__preFlt4Name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preFlt4Name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

  filterProtocol = __builtin__.property(_get_filterProtocol, _set_filterProtocol)
  filterProcessId = __builtin__.property(_get_filterProcessId, _set_filterProcessId)
  import_ = __builtin__.property(_get_import_, _set_import_)
  export = __builtin__.property(_get_export, _set_export)
  aclNameOrNum = __builtin__.property(_get_aclNameOrNum, _set_aclNameOrNum)
  preFlt4Name = __builtin__.property(_get_preFlt4Name, _set_preFlt4Name)


  _pyangbind_elements = OrderedDict([('filterProtocol', filterProtocol), ('filterProcessId', filterProcessId), ('import_', import_), ('export', export), ('aclNameOrNum', aclNameOrNum), ('preFlt4Name', preFlt4Name), ])


class yc_filterPolicys_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of filtering policies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__filterPolicy',)

  _yang_name = 'filterPolicys'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__filterPolicy = YANGDynClass(base=YANGListType("filterProtocol filterProcessId import export",yc_filterPolicy_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys_filterPolicy, yang_name="filterPolicy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterProtocol filterProcessId import export', extensions=None), is_container='list', yang_name="filterPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'filterPolicys']

  def _get_filterPolicy(self):
    """
    Getter method for filterPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy (list)

    YANG Description: Specify a filtering policy. It is used to filter the routes received from a peer and the routes to be advertised to the peer. By default, routes are not filtered.
    """
    return self.__filterPolicy
      
  def _set_filterPolicy(self, v, load=False):
    """
    Setter method for filterPolicy, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys/filterPolicy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filterPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filterPolicy() directly.

    YANG Description: Specify a filtering policy. It is used to filter the routes received from a peer and the routes to be advertised to the peer. By default, routes are not filtered.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("filterProtocol filterProcessId import export",yc_filterPolicy_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys_filterPolicy, yang_name="filterPolicy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterProtocol filterProcessId import export', extensions=None), is_container='list', yang_name="filterPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filterPolicy must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("filterProtocol filterProcessId import export",yc_filterPolicy_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys_filterPolicy, yang_name="filterPolicy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterProtocol filterProcessId import export', extensions=None), is_container='list', yang_name="filterPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__filterPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filterPolicy(self):
    self.__filterPolicy = YANGDynClass(base=YANGListType("filterProtocol filterProcessId import export",yc_filterPolicy_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys_filterPolicy, yang_name="filterPolicy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterProtocol filterProcessId import export', extensions=None), is_container='list', yang_name="filterPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  filterPolicy = __builtin__.property(_get_filterPolicy, _set_filterPolicy) # type: yc_filterPolicy_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys_filterPolicy


  _pyangbind_elements = OrderedDict([('filterPolicy', filterPolicy), ])


class yc_instanceImport_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports_instanceImport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Instance Imported Route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srcVrfName','__policyName','__validRtEnable',)

  _yang_name = 'instanceImport'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srcVrfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="srcVrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__policyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__validRtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="validRtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'instanceImports', 'instanceImport']

  def _get_srcVrfName(self):
    """
    Getter method for srcVrfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport/srcVrfName (string)

    YANG Description: Source VRF Name For Instance Imported Route.
    """
    return self.__srcVrfName
      
  def _set_srcVrfName(self, v, load=False):
    """
    Setter method for srcVrfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport/srcVrfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcVrfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcVrfName() directly.

    YANG Description: Source VRF Name For Instance Imported Route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="srcVrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcVrfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="srcVrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__srcVrfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcVrfName(self):
    self.__srcVrfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="srcVrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_policyName(self):
    """
    Getter method for policyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport/policyName (string)

    YANG Description: Policy for Route Import.
    """
    return self.__policyName
      
  def _set_policyName(self, v, load=False):
    """
    Setter method for policyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport/policyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyName() directly.

    YANG Description: Policy for Route Import.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="policyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__policyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyName(self):
    self.__policyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_validRtEnable(self):
    """
    Getter method for validRtEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport/validRtEnable (boolean)

    YANG Description: Imported Valid Route.
    """
    return self.__validRtEnable
      
  def _set_validRtEnable(self, v, load=False):
    """
    Setter method for validRtEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport/validRtEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_validRtEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_validRtEnable() directly.

    YANG Description: Imported Valid Route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="validRtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """validRtEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="validRtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__validRtEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_validRtEnable(self):
    self.__validRtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="validRtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  srcVrfName = __builtin__.property(_get_srcVrfName, _set_srcVrfName)
  policyName = __builtin__.property(_get_policyName, _set_policyName)
  validRtEnable = __builtin__.property(_get_validRtEnable, _set_validRtEnable)


  _pyangbind_elements = OrderedDict([('srcVrfName', srcVrfName), ('policyName', policyName), ('validRtEnable', validRtEnable), ])


class yc_instanceImports_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Instance Imported Routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instanceImport',)

  _yang_name = 'instanceImports'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instanceImport = YANGDynClass(base=YANGListType("srcVrfName",yc_instanceImport_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports_instanceImport, yang_name="instanceImport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srcVrfName', extensions=None), is_container='list', yang_name="instanceImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'instanceImports']

  def _get_instanceImport(self):
    """
    Getter method for instanceImport, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport (list)

    YANG Description: Instance Imported Route.
    """
    return self.__instanceImport
      
  def _set_instanceImport(self, v, load=False):
    """
    Setter method for instanceImport, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports/instanceImport (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instanceImport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instanceImport() directly.

    YANG Description: Instance Imported Route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srcVrfName",yc_instanceImport_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports_instanceImport, yang_name="instanceImport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srcVrfName', extensions=None), is_container='list', yang_name="instanceImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instanceImport must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srcVrfName",yc_instanceImport_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports_instanceImport, yang_name="instanceImport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srcVrfName', extensions=None), is_container='list', yang_name="instanceImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__instanceImport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instanceImport(self):
    self.__instanceImport = YANGDynClass(base=YANGListType("srcVrfName",yc_instanceImport_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports_instanceImport, yang_name="instanceImport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srcVrfName', extensions=None), is_container='list', yang_name="instanceImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  instanceImport = __builtin__.property(_get_instanceImport, _set_instanceImport) # type: yc_instanceImport_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports_instanceImport


  _pyangbind_elements = OrderedDict([('instanceImport', instanceImport), ])


class yc_bgpAdvRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes_bgpAdvRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Advertise Route Protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__importMultipath','__advRouteMode',)

  _yang_name = 'bgpAdvRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteProtocol', is_config=True)
    self.__importMultipath = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="importMultipath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__advRouteMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}, 'best': {}, 'valid': {}},), default=six.text_type("all"), is_leaf=True, yang_name="advRouteMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteToEvrfMode', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'bgpAdvRoutes', 'bgpAdvRoute']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute/protocol (bgpcommAdvRouteProtocol)

    YANG Description: Route Protocol.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute/protocol (bgpcommAdvRouteProtocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Route Protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteProtocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with bgpcommAdvRouteProtocol""",
          'defined-type': "huawei-bgp:bgpcommAdvRouteProtocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteProtocol', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteProtocol', is_config=True)


  def _get_importMultipath(self):
    """
    Getter method for importMultipath, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute/importMultipath (boolean)

    YANG Description: Import Route Multipath.
    """
    return self.__importMultipath
      
  def _set_importMultipath(self, v, load=False):
    """
    Setter method for importMultipath, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute/importMultipath (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importMultipath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importMultipath() directly.

    YANG Description: Import Route Multipath.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="importMultipath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importMultipath must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="importMultipath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__importMultipath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importMultipath(self):
    self.__importMultipath = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="importMultipath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_advRouteMode(self):
    """
    Getter method for advRouteMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute/advRouteMode (bgpcommAdvRouteToEvrfMode)

    YANG Description: Vpn advertise route mode to evrf.
    """
    return self.__advRouteMode
      
  def _set_advRouteMode(self, v, load=False):
    """
    Setter method for advRouteMode, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute/advRouteMode (bgpcommAdvRouteToEvrfMode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advRouteMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advRouteMode() directly.

    YANG Description: Vpn advertise route mode to evrf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}, 'best': {}, 'valid': {}},), default=six.text_type("all"), is_leaf=True, yang_name="advRouteMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteToEvrfMode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advRouteMode must be of a type compatible with bgpcommAdvRouteToEvrfMode""",
          'defined-type': "huawei-bgp:bgpcommAdvRouteToEvrfMode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}, 'best': {}, 'valid': {}},), default=six.text_type("all"), is_leaf=True, yang_name="advRouteMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteToEvrfMode', is_config=True)""",
        })

    self.__advRouteMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advRouteMode(self):
    self.__advRouteMode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'all': {}, 'best': {}, 'valid': {}},), default=six.text_type("all"), is_leaf=True, yang_name="advRouteMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommAdvRouteToEvrfMode', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  importMultipath = __builtin__.property(_get_importMultipath, _set_importMultipath)
  advRouteMode = __builtin__.property(_get_advRouteMode, _set_advRouteMode)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ('importMultipath', importMultipath), ('advRouteMode', advRouteMode), ])


class yc_bgpAdvRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Advertise Route Protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpAdvRoute',)

  _yang_name = 'bgpAdvRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpAdvRoute = YANGDynClass(base=YANGListType("protocol",yc_bgpAdvRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes_bgpAdvRoute, yang_name="bgpAdvRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol', extensions=None), is_container='list', yang_name="bgpAdvRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF', 'bgpAdvRoutes']

  def _get_bgpAdvRoute(self):
    """
    Getter method for bgpAdvRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute (list)

    YANG Description: Advertise Route Protocol.
    """
    return self.__bgpAdvRoute
      
  def _set_bgpAdvRoute(self, v, load=False):
    """
    Setter method for bgpAdvRoute, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes/bgpAdvRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpAdvRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpAdvRoute() directly.

    YANG Description: Advertise Route Protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("protocol",yc_bgpAdvRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes_bgpAdvRoute, yang_name="bgpAdvRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol', extensions=None), is_container='list', yang_name="bgpAdvRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpAdvRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("protocol",yc_bgpAdvRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes_bgpAdvRoute, yang_name="bgpAdvRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol', extensions=None), is_container='list', yang_name="bgpAdvRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpAdvRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpAdvRoute(self):
    self.__bgpAdvRoute = YANGDynClass(base=YANGListType("protocol",yc_bgpAdvRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes_bgpAdvRoute, yang_name="bgpAdvRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol', extensions=None), is_container='list', yang_name="bgpAdvRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpAdvRoute = __builtin__.property(_get_bgpAdvRoute, _set_bgpAdvRoute) # type: yc_bgpAdvRoute_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes_bgpAdvRoute


  _pyangbind_elements = OrderedDict([('bgpAdvRoute', bgpAdvRoute), ])


class yc_bgpMultiVrfAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP address family instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afType','__nexthopDelayTime','__noCriticalNexthopDelayTime','__vrfAsNum','__maxLoadIbgpNum','__ibgpEcmpNexthopChanged','__maxLoadEbgpNum','__ebgpEcmpNexthopChanged','__maximumLoadBalance','__ecmpNexthopChanged','__eibgpLoadBalan','__eibgpEcmpNexthopChanged','__defaultLocalPref','__defaultMed','__defaultRtImportEnable','__loadBalancingAsPathRelax','__routerId','__vrfRidAutoSel','__nexthopThirdParty','__summaryAutomatic','__autoFrrEnable','__loadBalancingAsPathIgnore','__ribOnlyEnable','__ribOnlyPolicyName','__activeRouteAdvertise','__asPathNeglect','__medNoneAsMaximum','__routerIdNeglect','__igpMetricIgnore','__alwaysCompareMed','__determinMed','__preferenceExternal','__preferenceInternal','__preferenceLocal','__prefrencePolicyName','__reflectBetweenClient','__reflectorClusterId','__reflectorClusterIpv4','__rrFilterNumber','__policyVpnTarget','__nextHopSelDependType','__nhpRelayRoutePolicyName','__ebgpIfSensitive','__ibgpIfSensitive','__reflectChgPath','__slowPeerDet','__slowPeerThVal','__addPathSelNum','__routeSelDelay','__originAsValidEnable','__originAsValid','__allowInvalidAs','__policyExtCommEnable','__policyQPPBEnable','__supernetUniAdv','__supernetLabelAdv','__ingressLspPolicyName','__originatorPrior','__lowestPriority','__relayDelayEnable','__irbAsymmetric','__peerGroupAFs','__peerAFs','__importRoutes','__networkRoutes','__aggregateRoutes','__dampRoutes','__filterPolicys','__instanceImports','__bgpAdvRoutes',)

  _yang_name = 'bgpMultiVrfAF'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'evpn': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommPrefixType', is_config=True)
    self.__nexthopDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="nexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__noCriticalNexthopDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="noCriticalNexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__vrfAsNum = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="vrfAsNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    self.__maxLoadIbgpNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadIbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__ibgpEcmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__maxLoadEbgpNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadEbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__ebgpEcmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ebgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__maximumLoadBalance = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maximumLoadBalance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__ecmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ecmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__eibgpLoadBalan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="eibgpLoadBalan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__eibgpEcmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__defaultLocalPref = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="defaultLocalPref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__defaultMed = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="defaultMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__defaultRtImportEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtImportEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__loadBalancingAsPathRelax = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathRelax", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routerId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__vrfRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__nexthopThirdParty = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nexthopThirdParty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__summaryAutomatic = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summaryAutomatic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__autoFrrEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__loadBalancingAsPathIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__ribOnlyEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ribOnlyEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__ribOnlyPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ribOnlyPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__activeRouteAdvertise = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="activeRouteAdvertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__asPathNeglect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asPathNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__medNoneAsMaximum = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="medNoneAsMaximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routerIdNeglect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="routerIdNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__igpMetricIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="igpMetricIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__alwaysCompareMed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="alwaysCompareMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__determinMed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="determinMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__preferenceExternal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__preferenceInternal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceInternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__preferenceLocal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__prefrencePolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefrencePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__reflectBetweenClient = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="reflectBetweenClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__reflectorClusterId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="reflectorClusterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__reflectorClusterIpv4 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="reflectorClusterIpv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__rrFilterNumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rrFilterNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__policyVpnTarget = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policyVpnTarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__nextHopSelDependType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'dependTunnel': {}, 'dependIp': {}},), is_leaf=True, yang_name="nextHopSelDependType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSelDependType', is_config=True)
    self.__nhpRelayRoutePolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nhpRelayRoutePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__ebgpIfSensitive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ebgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__ibgpIfSensitive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__reflectChgPath = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectChgPath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__slowPeerDet = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="slowPeerDet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__slowPeerThVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['120..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(300), is_leaf=True, yang_name="slowPeerThVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__addPathSelNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="addPathSelNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__routeSelDelay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="routeSelDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__originAsValidEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValidEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__originAsValid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__allowInvalidAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowInvalidAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__policyExtCommEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyExtCommEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__policyQPPBEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyQPPBEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__supernetUniAdv = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="supernetUniAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__supernetLabelAdv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supernetLabelAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__ingressLspPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingressLspPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__originatorPrior = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originatorPrior", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__lowestPriority = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__relayDelayEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="relayDelayEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__irbAsymmetric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="irbAsymmetric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__peerGroupAFs = YANGDynClass(base=yc_peerGroupAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs, is_container='container', yang_name="peerGroupAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peerAFs = YANGDynClass(base=yc_peerAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs, is_container='container', yang_name="peerAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__importRoutes = YANGDynClass(base=yc_importRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes, is_container='container', yang_name="importRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__networkRoutes = YANGDynClass(base=yc_networkRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes, is_container='container', yang_name="networkRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__aggregateRoutes = YANGDynClass(base=yc_aggregateRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes, is_container='container', yang_name="aggregateRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__dampRoutes = YANGDynClass(base=yc_dampRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes, is_container='container', yang_name="dampRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__filterPolicys = YANGDynClass(base=yc_filterPolicys_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys, is_container='container', yang_name="filterPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__instanceImports = YANGDynClass(base=yc_instanceImports_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports, is_container='container', yang_name="instanceImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpAdvRoutes = YANGDynClass(base=yc_bgpAdvRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes, is_container='container', yang_name="bgpAdvRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs', 'bgpMultiVrfAF']

  def _get_afType(self):
    """
    Getter method for afType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/afType (bgpmultiinstcommPrefixType)

    YANG Description: Address family type of a BGP instance. 
    """
    return self.__afType
      
  def _set_afType(self, v, load=False):
    """
    Setter method for afType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/afType (bgpmultiinstcommPrefixType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afType() directly.

    YANG Description: Address family type of a BGP instance. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'evpn': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommPrefixType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afType must be of a type compatible with bgpmultiinstcommPrefixType""",
          'defined-type': "huawei-bgp:bgpmultiinstcommPrefixType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'evpn': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommPrefixType', is_config=True)""",
        })

    self.__afType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afType(self):
    self.__afType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'evpn': {}},), is_leaf=True, yang_name="afType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommPrefixType', is_config=True)


  def _get_nexthopDelayTime(self):
    """
    Getter method for nexthopDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nexthopDelayTime (uint32)

    YANG Description: Configure the delay-time of nexthop.
    """
    return self.__nexthopDelayTime
      
  def _set_nexthopDelayTime(self, v, load=False):
    """
    Setter method for nexthopDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nexthopDelayTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthopDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthopDelayTime() directly.

    YANG Description: Configure the delay-time of nexthop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="nexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthopDelayTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="nexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__nexthopDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthopDelayTime(self):
    self.__nexthopDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="nexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_noCriticalNexthopDelayTime(self):
    """
    Getter method for noCriticalNexthopDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/noCriticalNexthopDelayTime (uint32)

    YANG Description: Configure the no-critical delay-time of nexthop.
    """
    return self.__noCriticalNexthopDelayTime
      
  def _set_noCriticalNexthopDelayTime(self, v, load=False):
    """
    Setter method for noCriticalNexthopDelayTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/noCriticalNexthopDelayTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_noCriticalNexthopDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_noCriticalNexthopDelayTime() directly.

    YANG Description: Configure the no-critical delay-time of nexthop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="noCriticalNexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """noCriticalNexthopDelayTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="noCriticalNexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__noCriticalNexthopDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_noCriticalNexthopDelayTime(self):
    self.__noCriticalNexthopDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), is_leaf=True, yang_name="noCriticalNexthopDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_vrfAsNum(self):
    """
    Getter method for vrfAsNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/vrfAsNum (asNumberValidate)

    YANG Description: Specify the unique AS number for the vpn instance
    """
    return self.__vrfAsNum
      
  def _set_vrfAsNum(self, v, load=False):
    """
    Setter method for vrfAsNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/vrfAsNum (asNumberValidate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfAsNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfAsNum() directly.

    YANG Description: Specify the unique AS number for the vpn instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="vrfAsNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfAsNum must be of a type compatible with asNumberValidate""",
          'defined-type': "huawei-bgp:asNumberValidate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="vrfAsNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)""",
        })

    self.__vrfAsNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfAsNum(self):
    self.__vrfAsNum = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="vrfAsNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='asNumberValidate', is_config=True)


  def _get_maxLoadIbgpNum(self):
    """
    Getter method for maxLoadIbgpNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/maxLoadIbgpNum (uint16)

    YANG Description: Specify the maximum number of equal-cost IBGP routes. By default, the value is 1. 
    """
    return self.__maxLoadIbgpNum
      
  def _set_maxLoadIbgpNum(self, v, load=False):
    """
    Setter method for maxLoadIbgpNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/maxLoadIbgpNum (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxLoadIbgpNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxLoadIbgpNum() directly.

    YANG Description: Specify the maximum number of equal-cost IBGP routes. By default, the value is 1. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadIbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxLoadIbgpNum must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadIbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__maxLoadIbgpNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxLoadIbgpNum(self):
    self.__maxLoadIbgpNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadIbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_ibgpEcmpNexthopChanged(self):
    """
    Getter method for ibgpEcmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ibgpEcmpNexthopChanged (boolean)

    YANG Description: When equal-cost IBGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. This function can be enabled only when the maximum number of equal-cost IBGP routes is greater than 1.
    """
    return self.__ibgpEcmpNexthopChanged
      
  def _set_ibgpEcmpNexthopChanged(self, v, load=False):
    """
    Setter method for ibgpEcmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ibgpEcmpNexthopChanged (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ibgpEcmpNexthopChanged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ibgpEcmpNexthopChanged() directly.

    YANG Description: When equal-cost IBGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. This function can be enabled only when the maximum number of equal-cost IBGP routes is greater than 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ibgpEcmpNexthopChanged must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ibgpEcmpNexthopChanged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ibgpEcmpNexthopChanged(self):
    self.__ibgpEcmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_maxLoadEbgpNum(self):
    """
    Getter method for maxLoadEbgpNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/maxLoadEbgpNum (uint16)

    YANG Description: Specify the maximum number of equal-cost EBGP routes. By default, the value is 1.
    """
    return self.__maxLoadEbgpNum
      
  def _set_maxLoadEbgpNum(self, v, load=False):
    """
    Setter method for maxLoadEbgpNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/maxLoadEbgpNum (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxLoadEbgpNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxLoadEbgpNum() directly.

    YANG Description: Specify the maximum number of equal-cost EBGP routes. By default, the value is 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadEbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxLoadEbgpNum must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadEbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__maxLoadEbgpNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxLoadEbgpNum(self):
    self.__maxLoadEbgpNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maxLoadEbgpNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_ebgpEcmpNexthopChanged(self):
    """
    Getter method for ebgpEcmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ebgpEcmpNexthopChanged (boolean)

    YANG Description: When equal-cost EBGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. This function can be enabled only when the maximum number of equal-cost EBGP routes is greater than 1.
    """
    return self.__ebgpEcmpNexthopChanged
      
  def _set_ebgpEcmpNexthopChanged(self, v, load=False):
    """
    Setter method for ebgpEcmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ebgpEcmpNexthopChanged (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgpEcmpNexthopChanged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgpEcmpNexthopChanged() directly.

    YANG Description: When equal-cost EBGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. This function can be enabled only when the maximum number of equal-cost EBGP routes is greater than 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ebgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgpEcmpNexthopChanged must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ebgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ebgpEcmpNexthopChanged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgpEcmpNexthopChanged(self):
    self.__ebgpEcmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ebgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_maximumLoadBalance(self):
    """
    Getter method for maximumLoadBalance, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/maximumLoadBalance (uint16)

    YANG Description: Specify the maximum number of equal-cost routes in the BGP routing table. The value can be 1 or an integer greater than 1. The value depends on the associated license. By default, the maximum number of equal-cost routes is 1. Equal-cost BGP routes can be generated for load balancing only when the BGP routes meet the first nine rules of the route-selection policy and have the same AS-Path attribute.
    """
    return self.__maximumLoadBalance
      
  def _set_maximumLoadBalance(self, v, load=False):
    """
    Setter method for maximumLoadBalance, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/maximumLoadBalance (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximumLoadBalance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximumLoadBalance() directly.

    YANG Description: Specify the maximum number of equal-cost routes in the BGP routing table. The value can be 1 or an integer greater than 1. The value depends on the associated license. By default, the maximum number of equal-cost routes is 1. Equal-cost BGP routes can be generated for load balancing only when the BGP routes meet the first nine rules of the route-selection policy and have the same AS-Path attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maximumLoadBalance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximumLoadBalance must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maximumLoadBalance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__maximumLoadBalance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximumLoadBalance(self):
    self.__maximumLoadBalance = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="maximumLoadBalance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_ecmpNexthopChanged(self):
    """
    Getter method for ecmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ecmpNexthopChanged (boolean)

    YANG Description: When equal-cost BGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. This function can be enabled only when the maximum number of equal-cost BGP routes is greater than 1.
    """
    return self.__ecmpNexthopChanged
      
  def _set_ecmpNexthopChanged(self, v, load=False):
    """
    Setter method for ecmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ecmpNexthopChanged (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecmpNexthopChanged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecmpNexthopChanged() directly.

    YANG Description: When equal-cost BGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. This function can be enabled only when the maximum number of equal-cost BGP routes is greater than 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ecmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecmpNexthopChanged must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ecmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ecmpNexthopChanged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecmpNexthopChanged(self):
    self.__ecmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ecmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_eibgpLoadBalan(self):
    """
    Getter method for eibgpLoadBalan, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/eibgpLoadBalan (uint16)

    YANG Description: Specify the maximum number of equal-cost EBGP routes and IBGP routes. After the attribute is set, load balancing is performed among equal-cost BGP VPN routes, regardless of the route type, EBGP or IBGP. By default, the maximum number of equal-cost EBGP routes and IBGP routes is 0.
    """
    return self.__eibgpLoadBalan
      
  def _set_eibgpLoadBalan(self, v, load=False):
    """
    Setter method for eibgpLoadBalan, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/eibgpLoadBalan (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eibgpLoadBalan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eibgpLoadBalan() directly.

    YANG Description: Specify the maximum number of equal-cost EBGP routes and IBGP routes. After the attribute is set, load balancing is performed among equal-cost BGP VPN routes, regardless of the route type, EBGP or IBGP. By default, the maximum number of equal-cost EBGP routes and IBGP routes is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="eibgpLoadBalan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eibgpLoadBalan must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="eibgpLoadBalan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__eibgpLoadBalan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eibgpLoadBalan(self):
    self.__eibgpLoadBalan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="eibgpLoadBalan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_eibgpEcmpNexthopChanged(self):
    """
    Getter method for eibgpEcmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/eibgpEcmpNexthopChanged (boolean)

    YANG Description: When equal-cost EBGP and IBGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. 
    """
    return self.__eibgpEcmpNexthopChanged
      
  def _set_eibgpEcmpNexthopChanged(self, v, load=False):
    """
    Setter method for eibgpEcmpNexthopChanged, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/eibgpEcmpNexthopChanged (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eibgpEcmpNexthopChanged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eibgpEcmpNexthopChanged() directly.

    YANG Description: When equal-cost EBGP and IBGP routes are load-balancing traffic, the next hop of these routes is changed to a local interface before these routes are advertised. By default, this function is not enabled. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eibgpEcmpNexthopChanged must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__eibgpEcmpNexthopChanged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eibgpEcmpNexthopChanged(self):
    self.__eibgpEcmpNexthopChanged = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eibgpEcmpNexthopChanged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_defaultLocalPref(self):
    """
    Getter method for defaultLocalPref, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/defaultLocalPref (uint32)

    YANG Description: Set the Local-Preference attribute. The value is an integer. The greater the value, the higher the priority. By default, the Local-Preference for BGP is 100. Setting different Local-Preferences affects BGP route selection. When a router that runs BGP has multiple routes to the same destination, the router selects the route with the highest Local-Preference. The Local-Preference is exchanged only between IBGP peers and is not advertised to other ASs.
    """
    return self.__defaultLocalPref
      
  def _set_defaultLocalPref(self, v, load=False):
    """
    Setter method for defaultLocalPref, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/defaultLocalPref (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultLocalPref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultLocalPref() directly.

    YANG Description: Set the Local-Preference attribute. The value is an integer. The greater the value, the higher the priority. By default, the Local-Preference for BGP is 100. Setting different Local-Preferences affects BGP route selection. When a router that runs BGP has multiple routes to the same destination, the router selects the route with the highest Local-Preference. The Local-Preference is exchanged only between IBGP peers and is not advertised to other ASs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="defaultLocalPref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultLocalPref must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="defaultLocalPref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__defaultLocalPref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultLocalPref(self):
    self.__defaultLocalPref = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="defaultLocalPref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_defaultMed(self):
    """
    Getter method for defaultMed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/defaultMed (uint32)

    YANG Description: Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer. By default, the MED is 0. This value is valid only for the imported routes and BGP summarized routes on the local router.

    """
    return self.__defaultMed
      
  def _set_defaultMed(self, v, load=False):
    """
    Setter method for defaultMed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/defaultMed (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultMed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultMed() directly.

    YANG Description: Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer. By default, the MED is 0. This value is valid only for the imported routes and BGP summarized routes on the local router.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="defaultMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultMed must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="defaultMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__defaultMed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultMed(self):
    self.__defaultMed = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="defaultMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_defaultRtImportEnable(self):
    """
    Getter method for defaultRtImportEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/defaultRtImportEnable (boolean)

    YANG Description: Import default routes into the BGP routing table. By default, BGP does not add default routes to the BGP routing table. default-route-imported must be used with import-routes so that default routes can be imported to the BGP routing table. If only import-routes is used, no default routes can be added to the BGP routing table. In addition, default-route-imported can only import the default routes in the routing table into the BGP routing table.
    """
    return self.__defaultRtImportEnable
      
  def _set_defaultRtImportEnable(self, v, load=False):
    """
    Setter method for defaultRtImportEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/defaultRtImportEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultRtImportEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultRtImportEnable() directly.

    YANG Description: Import default routes into the BGP routing table. By default, BGP does not add default routes to the BGP routing table. default-route-imported must be used with import-routes so that default routes can be imported to the BGP routing table. If only import-routes is used, no default routes can be added to the BGP routing table. In addition, default-route-imported can only import the default routes in the routing table into the BGP routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtImportEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultRtImportEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtImportEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__defaultRtImportEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultRtImportEnable(self):
    self.__defaultRtImportEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultRtImportEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_loadBalancingAsPathRelax(self):
    """
    Getter method for loadBalancingAsPathRelax, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/loadBalancingAsPathRelax (boolean)

    YANG Description: Configure BGP to ignore comparison of AS_Path attributes with the same length. By default, only the routes with the same AS_Path can participate in load balancing.
    """
    return self.__loadBalancingAsPathRelax
      
  def _set_loadBalancingAsPathRelax(self, v, load=False):
    """
    Setter method for loadBalancingAsPathRelax, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/loadBalancingAsPathRelax (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loadBalancingAsPathRelax is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loadBalancingAsPathRelax() directly.

    YANG Description: Configure BGP to ignore comparison of AS_Path attributes with the same length. By default, only the routes with the same AS_Path can participate in load balancing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathRelax", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loadBalancingAsPathRelax must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathRelax", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__loadBalancingAsPathRelax = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loadBalancingAsPathRelax(self):
    self.__loadBalancingAsPathRelax = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathRelax", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routerId(self):
    """
    Getter method for routerId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/routerId (inet:ipv4-address-no-zone)

    YANG Description: ID of a router that is in IPv4 address format. Certain dynamic routing protocols require a router ID. If no router ID is specified for a router when these protocols are enabled, the router ID in the RM module is used by default. The default router ID in the RM module is 0.0.0.0 when the router is not configured with any interface.
The rules for selecting a router ID are as follows:
1. If you set a router ID through this configuration, the set router ID is used. If the router ID is not set, you need to select a router ID according to the following rules:
(1) If loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the loopback interfaces is selected as the router ID.
(2) If no loopback interface configured with an IP address exists, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
The router ID is reselected only when the interface address that is selected as the router ID is deleted or changed. The router ID is not reselected in any of the following cases:
a. The interface is Down.
b. A loopback interface is configured when the IP address of a non-loopback interface is selected as the router ID.
c. A larger IP address of an interface is configured.
2. Each VPN instance selects the router ID from the addresses of the interfaces of the VPN instance according to the preceding rules.
3. When both the AMB and SMB exist on the router, the system backs up the router ID set through the related command and the router ID that is selected from IP addresses of the interfaces. After the active/standby switchover is performed, the system checks the validity of the router ID selected from the interface addresses. If the router ID is invalid, the system reselects a router ID.
    """
    return self.__routerId
      
  def _set_routerId(self, v, load=False):
    """
    Setter method for routerId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/routerId (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routerId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routerId() directly.

    YANG Description: ID of a router that is in IPv4 address format. Certain dynamic routing protocols require a router ID. If no router ID is specified for a router when these protocols are enabled, the router ID in the RM module is used by default. The default router ID in the RM module is 0.0.0.0 when the router is not configured with any interface.
The rules for selecting a router ID are as follows:
1. If you set a router ID through this configuration, the set router ID is used. If the router ID is not set, you need to select a router ID according to the following rules:
(1) If loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the loopback interfaces is selected as the router ID.
(2) If no loopback interface configured with an IP address exists, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
The router ID is reselected only when the interface address that is selected as the router ID is deleted or changed. The router ID is not reselected in any of the following cases:
a. The interface is Down.
b. A loopback interface is configured when the IP address of a non-loopback interface is selected as the router ID.
c. A larger IP address of an interface is configured.
2. Each VPN instance selects the router ID from the addresses of the interfaces of the VPN instance according to the preceding rules.
3. When both the AMB and SMB exist on the router, the system backs up the router ID set through the related command and the router ID that is selected from IP addresses of the interfaces. After the active/standby switchover is performed, the system checks the validity of the router ID selected from the interface addresses. If the router ID is invalid, the system reselects a router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routerId must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__routerId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routerId(self):
    self.__routerId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_vrfRidAutoSel(self):
    """
    Getter method for vrfRidAutoSel, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/vrfRidAutoSel (boolean)

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    return self.__vrfRidAutoSel
      
  def _set_vrfRidAutoSel(self, v, load=False):
    """
    Setter method for vrfRidAutoSel, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/vrfRidAutoSel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfRidAutoSel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfRidAutoSel() directly.

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfRidAutoSel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__vrfRidAutoSel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfRidAutoSel(self):
    self.__vrfRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_nexthopThirdParty(self):
    """
    Getter method for nexthopThirdParty, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nexthopThirdParty (boolean)

    YANG Description: Enable BGP third-party next hop.
    """
    return self.__nexthopThirdParty
      
  def _set_nexthopThirdParty(self, v, load=False):
    """
    Setter method for nexthopThirdParty, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nexthopThirdParty (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthopThirdParty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthopThirdParty() directly.

    YANG Description: Enable BGP third-party next hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nexthopThirdParty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthopThirdParty must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nexthopThirdParty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__nexthopThirdParty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthopThirdParty(self):
    self.__nexthopThirdParty = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nexthopThirdParty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_summaryAutomatic(self):
    """
    Getter method for summaryAutomatic, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/summaryAutomatic (boolean)

    YANG Description: Enable automatic summarization for imported routes. By default, the locally imported routes are not summarized automatically. Manual summarization takes precedence over automatic summarization. After automatic summarization is enabled, BGP summarizes routes based on the natural network segment (for example, 10.1.1.1/24 and 10.2.1.1/24 are summarized into 10.0.0.0/8, a Class A address), and sends only the summarized route to peers. This reduces the number of routes.
    """
    return self.__summaryAutomatic
      
  def _set_summaryAutomatic(self, v, load=False):
    """
    Setter method for summaryAutomatic, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/summaryAutomatic (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summaryAutomatic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summaryAutomatic() directly.

    YANG Description: Enable automatic summarization for imported routes. By default, the locally imported routes are not summarized automatically. Manual summarization takes precedence over automatic summarization. After automatic summarization is enabled, BGP summarizes routes based on the natural network segment (for example, 10.1.1.1/24 and 10.2.1.1/24 are summarized into 10.0.0.0/8, a Class A address), and sends only the summarized route to peers. This reduces the number of routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summaryAutomatic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summaryAutomatic must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summaryAutomatic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__summaryAutomatic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summaryAutomatic(self):
    self.__summaryAutomatic = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summaryAutomatic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_autoFrrEnable(self):
    """
    Getter method for autoFrrEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/autoFrrEnable (boolean)

    YANG Description: Enable BGP Auto FRR. By default, BGP Auto FRR is disabled. If IP FRR, VPN FRR, and Auto FRR are all enabled, IP FRR and VPN FRR take precedence over Auto FRR. If a route fails to match the routing policy of IP FRR or VPN FRR, Auto FRR takes effect.
    """
    return self.__autoFrrEnable
      
  def _set_autoFrrEnable(self, v, load=False):
    """
    Setter method for autoFrrEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/autoFrrEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoFrrEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoFrrEnable() directly.

    YANG Description: Enable BGP Auto FRR. By default, BGP Auto FRR is disabled. If IP FRR, VPN FRR, and Auto FRR are all enabled, IP FRR and VPN FRR take precedence over Auto FRR. If a route fails to match the routing policy of IP FRR or VPN FRR, Auto FRR takes effect.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoFrrEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__autoFrrEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoFrrEnable(self):
    self.__autoFrrEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoFrrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_loadBalancingAsPathIgnore(self):
    """
    Getter method for loadBalancingAsPathIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/loadBalancingAsPathIgnore (boolean)

    YANG Description: Configure BGP to ignore the AS_Path of each BGP route to the next hop when selecting routes for load balancing. By default, only the routes with the same AS_Path can participate in load balancing.
    """
    return self.__loadBalancingAsPathIgnore
      
  def _set_loadBalancingAsPathIgnore(self, v, load=False):
    """
    Setter method for loadBalancingAsPathIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/loadBalancingAsPathIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loadBalancingAsPathIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loadBalancingAsPathIgnore() directly.

    YANG Description: Configure BGP to ignore the AS_Path of each BGP route to the next hop when selecting routes for load balancing. By default, only the routes with the same AS_Path can participate in load balancing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loadBalancingAsPathIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__loadBalancingAsPathIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loadBalancingAsPathIgnore(self):
    self.__loadBalancingAsPathIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="loadBalancingAsPathIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_ribOnlyEnable(self):
    """
    Getter method for ribOnlyEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ribOnlyEnable (boolean)

    YANG Description: Prevent BGP routes from being added to the IP routing table. By default, preferred BGP routes are added to the IP routing table.
    """
    return self.__ribOnlyEnable
      
  def _set_ribOnlyEnable(self, v, load=False):
    """
    Setter method for ribOnlyEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ribOnlyEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribOnlyEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribOnlyEnable() directly.

    YANG Description: Prevent BGP routes from being added to the IP routing table. By default, preferred BGP routes are added to the IP routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ribOnlyEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribOnlyEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ribOnlyEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ribOnlyEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribOnlyEnable(self):
    self.__ribOnlyEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ribOnlyEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_ribOnlyPolicyName(self):
    """
    Getter method for ribOnlyPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ribOnlyPolicyName (string)

    YANG Description: Specify the name of a routing policy. When both rib-only-enable and rib-only-policy-name are used, the routes that match the routing policy are not added to the IP routing table. Conversely, the routes that do not match the routing policy are added to the IP routing table, and the attributes of these routes are not modified.
    """
    return self.__ribOnlyPolicyName
      
  def _set_ribOnlyPolicyName(self, v, load=False):
    """
    Setter method for ribOnlyPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ribOnlyPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribOnlyPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribOnlyPolicyName() directly.

    YANG Description: Specify the name of a routing policy. When both rib-only-enable and rib-only-policy-name are used, the routes that match the routing policy are not added to the IP routing table. Conversely, the routes that do not match the routing policy are added to the IP routing table, and the attributes of these routes are not modified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ribOnlyPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribOnlyPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ribOnlyPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__ribOnlyPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribOnlyPolicyName(self):
    self.__ribOnlyPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ribOnlyPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_activeRouteAdvertise(self):
    """
    Getter method for activeRouteAdvertise, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/activeRouteAdvertise (boolean)

    YANG Description: Advertise the optimal routes in the RM module to peers.
    """
    return self.__activeRouteAdvertise
      
  def _set_activeRouteAdvertise(self, v, load=False):
    """
    Setter method for activeRouteAdvertise, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/activeRouteAdvertise (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_activeRouteAdvertise is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_activeRouteAdvertise() directly.

    YANG Description: Advertise the optimal routes in the RM module to peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="activeRouteAdvertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """activeRouteAdvertise must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="activeRouteAdvertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__activeRouteAdvertise = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_activeRouteAdvertise(self):
    self.__activeRouteAdvertise = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="activeRouteAdvertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_asPathNeglect(self):
    """
    Getter method for asPathNeglect, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/asPathNeglect (boolean)

    YANG Description: Configure BGP to ignore the AS_Path attribute when selecting the optimal route. By default, BGP uses the AS_Path attribute as one of route selection rules, and a route with a shorter AS_Path is preferred. After as-path-neglect is selected, BGP does not compare the AS_Path length.
    """
    return self.__asPathNeglect
      
  def _set_asPathNeglect(self, v, load=False):
    """
    Setter method for asPathNeglect, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/asPathNeglect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asPathNeglect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asPathNeglect() directly.

    YANG Description: Configure BGP to ignore the AS_Path attribute when selecting the optimal route. By default, BGP uses the AS_Path attribute as one of route selection rules, and a route with a shorter AS_Path is preferred. After as-path-neglect is selected, BGP does not compare the AS_Path length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asPathNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asPathNeglect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asPathNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__asPathNeglect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asPathNeglect(self):
    self.__asPathNeglect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="asPathNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_medNoneAsMaximum(self):
    """
    Getter method for medNoneAsMaximum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/medNoneAsMaximum (boolean)

    YANG Description: If a route does not carry MED, BGP considers its MED as the default value (0) during route selection. After med-none-as-maximum is selected, BGP considers its MED as the largest MED value (4294967295).
    """
    return self.__medNoneAsMaximum
      
  def _set_medNoneAsMaximum(self, v, load=False):
    """
    Setter method for medNoneAsMaximum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/medNoneAsMaximum (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_medNoneAsMaximum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_medNoneAsMaximum() directly.

    YANG Description: If a route does not carry MED, BGP considers its MED as the default value (0) during route selection. After med-none-as-maximum is selected, BGP considers its MED as the largest MED value (4294967295).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="medNoneAsMaximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """medNoneAsMaximum must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="medNoneAsMaximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__medNoneAsMaximum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_medNoneAsMaximum(self):
    self.__medNoneAsMaximum = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="medNoneAsMaximum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routerIdNeglect(self):
    """
    Getter method for routerIdNeglect, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/routerIdNeglect (boolean)

    YANG Description: Configure BGP to ignore router IDs when selecting the optimal route. Comparing router IDs is the last resort in route selection. This means that if one optimal route must be selected and no other parameters can be used to break the tie, router IDs can be used. If this option is selected, the first received route will be selected as the optimal route, and BGP will ignore the router ID and peer address in route selection.
    """
    return self.__routerIdNeglect
      
  def _set_routerIdNeglect(self, v, load=False):
    """
    Setter method for routerIdNeglect, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/routerIdNeglect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routerIdNeglect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routerIdNeglect() directly.

    YANG Description: Configure BGP to ignore router IDs when selecting the optimal route. Comparing router IDs is the last resort in route selection. This means that if one optimal route must be selected and no other parameters can be used to break the tie, router IDs can be used. If this option is selected, the first received route will be selected as the optimal route, and BGP will ignore the router ID and peer address in route selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="routerIdNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routerIdNeglect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="routerIdNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__routerIdNeglect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routerIdNeglect(self):
    self.__routerIdNeglect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="routerIdNeglect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_igpMetricIgnore(self):
    """
    Getter method for igpMetricIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/igpMetricIgnore (boolean)

    YANG Description: Configure BGP to ignore the IGP cost of each BGP route to the next hop in route selection. By default, a BGP route with a smaller IGP cost to the next hop is preferred.
    """
    return self.__igpMetricIgnore
      
  def _set_igpMetricIgnore(self, v, load=False):
    """
    Setter method for igpMetricIgnore, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/igpMetricIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_igpMetricIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_igpMetricIgnore() directly.

    YANG Description: Configure BGP to ignore the IGP cost of each BGP route to the next hop in route selection. By default, a BGP route with a smaller IGP cost to the next hop is preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="igpMetricIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """igpMetricIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="igpMetricIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__igpMetricIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_igpMetricIgnore(self):
    self.__igpMetricIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="igpMetricIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_alwaysCompareMed(self):
    """
    Getter method for alwaysCompareMed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/alwaysCompareMed (boolean)

    YANG Description: Configure BGP to compare the MEDs of routes from peers in different ASs in route selection. By default, BGP does not compare the MEDs of routes from peers in different ASs. If there are multiple reachable routes to the same destination, the route with the smallest MED is preferred. Do not use this option unless different ASs use the same IGP and route selection mode.
    """
    return self.__alwaysCompareMed
      
  def _set_alwaysCompareMed(self, v, load=False):
    """
    Setter method for alwaysCompareMed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/alwaysCompareMed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alwaysCompareMed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alwaysCompareMed() directly.

    YANG Description: Configure BGP to compare the MEDs of routes from peers in different ASs in route selection. By default, BGP does not compare the MEDs of routes from peers in different ASs. If there are multiple reachable routes to the same destination, the route with the smallest MED is preferred. Do not use this option unless different ASs use the same IGP and route selection mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="alwaysCompareMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alwaysCompareMed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="alwaysCompareMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__alwaysCompareMed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alwaysCompareMed(self):
    self.__alwaysCompareMed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="alwaysCompareMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_determinMed(self):
    """
    Getter method for determinMed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/determinMed (boolean)

    YANG Description: Enable deterministic MED so that the route selection result is relevant to the sequence in which routes are received.
    """
    return self.__determinMed
      
  def _set_determinMed(self, v, load=False):
    """
    Setter method for determinMed, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/determinMed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_determinMed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_determinMed() directly.

    YANG Description: Enable deterministic MED so that the route selection result is relevant to the sequence in which routes are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="determinMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """determinMed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="determinMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__determinMed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_determinMed(self):
    self.__determinMed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="determinMed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_preferenceExternal(self):
    """
    Getter method for preferenceExternal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/preferenceExternal (uint8)

    YANG Description: Set the protocol priority of EBGP routes. The value is an integer. An EBGP route is the optimal route learned from a peer outside the local AS.
    """
    return self.__preferenceExternal
      
  def _set_preferenceExternal(self, v, load=False):
    """
    Setter method for preferenceExternal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/preferenceExternal (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferenceExternal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferenceExternal() directly.

    YANG Description: Set the protocol priority of EBGP routes. The value is an integer. An EBGP route is the optimal route learned from a peer outside the local AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferenceExternal must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__preferenceExternal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferenceExternal(self):
    self.__preferenceExternal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_preferenceInternal(self):
    """
    Getter method for preferenceInternal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/preferenceInternal (uint8)

    YANG Description: Set the protocol priority of IBGP routes. The value is an integer. An IBGP route is a route learned from a peer inside the local AS.
    """
    return self.__preferenceInternal
      
  def _set_preferenceInternal(self, v, load=False):
    """
    Setter method for preferenceInternal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/preferenceInternal (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferenceInternal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferenceInternal() directly.

    YANG Description: Set the protocol priority of IBGP routes. The value is an integer. An IBGP route is a route learned from a peer inside the local AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceInternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferenceInternal must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceInternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__preferenceInternal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferenceInternal(self):
    self.__preferenceInternal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceInternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_preferenceLocal(self):
    """
    Getter method for preferenceLocal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/preferenceLocal (uint8)

    YANG Description: Set the protocol priority of a local BGP route. The value is an integer. A local route refers to an automatically or manually summarized route.
    """
    return self.__preferenceLocal
      
  def _set_preferenceLocal(self, v, load=False):
    """
    Setter method for preferenceLocal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/preferenceLocal (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferenceLocal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferenceLocal() directly.

    YANG Description: Set the protocol priority of a local BGP route. The value is an integer. A local route refers to an automatically or manually summarized route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferenceLocal must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__preferenceLocal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferenceLocal(self):
    self.__preferenceLocal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="preferenceLocal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_prefrencePolicyName(self):
    """
    Getter method for prefrencePolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/prefrencePolicyName (string)

    YANG Description: Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The routes that do not meet the policy rules use the default priority.
    """
    return self.__prefrencePolicyName
      
  def _set_prefrencePolicyName(self, v, load=False):
    """
    Setter method for prefrencePolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/prefrencePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefrencePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefrencePolicyName() directly.

    YANG Description: Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The routes that do not meet the policy rules use the default priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="prefrencePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefrencePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefrencePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__prefrencePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefrencePolicyName(self):
    self.__prefrencePolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="prefrencePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_reflectBetweenClient(self):
    """
    Getter method for reflectBetweenClient, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectBetweenClient (boolean)

    YANG Description: Enable route reflection between clients. By default, route reflection is enabled between clients. If clients of a route reflector (RR) are fully meshed, you can disable route reflection among clients to reduce the cost.
    """
    return self.__reflectBetweenClient
      
  def _set_reflectBetweenClient(self, v, load=False):
    """
    Setter method for reflectBetweenClient, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectBetweenClient (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reflectBetweenClient is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reflectBetweenClient() directly.

    YANG Description: Enable route reflection between clients. By default, route reflection is enabled between clients. If clients of a route reflector (RR) are fully meshed, you can disable route reflection among clients to reduce the cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="reflectBetweenClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reflectBetweenClient must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="reflectBetweenClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__reflectBetweenClient = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reflectBetweenClient(self):
    self.__reflectBetweenClient = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="reflectBetweenClient", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_reflectorClusterId(self):
    """
    Getter method for reflectorClusterId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectorClusterId (uint32)

    YANG Description: Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. If a cluster has more than one RR, select this option to set the same cluster ID for all the RRs to avoid routing loops. To allow clients to receive routes from RRs, ensure that the cluster ID of the RRs is different from the router ID of any client. If the cluster ID of the RRs is the same as the router ID of a client, the client will discard received routes.
    """
    return self.__reflectorClusterId
      
  def _set_reflectorClusterId(self, v, load=False):
    """
    Setter method for reflectorClusterId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectorClusterId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reflectorClusterId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reflectorClusterId() directly.

    YANG Description: Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. If a cluster has more than one RR, select this option to set the same cluster ID for all the RRs to avoid routing loops. To allow clients to receive routes from RRs, ensure that the cluster ID of the RRs is different from the router ID of any client. If the cluster ID of the RRs is the same as the router ID of a client, the client will discard received routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="reflectorClusterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reflectorClusterId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="reflectorClusterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__reflectorClusterId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reflectorClusterId(self):
    self.__reflectorClusterId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="reflectorClusterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_reflectorClusterIpv4(self):
    """
    Getter method for reflectorClusterIpv4, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectorClusterIpv4 (inet:ipv4-address-no-zone)

    YANG Description: Set a cluster ID. The value is expressed in the format of an IPv4 address. Configuring multiple RRs in a cluster can enhance the stability of the network. If a cluster has more than one RR, select this option to set the same cluster ID for all the RRs to avoid routing loops. To allow clients to receive routes from RRs, ensure that the cluster ID of the RRs is different from the router ID of any client. If the cluster ID of the RRs is the same as the router ID of a client, the client will discard received routes.
    """
    return self.__reflectorClusterIpv4
      
  def _set_reflectorClusterIpv4(self, v, load=False):
    """
    Setter method for reflectorClusterIpv4, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectorClusterIpv4 (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reflectorClusterIpv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reflectorClusterIpv4() directly.

    YANG Description: Set a cluster ID. The value is expressed in the format of an IPv4 address. Configuring multiple RRs in a cluster can enhance the stability of the network. If a cluster has more than one RR, select this option to set the same cluster ID for all the RRs to avoid routing loops. To allow clients to receive routes from RRs, ensure that the cluster ID of the RRs is different from the router ID of any client. If the cluster ID of the RRs is the same as the router ID of a client, the client will discard received routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="reflectorClusterIpv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reflectorClusterIpv4 must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="reflectorClusterIpv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__reflectorClusterIpv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reflectorClusterIpv4(self):
    self.__reflectorClusterIpv4 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="reflectorClusterIpv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_rrFilterNumber(self):
    """
    Getter method for rrFilterNumber, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/rrFilterNumber (string)

    YANG Description: Set the number of the extended community filter supported by an RR group. For the purpose of load balancing, only the IBGP route whose route-target extended community attribute meets the matching rules can be reflected. The name of an extended community filter can be a numeral or a character string. The ID of an extended community filter is an integer ranging from 1 to 399. The name of an extended community filter is a string of 1 to 51 characters. The string cannot contain only numerals.
    """
    return self.__rrFilterNumber
      
  def _set_rrFilterNumber(self, v, load=False):
    """
    Setter method for rrFilterNumber, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/rrFilterNumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rrFilterNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rrFilterNumber() directly.

    YANG Description: Set the number of the extended community filter supported by an RR group. For the purpose of load balancing, only the IBGP route whose route-target extended community attribute meets the matching rules can be reflected. The name of an extended community filter can be a numeral or a character string. The ID of an extended community filter is an integer ranging from 1 to 399. The name of an extended community filter is a string of 1 to 51 characters. The string cannot contain only numerals.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rrFilterNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rrFilterNumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rrFilterNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__rrFilterNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rrFilterNumber(self):
    self.__rrFilterNumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rrFilterNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_policyVpnTarget(self):
    """
    Getter method for policyVpnTarget, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/policyVpnTarget (boolean)

    YANG Description: Enable VPN target-based filtering for the received VPN routes. By default, VPN target-based filtering is enabled. Only the VPN route whose Export RT attribute matches the local Import RT attribute can be added to the routing table.  This option can be used in the inter-AS VPN Option B solution and the ASBR MP-EBGP inter-AS L2VPN solution in Kompella mode.
    """
    return self.__policyVpnTarget
      
  def _set_policyVpnTarget(self, v, load=False):
    """
    Setter method for policyVpnTarget, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/policyVpnTarget (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyVpnTarget is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyVpnTarget() directly.

    YANG Description: Enable VPN target-based filtering for the received VPN routes. By default, VPN target-based filtering is enabled. Only the VPN route whose Export RT attribute matches the local Import RT attribute can be added to the routing table.  This option can be used in the inter-AS VPN Option B solution and the ASBR MP-EBGP inter-AS L2VPN solution in Kompella mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policyVpnTarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyVpnTarget must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policyVpnTarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__policyVpnTarget = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyVpnTarget(self):
    self.__policyVpnTarget = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policyVpnTarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_nextHopSelDependType(self):
    """
    Getter method for nextHopSelDependType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nextHopSelDependType (bgpcommSelDependType)

    YANG Description: Specify the route iteration mode: IP or tunnel. In tunnel mode, the labeled BGP IPv4 route can participate in route selection only after its next hop is iterated to an LSP. In IP mode, the labeled BGP IPv4 route can participate in route selection only after its next hop is iterated to an IP address. By default, the labeled BGP IPv4 route can participate in route selection if its next hop can be iterated to an IP address, regardless of whether the LSP of the next hop exists. This allows the RR that is not enabled with MPLS to forward labeled routes. In non-RR networking or RR networking where the BGP next hop is changed, BGP needs to check whether there is an LSP destined for the next hop. If such an LSP is not found, BGP needs to establish an LSP in advance. If the default setting is adopted, a labeled BGP IPv4 unicast route may be selected prior to LSP establishment. As a result, services are incorrectly switched before LSP establishment and service stability is affected. Therefore, allow route selection only after the labeled BGP IPv4 route is iterated to an LSP.
    """
    return self.__nextHopSelDependType
      
  def _set_nextHopSelDependType(self, v, load=False):
    """
    Setter method for nextHopSelDependType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nextHopSelDependType (bgpcommSelDependType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHopSelDependType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHopSelDependType() directly.

    YANG Description: Specify the route iteration mode: IP or tunnel. In tunnel mode, the labeled BGP IPv4 route can participate in route selection only after its next hop is iterated to an LSP. In IP mode, the labeled BGP IPv4 route can participate in route selection only after its next hop is iterated to an IP address. By default, the labeled BGP IPv4 route can participate in route selection if its next hop can be iterated to an IP address, regardless of whether the LSP of the next hop exists. This allows the RR that is not enabled with MPLS to forward labeled routes. In non-RR networking or RR networking where the BGP next hop is changed, BGP needs to check whether there is an LSP destined for the next hop. If such an LSP is not found, BGP needs to establish an LSP in advance. If the default setting is adopted, a labeled BGP IPv4 unicast route may be selected prior to LSP establishment. As a result, services are incorrectly switched before LSP establishment and service stability is affected. Therefore, allow route selection only after the labeled BGP IPv4 route is iterated to an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'dependTunnel': {}, 'dependIp': {}},), is_leaf=True, yang_name="nextHopSelDependType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSelDependType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHopSelDependType must be of a type compatible with bgpcommSelDependType""",
          'defined-type': "huawei-bgp:bgpcommSelDependType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'dependTunnel': {}, 'dependIp': {}},), is_leaf=True, yang_name="nextHopSelDependType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSelDependType', is_config=True)""",
        })

    self.__nextHopSelDependType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHopSelDependType(self):
    self.__nextHopSelDependType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {}, 'dependTunnel': {}, 'dependIp': {}},), is_leaf=True, yang_name="nextHopSelDependType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpcommSelDependType', is_config=True)


  def _get_nhpRelayRoutePolicyName(self):
    """
    Getter method for nhpRelayRoutePolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nhpRelayRoutePolicyName (string)

    YANG Description: Specify the name of a route-policy for route iteration.
    """
    return self.__nhpRelayRoutePolicyName
      
  def _set_nhpRelayRoutePolicyName(self, v, load=False):
    """
    Setter method for nhpRelayRoutePolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/nhpRelayRoutePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhpRelayRoutePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhpRelayRoutePolicyName() directly.

    YANG Description: Specify the name of a route-policy for route iteration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nhpRelayRoutePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhpRelayRoutePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nhpRelayRoutePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__nhpRelayRoutePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhpRelayRoutePolicyName(self):
    self.__nhpRelayRoutePolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nhpRelayRoutePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_ebgpIfSensitive(self):
    """
    Getter method for ebgpIfSensitive, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ebgpIfSensitive (boolean)

    YANG Description: After the function of EBGP interface fast sensing is enabled, the sessions of directly connected EBGP peers are immediately cleared from the associated interface when the interface becomes Down. By default, this function is enabled.
    """
    return self.__ebgpIfSensitive
      
  def _set_ebgpIfSensitive(self, v, load=False):
    """
    Setter method for ebgpIfSensitive, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ebgpIfSensitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgpIfSensitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgpIfSensitive() directly.

    YANG Description: After the function of EBGP interface fast sensing is enabled, the sessions of directly connected EBGP peers are immediately cleared from the associated interface when the interface becomes Down. By default, this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ebgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgpIfSensitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ebgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ebgpIfSensitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgpIfSensitive(self):
    self.__ebgpIfSensitive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ebgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_ibgpIfSensitive(self):
    """
    Getter method for ibgpIfSensitive, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ibgpIfSensitive (boolean)

    YANG Description: After the function of IBGP interface fast sensing is enabled, the sessions of directly connected IBGP peers are immediately cleared from the associated interface when the interface becomes Down. By default, this function is disabled.
    """
    return self.__ibgpIfSensitive
      
  def _set_ibgpIfSensitive(self, v, load=False):
    """
    Setter method for ibgpIfSensitive, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ibgpIfSensitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ibgpIfSensitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ibgpIfSensitive() directly.

    YANG Description: After the function of IBGP interface fast sensing is enabled, the sessions of directly connected IBGP peers are immediately cleared from the associated interface when the interface becomes Down. By default, this function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ibgpIfSensitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ibgpIfSensitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ibgpIfSensitive(self):
    self.__ibgpIfSensitive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ibgpIfSensitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_reflectChgPath(self):
    """
    Getter method for reflectChgPath, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectChgPath (boolean)

    YANG Description: Enable an RR to use an export policy to change route AS_Path. By default, this function is not enabled.
    """
    return self.__reflectChgPath
      
  def _set_reflectChgPath(self, v, load=False):
    """
    Setter method for reflectChgPath, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/reflectChgPath (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reflectChgPath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reflectChgPath() directly.

    YANG Description: Enable an RR to use an export policy to change route AS_Path. By default, this function is not enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectChgPath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reflectChgPath must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectChgPath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__reflectChgPath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reflectChgPath(self):
    self.__reflectChgPath = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="reflectChgPath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_slowPeerDet(self):
    """
    Getter method for slowPeerDet, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/slowPeerDet (boolean)

    YANG Description: Detect slow peers
    """
    return self.__slowPeerDet
      
  def _set_slowPeerDet(self, v, load=False):
    """
    Setter method for slowPeerDet, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/slowPeerDet (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slowPeerDet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slowPeerDet() directly.

    YANG Description: Detect slow peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="slowPeerDet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slowPeerDet must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="slowPeerDet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__slowPeerDet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slowPeerDet(self):
    self.__slowPeerDet = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="slowPeerDet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_slowPeerThVal(self):
    """
    Getter method for slowPeerThVal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/slowPeerThVal (uint16)

    YANG Description: Specify the time in seconds lagging behind average when a peer is determined to be a slow peer, default is 300
    """
    return self.__slowPeerThVal
      
  def _set_slowPeerThVal(self, v, load=False):
    """
    Setter method for slowPeerThVal, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/slowPeerThVal (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slowPeerThVal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slowPeerThVal() directly.

    YANG Description: Specify the time in seconds lagging behind average when a peer is determined to be a slow peer, default is 300
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['120..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(300), is_leaf=True, yang_name="slowPeerThVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slowPeerThVal must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['120..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(300), is_leaf=True, yang_name="slowPeerThVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__slowPeerThVal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slowPeerThVal(self):
    self.__slowPeerThVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['120..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(300), is_leaf=True, yang_name="slowPeerThVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_addPathSelNum(self):
    """
    Getter method for addPathSelNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/addPathSelNum (uint8)

    YANG Description: Number of Add-Path routes.
    """
    return self.__addPathSelNum
      
  def _set_addPathSelNum(self, v, load=False):
    """
    Setter method for addPathSelNum, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/addPathSelNum (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addPathSelNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addPathSelNum() directly.

    YANG Description: Number of Add-Path routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="addPathSelNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addPathSelNum must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="addPathSelNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__addPathSelNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addPathSelNum(self):
    self.__addPathSelNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), is_leaf=True, yang_name="addPathSelNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_routeSelDelay(self):
    """
    Getter method for routeSelDelay, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/routeSelDelay (uint16)

    YANG Description: Route selection delay. 
    """
    return self.__routeSelDelay
      
  def _set_routeSelDelay(self, v, load=False):
    """
    Setter method for routeSelDelay, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/routeSelDelay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeSelDelay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeSelDelay() directly.

    YANG Description: Route selection delay. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="routeSelDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeSelDelay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="routeSelDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__routeSelDelay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeSelDelay(self):
    self.__routeSelDelay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..3600']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="routeSelDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_originAsValidEnable(self):
    """
    Getter method for originAsValidEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/originAsValidEnable (boolean)

    YANG Description: Enable BGP origin AS validation.
    """
    return self.__originAsValidEnable
      
  def _set_originAsValidEnable(self, v, load=False):
    """
    Setter method for originAsValidEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/originAsValidEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originAsValidEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originAsValidEnable() directly.

    YANG Description: Enable BGP origin AS validation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValidEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originAsValidEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValidEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__originAsValidEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originAsValidEnable(self):
    self.__originAsValidEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValidEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_originAsValid(self):
    """
    Getter method for originAsValid, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/originAsValid (boolean)

    YANG Description: Apply the BGP origin AS validation result to route selection.
    """
    return self.__originAsValid
      
  def _set_originAsValid(self, v, load=False):
    """
    Setter method for originAsValid, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/originAsValid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originAsValid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originAsValid() directly.

    YANG Description: Apply the BGP origin AS validation result to route selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originAsValid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__originAsValid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originAsValid(self):
    self.__originAsValid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originAsValid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_allowInvalidAs(self):
    """
    Getter method for allowInvalidAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/allowInvalidAs (boolean)

    YANG Description: Allow routes with BGP origin AS validation result Invalid to be selected.
    """
    return self.__allowInvalidAs
      
  def _set_allowInvalidAs(self, v, load=False):
    """
    Setter method for allowInvalidAs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/allowInvalidAs (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowInvalidAs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowInvalidAs() directly.

    YANG Description: Allow routes with BGP origin AS validation result Invalid to be selected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowInvalidAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowInvalidAs must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowInvalidAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allowInvalidAs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowInvalidAs(self):
    self.__allowInvalidAs = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowInvalidAs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_policyExtCommEnable(self):
    """
    Getter method for policyExtCommEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/policyExtCommEnable (boolean)

    YANG Description: Change the extended community attribute.
    """
    return self.__policyExtCommEnable
      
  def _set_policyExtCommEnable(self, v, load=False):
    """
    Setter method for policyExtCommEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/policyExtCommEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyExtCommEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyExtCommEnable() directly.

    YANG Description: Change the extended community attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyExtCommEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyExtCommEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyExtCommEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__policyExtCommEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyExtCommEnable(self):
    self.__policyExtCommEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyExtCommEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_policyQPPBEnable(self):
    """
    Getter method for policyQPPBEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/policyQPPBEnable (boolean)

    YANG Description: Enable QPPB.
    """
    return self.__policyQPPBEnable
      
  def _set_policyQPPBEnable(self, v, load=False):
    """
    Setter method for policyQPPBEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/policyQPPBEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyQPPBEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyQPPBEnable() directly.

    YANG Description: Enable QPPB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyQPPBEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyQPPBEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyQPPBEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__policyQPPBEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyQPPBEnable(self):
    self.__policyQPPBEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="policyQPPBEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_supernetUniAdv(self):
    """
    Getter method for supernetUniAdv, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/supernetUniAdv (boolean)

    YANG Description: Advertise supernet unicast routes.
    """
    return self.__supernetUniAdv
      
  def _set_supernetUniAdv(self, v, load=False):
    """
    Setter method for supernetUniAdv, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/supernetUniAdv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supernetUniAdv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supernetUniAdv() directly.

    YANG Description: Advertise supernet unicast routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="supernetUniAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supernetUniAdv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="supernetUniAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__supernetUniAdv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supernetUniAdv(self):
    self.__supernetUniAdv = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="supernetUniAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_supernetLabelAdv(self):
    """
    Getter method for supernetLabelAdv, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/supernetLabelAdv (boolean)

    YANG Description: Advertise supernet labeled routes.
    """
    return self.__supernetLabelAdv
      
  def _set_supernetLabelAdv(self, v, load=False):
    """
    Setter method for supernetLabelAdv, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/supernetLabelAdv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supernetLabelAdv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supernetLabelAdv() directly.

    YANG Description: Advertise supernet labeled routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supernetLabelAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supernetLabelAdv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supernetLabelAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__supernetLabelAdv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supernetLabelAdv(self):
    self.__supernetLabelAdv = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supernetLabelAdv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_ingressLspPolicyName(self):
    """
    Getter method for ingressLspPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ingressLspPolicyName (string)

    YANG Description: Name of a route-policy. An ingress LSP is created for only the routes that match the route-policy.
    """
    return self.__ingressLspPolicyName
      
  def _set_ingressLspPolicyName(self, v, load=False):
    """
    Setter method for ingressLspPolicyName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/ingressLspPolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ingressLspPolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ingressLspPolicyName() directly.

    YANG Description: Name of a route-policy. An ingress LSP is created for only the routes that match the route-policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ingressLspPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ingressLspPolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingressLspPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__ingressLspPolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ingressLspPolicyName(self):
    self.__ingressLspPolicyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ingressLspPolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_originatorPrior(self):
    """
    Getter method for originatorPrior, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/originatorPrior (boolean)

    YANG Description: Configure BGP to compare originator before clusterlist in route selection.
    """
    return self.__originatorPrior
      
  def _set_originatorPrior(self, v, load=False):
    """
    Setter method for originatorPrior, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/originatorPrior (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originatorPrior is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originatorPrior() directly.

    YANG Description: Configure BGP to compare originator before clusterlist in route selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originatorPrior", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originatorPrior must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originatorPrior", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__originatorPrior = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originatorPrior(self):
    self.__originatorPrior = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="originatorPrior", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_lowestPriority(self):
    """
    Getter method for lowestPriority, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/lowestPriority (boolean)

    YANG Description: Reduce route priority to lowest.
    """
    return self.__lowestPriority
      
  def _set_lowestPriority(self, v, load=False):
    """
    Setter method for lowestPriority, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/lowestPriority (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowestPriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowestPriority() directly.

    YANG Description: Reduce route priority to lowest.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowestPriority must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__lowestPriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowestPriority(self):
    self.__lowestPriority = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lowestPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_relayDelayEnable(self):
    """
    Getter method for relayDelayEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/relayDelayEnable (boolean)

    YANG Description: Enable relay delay processing.
    """
    return self.__relayDelayEnable
      
  def _set_relayDelayEnable(self, v, load=False):
    """
    Setter method for relayDelayEnable, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/relayDelayEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relayDelayEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relayDelayEnable() directly.

    YANG Description: Enable relay delay processing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="relayDelayEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relayDelayEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="relayDelayEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__relayDelayEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relayDelayEnable(self):
    self.__relayDelayEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="relayDelayEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_irbAsymmetric(self):
    """
    Getter method for irbAsymmetric, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/irbAsymmetric (boolean)

    YANG Description: IRB Asymmetric mode.
    """
    return self.__irbAsymmetric
      
  def _set_irbAsymmetric(self, v, load=False):
    """
    Setter method for irbAsymmetric, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/irbAsymmetric (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_irbAsymmetric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_irbAsymmetric() directly.

    YANG Description: IRB Asymmetric mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="irbAsymmetric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """irbAsymmetric must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="irbAsymmetric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__irbAsymmetric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_irbAsymmetric(self):
    self.__irbAsymmetric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="irbAsymmetric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_peerGroupAFs(self):
    """
    Getter method for peerGroupAFs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs (container)

    YANG Description: List of all peer groups that are enabled in a specified address family.
    """
    return self.__peerGroupAFs
      
  def _set_peerGroupAFs(self, v, load=False):
    """
    Setter method for peerGroupAFs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerGroupAFs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerGroupAFs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerGroupAFs() directly.

    YANG Description: List of all peer groups that are enabled in a specified address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerGroupAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs, is_container='container', yang_name="peerGroupAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerGroupAFs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerGroupAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs, is_container='container', yang_name="peerGroupAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerGroupAFs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerGroupAFs(self):
    self.__peerGroupAFs = YANGDynClass(base=yc_peerGroupAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs, is_container='container', yang_name="peerGroupAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peerAFs(self):
    """
    Getter method for peerAFs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs (container)

    YANG Description: Peers in a specified address family.
    """
    return self.__peerAFs
      
  def _set_peerAFs(self, v, load=False):
    """
    Setter method for peerAFs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/peerAFs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerAFs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerAFs() directly.

    YANG Description: Peers in a specified address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peerAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs, is_container='container', yang_name="peerAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerAFs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peerAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs, is_container='container', yang_name="peerAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peerAFs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerAFs(self):
    self.__peerAFs = YANGDynClass(base=yc_peerAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs, is_container='container', yang_name="peerAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_importRoutes(self):
    """
    Getter method for importRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes (container)

    YANG Description: List of imported routes.
    """
    return self.__importRoutes
      
  def _set_importRoutes(self, v, load=False):
    """
    Setter method for importRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/importRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_importRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_importRoutes() directly.

    YANG Description: List of imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_importRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes, is_container='container', yang_name="importRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """importRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_importRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes, is_container='container', yang_name="importRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__importRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_importRoutes(self):
    self.__importRoutes = YANGDynClass(base=yc_importRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes, is_container='container', yang_name="importRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_networkRoutes(self):
    """
    Getter method for networkRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes (container)

    YANG Description: List of advertised routes.
    """
    return self.__networkRoutes
      
  def _set_networkRoutes(self, v, load=False):
    """
    Setter method for networkRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/networkRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networkRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networkRoutes() directly.

    YANG Description: List of advertised routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_networkRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes, is_container='container', yang_name="networkRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networkRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_networkRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes, is_container='container', yang_name="networkRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__networkRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networkRoutes(self):
    self.__networkRoutes = YANGDynClass(base=yc_networkRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes, is_container='container', yang_name="networkRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_aggregateRoutes(self):
    """
    Getter method for aggregateRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes (container)

    YANG Description: List of summarized routes.
    """
    return self.__aggregateRoutes
      
  def _set_aggregateRoutes(self, v, load=False):
    """
    Setter method for aggregateRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/aggregateRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregateRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregateRoutes() directly.

    YANG Description: List of summarized routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aggregateRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes, is_container='container', yang_name="aggregateRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregateRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aggregateRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes, is_container='container', yang_name="aggregateRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__aggregateRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregateRoutes(self):
    self.__aggregateRoutes = YANGDynClass(base=yc_aggregateRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes, is_container='container', yang_name="aggregateRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_dampRoutes(self):
    """
    Getter method for dampRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes (container)

    YANG Description: List of route dampening.
    """
    return self.__dampRoutes
      
  def _set_dampRoutes(self, v, load=False):
    """
    Setter method for dampRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/dampRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dampRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dampRoutes() directly.

    YANG Description: List of route dampening.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dampRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes, is_container='container', yang_name="dampRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dampRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dampRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes, is_container='container', yang_name="dampRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__dampRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dampRoutes(self):
    self.__dampRoutes = YANGDynClass(base=yc_dampRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes, is_container='container', yang_name="dampRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_filterPolicys(self):
    """
    Getter method for filterPolicys, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys (container)

    YANG Description: List of filtering policies.
    """
    return self.__filterPolicys
      
  def _set_filterPolicys(self, v, load=False):
    """
    Setter method for filterPolicys, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/filterPolicys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filterPolicys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filterPolicys() directly.

    YANG Description: List of filtering policies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filterPolicys_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys, is_container='container', yang_name="filterPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filterPolicys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filterPolicys_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys, is_container='container', yang_name="filterPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__filterPolicys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filterPolicys(self):
    self.__filterPolicys = YANGDynClass(base=yc_filterPolicys_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys, is_container='container', yang_name="filterPolicys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_instanceImports(self):
    """
    Getter method for instanceImports, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports (container)

    YANG Description: List of Instance Imported Routes.
    """
    return self.__instanceImports
      
  def _set_instanceImports(self, v, load=False):
    """
    Setter method for instanceImports, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/instanceImports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instanceImports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instanceImports() directly.

    YANG Description: List of Instance Imported Routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_instanceImports_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports, is_container='container', yang_name="instanceImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instanceImports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instanceImports_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports, is_container='container', yang_name="instanceImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__instanceImports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instanceImports(self):
    self.__instanceImports = YANGDynClass(base=yc_instanceImports_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports, is_container='container', yang_name="instanceImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpAdvRoutes(self):
    """
    Getter method for bgpAdvRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes (container)

    YANG Description: List of Advertise Route Protocol.
    """
    return self.__bgpAdvRoutes
      
  def _set_bgpAdvRoutes(self, v, load=False):
    """
    Setter method for bgpAdvRoutes, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF/bgpAdvRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpAdvRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpAdvRoutes() directly.

    YANG Description: List of Advertise Route Protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpAdvRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes, is_container='container', yang_name="bgpAdvRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpAdvRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpAdvRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes, is_container='container', yang_name="bgpAdvRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpAdvRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpAdvRoutes(self):
    self.__bgpAdvRoutes = YANGDynClass(base=yc_bgpAdvRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes, is_container='container', yang_name="bgpAdvRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  afType = __builtin__.property(_get_afType, _set_afType)
  nexthopDelayTime = __builtin__.property(_get_nexthopDelayTime, _set_nexthopDelayTime)
  noCriticalNexthopDelayTime = __builtin__.property(_get_noCriticalNexthopDelayTime, _set_noCriticalNexthopDelayTime)
  vrfAsNum = __builtin__.property(_get_vrfAsNum, _set_vrfAsNum)
  maxLoadIbgpNum = __builtin__.property(_get_maxLoadIbgpNum, _set_maxLoadIbgpNum)
  ibgpEcmpNexthopChanged = __builtin__.property(_get_ibgpEcmpNexthopChanged, _set_ibgpEcmpNexthopChanged)
  maxLoadEbgpNum = __builtin__.property(_get_maxLoadEbgpNum, _set_maxLoadEbgpNum)
  ebgpEcmpNexthopChanged = __builtin__.property(_get_ebgpEcmpNexthopChanged, _set_ebgpEcmpNexthopChanged)
  maximumLoadBalance = __builtin__.property(_get_maximumLoadBalance, _set_maximumLoadBalance)
  ecmpNexthopChanged = __builtin__.property(_get_ecmpNexthopChanged, _set_ecmpNexthopChanged)
  eibgpLoadBalan = __builtin__.property(_get_eibgpLoadBalan, _set_eibgpLoadBalan)
  eibgpEcmpNexthopChanged = __builtin__.property(_get_eibgpEcmpNexthopChanged, _set_eibgpEcmpNexthopChanged)
  defaultLocalPref = __builtin__.property(_get_defaultLocalPref, _set_defaultLocalPref)
  defaultMed = __builtin__.property(_get_defaultMed, _set_defaultMed)
  defaultRtImportEnable = __builtin__.property(_get_defaultRtImportEnable, _set_defaultRtImportEnable)
  loadBalancingAsPathRelax = __builtin__.property(_get_loadBalancingAsPathRelax, _set_loadBalancingAsPathRelax)
  routerId = __builtin__.property(_get_routerId, _set_routerId)
  vrfRidAutoSel = __builtin__.property(_get_vrfRidAutoSel, _set_vrfRidAutoSel)
  nexthopThirdParty = __builtin__.property(_get_nexthopThirdParty, _set_nexthopThirdParty)
  summaryAutomatic = __builtin__.property(_get_summaryAutomatic, _set_summaryAutomatic)
  autoFrrEnable = __builtin__.property(_get_autoFrrEnable, _set_autoFrrEnable)
  loadBalancingAsPathIgnore = __builtin__.property(_get_loadBalancingAsPathIgnore, _set_loadBalancingAsPathIgnore)
  ribOnlyEnable = __builtin__.property(_get_ribOnlyEnable, _set_ribOnlyEnable)
  ribOnlyPolicyName = __builtin__.property(_get_ribOnlyPolicyName, _set_ribOnlyPolicyName)
  activeRouteAdvertise = __builtin__.property(_get_activeRouteAdvertise, _set_activeRouteAdvertise)
  asPathNeglect = __builtin__.property(_get_asPathNeglect, _set_asPathNeglect)
  medNoneAsMaximum = __builtin__.property(_get_medNoneAsMaximum, _set_medNoneAsMaximum)
  routerIdNeglect = __builtin__.property(_get_routerIdNeglect, _set_routerIdNeglect)
  igpMetricIgnore = __builtin__.property(_get_igpMetricIgnore, _set_igpMetricIgnore)
  alwaysCompareMed = __builtin__.property(_get_alwaysCompareMed, _set_alwaysCompareMed)
  determinMed = __builtin__.property(_get_determinMed, _set_determinMed)
  preferenceExternal = __builtin__.property(_get_preferenceExternal, _set_preferenceExternal)
  preferenceInternal = __builtin__.property(_get_preferenceInternal, _set_preferenceInternal)
  preferenceLocal = __builtin__.property(_get_preferenceLocal, _set_preferenceLocal)
  prefrencePolicyName = __builtin__.property(_get_prefrencePolicyName, _set_prefrencePolicyName)
  reflectBetweenClient = __builtin__.property(_get_reflectBetweenClient, _set_reflectBetweenClient)
  reflectorClusterId = __builtin__.property(_get_reflectorClusterId, _set_reflectorClusterId)
  reflectorClusterIpv4 = __builtin__.property(_get_reflectorClusterIpv4, _set_reflectorClusterIpv4)
  rrFilterNumber = __builtin__.property(_get_rrFilterNumber, _set_rrFilterNumber)
  policyVpnTarget = __builtin__.property(_get_policyVpnTarget, _set_policyVpnTarget)
  nextHopSelDependType = __builtin__.property(_get_nextHopSelDependType, _set_nextHopSelDependType)
  nhpRelayRoutePolicyName = __builtin__.property(_get_nhpRelayRoutePolicyName, _set_nhpRelayRoutePolicyName)
  ebgpIfSensitive = __builtin__.property(_get_ebgpIfSensitive, _set_ebgpIfSensitive)
  ibgpIfSensitive = __builtin__.property(_get_ibgpIfSensitive, _set_ibgpIfSensitive)
  reflectChgPath = __builtin__.property(_get_reflectChgPath, _set_reflectChgPath)
  slowPeerDet = __builtin__.property(_get_slowPeerDet, _set_slowPeerDet)
  slowPeerThVal = __builtin__.property(_get_slowPeerThVal, _set_slowPeerThVal)
  addPathSelNum = __builtin__.property(_get_addPathSelNum, _set_addPathSelNum)
  routeSelDelay = __builtin__.property(_get_routeSelDelay, _set_routeSelDelay)
  originAsValidEnable = __builtin__.property(_get_originAsValidEnable, _set_originAsValidEnable)
  originAsValid = __builtin__.property(_get_originAsValid, _set_originAsValid)
  allowInvalidAs = __builtin__.property(_get_allowInvalidAs, _set_allowInvalidAs)
  policyExtCommEnable = __builtin__.property(_get_policyExtCommEnable, _set_policyExtCommEnable)
  policyQPPBEnable = __builtin__.property(_get_policyQPPBEnable, _set_policyQPPBEnable)
  supernetUniAdv = __builtin__.property(_get_supernetUniAdv, _set_supernetUniAdv)
  supernetLabelAdv = __builtin__.property(_get_supernetLabelAdv, _set_supernetLabelAdv)
  ingressLspPolicyName = __builtin__.property(_get_ingressLspPolicyName, _set_ingressLspPolicyName)
  originatorPrior = __builtin__.property(_get_originatorPrior, _set_originatorPrior)
  lowestPriority = __builtin__.property(_get_lowestPriority, _set_lowestPriority)
  relayDelayEnable = __builtin__.property(_get_relayDelayEnable, _set_relayDelayEnable)
  irbAsymmetric = __builtin__.property(_get_irbAsymmetric, _set_irbAsymmetric)
  peerGroupAFs = __builtin__.property(_get_peerGroupAFs, _set_peerGroupAFs) # type: yc_peerGroupAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerGroupAFs
  peerAFs = __builtin__.property(_get_peerAFs, _set_peerAFs) # type: yc_peerAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_peerAFs
  importRoutes = __builtin__.property(_get_importRoutes, _set_importRoutes) # type: yc_importRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_importRoutes
  networkRoutes = __builtin__.property(_get_networkRoutes, _set_networkRoutes) # type: yc_networkRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_networkRoutes
  aggregateRoutes = __builtin__.property(_get_aggregateRoutes, _set_aggregateRoutes) # type: yc_aggregateRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_aggregateRoutes
  dampRoutes = __builtin__.property(_get_dampRoutes, _set_dampRoutes) # type: yc_dampRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_dampRoutes
  filterPolicys = __builtin__.property(_get_filterPolicys, _set_filterPolicys) # type: yc_filterPolicys_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_filterPolicys
  instanceImports = __builtin__.property(_get_instanceImports, _set_instanceImports) # type: yc_instanceImports_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_instanceImports
  bgpAdvRoutes = __builtin__.property(_get_bgpAdvRoutes, _set_bgpAdvRoutes) # type: yc_bgpAdvRoutes_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF_bgpAdvRoutes


  _pyangbind_elements = OrderedDict([('afType', afType), ('nexthopDelayTime', nexthopDelayTime), ('noCriticalNexthopDelayTime', noCriticalNexthopDelayTime), ('vrfAsNum', vrfAsNum), ('maxLoadIbgpNum', maxLoadIbgpNum), ('ibgpEcmpNexthopChanged', ibgpEcmpNexthopChanged), ('maxLoadEbgpNum', maxLoadEbgpNum), ('ebgpEcmpNexthopChanged', ebgpEcmpNexthopChanged), ('maximumLoadBalance', maximumLoadBalance), ('ecmpNexthopChanged', ecmpNexthopChanged), ('eibgpLoadBalan', eibgpLoadBalan), ('eibgpEcmpNexthopChanged', eibgpEcmpNexthopChanged), ('defaultLocalPref', defaultLocalPref), ('defaultMed', defaultMed), ('defaultRtImportEnable', defaultRtImportEnable), ('loadBalancingAsPathRelax', loadBalancingAsPathRelax), ('routerId', routerId), ('vrfRidAutoSel', vrfRidAutoSel), ('nexthopThirdParty', nexthopThirdParty), ('summaryAutomatic', summaryAutomatic), ('autoFrrEnable', autoFrrEnable), ('loadBalancingAsPathIgnore', loadBalancingAsPathIgnore), ('ribOnlyEnable', ribOnlyEnable), ('ribOnlyPolicyName', ribOnlyPolicyName), ('activeRouteAdvertise', activeRouteAdvertise), ('asPathNeglect', asPathNeglect), ('medNoneAsMaximum', medNoneAsMaximum), ('routerIdNeglect', routerIdNeglect), ('igpMetricIgnore', igpMetricIgnore), ('alwaysCompareMed', alwaysCompareMed), ('determinMed', determinMed), ('preferenceExternal', preferenceExternal), ('preferenceInternal', preferenceInternal), ('preferenceLocal', preferenceLocal), ('prefrencePolicyName', prefrencePolicyName), ('reflectBetweenClient', reflectBetweenClient), ('reflectorClusterId', reflectorClusterId), ('reflectorClusterIpv4', reflectorClusterIpv4), ('rrFilterNumber', rrFilterNumber), ('policyVpnTarget', policyVpnTarget), ('nextHopSelDependType', nextHopSelDependType), ('nhpRelayRoutePolicyName', nhpRelayRoutePolicyName), ('ebgpIfSensitive', ebgpIfSensitive), ('ibgpIfSensitive', ibgpIfSensitive), ('reflectChgPath', reflectChgPath), ('slowPeerDet', slowPeerDet), ('slowPeerThVal', slowPeerThVal), ('addPathSelNum', addPathSelNum), ('routeSelDelay', routeSelDelay), ('originAsValidEnable', originAsValidEnable), ('originAsValid', originAsValid), ('allowInvalidAs', allowInvalidAs), ('policyExtCommEnable', policyExtCommEnable), ('policyQPPBEnable', policyQPPBEnable), ('supernetUniAdv', supernetUniAdv), ('supernetLabelAdv', supernetLabelAdv), ('ingressLspPolicyName', ingressLspPolicyName), ('originatorPrior', originatorPrior), ('lowestPriority', lowestPriority), ('relayDelayEnable', relayDelayEnable), ('irbAsymmetric', irbAsymmetric), ('peerGroupAFs', peerGroupAFs), ('peerAFs', peerAFs), ('importRoutes', importRoutes), ('networkRoutes', networkRoutes), ('aggregateRoutes', aggregateRoutes), ('dampRoutes', dampRoutes), ('filterPolicys', filterPolicys), ('instanceImports', instanceImports), ('bgpAdvRoutes', bgpAdvRoutes), ])


class yc_bgpMultiVrfAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP address family instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiVrfAF',)

  _yang_name = 'bgpMultiVrfAFs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiVrfAF = YANGDynClass(base=YANGListType("afType",yc_bgpMultiVrfAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF, yang_name="bgpMultiVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpMultiVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf', 'bgpMultiVrfAFs']

  def _get_bgpMultiVrfAF(self):
    """
    Getter method for bgpMultiVrfAF, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF (list)

    YANG Description: BGP address family instance.
    """
    return self.__bgpMultiVrfAF
      
  def _set_bgpMultiVrfAF(self, v, load=False):
    """
    Setter method for bgpMultiVrfAF, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs/bgpMultiVrfAF (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiVrfAF is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiVrfAF() directly.

    YANG Description: BGP address family instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afType",yc_bgpMultiVrfAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF, yang_name="bgpMultiVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpMultiVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiVrfAF must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afType",yc_bgpMultiVrfAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF, yang_name="bgpMultiVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpMultiVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpMultiVrfAF = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiVrfAF(self):
    self.__bgpMultiVrfAF = YANGDynClass(base=YANGListType("afType",yc_bgpMultiVrfAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF, yang_name="bgpMultiVrfAF", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afType', extensions=None), is_container='list', yang_name="bgpMultiVrfAF", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpMultiVrfAF = __builtin__.property(_get_bgpMultiVrfAF, _set_bgpMultiVrfAF) # type: yc_bgpMultiVrfAF_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs_bgpMultiVrfAF


  _pyangbind_elements = OrderedDict([('bgpMultiVrfAF', bgpMultiVrfAF), ])


class yc_bgpMultiVrf_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Create a BGP instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiSiteName','__vrfName','__vrfRidAutoSel','__routerId','__effectRouterId','__keepaliveTime','__holdTime','__minHoldTime','__connRetryTime','__defaultAfType','__bgpMultiPeerGroups','__bgpMultiPeers','__bgpMultiVrfAFs',)

  _yang_name = 'bgpMultiVrf'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiSiteName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    self.__vrfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__vrfRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__routerId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__effectRouterId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__keepaliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    self.__defaultAfType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommVrfPrefixType', is_config=True)
    self.__bgpMultiPeerGroups = YANGDynClass(base=yc_bgpMultiPeerGroups_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups, is_container='container', yang_name="bgpMultiPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpMultiPeers = YANGDynClass(base=yc_bgpMultiPeers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers, is_container='container', yang_name="bgpMultiPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpMultiVrfAFs = YANGDynClass(base=yc_bgpMultiVrfAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs, is_container='container', yang_name="bgpMultiVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs', 'bgpMultiVrf']

  def _get_bgpMultiSiteName(self):
    """
    Getter method for bgpMultiSiteName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiSiteName (leafref)

    YANG Description: Name of BGP Site.
    """
    return self.__bgpMultiSiteName
      
  def _set_bgpMultiSiteName(self, v, load=False):
    """
    Setter method for bgpMultiSiteName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiSiteName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiSiteName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiSiteName() directly.

    YANG Description: Name of BGP Site.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiSiteName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__bgpMultiSiteName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiSiteName(self):
    self.__bgpMultiSiteName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bgpMultiSiteName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='leafref', is_config=True)


  def _get_vrfName(self):
    """
    Getter method for vrfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/vrfName (string)

    YANG Description: Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. 
    """
    return self.__vrfName
      
  def _set_vrfName(self, v, load=False):
    """
    Setter method for vrfName, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/vrfName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfName() directly.

    YANG Description: Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__vrfName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfName(self):
    self.__vrfName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vrfName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_vrfRidAutoSel(self):
    """
    Getter method for vrfRidAutoSel, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/vrfRidAutoSel (boolean)

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    return self.__vrfRidAutoSel
      
  def _set_vrfRidAutoSel(self, v, load=False):
    """
    Setter method for vrfRidAutoSel, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/vrfRidAutoSel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfRidAutoSel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfRidAutoSel() directly.

    YANG Description: By default, a BGP VPN instance does not automatically select a router ID. If a BGP VPN instance is not enabled to select a router ID, a router ID can be configured for the BGP VPN instance. If no router ID is configured for the BGP VPN instance, the BGP VPN instance inherits the router ID of the public network instance. If a BGP VPN instance is enabled to select a router ID, it uses the address of an interface bound to a VPN as the router ID based on the following rules:
1. If Loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the Loopback interfaces is selected as the router ID.
2. If there is no Loopback interface configured with an IP address, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfRidAutoSel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__vrfRidAutoSel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfRidAutoSel(self):
    self.__vrfRidAutoSel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vrfRidAutoSel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_routerId(self):
    """
    Getter method for routerId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/routerId (inet:ipv4-address-no-zone)

    YANG Description: ID of a router that is in IPv4 address format. Certain dynamic routing protocols require a router ID. If no router ID is specified for a router when these protocols are enabled, the router ID in the RM module is used by default. The default router ID in the RM module is 0.0.0.0 when the router is not configured with any interface.
The rules for selecting a router ID are as follows:
1. If you set a router ID through this configuration, the set router ID is used. If the router ID is not set, you need to select a router ID according to the following rules:
(1) If loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the loopback interfaces is selected as the router ID.
(2) If no loopback interface configured with an IP address exists, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
The router ID is reselected only when the interface address that is selected as the router ID is deleted or changed. The router ID is not reselected in any of the following cases:
a. The interface is Down.
b. A loopback interface is configured when the IP address of a non-loopback interface is selected as the router ID.
c. A larger IP address of an interface is configured.
2. Each VPN instance selects the router ID from the addresses of the interfaces of the VPN instance according to the preceding rules.
3. When both the AMB and SMB exist on the router, the system backs up the router ID set through the related command and the router ID that is selected from IP addresses of the interfaces. After the active/standby switchover is performed, the system checks the validity of the router ID selected from the interface addresses. If the router ID is invalid, the system reselects a router ID.
    """
    return self.__routerId
      
  def _set_routerId(self, v, load=False):
    """
    Setter method for routerId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/routerId (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routerId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routerId() directly.

    YANG Description: ID of a router that is in IPv4 address format. Certain dynamic routing protocols require a router ID. If no router ID is specified for a router when these protocols are enabled, the router ID in the RM module is used by default. The default router ID in the RM module is 0.0.0.0 when the router is not configured with any interface.
The rules for selecting a router ID are as follows:
1. If you set a router ID through this configuration, the set router ID is used. If the router ID is not set, you need to select a router ID according to the following rules:
(1) If loopback interfaces configured with IP addresses exist, the largest IP address among the IP addresses of the loopback interfaces is selected as the router ID.
(2) If no loopback interface configured with an IP address exists, the largest IP address among the IP addresses of other interfaces is selected as the router ID, regardless of whether the interface is Up.
The router ID is reselected only when the interface address that is selected as the router ID is deleted or changed. The router ID is not reselected in any of the following cases:
a. The interface is Down.
b. A loopback interface is configured when the IP address of a non-loopback interface is selected as the router ID.
c. A larger IP address of an interface is configured.
2. Each VPN instance selects the router ID from the addresses of the interfaces of the VPN instance according to the preceding rules.
3. When both the AMB and SMB exist on the router, the system backs up the router ID set through the related command and the router ID that is selected from IP addresses of the interfaces. After the active/standby switchover is performed, the system checks the validity of the router ID selected from the interface addresses. If the router ID is invalid, the system reselects a router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routerId must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__routerId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routerId(self):
    self.__routerId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_effectRouterId(self):
    """
    Getter method for effectRouterId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/effectRouterId (inet:ipv4-address-no-zone)

    YANG Description: Router ID that takes effect.
    """
    return self.__effectRouterId
      
  def _set_effectRouterId(self, v, load=False):
    """
    Setter method for effectRouterId, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/effectRouterId (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effectRouterId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effectRouterId() directly.

    YANG Description: Router ID that takes effect.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effectRouterId must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__effectRouterId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effectRouterId(self):
    self.__effectRouterId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), default=six.text_type("0.0.0.0"), is_leaf=True, yang_name="effectRouterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_keepaliveTime(self):
    """
    Getter method for keepaliveTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/keepaliveTime (uint32)

    YANG Description: If the value of a timer changes, the BGP peer relationship between the routers is disconnected. This is because the peers need to re-negotiate the Keepalive time and hold time. Therefore, confirm the action before you change the value of the timer. The Keepalive time should be at least three times of the hold time.
    """
    return self.__keepaliveTime
      
  def _set_keepaliveTime(self, v, load=False):
    """
    Setter method for keepaliveTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/keepaliveTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepaliveTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepaliveTime() directly.

    YANG Description: If the value of a timer changes, the BGP peer relationship between the routers is disconnected. This is because the peers need to re-negotiate the Keepalive time and hold time. Therefore, confirm the action before you change the value of the timer. The Keepalive time should be at least three times of the hold time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepaliveTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__keepaliveTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepaliveTime(self):
    self.__keepaliveTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="keepaliveTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/holdTime (uint32)

    YANG Description: Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535. When setting keepalive-time and hold-time, note the following:
1. The values of keepalive-time and hold-time cannot both be 0. Otherwise, the BGP timer becomes invalid. That is, BGP does not detect link faults according to the timer.
2. The value of hold-time is much greater than that of keepalive-time, such as, keepalive 1 and hold 65535. If the value of hold-time is too large, BGP cannot detect link faults timely.
The priority of a timer is lower than that of a peer timer.
After a connection is established between peers, the values of keepalive-time and hold-time are negotiated by the peers. The smaller value of hold-time contained in Open packets of both peers is taken as the value of hold-time. The smaller value of the locally set value of keepalive-time and one third of the value of hold-time is taken as the value of keepalive-time.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535. When setting keepalive-time and hold-time, note the following:
1. The values of keepalive-time and hold-time cannot both be 0. Otherwise, the BGP timer becomes invalid. That is, BGP does not detect link faults according to the timer.
2. The value of hold-time is much greater than that of keepalive-time, such as, keepalive 1 and hold 65535. If the value of hold-time is too large, BGP cannot detect link faults timely.
The priority of a timer is lower than that of a peer timer.
After a connection is established between peers, the values of keepalive-time and hold-time are negotiated by the peers. The smaller value of hold-time contained in Open packets of both peers is taken as the value of hold-time. The smaller value of the locally set value of keepalive-time and one third of the value of hold-time is taken as the value of keepalive-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(180), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_minHoldTime(self):
    """
    Getter method for minHoldTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/minHoldTime (uint32)

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    return self.__minHoldTime
      
  def _set_minHoldTime(self, v, load=False):
    """
    Setter method for minHoldTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/minHoldTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minHoldTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minHoldTime() directly.

    YANG Description: The minimum hold time is either 0 or an integer ranging from 20 to 65535, in seconds. If the value is changed, the new value takes effect since the next peer relationship establishment. During the peer relationship establishment, the local device checks the hold time of the remote end. If the hold time is less than the minimum hold time, the local device sends an error packet with error code 02 and subcode 06, and the peer relationship fails to be established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minHoldTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__minHoldTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minHoldTime(self):
    self.__minHoldTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="minHoldTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint32', is_config=True)


  def _get_connRetryTime(self):
    """
    Getter method for connRetryTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/connRetryTime (uint16)

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    return self.__connRetryTime
      
  def _set_connRetryTime(self, v, load=False):
    """
    Setter method for connRetryTime, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/connRetryTime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connRetryTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connRetryTime() directly.

    YANG Description: ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connRetryTime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connRetryTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connRetryTime(self):
    self.__connRetryTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(32), is_leaf=True, yang_name="connRetryTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='uint16', is_config=True)


  def _get_defaultAfType(self):
    """
    Getter method for defaultAfType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/defaultAfType (bgpmultiinstcommVrfPrefixType)

    YANG Description: Type of a created address family, which can be IPv4 unicast or IPv6 unicast. The default type is IPv4 unicast. This option takes effect only when a BGP instance is created for the first time. 
    """
    return self.__defaultAfType
      
  def _set_defaultAfType(self, v, load=False):
    """
    Setter method for defaultAfType, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/defaultAfType (bgpmultiinstcommVrfPrefixType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultAfType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultAfType() directly.

    YANG Description: Type of a created address family, which can be IPv4 unicast or IPv6 unicast. The default type is IPv4 unicast. This option takes effect only when a BGP instance is created for the first time. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommVrfPrefixType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultAfType must be of a type compatible with bgpmultiinstcommVrfPrefixType""",
          'defined-type': "huawei-bgp:bgpmultiinstcommVrfPrefixType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommVrfPrefixType', is_config=True)""",
        })

    self.__defaultAfType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultAfType(self):
    self.__defaultAfType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {}, 'ipv6uni': {}},), default=six.text_type("ipv4uni"), is_leaf=True, yang_name="defaultAfType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='bgpmultiinstcommVrfPrefixType', is_config=True)


  def _get_bgpMultiPeerGroups(self):
    """
    Getter method for bgpMultiPeerGroups, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups (container)

    YANG Description: List of BGP peer groups. The BGP peer groups can help you simplify the configurations. If you want to perform the same configuration for several peers, you can create a peer group and then configure the peer group. After you add these peers to the peer group, all these peers will have the same configurations as the peer group. 
    """
    return self.__bgpMultiPeerGroups
      
  def _set_bgpMultiPeerGroups(self, v, load=False):
    """
    Setter method for bgpMultiPeerGroups, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeerGroups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiPeerGroups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiPeerGroups() directly.

    YANG Description: List of BGP peer groups. The BGP peer groups can help you simplify the configurations. If you want to perform the same configuration for several peers, you can create a peer group and then configure the peer group. After you add these peers to the peer group, all these peers will have the same configurations as the peer group. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpMultiPeerGroups_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups, is_container='container', yang_name="bgpMultiPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiPeerGroups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpMultiPeerGroups_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups, is_container='container', yang_name="bgpMultiPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpMultiPeerGroups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiPeerGroups(self):
    self.__bgpMultiPeerGroups = YANGDynClass(base=yc_bgpMultiPeerGroups_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups, is_container='container', yang_name="bgpMultiPeerGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpMultiPeers(self):
    """
    Getter method for bgpMultiPeers, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers (container)

    YANG Description: List of BGP peers.
    """
    return self.__bgpMultiPeers
      
  def _set_bgpMultiPeers(self, v, load=False):
    """
    Setter method for bgpMultiPeers, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiPeers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiPeers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiPeers() directly.

    YANG Description: List of BGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpMultiPeers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers, is_container='container', yang_name="bgpMultiPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiPeers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpMultiPeers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers, is_container='container', yang_name="bgpMultiPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpMultiPeers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiPeers(self):
    self.__bgpMultiPeers = YANGDynClass(base=yc_bgpMultiPeers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers, is_container='container', yang_name="bgpMultiPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpMultiVrfAFs(self):
    """
    Getter method for bgpMultiVrfAFs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs (container)

    YANG Description: List of BGP address family instances.
    """
    return self.__bgpMultiVrfAFs
      
  def _set_bgpMultiVrfAFs(self, v, load=False):
    """
    Setter method for bgpMultiVrfAFs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf/bgpMultiVrfAFs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiVrfAFs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiVrfAFs() directly.

    YANG Description: List of BGP address family instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpMultiVrfAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs, is_container='container', yang_name="bgpMultiVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiVrfAFs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpMultiVrfAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs, is_container='container', yang_name="bgpMultiVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpMultiVrfAFs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiVrfAFs(self):
    self.__bgpMultiVrfAFs = YANGDynClass(base=yc_bgpMultiVrfAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs, is_container='container', yang_name="bgpMultiVrfAFs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  bgpMultiSiteName = __builtin__.property(_get_bgpMultiSiteName, _set_bgpMultiSiteName)
  vrfName = __builtin__.property(_get_vrfName, _set_vrfName)
  vrfRidAutoSel = __builtin__.property(_get_vrfRidAutoSel, _set_vrfRidAutoSel)
  routerId = __builtin__.property(_get_routerId, _set_routerId)
  effectRouterId = __builtin__.property(_get_effectRouterId)
  keepaliveTime = __builtin__.property(_get_keepaliveTime, _set_keepaliveTime)
  holdTime = __builtin__.property(_get_holdTime, _set_holdTime)
  minHoldTime = __builtin__.property(_get_minHoldTime, _set_minHoldTime)
  connRetryTime = __builtin__.property(_get_connRetryTime, _set_connRetryTime)
  defaultAfType = __builtin__.property(_get_defaultAfType, _set_defaultAfType)
  bgpMultiPeerGroups = __builtin__.property(_get_bgpMultiPeerGroups, _set_bgpMultiPeerGroups) # type: yc_bgpMultiPeerGroups_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeerGroups
  bgpMultiPeers = __builtin__.property(_get_bgpMultiPeers, _set_bgpMultiPeers) # type: yc_bgpMultiPeers_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiPeers
  bgpMultiVrfAFs = __builtin__.property(_get_bgpMultiVrfAFs, _set_bgpMultiVrfAFs) # type: yc_bgpMultiVrfAFs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf_bgpMultiVrfAFs


  _pyangbind_elements = OrderedDict([('bgpMultiSiteName', bgpMultiSiteName), ('vrfName', vrfName), ('vrfRidAutoSel', vrfRidAutoSel), ('routerId', routerId), ('effectRouterId', effectRouterId), ('keepaliveTime', keepaliveTime), ('holdTime', holdTime), ('minHoldTime', minHoldTime), ('connRetryTime', connRetryTime), ('defaultAfType', defaultAfType), ('bgpMultiPeerGroups', bgpMultiPeerGroups), ('bgpMultiPeers', bgpMultiPeers), ('bgpMultiVrfAFs', bgpMultiVrfAFs), ])


class yc_bgpMultiVrfs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm/bgpMultiVrfs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the list of all BGP instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiVrf',)

  _yang_name = 'bgpMultiVrfs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiVrf = YANGDynClass(base=YANGListType("bgpMultiSiteName vrfName",yc_bgpMultiVrf_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf, yang_name="bgpMultiVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName vrfName', extensions=None), is_container='list', yang_name="bgpMultiVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm', 'bgpMultiVrfs']

  def _get_bgpMultiVrf(self):
    """
    Getter method for bgpMultiVrf, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf (list)

    YANG Description: Create a BGP instance.
    """
    return self.__bgpMultiVrf
      
  def _set_bgpMultiVrf(self, v, load=False):
    """
    Setter method for bgpMultiVrf, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs/bgpMultiVrf (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiVrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiVrf() directly.

    YANG Description: Create a BGP instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("bgpMultiSiteName vrfName",yc_bgpMultiVrf_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf, yang_name="bgpMultiVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName vrfName', extensions=None), is_container='list', yang_name="bgpMultiVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiVrf must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("bgpMultiSiteName vrfName",yc_bgpMultiVrf_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf, yang_name="bgpMultiVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName vrfName', extensions=None), is_container='list', yang_name="bgpMultiVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__bgpMultiVrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiVrf(self):
    self.__bgpMultiVrf = YANGDynClass(base=YANGListType("bgpMultiSiteName vrfName",yc_bgpMultiVrf_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf, yang_name="bgpMultiVrf", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='bgpMultiSiteName vrfName', extensions=None), is_container='list', yang_name="bgpMultiVrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  bgpMultiVrf = __builtin__.property(_get_bgpMultiVrf, _set_bgpMultiVrf) # type: yc_bgpMultiVrf_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs_bgpMultiVrf


  _pyangbind_elements = OrderedDict([('bgpMultiVrf', bgpMultiVrf), ])


class yc_bgpmultiinstcomm_huawei_bgp__bgp_bgpmultiinstcomm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/bgpmultiinstcomm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Universal BGP multi-instance configurations that contain the basic BGP configurations and the query information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpMultiSites','__bgpMultiVrfs',)

  _yang_name = 'bgpmultiinstcomm'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpMultiSites = YANGDynClass(base=yc_bgpMultiSites_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites, is_container='container', yang_name="bgpMultiSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpMultiVrfs = YANGDynClass(base=yc_bgpMultiVrfs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs, is_container='container', yang_name="bgpMultiVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'bgpmultiinstcomm']

  def _get_bgpMultiSites(self):
    """
    Getter method for bgpMultiSites, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites (container)

    YANG Description: List of BGP site.
    """
    return self.__bgpMultiSites
      
  def _set_bgpMultiSites(self, v, load=False):
    """
    Setter method for bgpMultiSites, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiSites (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiSites is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiSites() directly.

    YANG Description: List of BGP site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpMultiSites_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites, is_container='container', yang_name="bgpMultiSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiSites must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpMultiSites_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites, is_container='container', yang_name="bgpMultiSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpMultiSites = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiSites(self):
    self.__bgpMultiSites = YANGDynClass(base=yc_bgpMultiSites_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites, is_container='container', yang_name="bgpMultiSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpMultiVrfs(self):
    """
    Getter method for bgpMultiVrfs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs (container)

    YANG Description: Configure the list of all BGP instances.
    """
    return self.__bgpMultiVrfs
      
  def _set_bgpMultiVrfs(self, v, load=False):
    """
    Setter method for bgpMultiVrfs, mapped from YANG variable /bgp/bgpmultiinstcomm/bgpMultiVrfs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpMultiVrfs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpMultiVrfs() directly.

    YANG Description: Configure the list of all BGP instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpMultiVrfs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs, is_container='container', yang_name="bgpMultiVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpMultiVrfs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpMultiVrfs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs, is_container='container', yang_name="bgpMultiVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpMultiVrfs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpMultiVrfs(self):
    self.__bgpMultiVrfs = YANGDynClass(base=yc_bgpMultiVrfs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs, is_container='container', yang_name="bgpMultiVrfs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  bgpMultiSites = __builtin__.property(_get_bgpMultiSites, _set_bgpMultiSites) # type: yc_bgpMultiSites_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiSites
  bgpMultiVrfs = __builtin__.property(_get_bgpMultiVrfs, _set_bgpMultiVrfs) # type: yc_bgpMultiVrfs_huawei_bgp__bgp_bgpmultiinstcomm_bgpMultiVrfs


  _pyangbind_elements = OrderedDict([('bgpMultiSites', bgpMultiSites), ('bgpMultiVrfs', bgpMultiVrfs), ])


class yc_bgp_huawei_bgp__bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgpcomm','__bgpmultiinstcomm',)

  _yang_name = 'bgp'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgpcomm = YANGDynClass(base=yc_bgpcomm_huawei_bgp__bgp_bgpcomm, is_container='container', yang_name="bgpcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__bgpmultiinstcomm = YANGDynClass(base=yc_bgpmultiinstcomm_huawei_bgp__bgp_bgpmultiinstcomm, is_container='container', yang_name="bgpmultiinstcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp']

  def _get_bgpcomm(self):
    """
    Getter method for bgpcomm, mapped from YANG variable /bgp/bgpcomm (container)

    YANG Description: Universal BGP configurations that contain the basic BGP configurations and the query information.
    """
    return self.__bgpcomm
      
  def _set_bgpcomm(self, v, load=False):
    """
    Setter method for bgpcomm, mapped from YANG variable /bgp/bgpcomm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpcomm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpcomm() directly.

    YANG Description: Universal BGP configurations that contain the basic BGP configurations and the query information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpcomm_huawei_bgp__bgp_bgpcomm, is_container='container', yang_name="bgpcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpcomm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpcomm_huawei_bgp__bgp_bgpcomm, is_container='container', yang_name="bgpcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpcomm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpcomm(self):
    self.__bgpcomm = YANGDynClass(base=yc_bgpcomm_huawei_bgp__bgp_bgpcomm, is_container='container', yang_name="bgpcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_bgpmultiinstcomm(self):
    """
    Getter method for bgpmultiinstcomm, mapped from YANG variable /bgp/bgpmultiinstcomm (container)

    YANG Description: Universal BGP multi-instance configurations that contain the basic BGP configurations and the query information.
    """
    return self.__bgpmultiinstcomm
      
  def _set_bgpmultiinstcomm(self, v, load=False):
    """
    Setter method for bgpmultiinstcomm, mapped from YANG variable /bgp/bgpmultiinstcomm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgpmultiinstcomm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgpmultiinstcomm() directly.

    YANG Description: Universal BGP multi-instance configurations that contain the basic BGP configurations and the query information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgpmultiinstcomm_huawei_bgp__bgp_bgpmultiinstcomm, is_container='container', yang_name="bgpmultiinstcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgpmultiinstcomm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgpmultiinstcomm_huawei_bgp__bgp_bgpmultiinstcomm, is_container='container', yang_name="bgpmultiinstcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgpmultiinstcomm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgpmultiinstcomm(self):
    self.__bgpmultiinstcomm = YANGDynClass(base=yc_bgpmultiinstcomm_huawei_bgp__bgp_bgpmultiinstcomm, is_container='container', yang_name="bgpmultiinstcomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  bgpcomm = __builtin__.property(_get_bgpcomm, _set_bgpcomm) # type: yc_bgpcomm_huawei_bgp__bgp_bgpcomm
  bgpmultiinstcomm = __builtin__.property(_get_bgpmultiinstcomm, _set_bgpmultiinstcomm) # type: yc_bgpmultiinstcomm_huawei_bgp__bgp_bgpmultiinstcomm


  _pyangbind_elements = OrderedDict([('bgpcomm', bgpcomm), ('bgpmultiinstcomm', bgpmultiinstcomm), ])


class huawei_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /huawei-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'huawei-bgp'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems.
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp) # type: yc_bgp_huawei_bgp__bgp


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


class huawei_bgp_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-action - based on the path /huawei-bgp-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: the submodule of bgp : bgp_action
  """
  _pyangbind_elements = {}

  

class huawei_bgp_bgpcomm_action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-bgpcomm-action - based on the path /huawei-bgp-bgpcomm-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: the common actions of bgp
  """
  _pyangbind_elements = {}

  

class huawei_bgp_bgpcomm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-bgpcomm - based on the path /huawei-bgp-bgpcomm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Description of submodule bgp_bgpcomm
  """
  _pyangbind_elements = {}

  

class huawei_bgp_bgpmultiinstcomm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-bgpmultiinstcomm - based on the path /huawei-bgp-bgpmultiinstcomm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Description of submodule bgp_bgpmultiinstcomm
  """
  _pyangbind_elements = {}

  

class huawei_bgp_rpd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-rpd - based on the path /huawei-bgp-rpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Description of submodule bgp_bgpcomm
  """
  _pyangbind_elements = {}

  

class huawei_bgp_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-type - based on the path /huawei-bgp-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: the submodule of bgp:bgp_common_type
  """
  _pyangbind_elements = {}

  

class huawei_bgp_notification(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-notification - based on the path /huawei-bgp-notification. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: notification of bgp
  """
  _pyangbind_elements = {}

  

