# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_isLspAgeRefresh_huawei_isiscomm__isiscomm_isSites_isSite_isLspAgeRefresh(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLspAgeRefresh. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Refresh the remaining-lifetime field of a LSP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLspAgeRefreshEnable','__lspAgeRefreshMaxAge','__lspAgeRefreshValue',)

  _yang_name = 'isLspAgeRefresh'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLspAgeRefreshEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLspAgeRefreshEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__lspAgeRefreshMaxAge = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspAgeRefreshMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__lspAgeRefreshValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1200), is_leaf=True, yang_name="lspAgeRefreshValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLspAgeRefresh']

  def _get_isLspAgeRefreshEnable(self):
    """
    Getter method for isLspAgeRefreshEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh/isLspAgeRefreshEnable (boolean)

    YANG Description: Enable refresh remaining-lifetime field. By default, the feature is disabled.
    """
    return self.__isLspAgeRefreshEnable
      
  def _set_isLspAgeRefreshEnable(self, v, load=False):
    """
    Setter method for isLspAgeRefreshEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh/isLspAgeRefreshEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLspAgeRefreshEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLspAgeRefreshEnable() directly.

    YANG Description: Enable refresh remaining-lifetime field. By default, the feature is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLspAgeRefreshEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLspAgeRefreshEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLspAgeRefreshEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__isLspAgeRefreshEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLspAgeRefreshEnable(self):
    self.__isLspAgeRefreshEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isLspAgeRefreshEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_lspAgeRefreshMaxAge(self):
    """
    Getter method for lspAgeRefreshMaxAge, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh/lspAgeRefreshMaxAge (boolean)

    YANG Description: Use max-age as remaining-lifetime refresh value.
    """
    return self.__lspAgeRefreshMaxAge
      
  def _set_lspAgeRefreshMaxAge(self, v, load=False):
    """
    Setter method for lspAgeRefreshMaxAge, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh/lspAgeRefreshMaxAge (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspAgeRefreshMaxAge is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspAgeRefreshMaxAge() directly.

    YANG Description: Use max-age as remaining-lifetime refresh value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspAgeRefreshMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspAgeRefreshMaxAge must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspAgeRefreshMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__lspAgeRefreshMaxAge = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspAgeRefreshMaxAge(self):
    self.__lspAgeRefreshMaxAge = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspAgeRefreshMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_lspAgeRefreshValue(self):
    """
    Getter method for lspAgeRefreshValue, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh/lspAgeRefreshValue (uint16)

    YANG Description: Set remaining-lifetime refresh value.
    """
    return self.__lspAgeRefreshValue
      
  def _set_lspAgeRefreshValue(self, v, load=False):
    """
    Setter method for lspAgeRefreshValue, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh/lspAgeRefreshValue (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspAgeRefreshValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspAgeRefreshValue() directly.

    YANG Description: Set remaining-lifetime refresh value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1200), is_leaf=True, yang_name="lspAgeRefreshValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspAgeRefreshValue must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1200), is_leaf=True, yang_name="lspAgeRefreshValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)""",
        })

    self.__lspAgeRefreshValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspAgeRefreshValue(self):
    self.__lspAgeRefreshValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1200), is_leaf=True, yang_name="lspAgeRefreshValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

  isLspAgeRefreshEnable = __builtin__.property(_get_isLspAgeRefreshEnable, _set_isLspAgeRefreshEnable)
  lspAgeRefreshMaxAge = __builtin__.property(_get_lspAgeRefreshMaxAge, _set_lspAgeRefreshMaxAge)
  lspAgeRefreshValue = __builtin__.property(_get_lspAgeRefreshValue, _set_lspAgeRefreshValue)


  _pyangbind_elements = OrderedDict([('isLspAgeRefreshEnable', isLspAgeRefreshEnable), ('lspAgeRefreshMaxAge', lspAgeRefreshMaxAge), ('lspAgeRefreshValue', lspAgeRefreshValue), ])


class yc_isBgpLs_huawei_isiscomm__isiscomm_isSites_isSite_isBgpLs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isBgpLs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable the Bgp-ls.
  """
  __slots__ = ('_path_helper', '_extmethods', '__l1BgpLsEnable','__l2BgpLsEnable','__identifier',)

  _yang_name = 'isBgpLs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__l1BgpLsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__l2BgpLsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isBgpLs']

  def _get_l1BgpLsEnable(self):
    """
    Getter method for l1BgpLsEnable, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs/l1BgpLsEnable (boolean)

    YANG Description: Enable Level 1 bgp-ls.
    """
    return self.__l1BgpLsEnable
      
  def _set_l1BgpLsEnable(self, v, load=False):
    """
    Setter method for l1BgpLsEnable, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs/l1BgpLsEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1BgpLsEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1BgpLsEnable() directly.

    YANG Description: Enable Level 1 bgp-ls.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1BgpLsEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__l1BgpLsEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1BgpLsEnable(self):
    self.__l1BgpLsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_l2BgpLsEnable(self):
    """
    Getter method for l2BgpLsEnable, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs/l2BgpLsEnable (boolean)

    YANG Description: Enable Level 2 bgp-ls.
    """
    return self.__l2BgpLsEnable
      
  def _set_l2BgpLsEnable(self, v, load=False):
    """
    Setter method for l2BgpLsEnable, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs/l2BgpLsEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2BgpLsEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2BgpLsEnable() directly.

    YANG Description: Enable Level 2 bgp-ls.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2BgpLsEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__l2BgpLsEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2BgpLsEnable(self):
    self.__l2BgpLsEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2BgpLsEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs/identifier (uint32)

    YANG Description: Set bgp-ls identifier.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs/identifier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: Set bgp-ls identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  l1BgpLsEnable = __builtin__.property(_get_l1BgpLsEnable, _set_l1BgpLsEnable)
  l2BgpLsEnable = __builtin__.property(_get_l2BgpLsEnable, _set_l2BgpLsEnable)
  identifier = __builtin__.property(_get_identifier, _set_identifier)


  _pyangbind_elements = OrderedDict([('l1BgpLsEnable', l1BgpLsEnable), ('l2BgpLsEnable', l2BgpLsEnable), ('identifier', identifier), ])


class yc_isLspGenIntelliTimer_huawei_isiscomm__isiscomm_isSites_isSite_isLspGenIntelliTimer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLspGenIntelliTimer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set an intelligent timer to generate LSPs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__level1LspGenMaxInterval','__level2LspGenMaxInterval','__level1LspGenInitInterval','__level2LspGenInitInterval','__level1LspGenIncrInterval','__level2LspGenIncrInterval',)

  _yang_name = 'isLspGenIntelliTimer'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__level1LspGenMaxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level1LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2LspGenMaxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level2LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1LspGenInitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2LspGenInitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1LspGenIncrInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2LspGenIncrInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLspGenIntelliTimer']

  def _get_level1LspGenMaxInterval(self):
    """
    Getter method for level1LspGenMaxInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level1LspGenMaxInterval (uint32)

    YANG Description: Set the maximum delay for generating level-1 LSPs with the same LSP ID. The value is an integer, expressed in seconds. The default value is 2.
    """
    return self.__level1LspGenMaxInterval
      
  def _set_level1LspGenMaxInterval(self, v, load=False):
    """
    Setter method for level1LspGenMaxInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level1LspGenMaxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1LspGenMaxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1LspGenMaxInterval() directly.

    YANG Description: Set the maximum delay for generating level-1 LSPs with the same LSP ID. The value is an integer, expressed in seconds. The default value is 2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level1LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1LspGenMaxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level1LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1LspGenMaxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1LspGenMaxInterval(self):
    self.__level1LspGenMaxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level1LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2LspGenMaxInterval(self):
    """
    Getter method for level2LspGenMaxInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level2LspGenMaxInterval (uint32)

    YANG Description: Set the maximum delay for generating level-2 LSPs with the same LSP ID. The value is an integer, expressed in seconds. The default value is 2.
    """
    return self.__level2LspGenMaxInterval
      
  def _set_level2LspGenMaxInterval(self, v, load=False):
    """
    Setter method for level2LspGenMaxInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level2LspGenMaxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2LspGenMaxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2LspGenMaxInterval() directly.

    YANG Description: Set the maximum delay for generating level-2 LSPs with the same LSP ID. The value is an integer, expressed in seconds. The default value is 2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level2LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2LspGenMaxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level2LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2LspGenMaxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2LspGenMaxInterval(self):
    self.__level2LspGenMaxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2), is_leaf=True, yang_name="level2LspGenMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1LspGenInitInterval(self):
    """
    Getter method for level1LspGenInitInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level1LspGenInitInterval (uint32)

    YANG Description: Set the delay for generating level-1 LSPs with the same LSP ID for the first time. The value is an integer, expressed in milliseconds. By default, this delay is not used.
    """
    return self.__level1LspGenInitInterval
      
  def _set_level1LspGenInitInterval(self, v, load=False):
    """
    Setter method for level1LspGenInitInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level1LspGenInitInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1LspGenInitInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1LspGenInitInterval() directly.

    YANG Description: Set the delay for generating level-1 LSPs with the same LSP ID for the first time. The value is an integer, expressed in milliseconds. By default, this delay is not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1LspGenInitInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1LspGenInitInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1LspGenInitInterval(self):
    self.__level1LspGenInitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2LspGenInitInterval(self):
    """
    Getter method for level2LspGenInitInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level2LspGenInitInterval (uint32)

    YANG Description: Set the delay for generating level-2 LSPs with the same LSP ID for the first time. The value is an integer, expressed in milliseconds. By default, this delay is not used.
    """
    return self.__level2LspGenInitInterval
      
  def _set_level2LspGenInitInterval(self, v, load=False):
    """
    Setter method for level2LspGenInitInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level2LspGenInitInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2LspGenInitInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2LspGenInitInterval() directly.

    YANG Description: Set the delay for generating level-2 LSPs with the same LSP ID for the first time. The value is an integer, expressed in milliseconds. By default, this delay is not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2LspGenInitInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2LspGenInitInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2LspGenInitInterval(self):
    self.__level2LspGenInitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1LspGenIncrInterval(self):
    """
    Getter method for level1LspGenIncrInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level1LspGenIncrInterval (uint32)

    YANG Description: Set the incremental delay for generating two level-1 LSPs with the same LSP ID. The interval doubles the previous one each time. The value is an integer, expressed in milliseconds. By default, the delay is not used.
    """
    return self.__level1LspGenIncrInterval
      
  def _set_level1LspGenIncrInterval(self, v, load=False):
    """
    Setter method for level1LspGenIncrInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level1LspGenIncrInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1LspGenIncrInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1LspGenIncrInterval() directly.

    YANG Description: Set the incremental delay for generating two level-1 LSPs with the same LSP ID. The interval doubles the previous one each time. The value is an integer, expressed in milliseconds. By default, the delay is not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1LspGenIncrInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1LspGenIncrInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1LspGenIncrInterval(self):
    self.__level1LspGenIncrInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2LspGenIncrInterval(self):
    """
    Getter method for level2LspGenIncrInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level2LspGenIncrInterval (uint32)

    YANG Description: Set the incremental delay for generating two level-2 LSPs with the same LSP ID. The interval doubles the previous one each time. The value is an integer, expressed in milliseconds. By default, the delay is not used.
    """
    return self.__level2LspGenIncrInterval
      
  def _set_level2LspGenIncrInterval(self, v, load=False):
    """
    Setter method for level2LspGenIncrInterval, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer/level2LspGenIncrInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2LspGenIncrInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2LspGenIncrInterval() directly.

    YANG Description: Set the incremental delay for generating two level-2 LSPs with the same LSP ID. The interval doubles the previous one each time. The value is an integer, expressed in milliseconds. By default, the delay is not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2LspGenIncrInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2LspGenIncrInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2LspGenIncrInterval(self):
    self.__level2LspGenIncrInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2LspGenIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  level1LspGenMaxInterval = __builtin__.property(_get_level1LspGenMaxInterval, _set_level1LspGenMaxInterval)
  level2LspGenMaxInterval = __builtin__.property(_get_level2LspGenMaxInterval, _set_level2LspGenMaxInterval)
  level1LspGenInitInterval = __builtin__.property(_get_level1LspGenInitInterval, _set_level1LspGenInitInterval)
  level2LspGenInitInterval = __builtin__.property(_get_level2LspGenInitInterval, _set_level2LspGenInitInterval)
  level1LspGenIncrInterval = __builtin__.property(_get_level1LspGenIncrInterval, _set_level1LspGenIncrInterval)
  level2LspGenIncrInterval = __builtin__.property(_get_level2LspGenIncrInterval, _set_level2LspGenIncrInterval)


  _pyangbind_elements = OrderedDict([('level1LspGenMaxInterval', level1LspGenMaxInterval), ('level2LspGenMaxInterval', level2LspGenMaxInterval), ('level1LspGenInitInterval', level1LspGenInitInterval), ('level2LspGenInitInterval', level2LspGenInitInterval), ('level1LspGenIncrInterval', level1LspGenIncrInterval), ('level2LspGenIncrInterval', level2LspGenIncrInterval), ])


class yc_isFlashFlood_huawei_isiscomm__isiscomm_isSites_isSite_isFlashFlood(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isFlashFlood. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable immediate LSP flooding.
  """
  __slots__ = ('_path_helper', '_extmethods', '__level1FlashFloodEnable','__level2FlashFloodEnable','__level1FlashFloodLspNum','__level2FlashFloodLspNum','__level1FlashFloodMaxTime','__level2FlashFloodMaxTime',)

  _yang_name = 'isFlashFlood'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__level1FlashFloodEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2FlashFloodEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1FlashFloodLspNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level1FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2FlashFloodLspNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level2FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1FlashFloodMaxTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2FlashFloodMaxTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isFlashFlood']

  def _get_level1FlashFloodEnable(self):
    """
    Getter method for level1FlashFloodEnable, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level1FlashFloodEnable (boolean)

    YANG Description: Enable level-1 LSP flooding.
    """
    return self.__level1FlashFloodEnable
      
  def _set_level1FlashFloodEnable(self, v, load=False):
    """
    Setter method for level1FlashFloodEnable, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level1FlashFloodEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1FlashFloodEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1FlashFloodEnable() directly.

    YANG Description: Enable level-1 LSP flooding.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1FlashFloodEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1FlashFloodEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1FlashFloodEnable(self):
    self.__level1FlashFloodEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2FlashFloodEnable(self):
    """
    Getter method for level2FlashFloodEnable, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level2FlashFloodEnable (boolean)

    YANG Description: Enable level-2 LSP flooding.
    """
    return self.__level2FlashFloodEnable
      
  def _set_level2FlashFloodEnable(self, v, load=False):
    """
    Setter method for level2FlashFloodEnable, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level2FlashFloodEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2FlashFloodEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2FlashFloodEnable() directly.

    YANG Description: Enable level-2 LSP flooding.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2FlashFloodEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2FlashFloodEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2FlashFloodEnable(self):
    self.__level2FlashFloodEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FlashFloodEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1FlashFloodLspNum(self):
    """
    Getter method for level1FlashFloodLspNum, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level1FlashFloodLspNum (uint32)

    YANG Description: Set the maximum number of level-1 LSPs that can be flooded each time on each interface. The default value is 5. 
    """
    return self.__level1FlashFloodLspNum
      
  def _set_level1FlashFloodLspNum(self, v, load=False):
    """
    Setter method for level1FlashFloodLspNum, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level1FlashFloodLspNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1FlashFloodLspNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1FlashFloodLspNum() directly.

    YANG Description: Set the maximum number of level-1 LSPs that can be flooded each time on each interface. The default value is 5. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level1FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1FlashFloodLspNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level1FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1FlashFloodLspNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1FlashFloodLspNum(self):
    self.__level1FlashFloodLspNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level1FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2FlashFloodLspNum(self):
    """
    Getter method for level2FlashFloodLspNum, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level2FlashFloodLspNum (uint32)

    YANG Description: Set the maximum number of level-2 LSPs that can be flooded each time on each interface. The default value is 5. 
    """
    return self.__level2FlashFloodLspNum
      
  def _set_level2FlashFloodLspNum(self, v, load=False):
    """
    Setter method for level2FlashFloodLspNum, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level2FlashFloodLspNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2FlashFloodLspNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2FlashFloodLspNum() directly.

    YANG Description: Set the maximum number of level-2 LSPs that can be flooded each time on each interface. The default value is 5. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level2FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2FlashFloodLspNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level2FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2FlashFloodLspNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2FlashFloodLspNum(self):
    self.__level2FlashFloodLspNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..15']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="level2FlashFloodLspNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1FlashFloodMaxTime(self):
    """
    Getter method for level1FlashFloodMaxTime, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level1FlashFloodMaxTime (uint32)

    YANG Description: Set the maximum interval at which level-1 LSPs are flooded. The value is expressed in milliseconds. The default value is 10.
    """
    return self.__level1FlashFloodMaxTime
      
  def _set_level1FlashFloodMaxTime(self, v, load=False):
    """
    Setter method for level1FlashFloodMaxTime, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level1FlashFloodMaxTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1FlashFloodMaxTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1FlashFloodMaxTime() directly.

    YANG Description: Set the maximum interval at which level-1 LSPs are flooded. The value is expressed in milliseconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1FlashFloodMaxTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1FlashFloodMaxTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1FlashFloodMaxTime(self):
    self.__level1FlashFloodMaxTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2FlashFloodMaxTime(self):
    """
    Getter method for level2FlashFloodMaxTime, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level2FlashFloodMaxTime (uint32)

    YANG Description: Set the maximum interval at which level-2 LSPs are flooded. The value is expressed in milliseconds. The default value is 10.
    """
    return self.__level2FlashFloodMaxTime
      
  def _set_level2FlashFloodMaxTime(self, v, load=False):
    """
    Setter method for level2FlashFloodMaxTime, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood/level2FlashFloodMaxTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2FlashFloodMaxTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2FlashFloodMaxTime() directly.

    YANG Description: Set the maximum interval at which level-2 LSPs are flooded. The value is expressed in milliseconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2FlashFloodMaxTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2FlashFloodMaxTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2FlashFloodMaxTime(self):
    self.__level2FlashFloodMaxTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..50000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2FlashFloodMaxTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  level1FlashFloodEnable = __builtin__.property(_get_level1FlashFloodEnable, _set_level1FlashFloodEnable)
  level2FlashFloodEnable = __builtin__.property(_get_level2FlashFloodEnable, _set_level2FlashFloodEnable)
  level1FlashFloodLspNum = __builtin__.property(_get_level1FlashFloodLspNum, _set_level1FlashFloodLspNum)
  level2FlashFloodLspNum = __builtin__.property(_get_level2FlashFloodLspNum, _set_level2FlashFloodLspNum)
  level1FlashFloodMaxTime = __builtin__.property(_get_level1FlashFloodMaxTime, _set_level1FlashFloodMaxTime)
  level2FlashFloodMaxTime = __builtin__.property(_get_level2FlashFloodMaxTime, _set_level2FlashFloodMaxTime)


  _pyangbind_elements = OrderedDict([('level1FlashFloodEnable', level1FlashFloodEnable), ('level2FlashFloodEnable', level2FlashFloodEnable), ('level1FlashFloodLspNum', level1FlashFloodLspNum), ('level2FlashFloodLspNum', level2FlashFloodLspNum), ('level1FlashFloodMaxTime', level1FlashFloodMaxTime), ('level2FlashFloodMaxTime', level2FlashFloodMaxTime), ])


class yc_isOverloadSet_huawei_isiscomm__isiscomm_isSites_isSite_isOverloadSet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isOverloadSet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set overload.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stdOverloadType','__stdOverloadWaitType','__stdOverloadNbrSysId','__stdOverloadTimeout1','__stdOverloadTimeout2','__stdOverloadInterlevel','__stdOverloadExternal','__stdOverloadSendSaBit','__stdOverloadSaBitTime','__stdOverloadRtDelayTime',)

  _yang_name = 'isOverloadSet'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stdOverloadType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="stdOverloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__stdOverloadWaitType = YANGDynClass(base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="stdOverloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__stdOverloadNbrSysId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="stdOverloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__stdOverloadTimeout1 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="stdOverloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__stdOverloadTimeout2 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="stdOverloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__stdOverloadInterlevel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__stdOverloadExternal = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__stdOverloadSendSaBit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadSendSaBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__stdOverloadSaBitTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="stdOverloadSaBitTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__stdOverloadRtDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..1000']}), is_leaf=True, yang_name="stdOverloadRtDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isOverloadSet']

  def _get_stdOverloadType(self):
    """
    Getter method for stdOverloadType, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadType (string)

    YANG Description: Set the router to notify others that it is overloaded. The flag can be No Setting, Restart Setting, or Manual Setting. The default value is No Setting.
    """
    return self.__stdOverloadType
      
  def _set_stdOverloadType(self, v, load=False):
    """
    Setter method for stdOverloadType, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadType() directly.

    YANG Description: Set the router to notify others that it is overloaded. The flag can be No Setting, Restart Setting, or Manual Setting. The default value is No Setting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="stdOverloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="stdOverloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__stdOverloadType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadType(self):
    self.__stdOverloadType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="stdOverloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_stdOverloadWaitType(self):
    """
    Getter method for stdOverloadWaitType, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadWaitType (string)

    YANG Description: Set the overload type. The value can be Wait for BGP Convergence, Wait for Neighbor, or Not Wait. The default value is Not Wait.
    """
    return self.__stdOverloadWaitType
      
  def _set_stdOverloadWaitType(self, v, load=False):
    """
    Setter method for stdOverloadWaitType, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadWaitType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadWaitType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadWaitType() directly.

    YANG Description: Set the overload type. The value can be Wait for BGP Convergence, Wait for Neighbor, or Not Wait. The default value is Not Wait.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="stdOverloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadWaitType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="stdOverloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__stdOverloadWaitType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadWaitType(self):
    self.__stdOverloadWaitType = YANGDynClass(base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="stdOverloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_stdOverloadNbrSysId(self):
    """
    Getter method for stdOverloadNbrSysId, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadNbrSysId (string)

    YANG Description: Set the system ID of the neighbor. The duration for the system to keep the overload bit is set according to the status of the neighbor specified by the system ID. The length of the value is 6 bytes, in the format of XXXX.XXXX.XXXX, in which X is a hexadecimal case-insensitive character. 
    """
    return self.__stdOverloadNbrSysId
      
  def _set_stdOverloadNbrSysId(self, v, load=False):
    """
    Setter method for stdOverloadNbrSysId, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadNbrSysId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadNbrSysId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadNbrSysId() directly.

    YANG Description: Set the system ID of the neighbor. The duration for the system to keep the overload bit is set according to the status of the neighbor specified by the system ID. The length of the value is 6 bytes, in the format of XXXX.XXXX.XXXX, in which X is a hexadecimal case-insensitive character. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="stdOverloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadNbrSysId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="stdOverloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__stdOverloadNbrSysId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadNbrSysId(self):
    self.__stdOverloadNbrSysId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="stdOverloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_stdOverloadTimeout1(self):
    """
    Getter method for stdOverloadTimeout1, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadTimeout1 (uint32)

    YANG Description: If the specified neighbor does not become Up before the neighbor holdtime expires, the holdtime of the system overload flag is the neighbor holdtime. The value of neighbor holdtime is expressed in seconds, ranging from 5 to 86400. The default value is 1200. 
    """
    return self.__stdOverloadTimeout1
      
  def _set_stdOverloadTimeout1(self, v, load=False):
    """
    Setter method for stdOverloadTimeout1, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadTimeout1 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadTimeout1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadTimeout1() directly.

    YANG Description: If the specified neighbor does not become Up before the neighbor holdtime expires, the holdtime of the system overload flag is the neighbor holdtime. The value of neighbor holdtime is expressed in seconds, ranging from 5 to 86400. The default value is 1200. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="stdOverloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadTimeout1 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="stdOverloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdOverloadTimeout1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadTimeout1(self):
    self.__stdOverloadTimeout1 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="stdOverloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_stdOverloadTimeout2(self):
    """
    Getter method for stdOverloadTimeout2, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadTimeout2 (uint32)

    YANG Description: If the specified neighbor becomes Up before the neighbor holdtime expires, the system overload flag keeps the neighbor timeout period. The neighbor timeout period is expressed in seconds, ranging from 5 to 86400. The default value is 600.
    """
    return self.__stdOverloadTimeout2
      
  def _set_stdOverloadTimeout2(self, v, load=False):
    """
    Setter method for stdOverloadTimeout2, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadTimeout2 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadTimeout2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadTimeout2() directly.

    YANG Description: If the specified neighbor becomes Up before the neighbor holdtime expires, the system overload flag keeps the neighbor timeout period. The neighbor timeout period is expressed in seconds, ranging from 5 to 86400. The default value is 600.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="stdOverloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadTimeout2 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="stdOverloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdOverloadTimeout2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadTimeout2(self):
    self.__stdOverloadTimeout2 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="stdOverloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_stdOverloadInterlevel(self):
    """
    Getter method for stdOverloadInterlevel, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadInterlevel (boolean)

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from the IS-IS routes at different levels. By default, such IP address prefixes cannot be advertised.
    """
    return self.__stdOverloadInterlevel
      
  def _set_stdOverloadInterlevel(self, v, load=False):
    """
    Setter method for stdOverloadInterlevel, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadInterlevel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadInterlevel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadInterlevel() directly.

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from the IS-IS routes at different levels. By default, such IP address prefixes cannot be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadInterlevel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__stdOverloadInterlevel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadInterlevel(self):
    self.__stdOverloadInterlevel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_stdOverloadExternal(self):
    """
    Getter method for stdOverloadExternal, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadExternal (boolean)

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from other protocols. By default, such IP address prefixes cannot be advertised.
    """
    return self.__stdOverloadExternal
      
  def _set_stdOverloadExternal(self, v, load=False):
    """
    Setter method for stdOverloadExternal, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadExternal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadExternal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadExternal() directly.

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from other protocols. By default, such IP address prefixes cannot be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadExternal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__stdOverloadExternal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadExternal(self):
    self.__stdOverloadExternal = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_stdOverloadSendSaBit(self):
    """
    Getter method for stdOverloadSendSaBit, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadSendSaBit (boolean)

    YANG Description: Set the SA bit in Hello packets.
    """
    return self.__stdOverloadSendSaBit
      
  def _set_stdOverloadSendSaBit(self, v, load=False):
    """
    Setter method for stdOverloadSendSaBit, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadSendSaBit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadSendSaBit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadSendSaBit() directly.

    YANG Description: Set the SA bit in Hello packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadSendSaBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadSendSaBit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadSendSaBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__stdOverloadSendSaBit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadSendSaBit(self):
    self.__stdOverloadSendSaBit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdOverloadSendSaBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_stdOverloadSaBitTime(self):
    """
    Getter method for stdOverloadSaBitTime, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadSaBitTime (uint32)

    YANG Description: The SA bit advertisement period is carried in Hello packet. The value is expressed in seconds, The default value is 30 seconds.
    """
    return self.__stdOverloadSaBitTime
      
  def _set_stdOverloadSaBitTime(self, v, load=False):
    """
    Setter method for stdOverloadSaBitTime, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadSaBitTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadSaBitTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadSaBitTime() directly.

    YANG Description: The SA bit advertisement period is carried in Hello packet. The value is expressed in seconds, The default value is 30 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="stdOverloadSaBitTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadSaBitTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="stdOverloadSaBitTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdOverloadSaBitTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadSaBitTime(self):
    self.__stdOverloadSaBitTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="stdOverloadSaBitTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_stdOverloadRtDelayTime(self):
    """
    Getter method for stdOverloadRtDelayTime, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadRtDelayTime (uint32)

    YANG Description: The route delay distribute period. The value is expressed in seconds.
    """
    return self.__stdOverloadRtDelayTime
      
  def _set_stdOverloadRtDelayTime(self, v, load=False):
    """
    Setter method for stdOverloadRtDelayTime, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet/stdOverloadRtDelayTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdOverloadRtDelayTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdOverloadRtDelayTime() directly.

    YANG Description: The route delay distribute period. The value is expressed in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..1000']}), is_leaf=True, yang_name="stdOverloadRtDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdOverloadRtDelayTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..1000']}), is_leaf=True, yang_name="stdOverloadRtDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdOverloadRtDelayTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdOverloadRtDelayTime(self):
    self.__stdOverloadRtDelayTime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..1000']}), is_leaf=True, yang_name="stdOverloadRtDelayTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  stdOverloadType = __builtin__.property(_get_stdOverloadType, _set_stdOverloadType)
  stdOverloadWaitType = __builtin__.property(_get_stdOverloadWaitType, _set_stdOverloadWaitType)
  stdOverloadNbrSysId = __builtin__.property(_get_stdOverloadNbrSysId, _set_stdOverloadNbrSysId)
  stdOverloadTimeout1 = __builtin__.property(_get_stdOverloadTimeout1, _set_stdOverloadTimeout1)
  stdOverloadTimeout2 = __builtin__.property(_get_stdOverloadTimeout2, _set_stdOverloadTimeout2)
  stdOverloadInterlevel = __builtin__.property(_get_stdOverloadInterlevel, _set_stdOverloadInterlevel)
  stdOverloadExternal = __builtin__.property(_get_stdOverloadExternal, _set_stdOverloadExternal)
  stdOverloadSendSaBit = __builtin__.property(_get_stdOverloadSendSaBit, _set_stdOverloadSendSaBit)
  stdOverloadSaBitTime = __builtin__.property(_get_stdOverloadSaBitTime, _set_stdOverloadSaBitTime)
  stdOverloadRtDelayTime = __builtin__.property(_get_stdOverloadRtDelayTime, _set_stdOverloadRtDelayTime)


  _pyangbind_elements = OrderedDict([('stdOverloadType', stdOverloadType), ('stdOverloadWaitType', stdOverloadWaitType), ('stdOverloadNbrSysId', stdOverloadNbrSysId), ('stdOverloadTimeout1', stdOverloadTimeout1), ('stdOverloadTimeout2', stdOverloadTimeout2), ('stdOverloadInterlevel', stdOverloadInterlevel), ('stdOverloadExternal', stdOverloadExternal), ('stdOverloadSendSaBit', stdOverloadSendSaBit), ('stdOverloadSaBitTime', stdOverloadSaBitTime), ('stdOverloadRtDelayTime', stdOverloadRtDelayTime), ])


class yc_isLdpSyncdSet_huawei_isiscomm__isiscomm_isSites_isSite_isLdpSyncdSet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLdpSyncdSet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set LDP and IS-IS synchronization.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ldpSyncEnable','__ldpSyncBind','__ldpSyncTimerEnable','__ldpSyncTimer','__ldpSyncHDTimerEnable','__ldpSyncHDTimer',)

  _yang_name = 'isLdpSyncdSet'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ldpSyncEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpSyncBind = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncBind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpSyncTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpSyncTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__ldpSyncHDTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpSyncHDTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLdpSyncdSet']

  def _get_ldpSyncEnable(self):
    """
    Getter method for ldpSyncEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncEnable (boolean)

    YANG Description: Enable LDP and IS-IS synchronization on an interface. By default, LDP and IS-IS synchronization is disabled.
    """
    return self.__ldpSyncEnable
      
  def _set_ldpSyncEnable(self, v, load=False):
    """
    Setter method for ldpSyncEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncEnable() directly.

    YANG Description: Enable LDP and IS-IS synchronization on an interface. By default, LDP and IS-IS synchronization is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSyncEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncEnable(self):
    self.__ldpSyncEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpSyncBind(self):
    """
    Getter method for ldpSyncBind, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncBind (boolean)

    YANG Description: Enable MPLS LDP association. By default, MPLS LDP association is disabled.
    """
    return self.__ldpSyncBind
      
  def _set_ldpSyncBind(self, v, load=False):
    """
    Setter method for ldpSyncBind, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncBind (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncBind is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncBind() directly.

    YANG Description: Enable MPLS LDP association. By default, MPLS LDP association is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncBind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncBind must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncBind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSyncBind = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncBind(self):
    self.__ldpSyncBind = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncBind", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpSyncTimerEnable(self):
    """
    Getter method for ldpSyncTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncTimerEnable (boolean)

    YANG Description: Enable the LDP and IS-IS synchronization timer. By default, the LDP and IS-IS synchronization timer is disabled.
    """
    return self.__ldpSyncTimerEnable
      
  def _set_ldpSyncTimerEnable(self, v, load=False):
    """
    Setter method for ldpSyncTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncTimerEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncTimerEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncTimerEnable() directly.

    YANG Description: Enable the LDP and IS-IS synchronization timer. By default, the LDP and IS-IS synchronization timer is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncTimerEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSyncTimerEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncTimerEnable(self):
    self.__ldpSyncTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpSyncTimer(self):
    """
    Getter method for ldpSyncTimer, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncTimer (uint32)

    YANG Description: Set a value for the LDP and IS-IS synchronization timer. The value is expressed in seconds. 
    """
    return self.__ldpSyncTimer
      
  def _set_ldpSyncTimer(self, v, load=False):
    """
    Setter method for ldpSyncTimer, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncTimer() directly.

    YANG Description: Set a value for the LDP and IS-IS synchronization timer. The value is expressed in seconds. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__ldpSyncTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncTimer(self):
    self.__ldpSyncTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_ldpSyncHDTimerEnable(self):
    """
    Getter method for ldpSyncHDTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncHDTimerEnable (boolean)

    YANG Description: Enable the LDP and IS-IS synchronization holddown timer. By default, the LDP and IS-IS synchronization holddown timer is disabled.
    """
    return self.__ldpSyncHDTimerEnable
      
  def _set_ldpSyncHDTimerEnable(self, v, load=False):
    """
    Setter method for ldpSyncHDTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncHDTimerEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncHDTimerEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncHDTimerEnable() directly.

    YANG Description: Enable the LDP and IS-IS synchronization holddown timer. By default, the LDP and IS-IS synchronization holddown timer is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncHDTimerEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSyncHDTimerEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncHDTimerEnable(self):
    self.__ldpSyncHDTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpSyncHDTimer(self):
    """
    Getter method for ldpSyncHDTimer, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncHDTimer (uint32)

    YANG Description: Set a value for the LDP and IS-IS synchronization holddown timer. The value is expressed in seconds. 
    """
    return self.__ldpSyncHDTimer
      
  def _set_ldpSyncHDTimer(self, v, load=False):
    """
    Setter method for ldpSyncHDTimer, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet/ldpSyncHDTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncHDTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncHDTimer() directly.

    YANG Description: Set a value for the LDP and IS-IS synchronization holddown timer. The value is expressed in seconds. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncHDTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__ldpSyncHDTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncHDTimer(self):
    self.__ldpSyncHDTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  ldpSyncEnable = __builtin__.property(_get_ldpSyncEnable, _set_ldpSyncEnable)
  ldpSyncBind = __builtin__.property(_get_ldpSyncBind, _set_ldpSyncBind)
  ldpSyncTimerEnable = __builtin__.property(_get_ldpSyncTimerEnable, _set_ldpSyncTimerEnable)
  ldpSyncTimer = __builtin__.property(_get_ldpSyncTimer, _set_ldpSyncTimer)
  ldpSyncHDTimerEnable = __builtin__.property(_get_ldpSyncHDTimerEnable, _set_ldpSyncHDTimerEnable)
  ldpSyncHDTimer = __builtin__.property(_get_ldpSyncHDTimer, _set_ldpSyncHDTimer)


  _pyangbind_elements = OrderedDict([('ldpSyncEnable', ldpSyncEnable), ('ldpSyncBind', ldpSyncBind), ('ldpSyncTimerEnable', ldpSyncTimerEnable), ('ldpSyncTimer', ldpSyncTimer), ('ldpSyncHDTimerEnable', ldpSyncHDTimerEnable), ('ldpSyncHDTimer', ldpSyncHDTimer), ])


class yc_isExternAbility_huawei_isiscomm__isiscomm_isSites_isSite_isExternAbility(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isExternAbility. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Expansibility.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adjStrictCheck','__ecmpPrefer','__optChecksum','__attAdvControl','__attAvoidLearn','__vClusterEnable','__vAccessEnable',)

  _yang_name = 'isExternAbility'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adjStrictCheck = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adjStrictCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ecmpPrefer = YANGDynClass(base=six.text_type, default=six.text_type("none"), is_leaf=True, yang_name="ecmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__optChecksum = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optChecksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__attAdvControl = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__attAvoidLearn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__vClusterEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vClusterEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__vAccessEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vAccessEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isExternAbility']

  def _get_adjStrictCheck(self):
    """
    Getter method for adjStrictCheck, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/adjStrictCheck (boolean)

    YANG Description: Strict check on the neighbor.
    """
    return self.__adjStrictCheck
      
  def _set_adjStrictCheck(self, v, load=False):
    """
    Setter method for adjStrictCheck, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/adjStrictCheck (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjStrictCheck is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjStrictCheck() directly.

    YANG Description: Strict check on the neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adjStrictCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjStrictCheck must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adjStrictCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__adjStrictCheck = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjStrictCheck(self):
    self.__adjStrictCheck = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adjStrictCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ecmpPrefer(self):
    """
    Getter method for ecmpPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/ecmpPrefer (string)

    YANG Description: Configure whether the routes with a TE tunnel interface as the outbound interface or the routes with an IPv4 interface as the outbound interface are preferentially selected to load-balance IS-IS traffic.
    """
    return self.__ecmpPrefer
      
  def _set_ecmpPrefer(self, v, load=False):
    """
    Setter method for ecmpPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/ecmpPrefer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecmpPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecmpPrefer() directly.

    YANG Description: Configure whether the routes with a TE tunnel interface as the outbound interface or the routes with an IPv4 interface as the outbound interface are preferentially selected to load-balance IS-IS traffic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("none"), is_leaf=True, yang_name="ecmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecmpPrefer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("none"), is_leaf=True, yang_name="ecmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ecmpPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecmpPrefer(self):
    self.__ecmpPrefer = YANGDynClass(base=six.text_type, default=six.text_type("none"), is_leaf=True, yang_name="ecmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_optChecksum(self):
    """
    Getter method for optChecksum, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/optChecksum (boolean)

    YANG Description: Option Checksum.
    """
    return self.__optChecksum
      
  def _set_optChecksum(self, v, load=False):
    """
    Setter method for optChecksum, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/optChecksum (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optChecksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optChecksum() directly.

    YANG Description: Option Checksum.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optChecksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optChecksum must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optChecksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__optChecksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optChecksum(self):
    self.__optChecksum = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optChecksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_attAdvControl(self):
    """
    Getter method for attAdvControl, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/attAdvControl (string)

    YANG Description: Control to advertise the ATT bit.
    """
    return self.__attAdvControl
      
  def _set_attAdvControl(self, v, load=False):
    """
    Setter method for attAdvControl, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/attAdvControl (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attAdvControl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attAdvControl() directly.

    YANG Description: Control to advertise the ATT bit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attAdvControl must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__attAdvControl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attAdvControl(self):
    self.__attAdvControl = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_attAvoidLearn(self):
    """
    Getter method for attAvoidLearn, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/attAvoidLearn (boolean)

    YANG Description: Prevent the device from learning the LSPs with the ATT bit.
    """
    return self.__attAvoidLearn
      
  def _set_attAvoidLearn(self, v, load=False):
    """
    Setter method for attAvoidLearn, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/attAvoidLearn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attAvoidLearn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attAvoidLearn() directly.

    YANG Description: Prevent the device from learning the LSPs with the ATT bit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attAvoidLearn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__attAvoidLearn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attAvoidLearn(self):
    self.__attAvoidLearn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_vClusterEnable(self):
    """
    Getter method for vClusterEnable, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/vClusterEnable (boolean)

    YANG Description: Enable virtual cluster on the system.
    """
    return self.__vClusterEnable
      
  def _set_vClusterEnable(self, v, load=False):
    """
    Setter method for vClusterEnable, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/vClusterEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vClusterEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vClusterEnable() directly.

    YANG Description: Enable virtual cluster on the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vClusterEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vClusterEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vClusterEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__vClusterEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vClusterEnable(self):
    self.__vClusterEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vClusterEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_vAccessEnable(self):
    """
    Getter method for vAccessEnable, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/vAccessEnable (boolean)

    YANG Description: Enable virtual access on the system.
    """
    return self.__vAccessEnable
      
  def _set_vAccessEnable(self, v, load=False):
    """
    Setter method for vAccessEnable, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility/vAccessEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vAccessEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vAccessEnable() directly.

    YANG Description: Enable virtual access on the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vAccessEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vAccessEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vAccessEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__vAccessEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vAccessEnable(self):
    self.__vAccessEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vAccessEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  adjStrictCheck = __builtin__.property(_get_adjStrictCheck, _set_adjStrictCheck)
  ecmpPrefer = __builtin__.property(_get_ecmpPrefer, _set_ecmpPrefer)
  optChecksum = __builtin__.property(_get_optChecksum, _set_optChecksum)
  attAdvControl = __builtin__.property(_get_attAdvControl, _set_attAdvControl)
  attAvoidLearn = __builtin__.property(_get_attAvoidLearn, _set_attAvoidLearn)
  vClusterEnable = __builtin__.property(_get_vClusterEnable, _set_vClusterEnable)
  vAccessEnable = __builtin__.property(_get_vAccessEnable, _set_vAccessEnable)


  _pyangbind_elements = OrderedDict([('adjStrictCheck', adjStrictCheck), ('ecmpPrefer', ecmpPrefer), ('optChecksum', optChecksum), ('attAdvControl', attAdvControl), ('attAvoidLearn', attAvoidLearn), ('vClusterEnable', vClusterEnable), ('vAccessEnable', vAccessEnable), ])


class yc_isAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isAvoidMicroLoopSet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isAvoidMicroLoopSet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable IS-IS avoid-microloop.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frrAvoidLoopDisable','__ribUpdateDelayValue','__srAvoidLoopEnable','__srDelayAvoidLoopVal','__teTnlUloopEnable','__teTnlUloopDelay',)

  _yang_name = 'isAvoidMicroLoopSet'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frrAvoidLoopDisable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="frrAvoidLoopDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ribUpdateDelayValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="ribUpdateDelayValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__srAvoidLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__srDelayAvoidLoopVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="srDelayAvoidLoopVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    self.__teTnlUloopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teTnlUloopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__teTnlUloopDelay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="teTnlUloopDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isAvoidMicroLoopSet']

  def _get_frrAvoidLoopDisable(self):
    """
    Getter method for frrAvoidLoopDisable, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/frrAvoidLoopDisable (boolean)

    YANG Description: Disable FRR avoid-microloop.
    """
    return self.__frrAvoidLoopDisable
      
  def _set_frrAvoidLoopDisable(self, v, load=False):
    """
    Setter method for frrAvoidLoopDisable, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/frrAvoidLoopDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frrAvoidLoopDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frrAvoidLoopDisable() directly.

    YANG Description: Disable FRR avoid-microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="frrAvoidLoopDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frrAvoidLoopDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="frrAvoidLoopDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__frrAvoidLoopDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frrAvoidLoopDisable(self):
    self.__frrAvoidLoopDisable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="frrAvoidLoopDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ribUpdateDelayValue(self):
    """
    Getter method for ribUpdateDelayValue, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/ribUpdateDelayValue (uint32)

    YANG Description: Set the route delivery delay for FRR avoid-microloop. The default value is 100 ms.
    """
    return self.__ribUpdateDelayValue
      
  def _set_ribUpdateDelayValue(self, v, load=False):
    """
    Setter method for ribUpdateDelayValue, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/ribUpdateDelayValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribUpdateDelayValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribUpdateDelayValue() directly.

    YANG Description: Set the route delivery delay for FRR avoid-microloop. The default value is 100 ms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="ribUpdateDelayValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribUpdateDelayValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="ribUpdateDelayValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__ribUpdateDelayValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribUpdateDelayValue(self):
    self.__ribUpdateDelayValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="ribUpdateDelayValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_srAvoidLoopEnable(self):
    """
    Getter method for srAvoidLoopEnable, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/srAvoidLoopEnable (boolean)

    YANG Description: Enable SR avoid-microloop.
    """
    return self.__srAvoidLoopEnable
      
  def _set_srAvoidLoopEnable(self, v, load=False):
    """
    Setter method for srAvoidLoopEnable, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/srAvoidLoopEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srAvoidLoopEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srAvoidLoopEnable() directly.

    YANG Description: Enable SR avoid-microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srAvoidLoopEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__srAvoidLoopEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srAvoidLoopEnable(self):
    self.__srAvoidLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="srAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_srDelayAvoidLoopVal(self):
    """
    Getter method for srDelayAvoidLoopVal, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/srDelayAvoidLoopVal (uint16)

    YANG Description: Set the route delivery delay for SR avoid-microloop. The default value is 5000 ms.
    """
    return self.__srDelayAvoidLoopVal
      
  def _set_srDelayAvoidLoopVal(self, v, load=False):
    """
    Setter method for srDelayAvoidLoopVal, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/srDelayAvoidLoopVal (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srDelayAvoidLoopVal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srDelayAvoidLoopVal() directly.

    YANG Description: Set the route delivery delay for SR avoid-microloop. The default value is 5000 ms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="srDelayAvoidLoopVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srDelayAvoidLoopVal must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="srDelayAvoidLoopVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)""",
        })

    self.__srDelayAvoidLoopVal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srDelayAvoidLoopVal(self):
    self.__srDelayAvoidLoopVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="srDelayAvoidLoopVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)


  def _get_teTnlUloopEnable(self):
    """
    Getter method for teTnlUloopEnable, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/teTnlUloopEnable (boolean)

    YANG Description: Set te shortcut tunnel avoid microloop enable.
    """
    return self.__teTnlUloopEnable
      
  def _set_teTnlUloopEnable(self, v, load=False):
    """
    Setter method for teTnlUloopEnable, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/teTnlUloopEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_teTnlUloopEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_teTnlUloopEnable() directly.

    YANG Description: Set te shortcut tunnel avoid microloop enable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teTnlUloopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """teTnlUloopEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teTnlUloopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__teTnlUloopEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_teTnlUloopEnable(self):
    self.__teTnlUloopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="teTnlUloopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_teTnlUloopDelay(self):
    """
    Getter method for teTnlUloopDelay, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/teTnlUloopDelay (uint32)

    YANG Description: Set the route delivery delay for te shortcut tunnel. The default value is 1000 ms.
    """
    return self.__teTnlUloopDelay
      
  def _set_teTnlUloopDelay(self, v, load=False):
    """
    Setter method for teTnlUloopDelay, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet/teTnlUloopDelay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_teTnlUloopDelay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_teTnlUloopDelay() directly.

    YANG Description: Set the route delivery delay for te shortcut tunnel. The default value is 1000 ms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="teTnlUloopDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """teTnlUloopDelay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="teTnlUloopDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__teTnlUloopDelay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_teTnlUloopDelay(self):
    self.__teTnlUloopDelay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="teTnlUloopDelay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  frrAvoidLoopDisable = __builtin__.property(_get_frrAvoidLoopDisable, _set_frrAvoidLoopDisable)
  ribUpdateDelayValue = __builtin__.property(_get_ribUpdateDelayValue, _set_ribUpdateDelayValue)
  srAvoidLoopEnable = __builtin__.property(_get_srAvoidLoopEnable, _set_srAvoidLoopEnable)
  srDelayAvoidLoopVal = __builtin__.property(_get_srDelayAvoidLoopVal, _set_srDelayAvoidLoopVal)
  teTnlUloopEnable = __builtin__.property(_get_teTnlUloopEnable, _set_teTnlUloopEnable)
  teTnlUloopDelay = __builtin__.property(_get_teTnlUloopDelay, _set_teTnlUloopDelay)


  _pyangbind_elements = OrderedDict([('frrAvoidLoopDisable', frrAvoidLoopDisable), ('ribUpdateDelayValue', ribUpdateDelayValue), ('srAvoidLoopEnable', srAvoidLoopEnable), ('srDelayAvoidLoopVal', srDelayAvoidLoopVal), ('teTnlUloopEnable', teTnlUloopEnable), ('teTnlUloopDelay', teTnlUloopDelay), ])


class yc_isLocalMtSet_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets_isLocalMtSet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set a local multicast topology.
  """
  __slots__ = ('_path_helper', '_extmethods', '__localMtEnable','__policyType','__aclNumOrName','__ipPrefix',)

  _yang_name = 'isLocalMtSet'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__localMtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localMtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLocalMtSets', 'isLocalMtSet']

  def _get_localMtEnable(self):
    """
    Getter method for localMtEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/localMtEnable (boolean)

    YANG Description: Enable local multicast topology.
    """
    return self.__localMtEnable
      
  def _set_localMtEnable(self, v, load=False):
    """
    Setter method for localMtEnable, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/localMtEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localMtEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localMtEnable() directly.

    YANG Description: Enable local multicast topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localMtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localMtEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localMtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__localMtEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localMtEnable(self):
    self.__localMtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="localMtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/policyType (string)

    YANG Description: Set a policy mode for route filtering. In ACL mode, the ACL number parameter is available. In IP prefix mode, the IP prefix parameter is available. In None mode, both the ACL number and IP prefix parameters are unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Set a policy mode for route filtering. In ACL mode, the ACL number parameter is available. In IP prefix mode, the IP prefix parameter is available. In None mode, both the ACL number and IP prefix parameters are unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_aclNumOrName(self):
    """
    Getter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/aclNumOrName (string)

    YANG Description: Set the ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    return self.__aclNumOrName
      
  def _set_aclNumOrName(self, v, load=False):
    """
    Setter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/aclNumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aclNumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aclNumOrName() directly.

    YANG Description: Set the ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aclNumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__aclNumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aclNumOrName(self):
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipPrefix(self):
    """
    Getter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/ipPrefix (string)

    YANG Description: IP prefix name used during route filtering. 
    """
    return self.__ipPrefix
      
  def _set_ipPrefix(self, v, load=False):
    """
    Setter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet/ipPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefix() directly.

    YANG Description: IP prefix name used during route filtering. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefix(self):
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  localMtEnable = __builtin__.property(_get_localMtEnable, _set_localMtEnable)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  aclNumOrName = __builtin__.property(_get_aclNumOrName, _set_aclNumOrName)
  ipPrefix = __builtin__.property(_get_ipPrefix, _set_ipPrefix)


  _pyangbind_elements = OrderedDict([('localMtEnable', localMtEnable), ('policyType', policyType), ('aclNumOrName', aclNumOrName), ('ipPrefix', ipPrefix), ])


class yc_isLocalMtSets_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLocalMtSets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of local multicast topologies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLocalMtSet',)

  _yang_name = 'isLocalMtSets'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLocalMtSet = YANGDynClass(base=yc_isLocalMtSet_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets_isLocalMtSet, is_container='container', yang_name="isLocalMtSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLocalMtSets']

  def _get_isLocalMtSet(self):
    """
    Getter method for isLocalMtSet, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet (container)

    YANG Description: Set a local multicast topology.
    """
    return self.__isLocalMtSet
      
  def _set_isLocalMtSet(self, v, load=False):
    """
    Setter method for isLocalMtSet, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets/isLocalMtSet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLocalMtSet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLocalMtSet() directly.

    YANG Description: Set a local multicast topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLocalMtSet_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets_isLocalMtSet, is_container='container', yang_name="isLocalMtSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLocalMtSet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLocalMtSet_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets_isLocalMtSet, is_container='container', yang_name="isLocalMtSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLocalMtSet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLocalMtSet(self):
    self.__isLocalMtSet = YANGDynClass(base=yc_isLocalMtSet_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets_isLocalMtSet, is_container='container', yang_name="isLocalMtSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isLocalMtSet = __builtin__.property(_get_isLocalMtSet, _set_isLocalMtSet) # type: yc_isLocalMtSet_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets_isLocalMtSet


  _pyangbind_elements = OrderedDict([('isLocalMtSet', isLocalMtSet), ])


class yc_isAreaId_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds_isAreaId(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isAreaIds/isAreaId. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set an Auto NET.
  """
  __slots__ = ('_path_helper', '_extmethods', '__areaId','__autoSysIdStyle',)

  _yang_name = 'isAreaId'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__areaId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..53']}), is_leaf=True, yang_name="areaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__autoSysIdStyle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="autoSysIdStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isAreaIds', 'isAreaId']

  def _get_areaId(self):
    """
    Getter method for areaId, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds/isAreaId/areaId (string)

    YANG Description: Set an area ID. The area ID is in the format of XX.XXXX.XXXX...XXXX, in which X is a case-insensitive hexadecimal character. A maximum of 13 Xs are allowed.
    """
    return self.__areaId
      
  def _set_areaId(self, v, load=False):
    """
    Setter method for areaId, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds/isAreaId/areaId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_areaId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_areaId() directly.

    YANG Description: Set an area ID. The area ID is in the format of XX.XXXX.XXXX...XXXX, in which X is a case-insensitive hexadecimal character. A maximum of 13 Xs are allowed.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..53']}), is_leaf=True, yang_name="areaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """areaId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..53']}), is_leaf=True, yang_name="areaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__areaId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_areaId(self):
    self.__areaId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..53']}), is_leaf=True, yang_name="areaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_autoSysIdStyle(self):
    """
    Getter method for autoSysIdStyle, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds/isAreaId/autoSysIdStyle (string)

    YANG Description: Set automatic system ID mapping.
    """
    return self.__autoSysIdStyle
      
  def _set_autoSysIdStyle(self, v, load=False):
    """
    Setter method for autoSysIdStyle, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds/isAreaId/autoSysIdStyle (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoSysIdStyle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoSysIdStyle() directly.

    YANG Description: Set automatic system ID mapping.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="autoSysIdStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoSysIdStyle must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="autoSysIdStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__autoSysIdStyle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoSysIdStyle(self):
    self.__autoSysIdStyle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="autoSysIdStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  areaId = __builtin__.property(_get_areaId, _set_areaId)
  autoSysIdStyle = __builtin__.property(_get_autoSysIdStyle, _set_autoSysIdStyle)


  _pyangbind_elements = OrderedDict([('areaId', areaId), ('autoSysIdStyle', autoSysIdStyle), ])


class yc_isAreaIds_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isAreaIds. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Auto list of NETs. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__isAreaId',)

  _yang_name = 'isAreaIds'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isAreaId = YANGDynClass(base=YANGListType("areaId autoSysIdStyle",yc_isAreaId_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds_isAreaId, yang_name="isAreaId", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='areaId autoSysIdStyle', extensions=None), is_container='list', yang_name="isAreaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isAreaIds']

  def _get_isAreaId(self):
    """
    Getter method for isAreaId, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds/isAreaId (list)

    YANG Description: Set an Auto NET.
    """
    return self.__isAreaId
      
  def _set_isAreaId(self, v, load=False):
    """
    Setter method for isAreaId, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds/isAreaId (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isAreaId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isAreaId() directly.

    YANG Description: Set an Auto NET.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("areaId autoSysIdStyle",yc_isAreaId_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds_isAreaId, yang_name="isAreaId", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='areaId autoSysIdStyle', extensions=None), is_container='list', yang_name="isAreaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isAreaId must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("areaId autoSysIdStyle",yc_isAreaId_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds_isAreaId, yang_name="isAreaId", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='areaId autoSysIdStyle', extensions=None), is_container='list', yang_name="isAreaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isAreaId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isAreaId(self):
    self.__isAreaId = YANGDynClass(base=YANGListType("areaId autoSysIdStyle",yc_isAreaId_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds_isAreaId, yang_name="isAreaId", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='areaId autoSysIdStyle', extensions=None), is_container='list', yang_name="isAreaId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isAreaId = __builtin__.property(_get_isAreaId, _set_isAreaId) # type: yc_isAreaId_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds_isAreaId


  _pyangbind_elements = OrderedDict([('isAreaId', isAreaId), ])


class yc_isNetEntity_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys_isNetEntity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isNetEntitys/isNetEntity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set a NET.
  """
  __slots__ = ('_path_helper', '_extmethods', '__netEntity',)

  _yang_name = 'isNetEntity'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__netEntity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\s*((([0-9a-fA-F]\\.?){2}){7,19}0\\.?0)\\s*', 'length': ['0..83']}), is_leaf=True, yang_name="netEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isNetEntitys', 'isNetEntity']

  def _get_netEntity(self):
    """
    Getter method for netEntity, mapped from YANG variable /isiscomm/isSites/isSite/isNetEntitys/isNetEntity/netEntity (string)

    YANG Description: Set a NET. The NET is in the format of X...X.XXXX.XXXX.XXXX.00, in which X...X indicates the area address, the 12 Xs in the middle indicate the system ID, and the last 00 indicates the SEL. X is a case-insensitive hexadecimal character. Manual configuration and automatic configuration are mutually exclusive on PTN devices. The NET cannot be manually configured when creating a process.
    """
    return self.__netEntity
      
  def _set_netEntity(self, v, load=False):
    """
    Setter method for netEntity, mapped from YANG variable /isiscomm/isSites/isSite/isNetEntitys/isNetEntity/netEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netEntity() directly.

    YANG Description: Set a NET. The NET is in the format of X...X.XXXX.XXXX.XXXX.00, in which X...X indicates the area address, the 12 Xs in the middle indicate the system ID, and the last 00 indicates the SEL. X is a case-insensitive hexadecimal character. Manual configuration and automatic configuration are mutually exclusive on PTN devices. The NET cannot be manually configured when creating a process.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\s*((([0-9a-fA-F]\\.?){2}){7,19}0\\.?0)\\s*', 'length': ['0..83']}), is_leaf=True, yang_name="netEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\s*((([0-9a-fA-F]\\.?){2}){7,19}0\\.?0)\\s*', 'length': ['0..83']}), is_leaf=True, yang_name="netEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__netEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netEntity(self):
    self.__netEntity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\s*((([0-9a-fA-F]\\.?){2}){7,19}0\\.?0)\\s*', 'length': ['0..83']}), is_leaf=True, yang_name="netEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  netEntity = __builtin__.property(_get_netEntity, _set_netEntity)


  _pyangbind_elements = OrderedDict([('netEntity', netEntity), ])


class yc_isNetEntitys_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isNetEntitys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of NETs. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__isNetEntity',)

  _yang_name = 'isNetEntitys'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isNetEntity = YANGDynClass(base=YANGListType("netEntity",yc_isNetEntity_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys_isNetEntity, yang_name="isNetEntity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='netEntity', extensions=None), is_container='list', yang_name="isNetEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isNetEntitys']

  def _get_isNetEntity(self):
    """
    Getter method for isNetEntity, mapped from YANG variable /isiscomm/isSites/isSite/isNetEntitys/isNetEntity (list)

    YANG Description: Set a NET.
    """
    return self.__isNetEntity
      
  def _set_isNetEntity(self, v, load=False):
    """
    Setter method for isNetEntity, mapped from YANG variable /isiscomm/isSites/isSite/isNetEntitys/isNetEntity (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNetEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNetEntity() directly.

    YANG Description: Set a NET.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("netEntity",yc_isNetEntity_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys_isNetEntity, yang_name="isNetEntity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='netEntity', extensions=None), is_container='list', yang_name="isNetEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNetEntity must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("netEntity",yc_isNetEntity_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys_isNetEntity, yang_name="isNetEntity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='netEntity', extensions=None), is_container='list', yang_name="isNetEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isNetEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNetEntity(self):
    self.__isNetEntity = YANGDynClass(base=YANGListType("netEntity",yc_isNetEntity_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys_isNetEntity, yang_name="isNetEntity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='netEntity', extensions=None), is_container='list', yang_name="isNetEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isNetEntity = __builtin__.property(_get_isNetEntity, _set_isNetEntity) # type: yc_isNetEntity_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys_isNetEntity


  _pyangbind_elements = OrderedDict([('isNetEntity', isNetEntity), ])


class yc_isLspAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications_isLspAuthtication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Authenticate received routing packets (LSPs or SNPs) based on the specified authentication mode and password in an IS-IS area or domain. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__cmdType','__passwordType','__simplePassword','__md5Password','__keyChainName','__serviceType','__authenUsage','__keyId',)

  _yang_name = 'isLspAuthtication'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cmdType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cmdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__passwordType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__simplePassword = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__md5Password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__serviceType = YANGDynClass(base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__authenUsage = YANGDynClass(base=six.text_type, default=six.text_type("usage_default"), is_leaf=True, yang_name="authenUsage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__keyId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLspAuthtications', 'isLspAuthtication']

  def _get_cmdType(self):
    """
    Getter method for cmdType, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/cmdType (string)

    YANG Description: Set the command type, which can be area or domain.
    """
    return self.__cmdType
      
  def _set_cmdType(self, v, load=False):
    """
    Setter method for cmdType, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/cmdType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cmdType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cmdType() directly.

    YANG Description: Set the command type, which can be area or domain.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cmdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cmdType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cmdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__cmdType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cmdType(self):
    self.__cmdType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cmdType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_passwordType(self):
    """
    Getter method for passwordType, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/passwordType (string)

    YANG Description: Set the authentication type, which can be simple or MD5.
    """
    return self.__passwordType
      
  def _set_passwordType(self, v, load=False):
    """
    Setter method for passwordType, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/passwordType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_passwordType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_passwordType() directly.

    YANG Description: Set the authentication type, which can be simple or MD5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """passwordType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__passwordType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_passwordType(self):
    self.__passwordType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_simplePassword(self):
    """
    Getter method for simplePassword, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/simplePassword (string)

    YANG Description: Set a plaintext for the simple authentication. The value is a string of characters (letters or digits), spaces not supported.The password is a string ranging from 1 to 16 characters for a plaintext password and 1 to 128 characters for a ciphertext password.
    """
    return self.__simplePassword
      
  def _set_simplePassword(self, v, load=False):
    """
    Setter method for simplePassword, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/simplePassword (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_simplePassword is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_simplePassword() directly.

    YANG Description: Set a plaintext for the simple authentication. The value is a string of characters (letters or digits), spaces not supported.The password is a string ranging from 1 to 16 characters for a plaintext password and 1 to 128 characters for a ciphertext password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """simplePassword must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__simplePassword = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_simplePassword(self):
    self.__simplePassword = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_md5Password(self):
    """
    Getter method for md5Password, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/md5Password (string)

    YANG Description: Set a MD5 or HMAC-SHA256 authentication password. The value is a string of characters (letters or digits), spaces not supported. The password is a string ranging from 1 to 255 characters for a plaintext password and 1 to 432 characters for a ciphertext password.
    """
    return self.__md5Password
      
  def _set_md5Password(self, v, load=False):
    """
    Setter method for md5Password, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/md5Password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md5Password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md5Password() directly.

    YANG Description: Set a MD5 or HMAC-SHA256 authentication password. The value is a string of characters (letters or digits), spaces not supported. The password is a string ranging from 1 to 255 characters for a plaintext password and 1 to 432 characters for a ciphertext password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md5Password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__md5Password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md5Password(self):
    self.__md5Password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_keyChainName(self):
    """
    Getter method for keyChainName, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/keyChainName (string)

    YANG Description: Keychain Name.
    """
    return self.__keyChainName
      
  def _set_keyChainName(self, v, load=False):
    """
    Setter method for keyChainName, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/keyChainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyChainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyChainName() directly.

    YANG Description: Keychain Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyChainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__keyChainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyChainName(self):
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_serviceType(self):
    """
    Getter method for serviceType, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/serviceType (string)

    YANG Description: Set the authentication service type, which can be IP or OSI.
    """
    return self.__serviceType
      
  def _set_serviceType(self, v, load=False):
    """
    Setter method for serviceType, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/serviceType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serviceType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serviceType() directly.

    YANG Description: Set the authentication service type, which can be IP or OSI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serviceType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__serviceType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serviceType(self):
    self.__serviceType = YANGDynClass(base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_authenUsage(self):
    """
    Getter method for authenUsage, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/authenUsage (string)

    YANG Description: Set the authentication mode. The available options are as follows:
authentication-avoid: In this mode, the authentication information is not encapsulated for the generated SNPs, and the received SNPs are not checked. The authentication information is encapsulated for only the generated LSPs, and the received LSPs are checked.
send-only: In this mode, the authentication information is encapsulated for the generated LSPs and SNPs. Only the received LSPs are checked.
all-send-only: In this mode, the authentication information is encapsulated for the generated LSPs and SNPS. The received LSPs and SNPs, however, are not checked.
    """
    return self.__authenUsage
      
  def _set_authenUsage(self, v, load=False):
    """
    Setter method for authenUsage, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/authenUsage (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authenUsage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authenUsage() directly.

    YANG Description: Set the authentication mode. The available options are as follows:
authentication-avoid: In this mode, the authentication information is not encapsulated for the generated SNPs, and the received SNPs are not checked. The authentication information is encapsulated for only the generated LSPs, and the received LSPs are checked.
send-only: In this mode, the authentication information is encapsulated for the generated LSPs and SNPs. Only the received LSPs are checked.
all-send-only: In this mode, the authentication information is encapsulated for the generated LSPs and SNPS. The received LSPs and SNPs, however, are not checked.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("usage_default"), is_leaf=True, yang_name="authenUsage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authenUsage must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("usage_default"), is_leaf=True, yang_name="authenUsage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__authenUsage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authenUsage(self):
    self.__authenUsage = YANGDynClass(base=six.text_type, default=six.text_type("usage_default"), is_leaf=True, yang_name="authenUsage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_keyId(self):
    """
    Getter method for keyId, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/keyId (uint16)

    YANG Description: Set a value for key ID.
    """
    return self.__keyId
      
  def _set_keyId(self, v, load=False):
    """
    Setter method for keyId, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication/keyId (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyId() directly.

    YANG Description: Set a value for key ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyId must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)""",
        })

    self.__keyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyId(self):
    self.__keyId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

  cmdType = __builtin__.property(_get_cmdType, _set_cmdType)
  passwordType = __builtin__.property(_get_passwordType, _set_passwordType)
  simplePassword = __builtin__.property(_get_simplePassword, _set_simplePassword)
  md5Password = __builtin__.property(_get_md5Password, _set_md5Password)
  keyChainName = __builtin__.property(_get_keyChainName, _set_keyChainName)
  serviceType = __builtin__.property(_get_serviceType, _set_serviceType)
  authenUsage = __builtin__.property(_get_authenUsage, _set_authenUsage)
  keyId = __builtin__.property(_get_keyId, _set_keyId)


  _pyangbind_elements = OrderedDict([('cmdType', cmdType), ('passwordType', passwordType), ('simplePassword', simplePassword), ('md5Password', md5Password), ('keyChainName', keyChainName), ('serviceType', serviceType), ('authenUsage', authenUsage), ('keyId', keyId), ])


class yc_isLspAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLspAuthtications. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routing packet authentication list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLspAuthtication',)

  _yang_name = 'isLspAuthtications'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLspAuthtication = YANGDynClass(base=YANGListType("cmdType",yc_isLspAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications_isLspAuthtication, yang_name="isLspAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cmdType', extensions=None), is_container='list', yang_name="isLspAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLspAuthtications']

  def _get_isLspAuthtication(self):
    """
    Getter method for isLspAuthtication, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication (list)

    YANG Description: Authenticate received routing packets (LSPs or SNPs) based on the specified authentication mode and password in an IS-IS area or domain. 
    """
    return self.__isLspAuthtication
      
  def _set_isLspAuthtication(self, v, load=False):
    """
    Setter method for isLspAuthtication, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications/isLspAuthtication (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLspAuthtication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLspAuthtication() directly.

    YANG Description: Authenticate received routing packets (LSPs or SNPs) based on the specified authentication mode and password in an IS-IS area or domain. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("cmdType",yc_isLspAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications_isLspAuthtication, yang_name="isLspAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cmdType', extensions=None), is_container='list', yang_name="isLspAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLspAuthtication must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("cmdType",yc_isLspAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications_isLspAuthtication, yang_name="isLspAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cmdType', extensions=None), is_container='list', yang_name="isLspAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isLspAuthtication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLspAuthtication(self):
    self.__isLspAuthtication = YANGDynClass(base=YANGListType("cmdType",yc_isLspAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications_isLspAuthtication, yang_name="isLspAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='cmdType', extensions=None), is_container='list', yang_name="isLspAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isLspAuthtication = __builtin__.property(_get_isLspAuthtication, _set_isLspAuthtication) # type: yc_isLspAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications_isLspAuthtication


  _pyangbind_elements = OrderedDict([('isLspAuthtication', isLspAuthtication), ])


class yc_isNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables_isNameTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isNameTables/isNameTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable the ability to identify the host names in LSPs. On the local end, a mapping name (an alias) is configured for the IS-IS system on the remote end. The mapping name is not advertised.
  """
  __slots__ = ('_path_helper', '_extmethods', '__systemId','__hostName',)

  _yang_name = 'isNameTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4}(\\.([0-9]|[a-f]|[A-F]){2})?)', 'length': ['12..31']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__hostName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..64']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isNameTables', 'isNameTable']

  def _get_systemId(self):
    """
    Getter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables/isNameTable/systemId (string)

    YANG Description: ID of the IS-IS system on the remote end or the pseudo node ID. The value is in the format of XXXX.XXXX.XXXX[.XX], in which X is a case-insensitive hexadecimal character. The value of a pseudo node cannot be 0.
    """
    return self.__systemId
      
  def _set_systemId(self, v, load=False):
    """
    Setter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables/isNameTable/systemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_systemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_systemId() directly.

    YANG Description: ID of the IS-IS system on the remote end or the pseudo node ID. The value is in the format of XXXX.XXXX.XXXX[.XX], in which X is a case-insensitive hexadecimal character. The value of a pseudo node cannot be 0.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4}(\\.([0-9]|[a-f]|[A-F]){2})?)', 'length': ['12..31']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """systemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4}(\\.([0-9]|[a-f]|[A-F]){2})?)', 'length': ['12..31']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__systemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_systemId(self):
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4}(\\.([0-9]|[a-f]|[A-F]){2})?)', 'length': ['12..31']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_hostName(self):
    """
    Getter method for hostName, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables/isNameTable/hostName (string)

    YANG Description: Name of the IS-IS system on the remote end. 
    """
    return self.__hostName
      
  def _set_hostName(self, v, load=False):
    """
    Setter method for hostName, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables/isNameTable/hostName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostName() directly.

    YANG Description: Name of the IS-IS system on the remote end. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..64']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..64']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__hostName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostName(self):
    self.__hostName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..64']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  systemId = __builtin__.property(_get_systemId, _set_systemId)
  hostName = __builtin__.property(_get_hostName, _set_hostName)


  _pyangbind_elements = OrderedDict([('systemId', systemId), ('hostName', hostName), ])


class yc_isNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isNameTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of name mapping information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isNameTable',)

  _yang_name = 'isNameTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isNameTable = YANGDynClass(base=YANGListType("systemId",yc_isNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables_isNameTable, yang_name="isNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='systemId', extensions=None), is_container='list', yang_name="isNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isNameTables']

  def _get_isNameTable(self):
    """
    Getter method for isNameTable, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables/isNameTable (list)

    YANG Description: Enable the ability to identify the host names in LSPs. On the local end, a mapping name (an alias) is configured for the IS-IS system on the remote end. The mapping name is not advertised.
    """
    return self.__isNameTable
      
  def _set_isNameTable(self, v, load=False):
    """
    Setter method for isNameTable, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables/isNameTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNameTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNameTable() directly.

    YANG Description: Enable the ability to identify the host names in LSPs. On the local end, a mapping name (an alias) is configured for the IS-IS system on the remote end. The mapping name is not advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("systemId",yc_isNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables_isNameTable, yang_name="isNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='systemId', extensions=None), is_container='list', yang_name="isNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNameTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("systemId",yc_isNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables_isNameTable, yang_name="isNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='systemId', extensions=None), is_container='list', yang_name="isNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isNameTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNameTable(self):
    self.__isNameTable = YANGDynClass(base=YANGListType("systemId",yc_isNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables_isNameTable, yang_name="isNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='systemId', extensions=None), is_container='list', yang_name="isNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isNameTable = __builtin__.property(_get_isNameTable, _set_isNameTable) # type: yc_isNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables_isNameTable


  _pyangbind_elements = OrderedDict([('isNameTable', isNameTable), ])


class yc_isVirtualSystem_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems_isVirtualSystem(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isVirtualSystems/isVirtualSystem. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual system ID used to set the IS-IS process. Without a system ID, extended LSPs are not generated. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtualSystemId',)

  _yang_name = 'isVirtualSystem'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtualSystemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['12..19']}), is_leaf=True, yang_name="virtualSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isVirtualSystems', 'isVirtualSystem']

  def _get_virtualSystemId(self):
    """
    Getter method for virtualSystemId, mapped from YANG variable /isiscomm/isSites/isSite/isVirtualSystems/isVirtualSystem/virtualSystemId (string)

    YANG Description: Set a virtual system ID for an IS-IS process. The length of the value is 6 bytes. The value is in the format of XXXX.XXXX.XXXX, in which X is a case-insensitive hexadecimal character.
    """
    return self.__virtualSystemId
      
  def _set_virtualSystemId(self, v, load=False):
    """
    Setter method for virtualSystemId, mapped from YANG variable /isiscomm/isSites/isSite/isVirtualSystems/isVirtualSystem/virtualSystemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualSystemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualSystemId() directly.

    YANG Description: Set a virtual system ID for an IS-IS process. The length of the value is 6 bytes. The value is in the format of XXXX.XXXX.XXXX, in which X is a case-insensitive hexadecimal character.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['12..19']}), is_leaf=True, yang_name="virtualSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualSystemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['12..19']}), is_leaf=True, yang_name="virtualSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__virtualSystemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualSystemId(self):
    self.__virtualSystemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['12..19']}), is_leaf=True, yang_name="virtualSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  virtualSystemId = __builtin__.property(_get_virtualSystemId, _set_virtualSystemId)


  _pyangbind_elements = OrderedDict([('virtualSystemId', virtualSystemId), ])


class yc_isVirtualSystems_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isVirtualSystems. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual system list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isVirtualSystem',)

  _yang_name = 'isVirtualSystems'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isVirtualSystem = YANGDynClass(base=YANGListType("virtualSystemId",yc_isVirtualSystem_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems_isVirtualSystem, yang_name="isVirtualSystem", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtualSystemId', extensions=None), is_container='list', yang_name="isVirtualSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isVirtualSystems']

  def _get_isVirtualSystem(self):
    """
    Getter method for isVirtualSystem, mapped from YANG variable /isiscomm/isSites/isSite/isVirtualSystems/isVirtualSystem (list)

    YANG Description: Virtual system ID used to set the IS-IS process. Without a system ID, extended LSPs are not generated. 
    """
    return self.__isVirtualSystem
      
  def _set_isVirtualSystem(self, v, load=False):
    """
    Setter method for isVirtualSystem, mapped from YANG variable /isiscomm/isSites/isSite/isVirtualSystems/isVirtualSystem (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isVirtualSystem is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isVirtualSystem() directly.

    YANG Description: Virtual system ID used to set the IS-IS process. Without a system ID, extended LSPs are not generated. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("virtualSystemId",yc_isVirtualSystem_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems_isVirtualSystem, yang_name="isVirtualSystem", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtualSystemId', extensions=None), is_container='list', yang_name="isVirtualSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isVirtualSystem must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("virtualSystemId",yc_isVirtualSystem_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems_isVirtualSystem, yang_name="isVirtualSystem", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtualSystemId', extensions=None), is_container='list', yang_name="isVirtualSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isVirtualSystem = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isVirtualSystem(self):
    self.__isVirtualSystem = YANGDynClass(base=YANGListType("virtualSystemId",yc_isVirtualSystem_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems_isVirtualSystem, yang_name="isVirtualSystem", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtualSystemId', extensions=None), is_container='list', yang_name="isVirtualSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isVirtualSystem = __builtin__.property(_get_isVirtualSystem, _set_isVirtualSystem) # type: yc_isVirtualSystem_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems_isVirtualSystem


  _pyangbind_elements = OrderedDict([('isVirtualSystem', isVirtualSystem), ])


class yc_isSrgb_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs_isSrgb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSrgbs/isSrgb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about Segment Routing Global-block.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srgbBegin','__srgbEnd',)

  _yang_name = 'isSrgb'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srgbBegin = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbBegin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__srgbEnd = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbEnd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSrgbs', 'isSrgb']

  def _get_srgbBegin(self):
    """
    Getter method for srgbBegin, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs/isSrgb/srgbBegin (uint32)

    YANG Description: SRGB begin value.
    """
    return self.__srgbBegin
      
  def _set_srgbBegin(self, v, load=False):
    """
    Setter method for srgbBegin, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs/isSrgb/srgbBegin (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srgbBegin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srgbBegin() directly.

    YANG Description: SRGB begin value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbBegin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srgbBegin must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbBegin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__srgbBegin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srgbBegin(self):
    self.__srgbBegin = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbBegin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_srgbEnd(self):
    """
    Getter method for srgbEnd, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs/isSrgb/srgbEnd (uint32)

    YANG Description: SRGB end value.
    """
    return self.__srgbEnd
      
  def _set_srgbEnd(self, v, load=False):
    """
    Setter method for srgbEnd, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs/isSrgb/srgbEnd (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srgbEnd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srgbEnd() directly.

    YANG Description: SRGB end value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbEnd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srgbEnd must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbEnd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__srgbEnd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srgbEnd(self):
    self.__srgbEnd = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="srgbEnd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  srgbBegin = __builtin__.property(_get_srgbBegin, _set_srgbBegin)
  srgbEnd = __builtin__.property(_get_srgbEnd, _set_srgbEnd)


  _pyangbind_elements = OrderedDict([('srgbBegin', srgbBegin), ('srgbEnd', srgbEnd), ])


class yc_isSrgbs_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSrgbs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Segment Routing Global-block.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isSrgb',)

  _yang_name = 'isSrgbs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isSrgb = YANGDynClass(base=YANGListType("srgbBegin srgbEnd",yc_isSrgb_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs_isSrgb, yang_name="isSrgb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srgbBegin srgbEnd', extensions=None), is_container='list', yang_name="isSrgb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSrgbs']

  def _get_isSrgb(self):
    """
    Getter method for isSrgb, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs/isSrgb (list)

    YANG Description: Information about Segment Routing Global-block.
    """
    return self.__isSrgb
      
  def _set_isSrgb(self, v, load=False):
    """
    Setter method for isSrgb, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs/isSrgb (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrgb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrgb() directly.

    YANG Description: Information about Segment Routing Global-block.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srgbBegin srgbEnd",yc_isSrgb_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs_isSrgb, yang_name="isSrgb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srgbBegin srgbEnd', extensions=None), is_container='list', yang_name="isSrgb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrgb must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srgbBegin srgbEnd",yc_isSrgb_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs_isSrgb, yang_name="isSrgb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srgbBegin srgbEnd', extensions=None), is_container='list', yang_name="isSrgb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isSrgb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrgb(self):
    self.__isSrgb = YANGDynClass(base=YANGListType("srgbBegin srgbEnd",yc_isSrgb_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs_isSrgb, yang_name="isSrgb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srgbBegin srgbEnd', extensions=None), is_container='list', yang_name="isSrgb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isSrgb = __builtin__.property(_get_isSrgb, _set_isSrgb) # type: yc_isSrgb_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs_isSrgb


  _pyangbind_elements = OrderedDict([('isSrgb', isSrgb), ])


class yc_isHelloAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications_isHelloAuthtication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an IS-IS interface to authenticate Hello packets in the specified mode and password.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__passwordType','__simplePassword','__keyChainName','__md5Password','__serviceType','__sendOnly','__keyId',)

  _yang_name = 'isHelloAuthtication'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__passwordType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__simplePassword = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__md5Password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__serviceType = YANGDynClass(base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__sendOnly = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sendOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__keyId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isCircuits', 'isCircuit', 'isHelloAuthtications', 'isHelloAuthtication']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/levelType (string)

    YANG Description: Set the level type for authentication, which can be level-1 or level-2. This field is not required for P2P interfaces.
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Set the level type for authentication, which can be level-1 or level-2. This field is not required for P2P interfaces.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_passwordType(self):
    """
    Getter method for passwordType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/passwordType (string)

    YANG Description: Set the authentication password type of Hello packets, which can be simple, MD5, etc.
    """
    return self.__passwordType
      
  def _set_passwordType(self, v, load=False):
    """
    Setter method for passwordType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/passwordType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_passwordType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_passwordType() directly.

    YANG Description: Set the authentication password type of Hello packets, which can be simple, MD5, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """passwordType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__passwordType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_passwordType(self):
    self.__passwordType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="passwordType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_simplePassword(self):
    """
    Getter method for simplePassword, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/simplePassword (string)

    YANG Description: Set a plaintext. The value is a string of characters (letters or digits), spaces not supported.The password is a string ranging from 1 to 16 characters for a plaintext password and 1 to 128 characters for a ciphertext password.
    """
    return self.__simplePassword
      
  def _set_simplePassword(self, v, load=False):
    """
    Setter method for simplePassword, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/simplePassword (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_simplePassword is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_simplePassword() directly.

    YANG Description: Set a plaintext. The value is a string of characters (letters or digits), spaces not supported.The password is a string ranging from 1 to 16 characters for a plaintext password and 1 to 128 characters for a ciphertext password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """simplePassword must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__simplePassword = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_simplePassword(self):
    self.__simplePassword = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="simplePassword", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_keyChainName(self):
    """
    Getter method for keyChainName, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/keyChainName (string)

    YANG Description: Keychain Name.
    """
    return self.__keyChainName
      
  def _set_keyChainName(self, v, load=False):
    """
    Setter method for keyChainName, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/keyChainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyChainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyChainName() directly.

    YANG Description: Keychain Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyChainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__keyChainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyChainName(self):
    self.__keyChainName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..47']}), is_leaf=True, yang_name="keyChainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_md5Password(self):
    """
    Getter method for md5Password, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/md5Password (string)

    YANG Description: Set a MD5 or HMAC-SHA256 authentication password. The value is a string of characters (letters or digits), spaces not supported.The password is a string ranging from 1 to 255 characters for a plaintext password and 1 to 432 characters for a ciphertext password.
    """
    return self.__md5Password
      
  def _set_md5Password(self, v, load=False):
    """
    Setter method for md5Password, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/md5Password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md5Password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md5Password() directly.

    YANG Description: Set a MD5 or HMAC-SHA256 authentication password. The value is a string of characters (letters or digits), spaces not supported.The password is a string ranging from 1 to 255 characters for a plaintext password and 1 to 432 characters for a ciphertext password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md5Password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__md5Password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md5Password(self):
    self.__md5Password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5Password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_serviceType(self):
    """
    Getter method for serviceType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/serviceType (string)

    YANG Description: Set the authentication service type, which can be IP or OSI.
    """
    return self.__serviceType
      
  def _set_serviceType(self, v, load=False):
    """
    Setter method for serviceType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/serviceType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serviceType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serviceType() directly.

    YANG Description: Set the authentication service type, which can be IP or OSI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serviceType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__serviceType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serviceType(self):
    self.__serviceType = YANGDynClass(base=six.text_type, default=six.text_type("osi"), is_leaf=True, yang_name="serviceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_sendOnly(self):
    """
    Getter method for sendOnly, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/sendOnly (boolean)

    YANG Description: Encapsulate the authentication information in only the Hello packets to be sent.
    """
    return self.__sendOnly
      
  def _set_sendOnly(self, v, load=False):
    """
    Setter method for sendOnly, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/sendOnly (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sendOnly is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sendOnly() directly.

    YANG Description: Encapsulate the authentication information in only the Hello packets to be sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sendOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sendOnly must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sendOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__sendOnly = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sendOnly(self):
    self.__sendOnly = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sendOnly", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_keyId(self):
    """
    Getter method for keyId, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/keyId (uint16)

    YANG Description: Set a value for Key ID.
    """
    return self.__keyId
      
  def _set_keyId(self, v, load=False):
    """
    Setter method for keyId, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication/keyId (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyId() directly.

    YANG Description: Set a value for Key ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyId must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)""",
        })

    self.__keyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyId(self):
    self.__keyId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="keyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

  levelType = __builtin__.property(_get_levelType, _set_levelType)
  passwordType = __builtin__.property(_get_passwordType, _set_passwordType)
  simplePassword = __builtin__.property(_get_simplePassword, _set_simplePassword)
  keyChainName = __builtin__.property(_get_keyChainName, _set_keyChainName)
  md5Password = __builtin__.property(_get_md5Password, _set_md5Password)
  serviceType = __builtin__.property(_get_serviceType, _set_serviceType)
  sendOnly = __builtin__.property(_get_sendOnly, _set_sendOnly)
  keyId = __builtin__.property(_get_keyId, _set_keyId)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('passwordType', passwordType), ('simplePassword', simplePassword), ('keyChainName', keyChainName), ('md5Password', md5Password), ('serviceType', serviceType), ('sendOnly', sendOnly), ('keyId', keyId), ])


class yc_isHelloAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Hello packet authentication.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isHelloAuthtication',)

  _yang_name = 'isHelloAuthtications'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isHelloAuthtication = YANGDynClass(base=YANGListType("levelType",yc_isHelloAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications_isHelloAuthtication, yang_name="isHelloAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isHelloAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isCircuits', 'isCircuit', 'isHelloAuthtications']

  def _get_isHelloAuthtication(self):
    """
    Getter method for isHelloAuthtication, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication (list)

    YANG Description: Configure an IS-IS interface to authenticate Hello packets in the specified mode and password.
    """
    return self.__isHelloAuthtication
      
  def _set_isHelloAuthtication(self, v, load=False):
    """
    Setter method for isHelloAuthtication, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications/isHelloAuthtication (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isHelloAuthtication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isHelloAuthtication() directly.

    YANG Description: Configure an IS-IS interface to authenticate Hello packets in the specified mode and password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType",yc_isHelloAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications_isHelloAuthtication, yang_name="isHelloAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isHelloAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isHelloAuthtication must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType",yc_isHelloAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications_isHelloAuthtication, yang_name="isHelloAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isHelloAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isHelloAuthtication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isHelloAuthtication(self):
    self.__isHelloAuthtication = YANGDynClass(base=YANGListType("levelType",yc_isHelloAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications_isHelloAuthtication, yang_name="isHelloAuthtication", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isHelloAuthtication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isHelloAuthtication = __builtin__.property(_get_isHelloAuthtication, _set_isHelloAuthtication) # type: yc_isHelloAuthtication_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications_isHelloAuthtication


  _pyangbind_elements = OrderedDict([('isHelloAuthtication', isHelloAuthtication), ])


class yc_isSrlg_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs_isSrlg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs/isSrlg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set values for the Srlg group ID
  """
  __slots__ = ('_path_helper', '_extmethods', '__srlgGroupId',)

  _yang_name = 'isSrlg'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srlgGroupId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="srlgGroupId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isCircuits', 'isCircuit', 'isSrlgs', 'isSrlg']

  def _get_srlgGroupId(self):
    """
    Getter method for srlgGroupId, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs/isSrlg/srlgGroupId (uint32)

    YANG Description: Set the Srlg group ID.
    """
    return self.__srlgGroupId
      
  def _set_srlgGroupId(self, v, load=False):
    """
    Setter method for srlgGroupId, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs/isSrlg/srlgGroupId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srlgGroupId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srlgGroupId() directly.

    YANG Description: Set the Srlg group ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="srlgGroupId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srlgGroupId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="srlgGroupId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__srlgGroupId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srlgGroupId(self):
    self.__srlgGroupId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="srlgGroupId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  srlgGroupId = __builtin__.property(_get_srlgGroupId, _set_srlgGroupId)


  _pyangbind_elements = OrderedDict([('srlgGroupId', srlgGroupId), ])


class yc_isSrlgs_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Share risk link-group information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isSrlg',)

  _yang_name = 'isSrlgs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isSrlg = YANGDynClass(base=YANGListType("srlgGroupId",yc_isSrlg_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs_isSrlg, yang_name="isSrlg", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srlgGroupId', extensions=None), is_container='list', yang_name="isSrlg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isCircuits', 'isCircuit', 'isSrlgs']

  def _get_isSrlg(self):
    """
    Getter method for isSrlg, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs/isSrlg (list)

    YANG Description: Set values for the Srlg group ID
    """
    return self.__isSrlg
      
  def _set_isSrlg(self, v, load=False):
    """
    Setter method for isSrlg, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs/isSrlg (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrlg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrlg() directly.

    YANG Description: Set values for the Srlg group ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("srlgGroupId",yc_isSrlg_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs_isSrlg, yang_name="isSrlg", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srlgGroupId', extensions=None), is_container='list', yang_name="isSrlg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrlg must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("srlgGroupId",yc_isSrlg_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs_isSrlg, yang_name="isSrlg", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srlgGroupId', extensions=None), is_container='list', yang_name="isSrlg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isSrlg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrlg(self):
    self.__isSrlg = YANGDynClass(base=YANGListType("srlgGroupId",yc_isSrlg_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs_isSrlg, yang_name="isSrlg", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='srlgGroupId', extensions=None), is_container='list', yang_name="isSrlg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isSrlg = __builtin__.property(_get_isSrlg, _set_isSrlg) # type: yc_isSrlg_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs_isSrlg


  _pyangbind_elements = OrderedDict([('isSrlg', isSrlg), ])


class yc_isCircuit_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isCircuits/isCircuit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set parameters for an IS-IS interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifName','__ipv4Enable','__ipv6Enable','__circuitLevelType','__typeP2pEnable','__snpaCheck','__silentEnable','__silentCost','__level1CsnpInterval','__level2CsnpInterval','__throttleTimer','__throttleCount','__level1HelloTimer','__level2HelloTimer','__level1HoldMultiplier','__level2HoldMultiplier','__disName','__level1DisPriority','__level2DisPriority','__p2pPeerIPIgnore','__p2pNegotiationMode','__p2pHelloTimer','__p2pHoldMulti','__lspRetransmitInterval','__pPPOsicpCheckEnable','__ldpAutoBlock','__helloMode','__level1Cost','__level2Cost','__ldpSyncState','__ldpSyncTimerEnable','__ldpSyncTimer','__ldpSyncHDTimerEnable','__ldpSyncHDTimer','__ldpSynInfinite','__level1FrrBlock','__level2FrrBlock','__level1RemoteLFA','__level2RemoteLFA','__l1TilfaDisable','__l2TilfaDisable','__peerFlapSuppressEnable','__peerFlapSuppressDetectInterval','__peerFlapSuppressThreshold','__peerFlapSuppressResumeInterval','__peerFlapSuppressHoldDown','__peerFlapSuppressDownInterval','__peerFlapSuppressHoldMaxCost','__peerFlapSuppressStatus','__peerFlapCount','__peerFlapThreshold','__peerFlapSuppressTimer','__peerFlapSuppressRemainTimer','__meshGroupState','__meshGroupNumber','__incrCost','__incrCostIpv6','__circuitId','__circuitMTU','__circuitL1IsDis','__circuitL2IsDis','__v4Status','__mtuState','__linkState','__ipState','__v6Status','__mtuV6State','__linkV6State','__ipV6State','__vcState','__level1Conser','__level2Conser','__p2pConser','__purgeSourceTraceBlock','__isHelloAuthtications','__peerHoldMaxCostTimer','__isSrlgs',)

  _yang_name = 'isCircuit'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipv4Enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ipv4Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ipv6Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__circuitLevelType = YANGDynClass(base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="circuitLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__typeP2pEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="typeP2pEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__snpaCheck = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snpaCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__silentEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__silentCost = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1CsnpInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2CsnpInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__throttleTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="throttleTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__throttleCount = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="throttleCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1HelloTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2HelloTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1HoldMultiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level1HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2HoldMultiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level2HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__disName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..64']}), is_leaf=True, yang_name="disName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__level1DisPriority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level1DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2DisPriority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level2DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__p2pPeerIPIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pPeerIPIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__p2pNegotiationMode = YANGDynClass(base=six.text_type, default=six.text_type("3_way"), is_leaf=True, yang_name="p2pNegotiationMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__p2pHelloTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="p2pHelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__p2pHoldMulti = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="p2pHoldMulti", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__lspRetransmitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="lspRetransmitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__pPPOsicpCheckEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pPPOsicpCheckEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpAutoBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__helloMode = YANGDynClass(base=six.text_type, default=six.text_type("normal"), is_leaf=True, yang_name="helloMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__level1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__ldpSyncState = YANGDynClass(base=six.text_type, default=six.text_type("noConfig"), is_leaf=True, yang_name="ldpSyncState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ldpSyncTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpSyncTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__ldpSyncHDTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ldpSyncHDTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__ldpSynInfinite = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSynInfinite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__l1TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__l2TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__peerFlapSuppressEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__peerFlapSuppressDetectInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="peerFlapSuppressDetectInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__peerFlapSuppressThreshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="peerFlapSuppressThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__peerFlapSuppressResumeInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="peerFlapSuppressResumeInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__peerFlapSuppressHoldDown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="peerFlapSuppressHoldDown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__peerFlapSuppressDownInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..600']}), is_leaf=True, yang_name="peerFlapSuppressDownInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__peerFlapSuppressHoldMaxCost = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressHoldMaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__peerFlapSuppressStatus = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerFlapSuppressStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__peerFlapCount = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__peerFlapThreshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__peerFlapSuppressTimer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peerFlapSuppressTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__peerFlapSuppressRemainTimer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapSuppressRemainTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__meshGroupState = YANGDynClass(base=six.text_type, default=six.text_type("inactive"), is_leaf=True, yang_name="meshGroupState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__meshGroupNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="meshGroupNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__incrCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__incrCostIpv6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777214']}), is_leaf=True, yang_name="incrCostIpv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__circuitId = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=False)
    self.__circuitMTU = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circuitMTU", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__circuitL1IsDis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circuitL1IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__circuitL2IsDis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circuitL2IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__v4Status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v4Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__mtuState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mtuState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__linkState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="linkState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__ipState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__v6Status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v6Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__mtuV6State = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mtuV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__linkV6State = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="linkV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__ipV6State = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__vcState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vcState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__level1Conser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2Conser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__p2pConser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pConser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__purgeSourceTraceBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="purgeSourceTraceBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isHelloAuthtications = YANGDynClass(base=yc_isHelloAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications, is_container='container', yang_name="isHelloAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__peerHoldMaxCostTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peerHoldMaxCostTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__isSrlgs = YANGDynClass(base=yc_isSrlgs_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs, is_container='container', yang_name="isSrlgs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isCircuits', 'isCircuit']

  def _get_ifName(self):
    """
    Getter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ifName (string)

    YANG Description: Interface name.
    """
    return self.__ifName
      
  def _set_ifName(self, v, load=False):
    """
    Setter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ifName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifName() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ifName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifName(self):
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipv4Enable(self):
    """
    Getter method for ipv4Enable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipv4Enable (boolean)

    YANG Description: Enable IS-IS IPv4 on an interface. This flag or the flag for enabling IS-IS IPv6 must be enabled when creating an interface and at least one needs to be true during the modification of an interface.
    """
    return self.__ipv4Enable
      
  def _set_ipv4Enable(self, v, load=False):
    """
    Setter method for ipv4Enable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipv4Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Enable() directly.

    YANG Description: Enable IS-IS IPv4 on an interface. This flag or the flag for enabling IS-IS IPv6 must be enabled when creating an interface and at least one needs to be true during the modification of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ipv4Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ipv4Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv4Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Enable(self):
    self.__ipv4Enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ipv4Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ipv6Enable(self):
    """
    Getter method for ipv6Enable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipv6Enable (boolean)

    YANG Description: Enable IS-IS IPv6 on an interface. IPv6 must have been enabled in a process and on the interface. This flag or the flag for enabling IS-IS IPv4 must be enabled when creating an interface and at least one needs to be true during the modification of an interface.
    """
    return self.__ipv6Enable
      
  def _set_ipv6Enable(self, v, load=False):
    """
    Setter method for ipv6Enable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipv6Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Enable() directly.

    YANG Description: Enable IS-IS IPv6 on an interface. IPv6 must have been enabled in a process and on the interface. This flag or the flag for enabling IS-IS IPv4 must be enabled when creating an interface and at least one needs to be true during the modification of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv6Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Enable(self):
    self.__ipv6Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_circuitLevelType(self):
    """
    Getter method for circuitLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitLevelType (string)

    YANG Description: Set a level for an interface, which can be level-1, level-2, or level-1-2. The default value is level-1-2.
    """
    return self.__circuitLevelType
      
  def _set_circuitLevelType(self, v, load=False):
    """
    Setter method for circuitLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitLevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitLevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitLevelType() directly.

    YANG Description: Set a level for an interface, which can be level-1, level-2, or level-1-2. The default value is level-1-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="circuitLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitLevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="circuitLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__circuitLevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitLevelType(self):
    self.__circuitLevelType = YANGDynClass(base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="circuitLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_typeP2pEnable(self):
    """
    Getter method for typeP2pEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/typeP2pEnable (boolean)

    YANG Description: Emulate an interface as a P2P interface. This command takes effect only when the interface is of the broadcast type.
    """
    return self.__typeP2pEnable
      
  def _set_typeP2pEnable(self, v, load=False):
    """
    Setter method for typeP2pEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/typeP2pEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_typeP2pEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_typeP2pEnable() directly.

    YANG Description: Emulate an interface as a P2P interface. This command takes effect only when the interface is of the broadcast type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="typeP2pEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """typeP2pEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="typeP2pEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__typeP2pEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_typeP2pEnable(self):
    self.__typeP2pEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="typeP2pEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_snpaCheck(self):
    """
    Getter method for snpaCheck, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/snpaCheck (boolean)

    YANG Description: Enable the SNPA check of LSP and SNP.
    """
    return self.__snpaCheck
      
  def _set_snpaCheck(self, v, load=False):
    """
    Setter method for snpaCheck, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/snpaCheck (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snpaCheck is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snpaCheck() directly.

    YANG Description: Enable the SNPA check of LSP and SNP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snpaCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snpaCheck must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snpaCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__snpaCheck = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snpaCheck(self):
    self.__snpaCheck = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="snpaCheck", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_silentEnable(self):
    """
    Getter method for silentEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/silentEnable (boolean)

    YANG Description: Prevent an interface from receiving and sending IS-IS packets. By default, an interface can receive and send IS-IS packets. 
    """
    return self.__silentEnable
      
  def _set_silentEnable(self, v, load=False):
    """
    Setter method for silentEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/silentEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_silentEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_silentEnable() directly.

    YANG Description: Prevent an interface from receiving and sending IS-IS packets. By default, an interface can receive and send IS-IS packets. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """silentEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__silentEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_silentEnable(self):
    self.__silentEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_silentCost(self):
    """
    Getter method for silentCost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/silentCost (boolean)

    YANG Description: Advertise the silent cost.
    """
    return self.__silentCost
      
  def _set_silentCost(self, v, load=False):
    """
    Setter method for silentCost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/silentCost (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_silentCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_silentCost() directly.

    YANG Description: Advertise the silent cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """silentCost must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__silentCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_silentCost(self):
    self.__silentCost = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silentCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1CsnpInterval(self):
    """
    Getter method for level1CsnpInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1CsnpInterval (uint32)

    YANG Description: Set the interval at which level-1 CSNPs are sent. The value is expressed in seconds. The default value is 10.
    """
    return self.__level1CsnpInterval
      
  def _set_level1CsnpInterval(self, v, load=False):
    """
    Setter method for level1CsnpInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1CsnpInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1CsnpInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1CsnpInterval() directly.

    YANG Description: Set the interval at which level-1 CSNPs are sent. The value is expressed in seconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1CsnpInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1CsnpInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1CsnpInterval(self):
    self.__level1CsnpInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2CsnpInterval(self):
    """
    Getter method for level2CsnpInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2CsnpInterval (uint32)

    YANG Description: Set the interval at which level-2 CSNPs are sent. The value is expressed in seconds. The default value is 10.
    """
    return self.__level2CsnpInterval
      
  def _set_level2CsnpInterval(self, v, load=False):
    """
    Setter method for level2CsnpInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2CsnpInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2CsnpInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2CsnpInterval() directly.

    YANG Description: Set the interval at which level-2 CSNPs are sent. The value is expressed in seconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2CsnpInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2CsnpInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2CsnpInterval(self):
    self.__level2CsnpInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2CsnpInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_throttleTimer(self):
    """
    Getter method for throttleTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/throttleTimer (uint32)

    YANG Description: Set the minimum interval at which LSPs are sent. The value is expressed in milliseconds. The default value is 50.
    """
    return self.__throttleTimer
      
  def _set_throttleTimer(self, v, load=False):
    """
    Setter method for throttleTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/throttleTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_throttleTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_throttleTimer() directly.

    YANG Description: Set the minimum interval at which LSPs are sent. The value is expressed in milliseconds. The default value is 50.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="throttleTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """throttleTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="throttleTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__throttleTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_throttleTimer(self):
    self.__throttleTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="throttleTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_throttleCount(self):
    """
    Getter method for throttleCount, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/throttleCount (uint32)

    YANG Description: Set the maximum number of LSPs that are sent during the interval. The value is expressed in milliseconds. The default value is 10.
    """
    return self.__throttleCount
      
  def _set_throttleCount(self, v, load=False):
    """
    Setter method for throttleCount, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/throttleCount (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_throttleCount is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_throttleCount() directly.

    YANG Description: Set the maximum number of LSPs that are sent during the interval. The value is expressed in milliseconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="throttleCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """throttleCount must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="throttleCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__throttleCount = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_throttleCount(self):
    self.__throttleCount = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="throttleCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1HelloTimer(self):
    """
    Getter method for level1HelloTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1HelloTimer (uint32)

    YANG Description: Set the interval at which level-1 Hello packets are sent. The value is expressed in seconds. The default value is 10.
    """
    return self.__level1HelloTimer
      
  def _set_level1HelloTimer(self, v, load=False):
    """
    Setter method for level1HelloTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1HelloTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1HelloTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1HelloTimer() directly.

    YANG Description: Set the interval at which level-1 Hello packets are sent. The value is expressed in seconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1HelloTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1HelloTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1HelloTimer(self):
    self.__level1HelloTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level1HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2HelloTimer(self):
    """
    Getter method for level2HelloTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2HelloTimer (uint32)

    YANG Description: To set the interval for sending level-2 Hello packets. The value is expressed in seconds. The default value is 10.
    """
    return self.__level2HelloTimer
      
  def _set_level2HelloTimer(self, v, load=False):
    """
    Setter method for level2HelloTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2HelloTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2HelloTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2HelloTimer() directly.

    YANG Description: To set the interval for sending level-2 Hello packets. The value is expressed in seconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2HelloTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2HelloTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2HelloTimer(self):
    self.__level2HelloTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="level2HelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1HoldMultiplier(self):
    """
    Getter method for level1HoldMultiplier, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1HoldMultiplier (uint32)

    YANG Description: Set the number of Hello packets that the local IS-IS router fails to receive from a level-1 neighbor before the local router declares the neighbor Down. The default value is 3.
    """
    return self.__level1HoldMultiplier
      
  def _set_level1HoldMultiplier(self, v, load=False):
    """
    Setter method for level1HoldMultiplier, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1HoldMultiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1HoldMultiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1HoldMultiplier() directly.

    YANG Description: Set the number of Hello packets that the local IS-IS router fails to receive from a level-1 neighbor before the local router declares the neighbor Down. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level1HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1HoldMultiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level1HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1HoldMultiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1HoldMultiplier(self):
    self.__level1HoldMultiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level1HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2HoldMultiplier(self):
    """
    Getter method for level2HoldMultiplier, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2HoldMultiplier (uint32)

    YANG Description: Set the number of Hello packets that the local IS-IS router fails to receive from a level-2 neighbor before the local router declares the neighbor Down. The default value is 3.
    """
    return self.__level2HoldMultiplier
      
  def _set_level2HoldMultiplier(self, v, load=False):
    """
    Setter method for level2HoldMultiplier, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2HoldMultiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2HoldMultiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2HoldMultiplier() directly.

    YANG Description: Set the number of Hello packets that the local IS-IS router fails to receive from a level-2 neighbor before the local router declares the neighbor Down. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level2HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2HoldMultiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level2HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2HoldMultiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2HoldMultiplier(self):
    self.__level2HoldMultiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="level2HoldMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_disName(self):
    """
    Getter method for disName, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/disName (string)

    YANG Description: Set a name for the DIS on the LAN.
    """
    return self.__disName
      
  def _set_disName(self, v, load=False):
    """
    Setter method for disName, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/disName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disName() directly.

    YANG Description: Set a name for the DIS on the LAN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..64']}), is_leaf=True, yang_name="disName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..64']}), is_leaf=True, yang_name="disName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__disName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disName(self):
    self.__disName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..64']}), is_leaf=True, yang_name="disName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_level1DisPriority(self):
    """
    Getter method for level1DisPriority, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1DisPriority (uint32)

    YANG Description: Set a priority for level-1 DIS election. The default value is 64. The greater the value, the higher the priority.
    """
    return self.__level1DisPriority
      
  def _set_level1DisPriority(self, v, load=False):
    """
    Setter method for level1DisPriority, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1DisPriority (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1DisPriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1DisPriority() directly.

    YANG Description: Set a priority for level-1 DIS election. The default value is 64. The greater the value, the higher the priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level1DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1DisPriority must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level1DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1DisPriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1DisPriority(self):
    self.__level1DisPriority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level1DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2DisPriority(self):
    """
    Getter method for level2DisPriority, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2DisPriority (uint32)

    YANG Description: Set a priority for level-2 DIS election. The default value is 64. The greater the value, the higher the priority.
    """
    return self.__level2DisPriority
      
  def _set_level2DisPriority(self, v, load=False):
    """
    Setter method for level2DisPriority, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2DisPriority (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2DisPriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2DisPriority() directly.

    YANG Description: Set a priority for level-2 DIS election. The default value is 64. The greater the value, the higher the priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level2DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2DisPriority must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level2DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2DisPriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2DisPriority(self):
    self.__level2DisPriority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="level2DisPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_p2pPeerIPIgnore(self):
    """
    Getter method for p2pPeerIPIgnore, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pPeerIPIgnore (boolean)

    YANG Description: Ignore the IP address check when P2P Hello packets are received. By default, the IP addresses are checked when P2P Hello packets are received.
    """
    return self.__p2pPeerIPIgnore
      
  def _set_p2pPeerIPIgnore(self, v, load=False):
    """
    Setter method for p2pPeerIPIgnore, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pPeerIPIgnore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_p2pPeerIPIgnore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_p2pPeerIPIgnore() directly.

    YANG Description: Ignore the IP address check when P2P Hello packets are received. By default, the IP addresses are checked when P2P Hello packets are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pPeerIPIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """p2pPeerIPIgnore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pPeerIPIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__p2pPeerIPIgnore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_p2pPeerIPIgnore(self):
    self.__p2pPeerIPIgnore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pPeerIPIgnore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_p2pNegotiationMode(self):
    """
    Getter method for p2pNegotiationMode, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pNegotiationMode (string)

    YANG Description: Set the P2P neighbor negotiation type, which can be 2-way, 3-way, or 3-way only. The default value is 3-way.
    """
    return self.__p2pNegotiationMode
      
  def _set_p2pNegotiationMode(self, v, load=False):
    """
    Setter method for p2pNegotiationMode, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pNegotiationMode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_p2pNegotiationMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_p2pNegotiationMode() directly.

    YANG Description: Set the P2P neighbor negotiation type, which can be 2-way, 3-way, or 3-way only. The default value is 3-way.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("3_way"), is_leaf=True, yang_name="p2pNegotiationMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """p2pNegotiationMode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("3_way"), is_leaf=True, yang_name="p2pNegotiationMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__p2pNegotiationMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_p2pNegotiationMode(self):
    self.__p2pNegotiationMode = YANGDynClass(base=six.text_type, default=six.text_type("3_way"), is_leaf=True, yang_name="p2pNegotiationMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_p2pHelloTimer(self):
    """
    Getter method for p2pHelloTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pHelloTimer (uint32)

    YANG Description: Set the interval at which P2P Hello packets are sent. The value is expressed in seconds. The default value is 10.
    """
    return self.__p2pHelloTimer
      
  def _set_p2pHelloTimer(self, v, load=False):
    """
    Setter method for p2pHelloTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pHelloTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_p2pHelloTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_p2pHelloTimer() directly.

    YANG Description: Set the interval at which P2P Hello packets are sent. The value is expressed in seconds. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="p2pHelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """p2pHelloTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="p2pHelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__p2pHelloTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_p2pHelloTimer(self):
    self.__p2pHelloTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="p2pHelloTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_p2pHoldMulti(self):
    """
    Getter method for p2pHoldMulti, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pHoldMulti (uint32)

    YANG Description: Set the number of P2P Hello packets that the local IS-IS router fails to receive from a P2P neighbor before the local router declares the neighbor Down. The default value is 3.
    """
    return self.__p2pHoldMulti
      
  def _set_p2pHoldMulti(self, v, load=False):
    """
    Setter method for p2pHoldMulti, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pHoldMulti (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_p2pHoldMulti is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_p2pHoldMulti() directly.

    YANG Description: Set the number of P2P Hello packets that the local IS-IS router fails to receive from a P2P neighbor before the local router declares the neighbor Down. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="p2pHoldMulti", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """p2pHoldMulti must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="p2pHoldMulti", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__p2pHoldMulti = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_p2pHoldMulti(self):
    self.__p2pHoldMulti = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="p2pHoldMulti", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_lspRetransmitInterval(self):
    """
    Getter method for lspRetransmitInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/lspRetransmitInterval (uint32)

    YANG Description: Set the interval for retransmitting LSPs on the P2P link. The value is expressed in seconds. The default value is 5.
    """
    return self.__lspRetransmitInterval
      
  def _set_lspRetransmitInterval(self, v, load=False):
    """
    Setter method for lspRetransmitInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/lspRetransmitInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspRetransmitInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspRetransmitInterval() directly.

    YANG Description: Set the interval for retransmitting LSPs on the P2P link. The value is expressed in seconds. The default value is 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="lspRetransmitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspRetransmitInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="lspRetransmitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__lspRetransmitInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspRetransmitInterval(self):
    self.__lspRetransmitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="lspRetransmitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_pPPOsicpCheckEnable(self):
    """
    Getter method for pPPOsicpCheckEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/pPPOsicpCheckEnable (boolean)

    YANG Description: Check the OSICP negotiation status on the interfaces with PPP link protocols. The negotiation status affects the status of the interfaces in IS-IS. By default,  the OSICP negotiation status is not checked.
    """
    return self.__pPPOsicpCheckEnable
      
  def _set_pPPOsicpCheckEnable(self, v, load=False):
    """
    Setter method for pPPOsicpCheckEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/pPPOsicpCheckEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pPPOsicpCheckEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pPPOsicpCheckEnable() directly.

    YANG Description: Check the OSICP negotiation status on the interfaces with PPP link protocols. The negotiation status affects the status of the interfaces in IS-IS. By default,  the OSICP negotiation status is not checked.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pPPOsicpCheckEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pPPOsicpCheckEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pPPOsicpCheckEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__pPPOsicpCheckEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pPPOsicpCheckEnable(self):
    self.__pPPOsicpCheckEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pPPOsicpCheckEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpAutoBlock(self):
    """
    Getter method for ldpAutoBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpAutoBlock (boolean)

    YANG Description: Disable automatic MPLS LDP configuration on an interface.
    """
    return self.__ldpAutoBlock
      
  def _set_ldpAutoBlock(self, v, load=False):
    """
    Setter method for ldpAutoBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpAutoBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpAutoBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpAutoBlock() directly.

    YANG Description: Disable automatic MPLS LDP configuration on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpAutoBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpAutoBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpAutoBlock(self):
    self.__ldpAutoBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_helloMode(self):
    """
    Getter method for helloMode, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/helloMode (string)

    YANG Description: Set the Hello packet padding type, which can be Small, Padding, or Normal. The default value is Normal.
    """
    return self.__helloMode
      
  def _set_helloMode(self, v, load=False):
    """
    Setter method for helloMode, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/helloMode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helloMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helloMode() directly.

    YANG Description: Set the Hello packet padding type, which can be Small, Padding, or Normal. The default value is Normal.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("normal"), is_leaf=True, yang_name="helloMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helloMode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("normal"), is_leaf=True, yang_name="helloMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__helloMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helloMode(self):
    self.__helloMode = YANGDynClass(base=six.text_type, default=six.text_type("normal"), is_leaf=True, yang_name="helloMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_level1Cost(self):
    """
    Getter method for level1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1Cost (uint32)

    YANG Description: Link cost of an interface used for the level-1 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    return self.__level1Cost
      
  def _set_level1Cost(self, v, load=False):
    """
    Setter method for level1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1Cost() directly.

    YANG Description: Link cost of an interface used for the level-1 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1Cost(self):
    self.__level1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2Cost(self):
    """
    Getter method for level2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2Cost (uint32)

    YANG Description: Link cost of an interface used for the level-2 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    return self.__level2Cost
      
  def _set_level2Cost(self, v, load=False):
    """
    Setter method for level2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2Cost() directly.

    YANG Description: Link cost of an interface used for the level-2 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2Cost(self):
    self.__level2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_ldpSyncState(self):
    """
    Getter method for ldpSyncState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncState (string)

    YANG Description: LDP and IS-IS synchronization state on an interface, which can be NoConfig, Enable, or Block. The default value is NoConfig.
    """
    return self.__ldpSyncState
      
  def _set_ldpSyncState(self, v, load=False):
    """
    Setter method for ldpSyncState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncState() directly.

    YANG Description: LDP and IS-IS synchronization state on an interface, which can be NoConfig, Enable, or Block. The default value is NoConfig.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noConfig"), is_leaf=True, yang_name="ldpSyncState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noConfig"), is_leaf=True, yang_name="ldpSyncState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ldpSyncState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncState(self):
    self.__ldpSyncState = YANGDynClass(base=six.text_type, default=six.text_type("noConfig"), is_leaf=True, yang_name="ldpSyncState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ldpSyncTimerEnable(self):
    """
    Getter method for ldpSyncTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncTimerEnable (boolean)

    YANG Description: Enable the LDP and IS-IS synchronization timer.
    """
    return self.__ldpSyncTimerEnable
      
  def _set_ldpSyncTimerEnable(self, v, load=False):
    """
    Setter method for ldpSyncTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncTimerEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncTimerEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncTimerEnable() directly.

    YANG Description: Enable the LDP and IS-IS synchronization timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncTimerEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSyncTimerEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncTimerEnable(self):
    self.__ldpSyncTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpSyncTimer(self):
    """
    Getter method for ldpSyncTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncTimer (uint32)

    YANG Description: Set a value for the LDP and IS-IS synchronization timer. The value is expressed in seconds.
    """
    return self.__ldpSyncTimer
      
  def _set_ldpSyncTimer(self, v, load=False):
    """
    Setter method for ldpSyncTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncTimer() directly.

    YANG Description: Set a value for the LDP and IS-IS synchronization timer. The value is expressed in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__ldpSyncTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncTimer(self):
    self.__ldpSyncTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_ldpSyncHDTimerEnable(self):
    """
    Getter method for ldpSyncHDTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncHDTimerEnable (boolean)

    YANG Description: Enable the LDP and IS-IS synchronization holddown timer. 
    """
    return self.__ldpSyncHDTimerEnable
      
  def _set_ldpSyncHDTimerEnable(self, v, load=False):
    """
    Setter method for ldpSyncHDTimerEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncHDTimerEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncHDTimerEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncHDTimerEnable() directly.

    YANG Description: Enable the LDP and IS-IS synchronization holddown timer. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncHDTimerEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSyncHDTimerEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncHDTimerEnable(self):
    self.__ldpSyncHDTimerEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSyncHDTimerEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ldpSyncHDTimer(self):
    """
    Getter method for ldpSyncHDTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncHDTimer (uint32)

    YANG Description: Set a value for the LDP and IS-IS synchronization holddown timer. The value is expressed in seconds. 
    """
    return self.__ldpSyncHDTimer
      
  def _set_ldpSyncHDTimer(self, v, load=False):
    """
    Setter method for ldpSyncHDTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSyncHDTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSyncHDTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSyncHDTimer() directly.

    YANG Description: Set a value for the LDP and IS-IS synchronization holddown timer. The value is expressed in seconds. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSyncHDTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__ldpSyncHDTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSyncHDTimer(self):
    self.__ldpSyncHDTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="ldpSyncHDTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_ldpSynInfinite(self):
    """
    Getter method for ldpSynInfinite, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSynInfinite (boolean)

    YANG Description: Enable infinite LDP and IS-IS synchronization. The LDP and IS-IS synchronization is kept before the LDP session goes Up.
    """
    return self.__ldpSynInfinite
      
  def _set_ldpSynInfinite(self, v, load=False):
    """
    Setter method for ldpSynInfinite, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ldpSynInfinite (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpSynInfinite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpSynInfinite() directly.

    YANG Description: Enable infinite LDP and IS-IS synchronization. The LDP and IS-IS synchronization is kept before the LDP session goes Up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSynInfinite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpSynInfinite must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSynInfinite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpSynInfinite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpSynInfinite(self):
    self.__ldpSynInfinite = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpSynInfinite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1FrrBlock(self):
    """
    Getter method for level1FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1FrrBlock (boolean)

    YANG Description: Prevent an interface from participating Level-1 LFA Backup Interface calculation in an IPv4 base topology.
    """
    return self.__level1FrrBlock
      
  def _set_level1FrrBlock(self, v, load=False):
    """
    Setter method for level1FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1FrrBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1FrrBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1FrrBlock() directly.

    YANG Description: Prevent an interface from participating Level-1 LFA Backup Interface calculation in an IPv4 base topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1FrrBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1FrrBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1FrrBlock(self):
    self.__level1FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2FrrBlock(self):
    """
    Getter method for level2FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2FrrBlock (boolean)

    YANG Description: Prevent an interface from participating Level-2 LFA Backup Interface calculation in an IPv4 base topology.
    """
    return self.__level2FrrBlock
      
  def _set_level2FrrBlock(self, v, load=False):
    """
    Setter method for level2FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2FrrBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2FrrBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2FrrBlock() directly.

    YANG Description: Prevent an interface from participating Level-2 LFA Backup Interface calculation in an IPv4 base topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2FrrBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2FrrBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2FrrBlock(self):
    self.__level2FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1RemoteLFA(self):
    """
    Getter method for level1RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1RemoteLFA (boolean)

    YANG Description: Disable Level-1 RLFA of the Interface.
    """
    return self.__level1RemoteLFA
      
  def _set_level1RemoteLFA(self, v, load=False):
    """
    Setter method for level1RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1RemoteLFA (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1RemoteLFA is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1RemoteLFA() directly.

    YANG Description: Disable Level-1 RLFA of the Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1RemoteLFA must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1RemoteLFA = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1RemoteLFA(self):
    self.__level1RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2RemoteLFA(self):
    """
    Getter method for level2RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2RemoteLFA (boolean)

    YANG Description: Disable Level-2 RLFA of the Interface.
    """
    return self.__level2RemoteLFA
      
  def _set_level2RemoteLFA(self, v, load=False):
    """
    Setter method for level2RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2RemoteLFA (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2RemoteLFA is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2RemoteLFA() directly.

    YANG Description: Disable Level-2 RLFA of the Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2RemoteLFA must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2RemoteLFA = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2RemoteLFA(self):
    self.__level2RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_l1TilfaDisable(self):
    """
    Getter method for l1TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/l1TilfaDisable (boolean)

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-1 LFA calculation in the IPv4 base topology.
    """
    return self.__l1TilfaDisable
      
  def _set_l1TilfaDisable(self, v, load=False):
    """
    Setter method for l1TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/l1TilfaDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1TilfaDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1TilfaDisable() directly.

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-1 LFA calculation in the IPv4 base topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1TilfaDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__l1TilfaDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1TilfaDisable(self):
    self.__l1TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_l2TilfaDisable(self):
    """
    Getter method for l2TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/l2TilfaDisable (boolean)

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-2 LFA calculation in the IPv4 base topology.
    """
    return self.__l2TilfaDisable
      
  def _set_l2TilfaDisable(self, v, load=False):
    """
    Setter method for l2TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/l2TilfaDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2TilfaDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2TilfaDisable() directly.

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-2 LFA calculation in the IPv4 base topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2TilfaDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__l2TilfaDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2TilfaDisable(self):
    self.__l2TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_peerFlapSuppressEnable(self):
    """
    Getter method for peerFlapSuppressEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressEnable (boolean)

    YANG Description: Enable the neighbor relationship flapping suppression function. By default, the function is enabled.
    """
    return self.__peerFlapSuppressEnable
      
  def _set_peerFlapSuppressEnable(self, v, load=False):
    """
    Setter method for peerFlapSuppressEnable, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressEnable() directly.

    YANG Description: Enable the neighbor relationship flapping suppression function. By default, the function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__peerFlapSuppressEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressEnable(self):
    self.__peerFlapSuppressEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_peerFlapSuppressDetectInterval(self):
    """
    Getter method for peerFlapSuppressDetectInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressDetectInterval (uint32)

    YANG Description: Set the detection interval of neighbor relationship flapping suppression, in seconds. If the neighbor relationship goes Down twice within the interval, a flapping event is recorded. The default value is 60. 
    """
    return self.__peerFlapSuppressDetectInterval
      
  def _set_peerFlapSuppressDetectInterval(self, v, load=False):
    """
    Setter method for peerFlapSuppressDetectInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressDetectInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressDetectInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressDetectInterval() directly.

    YANG Description: Set the detection interval of neighbor relationship flapping suppression, in seconds. If the neighbor relationship goes Down twice within the interval, a flapping event is recorded. The default value is 60. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="peerFlapSuppressDetectInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressDetectInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="peerFlapSuppressDetectInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__peerFlapSuppressDetectInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressDetectInterval(self):
    self.__peerFlapSuppressDetectInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="peerFlapSuppressDetectInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_peerFlapSuppressThreshold(self):
    """
    Getter method for peerFlapSuppressThreshold, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressThreshold (uint32)

    YANG Description: Set the threshold of IS-IS neighbor relationship flapping suppression. When the flapping_count reaches or exceeds the threshold, flapping suppression takes effect. The default value is 10.
    """
    return self.__peerFlapSuppressThreshold
      
  def _set_peerFlapSuppressThreshold(self, v, load=False):
    """
    Setter method for peerFlapSuppressThreshold, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressThreshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressThreshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressThreshold() directly.

    YANG Description: Set the threshold of IS-IS neighbor relationship flapping suppression. When the flapping_count reaches or exceeds the threshold, flapping suppression takes effect. The default value is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="peerFlapSuppressThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressThreshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="peerFlapSuppressThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__peerFlapSuppressThreshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressThreshold(self):
    self.__peerFlapSuppressThreshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="peerFlapSuppressThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_peerFlapSuppressResumeInterval(self):
    """
    Getter method for peerFlapSuppressResumeInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressResumeInterval (uint32)

    YANG Description: Set the interval for exiting from IS-IS neighbor relationship flapping suppression, in seconds. If the interval between successive neighbor Down events is greater than resume-interval, the flapping_count is reset. In Hold-max-cost mode, if the neighbor relationship does not go Down within two successive resume-intervals or the interval between successive neighbor Down events is greater than resume-interval, the interface exits from Hold-max-cost mode. The default value is 120.
    """
    return self.__peerFlapSuppressResumeInterval
      
  def _set_peerFlapSuppressResumeInterval(self, v, load=False):
    """
    Setter method for peerFlapSuppressResumeInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressResumeInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressResumeInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressResumeInterval() directly.

    YANG Description: Set the interval for exiting from IS-IS neighbor relationship flapping suppression, in seconds. If the interval between successive neighbor Down events is greater than resume-interval, the flapping_count is reset. In Hold-max-cost mode, if the neighbor relationship does not go Down within two successive resume-intervals or the interval between successive neighbor Down events is greater than resume-interval, the interface exits from Hold-max-cost mode. The default value is 120.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="peerFlapSuppressResumeInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressResumeInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="peerFlapSuppressResumeInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__peerFlapSuppressResumeInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressResumeInterval(self):
    self.__peerFlapSuppressResumeInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="peerFlapSuppressResumeInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_peerFlapSuppressHoldDown(self):
    """
    Getter method for peerFlapSuppressHoldDown, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressHoldDown (boolean)

    YANG Description: Enable Hold-down mode. By default, the mode is disabled.
    """
    return self.__peerFlapSuppressHoldDown
      
  def _set_peerFlapSuppressHoldDown(self, v, load=False):
    """
    Setter method for peerFlapSuppressHoldDown, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressHoldDown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressHoldDown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressHoldDown() directly.

    YANG Description: Enable Hold-down mode. By default, the mode is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="peerFlapSuppressHoldDown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressHoldDown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="peerFlapSuppressHoldDown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__peerFlapSuppressHoldDown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressHoldDown(self):
    self.__peerFlapSuppressHoldDown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="peerFlapSuppressHoldDown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_peerFlapSuppressDownInterval(self):
    """
    Getter method for peerFlapSuppressDownInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressDownInterval (uint32)

    YANG Description: Set the duration of the Hold-down mode, in seconds.
    """
    return self.__peerFlapSuppressDownInterval
      
  def _set_peerFlapSuppressDownInterval(self, v, load=False):
    """
    Setter method for peerFlapSuppressDownInterval, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressDownInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressDownInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressDownInterval() directly.

    YANG Description: Set the duration of the Hold-down mode, in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..600']}), is_leaf=True, yang_name="peerFlapSuppressDownInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressDownInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..600']}), is_leaf=True, yang_name="peerFlapSuppressDownInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__peerFlapSuppressDownInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressDownInterval(self):
    self.__peerFlapSuppressDownInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..600']}), is_leaf=True, yang_name="peerFlapSuppressDownInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_peerFlapSuppressHoldMaxCost(self):
    """
    Getter method for peerFlapSuppressHoldMaxCost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressHoldMaxCost (boolean)

    YANG Description: Enable Hold-max-cost mode. By default, the mode is enabled.
    """
    return self.__peerFlapSuppressHoldMaxCost
      
  def _set_peerFlapSuppressHoldMaxCost(self, v, load=False):
    """
    Setter method for peerFlapSuppressHoldMaxCost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressHoldMaxCost (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressHoldMaxCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressHoldMaxCost() directly.

    YANG Description: Enable Hold-max-cost mode. By default, the mode is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressHoldMaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressHoldMaxCost must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressHoldMaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__peerFlapSuppressHoldMaxCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressHoldMaxCost(self):
    self.__peerFlapSuppressHoldMaxCost = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlapSuppressHoldMaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_peerFlapSuppressStatus(self):
    """
    Getter method for peerFlapSuppressStatus, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressStatus (string)

    YANG Description: Display the neighbor relationship flapping suppression status.
    """
    return self.__peerFlapSuppressStatus
      
  def _set_peerFlapSuppressStatus(self, v, load=False):
    """
    Setter method for peerFlapSuppressStatus, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressStatus (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressStatus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressStatus() directly.

    YANG Description: Display the neighbor relationship flapping suppression status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="peerFlapSuppressStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressStatus must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerFlapSuppressStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__peerFlapSuppressStatus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressStatus(self):
    self.__peerFlapSuppressStatus = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerFlapSuppressStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_peerFlapCount(self):
    """
    Getter method for peerFlapCount, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapCount (uint32)

    YANG Description: Display the current flapping_count.
    """
    return self.__peerFlapCount
      
  def _set_peerFlapCount(self, v, load=False):
    """
    Setter method for peerFlapCount, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapCount (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapCount is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapCount() directly.

    YANG Description: Display the current flapping_count.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapCount must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__peerFlapCount = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapCount(self):
    self.__peerFlapCount = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapCount", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_peerFlapThreshold(self):
    """
    Getter method for peerFlapThreshold, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapThreshold (uint32)

    YANG Description: Display threshold of neighbor relationship flapping suppression
    """
    return self.__peerFlapThreshold
      
  def _set_peerFlapThreshold(self, v, load=False):
    """
    Setter method for peerFlapThreshold, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapThreshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapThreshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapThreshold() directly.

    YANG Description: Display threshold of neighbor relationship flapping suppression
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapThreshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__peerFlapThreshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapThreshold(self):
    self.__peerFlapThreshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapThreshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_peerFlapSuppressTimer(self):
    """
    Getter method for peerFlapSuppressTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressTimer (string)

    YANG Description: Display the time when neighbor relationship flapping suppression took effect.
    """
    return self.__peerFlapSuppressTimer
      
  def _set_peerFlapSuppressTimer(self, v, load=False):
    """
    Setter method for peerFlapSuppressTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressTimer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressTimer() directly.

    YANG Description: Display the time when neighbor relationship flapping suppression took effect.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peerFlapSuppressTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressTimer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peerFlapSuppressTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__peerFlapSuppressTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressTimer(self):
    self.__peerFlapSuppressTimer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peerFlapSuppressTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_peerFlapSuppressRemainTimer(self):
    """
    Getter method for peerFlapSuppressRemainTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressRemainTimer (uint32)

    YANG Description: Display the remaining time of neighbor relationship flapping suppression.
    """
    return self.__peerFlapSuppressRemainTimer
      
  def _set_peerFlapSuppressRemainTimer(self, v, load=False):
    """
    Setter method for peerFlapSuppressRemainTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerFlapSuppressRemainTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlapSuppressRemainTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlapSuppressRemainTimer() directly.

    YANG Description: Display the remaining time of neighbor relationship flapping suppression.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapSuppressRemainTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlapSuppressRemainTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapSuppressRemainTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__peerFlapSuppressRemainTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlapSuppressRemainTimer(self):
    self.__peerFlapSuppressRemainTimer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peerFlapSuppressRemainTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_meshGroupState(self):
    """
    Getter method for meshGroupState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/meshGroupState (string)

    YANG Description: Mesh-group state on an interface. If the state is Block, the interface cannot flood received LSPs.
    """
    return self.__meshGroupState
      
  def _set_meshGroupState(self, v, load=False):
    """
    Setter method for meshGroupState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/meshGroupState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_meshGroupState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_meshGroupState() directly.

    YANG Description: Mesh-group state on an interface. If the state is Block, the interface cannot flood received LSPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("inactive"), is_leaf=True, yang_name="meshGroupState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """meshGroupState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("inactive"), is_leaf=True, yang_name="meshGroupState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__meshGroupState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_meshGroupState(self):
    self.__meshGroupState = YANGDynClass(base=six.text_type, default=six.text_type("inactive"), is_leaf=True, yang_name="meshGroupState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_meshGroupNumber(self):
    """
    Getter method for meshGroupNumber, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/meshGroupNumber (uint32)

    YANG Description: Set an ID for a mesh-group. The value is an integer. When the state of the mesh-group is Set, the value ranges from 1 to 4294967295. 
    """
    return self.__meshGroupNumber
      
  def _set_meshGroupNumber(self, v, load=False):
    """
    Setter method for meshGroupNumber, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/meshGroupNumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_meshGroupNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_meshGroupNumber() directly.

    YANG Description: Set an ID for a mesh-group. The value is an integer. When the state of the mesh-group is Set, the value ranges from 1 to 4294967295. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="meshGroupNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """meshGroupNumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="meshGroupNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__meshGroupNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_meshGroupNumber(self):
    self.__meshGroupNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="meshGroupNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_incrCost(self):
    """
    Getter method for incrCost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/incrCost (uint32)

    YANG Description: Set the cost to be added if the link quality is low. The value is an integer ranging from 1 to 16777214. 
    """
    return self.__incrCost
      
  def _set_incrCost(self, v, load=False):
    """
    Setter method for incrCost, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/incrCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_incrCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_incrCost() directly.

    YANG Description: Set the cost to be added if the link quality is low. The value is an integer ranging from 1 to 16777214. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """incrCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__incrCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_incrCost(self):
    self.__incrCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_incrCostIpv6(self):
    """
    Getter method for incrCostIpv6, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/incrCostIpv6 (uint32)

    YANG Description: Set the increase cost value about ipv6
    """
    return self.__incrCostIpv6
      
  def _set_incrCostIpv6(self, v, load=False):
    """
    Setter method for incrCostIpv6, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/incrCostIpv6 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_incrCostIpv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_incrCostIpv6() directly.

    YANG Description: Set the increase cost value about ipv6
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777214']}), is_leaf=True, yang_name="incrCostIpv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """incrCostIpv6 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777214']}), is_leaf=True, yang_name="incrCostIpv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__incrCostIpv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_incrCostIpv6(self):
    self.__incrCostIpv6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777214']}), is_leaf=True, yang_name="incrCostIpv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_circuitId(self):
    """
    Getter method for circuitId, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitId (uint8)

    YANG Description: Circuit ID of an interface.
    """
    return self.__circuitId
      
  def _set_circuitId(self, v, load=False):
    """
    Setter method for circuitId, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitId (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitId() directly.

    YANG Description: Circuit ID of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitId must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=False)""",
        })

    self.__circuitId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitId(self):
    self.__circuitId = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=False)


  def _get_circuitMTU(self):
    """
    Getter method for circuitMTU, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitMTU (uint32)

    YANG Description: MTU value of an interface.
    """
    return self.__circuitMTU
      
  def _set_circuitMTU(self, v, load=False):
    """
    Setter method for circuitMTU, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitMTU (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitMTU is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitMTU() directly.

    YANG Description: MTU value of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circuitMTU", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitMTU must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circuitMTU", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__circuitMTU = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitMTU(self):
    self.__circuitMTU = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="circuitMTU", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_circuitL1IsDis(self):
    """
    Getter method for circuitL1IsDis, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitL1IsDis (boolean)

    YANG Description: Determine whether the interface is a level-1 DIS.
    """
    return self.__circuitL1IsDis
      
  def _set_circuitL1IsDis(self, v, load=False):
    """
    Setter method for circuitL1IsDis, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitL1IsDis (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitL1IsDis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitL1IsDis() directly.

    YANG Description: Determine whether the interface is a level-1 DIS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="circuitL1IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitL1IsDis must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circuitL1IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__circuitL1IsDis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitL1IsDis(self):
    self.__circuitL1IsDis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circuitL1IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_circuitL2IsDis(self):
    """
    Getter method for circuitL2IsDis, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitL2IsDis (boolean)

    YANG Description: Determine whether the interface is a level-2 DIS.
    """
    return self.__circuitL2IsDis
      
  def _set_circuitL2IsDis(self, v, load=False):
    """
    Setter method for circuitL2IsDis, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/circuitL2IsDis (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitL2IsDis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitL2IsDis() directly.

    YANG Description: Determine whether the interface is a level-2 DIS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="circuitL2IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitL2IsDis must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circuitL2IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__circuitL2IsDis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitL2IsDis(self):
    self.__circuitL2IsDis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="circuitL2IsDis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_v4Status(self):
    """
    Getter method for v4Status, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/v4Status (string)

    YANG Description: IPv4 status of the interface, Up or Down.
    """
    return self.__v4Status
      
  def _set_v4Status(self, v, load=False):
    """
    Setter method for v4Status, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/v4Status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4Status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4Status() directly.

    YANG Description: IPv4 status of the interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v4Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4Status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v4Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__v4Status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4Status(self):
    self.__v4Status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v4Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_mtuState(self):
    """
    Getter method for mtuState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/mtuState (boolean)

    YANG Description: MTU status of an interface, Up or Down.
    """
    return self.__mtuState
      
  def _set_mtuState(self, v, load=False):
    """
    Setter method for mtuState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/mtuState (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtuState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtuState() directly.

    YANG Description: MTU status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mtuState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtuState must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mtuState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__mtuState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtuState(self):
    self.__mtuState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mtuState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_linkState(self):
    """
    Getter method for linkState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/linkState (boolean)

    YANG Description: Link status of an interface, Up or Down.
    """
    return self.__linkState
      
  def _set_linkState(self, v, load=False):
    """
    Setter method for linkState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/linkState (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linkState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linkState() directly.

    YANG Description: Link status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="linkState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linkState must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="linkState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__linkState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linkState(self):
    self.__linkState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="linkState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_ipState(self):
    """
    Getter method for ipState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipState (boolean)

    YANG Description: IPv4 address status of an interface, Up or Down.
    """
    return self.__ipState
      
  def _set_ipState(self, v, load=False):
    """
    Setter method for ipState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipState (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipState() directly.

    YANG Description: IPv4 address status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipState must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__ipState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipState(self):
    self.__ipState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_v6Status(self):
    """
    Getter method for v6Status, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/v6Status (string)

    YANG Description: IS-IS IPv6 status of an interface, Up or Down.
    """
    return self.__v6Status
      
  def _set_v6Status(self, v, load=False):
    """
    Setter method for v6Status, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/v6Status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6Status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6Status() directly.

    YANG Description: IS-IS IPv6 status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v6Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6Status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v6Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__v6Status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6Status(self):
    self.__v6Status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="v6Status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_mtuV6State(self):
    """
    Getter method for mtuV6State, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/mtuV6State (boolean)

    YANG Description: MTU IPv6 status of an interface, Up or Down.
    """
    return self.__mtuV6State
      
  def _set_mtuV6State(self, v, load=False):
    """
    Setter method for mtuV6State, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/mtuV6State (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtuV6State is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtuV6State() directly.

    YANG Description: MTU IPv6 status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mtuV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtuV6State must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mtuV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__mtuV6State = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtuV6State(self):
    self.__mtuV6State = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mtuV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_linkV6State(self):
    """
    Getter method for linkV6State, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/linkV6State (boolean)

    YANG Description: Link IPv6 status of an interface, Up or Down.
    """
    return self.__linkV6State
      
  def _set_linkV6State(self, v, load=False):
    """
    Setter method for linkV6State, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/linkV6State (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linkV6State is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linkV6State() directly.

    YANG Description: Link IPv6 status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="linkV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linkV6State must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="linkV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__linkV6State = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linkV6State(self):
    self.__linkV6State = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="linkV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_ipV6State(self):
    """
    Getter method for ipV6State, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipV6State (boolean)

    YANG Description: IPv6 address status of an interface, Up or Down.
    """
    return self.__ipV6State
      
  def _set_ipV6State(self, v, load=False):
    """
    Setter method for ipV6State, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/ipV6State (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipV6State is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipV6State() directly.

    YANG Description: IPv6 address status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ipV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipV6State must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__ipV6State = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipV6State(self):
    self.__ipV6State = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ipV6State", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_vcState(self):
    """
    Getter method for vcState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/vcState (boolean)

    YANG Description: Virtual Cluster status of an interface, Up or Down.
    """
    return self.__vcState
      
  def _set_vcState(self, v, load=False):
    """
    Setter method for vcState, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/vcState (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcState() directly.

    YANG Description: Virtual Cluster status of an interface, Up or Down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="vcState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcState must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vcState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__vcState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcState(self):
    self.__vcState = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vcState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_level1Conser(self):
    """
    Getter method for level1Conser, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1Conser (boolean)

    YANG Description: level1 hello-interval conservative flag
    """
    return self.__level1Conser
      
  def _set_level1Conser(self, v, load=False):
    """
    Setter method for level1Conser, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level1Conser (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1Conser is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1Conser() directly.

    YANG Description: level1 hello-interval conservative flag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1Conser must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1Conser = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1Conser(self):
    self.__level1Conser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2Conser(self):
    """
    Getter method for level2Conser, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2Conser (boolean)

    YANG Description: level2 hello-interval conservative flag
    """
    return self.__level2Conser
      
  def _set_level2Conser(self, v, load=False):
    """
    Setter method for level2Conser, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/level2Conser (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2Conser is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2Conser() directly.

    YANG Description: level2 hello-interval conservative flag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2Conser must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2Conser = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2Conser(self):
    self.__level2Conser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2Conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_p2pConser(self):
    """
    Getter method for p2pConser, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pConser (boolean)

    YANG Description: p2p hello-interval conservative flag
    """
    return self.__p2pConser
      
  def _set_p2pConser(self, v, load=False):
    """
    Setter method for p2pConser, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/p2pConser (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_p2pConser is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_p2pConser() directly.

    YANG Description: p2p hello-interval conservative flag
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pConser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """p2pConser must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pConser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__p2pConser = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_p2pConser(self):
    self.__p2pConser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2pConser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_purgeSourceTraceBlock(self):
    """
    Getter method for purgeSourceTraceBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/purgeSourceTraceBlock (boolean)

    YANG Description: Block purge LSP source tracing on this interface.
    """
    return self.__purgeSourceTraceBlock
      
  def _set_purgeSourceTraceBlock(self, v, load=False):
    """
    Setter method for purgeSourceTraceBlock, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/purgeSourceTraceBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purgeSourceTraceBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purgeSourceTraceBlock() directly.

    YANG Description: Block purge LSP source tracing on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="purgeSourceTraceBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purgeSourceTraceBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="purgeSourceTraceBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__purgeSourceTraceBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purgeSourceTraceBlock(self):
    self.__purgeSourceTraceBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="purgeSourceTraceBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isHelloAuthtications(self):
    """
    Getter method for isHelloAuthtications, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications (container)

    YANG Description: List of Hello packet authentication.
    """
    return self.__isHelloAuthtications
      
  def _set_isHelloAuthtications(self, v, load=False):
    """
    Setter method for isHelloAuthtications, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isHelloAuthtications (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isHelloAuthtications is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isHelloAuthtications() directly.

    YANG Description: List of Hello packet authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isHelloAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications, is_container='container', yang_name="isHelloAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isHelloAuthtications must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isHelloAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications, is_container='container', yang_name="isHelloAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isHelloAuthtications = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isHelloAuthtications(self):
    self.__isHelloAuthtications = YANGDynClass(base=yc_isHelloAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications, is_container='container', yang_name="isHelloAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_peerHoldMaxCostTimer(self):
    """
    Getter method for peerHoldMaxCostTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerHoldMaxCostTimer (uint32)

    YANG Description: Config peer hold-max-cost interval. The value is expressed in milliseconds.
    """
    return self.__peerHoldMaxCostTimer
      
  def _set_peerHoldMaxCostTimer(self, v, load=False):
    """
    Setter method for peerHoldMaxCostTimer, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/peerHoldMaxCostTimer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerHoldMaxCostTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerHoldMaxCostTimer() directly.

    YANG Description: Config peer hold-max-cost interval. The value is expressed in milliseconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peerHoldMaxCostTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerHoldMaxCostTimer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peerHoldMaxCostTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__peerHoldMaxCostTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerHoldMaxCostTimer(self):
    self.__peerHoldMaxCostTimer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peerHoldMaxCostTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_isSrlgs(self):
    """
    Getter method for isSrlgs, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs (container)

    YANG Description: List of Share risk link-group information.
    """
    return self.__isSrlgs
      
  def _set_isSrlgs(self, v, load=False):
    """
    Setter method for isSrlgs, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit/isSrlgs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrlgs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrlgs() directly.

    YANG Description: List of Share risk link-group information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSrlgs_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs, is_container='container', yang_name="isSrlgs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrlgs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSrlgs_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs, is_container='container', yang_name="isSrlgs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSrlgs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrlgs(self):
    self.__isSrlgs = YANGDynClass(base=yc_isSrlgs_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs, is_container='container', yang_name="isSrlgs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  ifName = __builtin__.property(_get_ifName, _set_ifName)
  ipv4Enable = __builtin__.property(_get_ipv4Enable, _set_ipv4Enable)
  ipv6Enable = __builtin__.property(_get_ipv6Enable, _set_ipv6Enable)
  circuitLevelType = __builtin__.property(_get_circuitLevelType, _set_circuitLevelType)
  typeP2pEnable = __builtin__.property(_get_typeP2pEnable, _set_typeP2pEnable)
  snpaCheck = __builtin__.property(_get_snpaCheck, _set_snpaCheck)
  silentEnable = __builtin__.property(_get_silentEnable, _set_silentEnable)
  silentCost = __builtin__.property(_get_silentCost, _set_silentCost)
  level1CsnpInterval = __builtin__.property(_get_level1CsnpInterval, _set_level1CsnpInterval)
  level2CsnpInterval = __builtin__.property(_get_level2CsnpInterval, _set_level2CsnpInterval)
  throttleTimer = __builtin__.property(_get_throttleTimer, _set_throttleTimer)
  throttleCount = __builtin__.property(_get_throttleCount, _set_throttleCount)
  level1HelloTimer = __builtin__.property(_get_level1HelloTimer, _set_level1HelloTimer)
  level2HelloTimer = __builtin__.property(_get_level2HelloTimer, _set_level2HelloTimer)
  level1HoldMultiplier = __builtin__.property(_get_level1HoldMultiplier, _set_level1HoldMultiplier)
  level2HoldMultiplier = __builtin__.property(_get_level2HoldMultiplier, _set_level2HoldMultiplier)
  disName = __builtin__.property(_get_disName, _set_disName)
  level1DisPriority = __builtin__.property(_get_level1DisPriority, _set_level1DisPriority)
  level2DisPriority = __builtin__.property(_get_level2DisPriority, _set_level2DisPriority)
  p2pPeerIPIgnore = __builtin__.property(_get_p2pPeerIPIgnore, _set_p2pPeerIPIgnore)
  p2pNegotiationMode = __builtin__.property(_get_p2pNegotiationMode, _set_p2pNegotiationMode)
  p2pHelloTimer = __builtin__.property(_get_p2pHelloTimer, _set_p2pHelloTimer)
  p2pHoldMulti = __builtin__.property(_get_p2pHoldMulti, _set_p2pHoldMulti)
  lspRetransmitInterval = __builtin__.property(_get_lspRetransmitInterval, _set_lspRetransmitInterval)
  pPPOsicpCheckEnable = __builtin__.property(_get_pPPOsicpCheckEnable, _set_pPPOsicpCheckEnable)
  ldpAutoBlock = __builtin__.property(_get_ldpAutoBlock, _set_ldpAutoBlock)
  helloMode = __builtin__.property(_get_helloMode, _set_helloMode)
  level1Cost = __builtin__.property(_get_level1Cost, _set_level1Cost)
  level2Cost = __builtin__.property(_get_level2Cost, _set_level2Cost)
  ldpSyncState = __builtin__.property(_get_ldpSyncState, _set_ldpSyncState)
  ldpSyncTimerEnable = __builtin__.property(_get_ldpSyncTimerEnable, _set_ldpSyncTimerEnable)
  ldpSyncTimer = __builtin__.property(_get_ldpSyncTimer, _set_ldpSyncTimer)
  ldpSyncHDTimerEnable = __builtin__.property(_get_ldpSyncHDTimerEnable, _set_ldpSyncHDTimerEnable)
  ldpSyncHDTimer = __builtin__.property(_get_ldpSyncHDTimer, _set_ldpSyncHDTimer)
  ldpSynInfinite = __builtin__.property(_get_ldpSynInfinite, _set_ldpSynInfinite)
  level1FrrBlock = __builtin__.property(_get_level1FrrBlock, _set_level1FrrBlock)
  level2FrrBlock = __builtin__.property(_get_level2FrrBlock, _set_level2FrrBlock)
  level1RemoteLFA = __builtin__.property(_get_level1RemoteLFA, _set_level1RemoteLFA)
  level2RemoteLFA = __builtin__.property(_get_level2RemoteLFA, _set_level2RemoteLFA)
  l1TilfaDisable = __builtin__.property(_get_l1TilfaDisable, _set_l1TilfaDisable)
  l2TilfaDisable = __builtin__.property(_get_l2TilfaDisable, _set_l2TilfaDisable)
  peerFlapSuppressEnable = __builtin__.property(_get_peerFlapSuppressEnable, _set_peerFlapSuppressEnable)
  peerFlapSuppressDetectInterval = __builtin__.property(_get_peerFlapSuppressDetectInterval, _set_peerFlapSuppressDetectInterval)
  peerFlapSuppressThreshold = __builtin__.property(_get_peerFlapSuppressThreshold, _set_peerFlapSuppressThreshold)
  peerFlapSuppressResumeInterval = __builtin__.property(_get_peerFlapSuppressResumeInterval, _set_peerFlapSuppressResumeInterval)
  peerFlapSuppressHoldDown = __builtin__.property(_get_peerFlapSuppressHoldDown, _set_peerFlapSuppressHoldDown)
  peerFlapSuppressDownInterval = __builtin__.property(_get_peerFlapSuppressDownInterval, _set_peerFlapSuppressDownInterval)
  peerFlapSuppressHoldMaxCost = __builtin__.property(_get_peerFlapSuppressHoldMaxCost, _set_peerFlapSuppressHoldMaxCost)
  peerFlapSuppressStatus = __builtin__.property(_get_peerFlapSuppressStatus)
  peerFlapCount = __builtin__.property(_get_peerFlapCount)
  peerFlapThreshold = __builtin__.property(_get_peerFlapThreshold)
  peerFlapSuppressTimer = __builtin__.property(_get_peerFlapSuppressTimer)
  peerFlapSuppressRemainTimer = __builtin__.property(_get_peerFlapSuppressRemainTimer)
  meshGroupState = __builtin__.property(_get_meshGroupState, _set_meshGroupState)
  meshGroupNumber = __builtin__.property(_get_meshGroupNumber, _set_meshGroupNumber)
  incrCost = __builtin__.property(_get_incrCost, _set_incrCost)
  incrCostIpv6 = __builtin__.property(_get_incrCostIpv6, _set_incrCostIpv6)
  circuitId = __builtin__.property(_get_circuitId)
  circuitMTU = __builtin__.property(_get_circuitMTU)
  circuitL1IsDis = __builtin__.property(_get_circuitL1IsDis)
  circuitL2IsDis = __builtin__.property(_get_circuitL2IsDis)
  v4Status = __builtin__.property(_get_v4Status)
  mtuState = __builtin__.property(_get_mtuState)
  linkState = __builtin__.property(_get_linkState)
  ipState = __builtin__.property(_get_ipState)
  v6Status = __builtin__.property(_get_v6Status)
  mtuV6State = __builtin__.property(_get_mtuV6State)
  linkV6State = __builtin__.property(_get_linkV6State)
  ipV6State = __builtin__.property(_get_ipV6State)
  vcState = __builtin__.property(_get_vcState)
  level1Conser = __builtin__.property(_get_level1Conser, _set_level1Conser)
  level2Conser = __builtin__.property(_get_level2Conser, _set_level2Conser)
  p2pConser = __builtin__.property(_get_p2pConser, _set_p2pConser)
  purgeSourceTraceBlock = __builtin__.property(_get_purgeSourceTraceBlock, _set_purgeSourceTraceBlock)
  isHelloAuthtications = __builtin__.property(_get_isHelloAuthtications, _set_isHelloAuthtications) # type: yc_isHelloAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isHelloAuthtications
  peerHoldMaxCostTimer = __builtin__.property(_get_peerHoldMaxCostTimer, _set_peerHoldMaxCostTimer)
  isSrlgs = __builtin__.property(_get_isSrlgs, _set_isSrlgs) # type: yc_isSrlgs_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit_isSrlgs


  _pyangbind_elements = OrderedDict([('ifName', ifName), ('ipv4Enable', ipv4Enable), ('ipv6Enable', ipv6Enable), ('circuitLevelType', circuitLevelType), ('typeP2pEnable', typeP2pEnable), ('snpaCheck', snpaCheck), ('silentEnable', silentEnable), ('silentCost', silentCost), ('level1CsnpInterval', level1CsnpInterval), ('level2CsnpInterval', level2CsnpInterval), ('throttleTimer', throttleTimer), ('throttleCount', throttleCount), ('level1HelloTimer', level1HelloTimer), ('level2HelloTimer', level2HelloTimer), ('level1HoldMultiplier', level1HoldMultiplier), ('level2HoldMultiplier', level2HoldMultiplier), ('disName', disName), ('level1DisPriority', level1DisPriority), ('level2DisPriority', level2DisPriority), ('p2pPeerIPIgnore', p2pPeerIPIgnore), ('p2pNegotiationMode', p2pNegotiationMode), ('p2pHelloTimer', p2pHelloTimer), ('p2pHoldMulti', p2pHoldMulti), ('lspRetransmitInterval', lspRetransmitInterval), ('pPPOsicpCheckEnable', pPPOsicpCheckEnable), ('ldpAutoBlock', ldpAutoBlock), ('helloMode', helloMode), ('level1Cost', level1Cost), ('level2Cost', level2Cost), ('ldpSyncState', ldpSyncState), ('ldpSyncTimerEnable', ldpSyncTimerEnable), ('ldpSyncTimer', ldpSyncTimer), ('ldpSyncHDTimerEnable', ldpSyncHDTimerEnable), ('ldpSyncHDTimer', ldpSyncHDTimer), ('ldpSynInfinite', ldpSynInfinite), ('level1FrrBlock', level1FrrBlock), ('level2FrrBlock', level2FrrBlock), ('level1RemoteLFA', level1RemoteLFA), ('level2RemoteLFA', level2RemoteLFA), ('l1TilfaDisable', l1TilfaDisable), ('l2TilfaDisable', l2TilfaDisable), ('peerFlapSuppressEnable', peerFlapSuppressEnable), ('peerFlapSuppressDetectInterval', peerFlapSuppressDetectInterval), ('peerFlapSuppressThreshold', peerFlapSuppressThreshold), ('peerFlapSuppressResumeInterval', peerFlapSuppressResumeInterval), ('peerFlapSuppressHoldDown', peerFlapSuppressHoldDown), ('peerFlapSuppressDownInterval', peerFlapSuppressDownInterval), ('peerFlapSuppressHoldMaxCost', peerFlapSuppressHoldMaxCost), ('peerFlapSuppressStatus', peerFlapSuppressStatus), ('peerFlapCount', peerFlapCount), ('peerFlapThreshold', peerFlapThreshold), ('peerFlapSuppressTimer', peerFlapSuppressTimer), ('peerFlapSuppressRemainTimer', peerFlapSuppressRemainTimer), ('meshGroupState', meshGroupState), ('meshGroupNumber', meshGroupNumber), ('incrCost', incrCost), ('incrCostIpv6', incrCostIpv6), ('circuitId', circuitId), ('circuitMTU', circuitMTU), ('circuitL1IsDis', circuitL1IsDis), ('circuitL2IsDis', circuitL2IsDis), ('v4Status', v4Status), ('mtuState', mtuState), ('linkState', linkState), ('ipState', ipState), ('v6Status', v6Status), ('mtuV6State', mtuV6State), ('linkV6State', linkV6State), ('ipV6State', ipV6State), ('vcState', vcState), ('level1Conser', level1Conser), ('level2Conser', level2Conser), ('p2pConser', p2pConser), ('purgeSourceTraceBlock', purgeSourceTraceBlock), ('isHelloAuthtications', isHelloAuthtications), ('peerHoldMaxCostTimer', peerHoldMaxCostTimer), ('isSrlgs', isSrlgs), ])


class yc_isCircuits_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isCircuits. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IS-IS interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isCircuit',)

  _yang_name = 'isCircuits'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isCircuit = YANGDynClass(base=YANGListType("ifName",yc_isCircuit_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit, yang_name="isCircuit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isCircuits']

  def _get_isCircuit(self):
    """
    Getter method for isCircuit, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit (list)

    YANG Description: Set parameters for an IS-IS interface.
    """
    return self.__isCircuit
      
  def _set_isCircuit(self, v, load=False):
    """
    Setter method for isCircuit, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits/isCircuit (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isCircuit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isCircuit() directly.

    YANG Description: Set parameters for an IS-IS interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ifName",yc_isCircuit_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit, yang_name="isCircuit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isCircuit must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ifName",yc_isCircuit_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit, yang_name="isCircuit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isCircuit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isCircuit(self):
    self.__isCircuit = YANGDynClass(base=YANGListType("ifName",yc_isCircuit_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit, yang_name="isCircuit", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isCircuit = __builtin__.property(_get_isCircuit, _set_isCircuit) # type: yc_isCircuit_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits_isCircuit


  _pyangbind_elements = OrderedDict([('isCircuit', isCircuit), ])


class yc_isNextHopWeight_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights_isNextHopWeight(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set a next hop weight.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipAddress','__weight',)

  _yang_name = 'isNextHopWeight'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isNextHopWeights', 'isNextHopWeight']

  def _get_ipAddress(self):
    """
    Getter method for ipAddress, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight/ipAddress (inet:ipv4-address-no-zone)

    YANG Description: Set A next hop address. 
    """
    return self.__ipAddress
      
  def _set_ipAddress(self, v, load=False):
    """
    Setter method for ipAddress, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight/ipAddress (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddress() directly.

    YANG Description: Set A next hop address. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddress must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ipAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddress(self):
    self.__ipAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight/weight (uint32)

    YANG Description: Set a weight value for the next hop.
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight/weight (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: Set a weight value for the next hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  ipAddress = __builtin__.property(_get_ipAddress, _set_ipAddress)
  weight = __builtin__.property(_get_weight, _set_weight)


  _pyangbind_elements = OrderedDict([('ipAddress', ipAddress), ('weight', weight), ])


class yc_isNextHopWeights_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of next hop weights.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isNextHopWeight',)

  _yang_name = 'isNextHopWeights'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isNextHopWeight = YANGDynClass(base=YANGListType("ipAddress",yc_isNextHopWeight_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights_isNextHopWeight, yang_name="isNextHopWeight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipAddress', extensions=None), is_container='list', yang_name="isNextHopWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isNextHopWeights']

  def _get_isNextHopWeight(self):
    """
    Getter method for isNextHopWeight, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight (list)

    YANG Description: Set a next hop weight.
    """
    return self.__isNextHopWeight
      
  def _set_isNextHopWeight(self, v, load=False):
    """
    Setter method for isNextHopWeight, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights/isNextHopWeight (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNextHopWeight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNextHopWeight() directly.

    YANG Description: Set a next hop weight.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipAddress",yc_isNextHopWeight_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights_isNextHopWeight, yang_name="isNextHopWeight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipAddress', extensions=None), is_container='list', yang_name="isNextHopWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNextHopWeight must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipAddress",yc_isNextHopWeight_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights_isNextHopWeight, yang_name="isNextHopWeight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipAddress', extensions=None), is_container='list', yang_name="isNextHopWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isNextHopWeight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNextHopWeight(self):
    self.__isNextHopWeight = YANGDynClass(base=YANGListType("ipAddress",yc_isNextHopWeight_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights_isNextHopWeight, yang_name="isNextHopWeight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipAddress', extensions=None), is_container='list', yang_name="isNextHopWeight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isNextHopWeight = __builtin__.property(_get_isNextHopWeight, _set_isNextHopWeight) # type: yc_isNextHopWeight_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights_isNextHopWeight


  _pyangbind_elements = OrderedDict([('isNextHopWeight', isNextHopWeight), ])


class yc_isSummaryRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes_isSummaryRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Summary route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipPrefix','__ipMaskLen','__levelType','__tag','__genNull0Route','__avoidFeadBack','__cost',)

  _yang_name = 'isSummaryRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipPrefix = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__ipMaskLen = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="ipMaskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__levelType = YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__genNull0Route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="genNull0Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__avoidFeadBack = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidFeadBack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isSummaryRoutes', 'isSummaryRoute']

  def _get_ipPrefix(self):
    """
    Getter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/ipPrefix (inet:ip-address-no-zone)

    YANG Description: Set a summary address. 
    """
    return self.__ipPrefix
      
  def _set_ipPrefix(self, v, load=False):
    """
    Setter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/ipPrefix (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefix() directly.

    YANG Description: Set a summary address. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefix must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__ipPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefix(self):
    self.__ipPrefix = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_ipMaskLen(self):
    """
    Getter method for ipMaskLen, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/ipMaskLen (uint8)

    YANG Description: Set the summary address mask. If summary address is the type of IPv4,  the max value is 32. If summary address is the type of IPv6,  the max value is 128.
    """
    return self.__ipMaskLen
      
  def _set_ipMaskLen(self, v, load=False):
    """
    Setter method for ipMaskLen, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/ipMaskLen (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipMaskLen is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipMaskLen() directly.

    YANG Description: Set the summary address mask. If summary address is the type of IPv4,  the max value is 32. If summary address is the type of IPv6,  the max value is 128.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="ipMaskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipMaskLen must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="ipMaskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__ipMaskLen = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipMaskLen(self):
    self.__ipMaskLen = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="ipMaskLen", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/levelType (string)

    YANG Description: Set the level for summary routes. The value can be level-1, level-2, or level-1-2. The default value is level-2.
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Set the level for summary routes. The value can be level-1, level-2, or level-1-2. The default value is level-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/tag (uint32)

    YANG Description: Set a tag for summary routes. The value ranges from 1 to 4294967295.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Set a tag for summary routes. The value ranges from 1 to 4294967295.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_genNull0Route(self):
    """
    Getter method for genNull0Route, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/genNull0Route (boolean)

    YANG Description: Generate a Null 0 route to prevent routing loops.
    """
    return self.__genNull0Route
      
  def _set_genNull0Route(self, v, load=False):
    """
    Setter method for genNull0Route, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/genNull0Route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_genNull0Route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_genNull0Route() directly.

    YANG Description: Generate a Null 0 route to prevent routing loops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="genNull0Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """genNull0Route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="genNull0Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__genNull0Route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_genNull0Route(self):
    self.__genNull0Route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="genNull0Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_avoidFeadBack(self):
    """
    Getter method for avoidFeadBack, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/avoidFeadBack (boolean)

    YANG Description: Avoid learning summary routes.
    """
    return self.__avoidFeadBack
      
  def _set_avoidFeadBack(self, v, load=False):
    """
    Setter method for avoidFeadBack, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/avoidFeadBack (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avoidFeadBack is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avoidFeadBack() directly.

    YANG Description: Avoid learning summary routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidFeadBack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avoidFeadBack must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidFeadBack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__avoidFeadBack = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avoidFeadBack(self):
    self.__avoidFeadBack = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidFeadBack", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/cost (uint32)

    YANG Description: Set a cost for summarized routes. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Set a cost for summarized routes. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  ipPrefix = __builtin__.property(_get_ipPrefix, _set_ipPrefix)
  ipMaskLen = __builtin__.property(_get_ipMaskLen, _set_ipMaskLen)
  levelType = __builtin__.property(_get_levelType, _set_levelType)
  tag = __builtin__.property(_get_tag, _set_tag)
  genNull0Route = __builtin__.property(_get_genNull0Route, _set_genNull0Route)
  avoidFeadBack = __builtin__.property(_get_avoidFeadBack, _set_avoidFeadBack)
  cost = __builtin__.property(_get_cost, _set_cost)


  _pyangbind_elements = OrderedDict([('ipPrefix', ipPrefix), ('ipMaskLen', ipMaskLen), ('levelType', levelType), ('tag', tag), ('genNull0Route', genNull0Route), ('avoidFeadBack', avoidFeadBack), ('cost', cost), ])


class yc_isSummaryRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of summary routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isSummaryRoute',)

  _yang_name = 'isSummaryRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isSummaryRoute = YANGDynClass(base=YANGListType("ipPrefix ipMaskLen",yc_isSummaryRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes_isSummaryRoute, yang_name="isSummaryRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipPrefix ipMaskLen', extensions=None), is_container='list', yang_name="isSummaryRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isSummaryRoutes']

  def _get_isSummaryRoute(self):
    """
    Getter method for isSummaryRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute (list)

    YANG Description: Summary route.
    """
    return self.__isSummaryRoute
      
  def _set_isSummaryRoute(self, v, load=False):
    """
    Setter method for isSummaryRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes/isSummaryRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSummaryRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSummaryRoute() directly.

    YANG Description: Summary route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipPrefix ipMaskLen",yc_isSummaryRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes_isSummaryRoute, yang_name="isSummaryRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipPrefix ipMaskLen', extensions=None), is_container='list', yang_name="isSummaryRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSummaryRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipPrefix ipMaskLen",yc_isSummaryRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes_isSummaryRoute, yang_name="isSummaryRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipPrefix ipMaskLen', extensions=None), is_container='list', yang_name="isSummaryRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isSummaryRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSummaryRoute(self):
    self.__isSummaryRoute = YANGDynClass(base=YANGListType("ipPrefix ipMaskLen",yc_isSummaryRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes_isSummaryRoute, yang_name="isSummaryRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipPrefix ipMaskLen', extensions=None), is_container='list', yang_name="isSummaryRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isSummaryRoute = __builtin__.property(_get_isSummaryRoute, _set_isSummaryRoute) # type: yc_isSummaryRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes_isSummaryRoute


  _pyangbind_elements = OrderedDict([('isSummaryRoute', isSummaryRoute), ])


class yc_isDefaultRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes_isDefaultRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable the level-1 and level-2 routers to generate default routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defaultMode','__policyType','__routePolicyName','__routeFilterNameEntity','__cost','__tag','__levelType','__avoidLearning',)

  _yang_name = 'isDefaultRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defaultMode = YANGDynClass(base=six.text_type, default=six.text_type("always"), is_leaf=True, yang_name="defaultMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__levelType = YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__avoidLearning = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidLearning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDefaultRoutes', 'isDefaultRoute']

  def _get_defaultMode(self):
    """
    Getter method for defaultMode, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/defaultMode (string)

    YANG Description: If the value is Match Any, the route-policy name parameter is available. If the value is Always, the default routes use the Always mode. If the value is Match Default, the default routes use the Match Default mode.
    """
    return self.__defaultMode
      
  def _set_defaultMode(self, v, load=False):
    """
    Setter method for defaultMode, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/defaultMode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultMode() directly.

    YANG Description: If the value is Match Any, the route-policy name parameter is available. If the value is Always, the default routes use the Always mode. If the value is Match Default, the default routes use the Match Default mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("always"), is_leaf=True, yang_name="defaultMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultMode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("always"), is_leaf=True, yang_name="defaultMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__defaultMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultMode(self):
    self.__defaultMode = YANGDynClass(base=six.text_type, default=six.text_type("always"), is_leaf=True, yang_name="defaultMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/policyType (string)

    YANG Description: Mode of the policy used for default route. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is Xpl-Route-Policy, the Xpl-Route-Policy Name parameter is available. In None mode, the  Route-Policy and Xpl-Route-Policy are all unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Mode of the policy used for default route. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is Xpl-Route-Policy, the Xpl-Route-Policy Name parameter is available. In None mode, the  Route-Policy and Xpl-Route-Policy are all unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/routePolicyName (string)

    YANG Description: Set a route-policy name for default routes. 
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Set a route-policy name for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/cost (uint32)

    YANG Description: Set a cost for default routes. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 4261412864.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Set a cost for default routes. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 4261412864.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/tag (uint32)

    YANG Description: Set a tag for default routes. The value ranges from 1 to 4294967295. 
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Set a tag for default routes. The value ranges from 1 to 4294967295. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/levelType (string)

    YANG Description: Set a level for default routes. The value can be level-1, level-2, or level-1-2. The default value is level-2.
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Set a level for default routes. The value can be level-1, level-2, or level-1-2. The default value is level-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_avoidLearning(self):
    """
    Getter method for avoidLearning, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/avoidLearning (boolean)

    YANG Description: To prevent IS-IS processes from learning default routes and adding the default routes to the routing table. If the default routes that already exist in the routing table are active, the status of the route is set to inactive.
    """
    return self.__avoidLearning
      
  def _set_avoidLearning(self, v, load=False):
    """
    Setter method for avoidLearning, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute/avoidLearning (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avoidLearning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avoidLearning() directly.

    YANG Description: To prevent IS-IS processes from learning default routes and adding the default routes to the routing table. If the default routes that already exist in the routing table are active, the status of the route is set to inactive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidLearning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avoidLearning must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidLearning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__avoidLearning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avoidLearning(self):
    self.__avoidLearning = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="avoidLearning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  defaultMode = __builtin__.property(_get_defaultMode, _set_defaultMode)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)
  cost = __builtin__.property(_get_cost, _set_cost)
  tag = __builtin__.property(_get_tag, _set_tag)
  levelType = __builtin__.property(_get_levelType, _set_levelType)
  avoidLearning = __builtin__.property(_get_avoidLearning, _set_avoidLearning)


  _pyangbind_elements = OrderedDict([('defaultMode', defaultMode), ('policyType', policyType), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ('cost', cost), ('tag', tag), ('levelType', levelType), ('avoidLearning', avoidLearning), ])


class yc_isDefaultRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Default route list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDefaultRoute',)

  _yang_name = 'isDefaultRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDefaultRoute = YANGDynClass(base=yc_isDefaultRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes_isDefaultRoute, is_container='container', yang_name="isDefaultRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDefaultRoutes']

  def _get_isDefaultRoute(self):
    """
    Getter method for isDefaultRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute (container)

    YANG Description: Enable the level-1 and level-2 routers to generate default routes.
    """
    return self.__isDefaultRoute
      
  def _set_isDefaultRoute(self, v, load=False):
    """
    Setter method for isDefaultRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes/isDefaultRoute (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDefaultRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDefaultRoute() directly.

    YANG Description: Enable the level-1 and level-2 routers to generate default routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDefaultRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes_isDefaultRoute, is_container='container', yang_name="isDefaultRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDefaultRoute must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDefaultRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes_isDefaultRoute, is_container='container', yang_name="isDefaultRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDefaultRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDefaultRoute(self):
    self.__isDefaultRoute = YANGDynClass(base=yc_isDefaultRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes_isDefaultRoute, is_container='container', yang_name="isDefaultRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isDefaultRoute = __builtin__.property(_get_isDefaultRoute, _set_isDefaultRoute) # type: yc_isDefaultRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes_isDefaultRoute


  _pyangbind_elements = OrderedDict([('isDefaultRoute', isDefaultRoute), ])


class yc_isImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes_isImportRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Import routes of other routing protocols.
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__processId','__costType','__cost','__tag','__policyType','__routePolicyName','__routeFilterNameEntity','__levelType','__inheritCost','__permitIbgp','__nosidflag',)

  _yang_name = 'isImportRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__processId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__costType = YANGDynClass(base=six.text_type, default=six.text_type("external"), is_leaf=True, yang_name="costType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__levelType = YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__inheritCost = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="inheritCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__permitIbgp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permitIbgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__nosidflag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isImportRoutes', 'isImportRoute']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/protocol (string)

    YANG Description: Set the routing protocol from which routes are imported. The value can be Direct, Static, RIP, OSPF, IS-IS, or BGP. 
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Set the routing protocol from which routes are imported. The value can be Direct, Static, RIP, OSPF, IS-IS, or BGP. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_processId(self):
    """
    Getter method for processId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/processId (uint32)

    YANG Description: Set the process ID. The process ID is required when the routing protocol is RIP, OSPF, or IS-IS. The default value is 1.
    """
    return self.__processId
      
  def _set_processId(self, v, load=False):
    """
    Setter method for processId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/processId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processId() directly.

    YANG Description: Set the process ID. The process ID is required when the routing protocol is RIP, OSPF, or IS-IS. The default value is 1.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__processId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processId(self):
    self.__processId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_costType(self):
    """
    Getter method for costType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/costType (string)

    YANG Description: Set the cost type for imported routes. The value can be External or Internal. The default value is External.
    """
    return self.__costType
      
  def _set_costType(self, v, load=False):
    """
    Setter method for costType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/costType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_costType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_costType() directly.

    YANG Description: Set the cost type for imported routes. The value can be External or Internal. The default value is External.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("external"), is_leaf=True, yang_name="costType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """costType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("external"), is_leaf=True, yang_name="costType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__costType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_costType(self):
    self.__costType = YANGDynClass(base=six.text_type, default=six.text_type("external"), is_leaf=True, yang_name="costType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/cost (uint32)

    YANG Description: Set a cost for imported routes. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 4261412864.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Set a cost for imported routes. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 4261412864.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/tag (uint32)

    YANG Description: Set a tag for imported routes. The value ranges from 1 to 4294967295. 
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Set a tag for imported routes. The value ranges from 1 to 4294967295. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/policyType (string)

    YANG Description: Mode of the policy used for import route. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is Xpl-Route-Policy, the Xpl-Route-Policy Name parameter is available. In None mode, the  Route-Policy and Xpl-Route-Policy are all unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Mode of the policy used for import route. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is Xpl-Route-Policy, the Xpl-Route-Policy Name parameter is available. In None mode, the  Route-Policy and Xpl-Route-Policy are all unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/routePolicyName (string)

    YANG Description: Set a route-policy name. 
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Set a route-policy name. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/levelType (string)

    YANG Description: Import routes to the level-1 or (and) level-2 routing table. Level-1: Import routes to the level-1 routing table.
Level-2: Import routes to the level-2 routing table.
Level-1-2: Import routes to the level-1 and level-2 routing table. The default option is level-2.
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Import routes to the level-1 or (and) level-2 routing table. Level-1: Import routes to the level-1 routing table.
Level-2: Import routes to the level-2 routing table.
Level-1-2: Import routes to the level-1 and level-2 routing table. The default option is level-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, default=six.text_type("level_2"), is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_inheritCost(self):
    """
    Getter method for inheritCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/inheritCost (boolean)

    YANG Description: Keep the original cost of a route when importing the route to IS-IS.
    """
    return self.__inheritCost
      
  def _set_inheritCost(self, v, load=False):
    """
    Setter method for inheritCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/inheritCost (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inheritCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inheritCost() directly.

    YANG Description: Keep the original cost of a route when importing the route to IS-IS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="inheritCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inheritCost must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="inheritCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__inheritCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inheritCost(self):
    self.__inheritCost = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="inheritCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_permitIbgp(self):
    """
    Getter method for permitIbgp, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/permitIbgp (boolean)

    YANG Description: Enable the device to import IBGP routes.
    """
    return self.__permitIbgp
      
  def _set_permitIbgp(self, v, load=False):
    """
    Setter method for permitIbgp, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/permitIbgp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_permitIbgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_permitIbgp() directly.

    YANG Description: Enable the device to import IBGP routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permitIbgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """permitIbgp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permitIbgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__permitIbgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_permitIbgp(self):
    self.__permitIbgp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permitIbgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_nosidflag(self):
    """
    Getter method for nosidflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/nosidflag (boolean)

    YANG Description: prohibit sid when import other process or protocol routes.
    """
    return self.__nosidflag
      
  def _set_nosidflag(self, v, load=False):
    """
    Setter method for nosidflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute/nosidflag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nosidflag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nosidflag() directly.

    YANG Description: prohibit sid when import other process or protocol routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nosidflag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__nosidflag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nosidflag(self):
    self.__nosidflag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  processId = __builtin__.property(_get_processId, _set_processId)
  costType = __builtin__.property(_get_costType, _set_costType)
  cost = __builtin__.property(_get_cost, _set_cost)
  tag = __builtin__.property(_get_tag, _set_tag)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)
  levelType = __builtin__.property(_get_levelType, _set_levelType)
  inheritCost = __builtin__.property(_get_inheritCost, _set_inheritCost)
  permitIbgp = __builtin__.property(_get_permitIbgp, _set_permitIbgp)
  nosidflag = __builtin__.property(_get_nosidflag, _set_nosidflag)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ('processId', processId), ('costType', costType), ('cost', cost), ('tag', tag), ('policyType', policyType), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ('levelType', levelType), ('inheritCost', inheritCost), ('permitIbgp', permitIbgp), ('nosidflag', nosidflag), ])


class yc_isImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Import routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isImportRoute',)

  _yang_name = 'isImportRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isImportRoute = YANGDynClass(base=YANGListType("protocol processId",yc_isImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes_isImportRoute, yang_name="isImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isImportRoutes']

  def _get_isImportRoute(self):
    """
    Getter method for isImportRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute (list)

    YANG Description: Import routes of other routing protocols.
    """
    return self.__isImportRoute
      
  def _set_isImportRoute(self, v, load=False):
    """
    Setter method for isImportRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes/isImportRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isImportRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isImportRoute() directly.

    YANG Description: Import routes of other routing protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("protocol processId",yc_isImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes_isImportRoute, yang_name="isImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isImportRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("protocol processId",yc_isImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes_isImportRoute, yang_name="isImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isImportRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isImportRoute(self):
    self.__isImportRoute = YANGDynClass(base=YANGListType("protocol processId",yc_isImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes_isImportRoute, yang_name="isImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isImportRoute = __builtin__.property(_get_isImportRoute, _set_isImportRoute) # type: yc_isImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes_isImportRoute


  _pyangbind_elements = OrderedDict([('isImportRoute', isImportRoute), ])


class yc_isFilterImport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports_isFilterImport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set a policy to filter received routes so that only given routes are added to the IP routing table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__policyType','__aclNumOrName','__acl6NumOrName','__ipPrefix','__ipv6Prefix','__routePolicyName','__routeFilterNameEntity',)

  _yang_name = 'isFilterImport'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__policyType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFilterImports', 'isFilterImport']

  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/policyType (string)

    YANG Description: Set the policy mode for route filtering. In ACL mode, the ACL Number parameter is available. In Route-Policy mode, the Route-Policy Name parameter is available. In IP Prefix mode, the IP Prefix parameter is available. In None mode, the ACL Number, Route-Policy Name, and IP Prefix parameters are all unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Set the policy mode for route filtering. In ACL mode, the ACL Number parameter is available. In Route-Policy mode, the Route-Policy Name parameter is available. In IP Prefix mode, the IP Prefix parameter is available. In None mode, the ACL Number, Route-Policy Name, and IP Prefix parameters are all unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_aclNumOrName(self):
    """
    Getter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/aclNumOrName (string)

    YANG Description: Set an ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    return self.__aclNumOrName
      
  def _set_aclNumOrName(self, v, load=False):
    """
    Setter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/aclNumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aclNumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aclNumOrName() directly.

    YANG Description: Set an ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aclNumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__aclNumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aclNumOrName(self):
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_acl6NumOrName(self):
    """
    Getter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/acl6NumOrName (string)

    YANG Description: Set an ACL6 number or name used for route filtering. The ACL6 number ranges from 2000 to 2999. The ACL6 name must start with a letter, and the ACL6 name is case-sensitive.
    """
    return self.__acl6NumOrName
      
  def _set_acl6NumOrName(self, v, load=False):
    """
    Setter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/acl6NumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl6NumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl6NumOrName() directly.

    YANG Description: Set an ACL6 number or name used for route filtering. The ACL6 number ranges from 2000 to 2999. The ACL6 name must start with a letter, and the ACL6 name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl6NumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__acl6NumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl6NumOrName(self):
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipPrefix(self):
    """
    Getter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/ipPrefix (string)

    YANG Description: Set the name of an IP prefix list.
    """
    return self.__ipPrefix
      
  def _set_ipPrefix(self, v, load=False):
    """
    Setter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/ipPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefix() directly.

    YANG Description: Set the name of an IP prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefix(self):
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipv6Prefix(self):
    """
    Getter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/ipv6Prefix (string)

    YANG Description: Set the name of an IPv6 prefix list.
    """
    return self.__ipv6Prefix
      
  def _set_ipv6Prefix(self, v, load=False):
    """
    Setter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/ipv6Prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Prefix() directly.

    YANG Description: Set the name of an IPv6 prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipv6Prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Prefix(self):
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/routePolicyName (string)

    YANG Description: Set the name of a route-policy which filters routes based on the tag or other protocol parameters.
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Set the name of a route-policy which filters routes based on the tag or other protocol parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  policyType = __builtin__.property(_get_policyType, _set_policyType)
  aclNumOrName = __builtin__.property(_get_aclNumOrName, _set_aclNumOrName)
  acl6NumOrName = __builtin__.property(_get_acl6NumOrName, _set_acl6NumOrName)
  ipPrefix = __builtin__.property(_get_ipPrefix, _set_ipPrefix)
  ipv6Prefix = __builtin__.property(_get_ipv6Prefix, _set_ipv6Prefix)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)


  _pyangbind_elements = OrderedDict([('policyType', policyType), ('aclNumOrName', aclNumOrName), ('acl6NumOrName', acl6NumOrName), ('ipPrefix', ipPrefix), ('ipv6Prefix', ipv6Prefix), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ])


class yc_isFilterImports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route import policy list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isFilterImport',)

  _yang_name = 'isFilterImports'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isFilterImport = YANGDynClass(base=yc_isFilterImport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports_isFilterImport, is_container='container', yang_name="isFilterImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFilterImports']

  def _get_isFilterImport(self):
    """
    Getter method for isFilterImport, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport (container)

    YANG Description: Set a policy to filter received routes so that only given routes are added to the IP routing table.
    """
    return self.__isFilterImport
      
  def _set_isFilterImport(self, v, load=False):
    """
    Setter method for isFilterImport, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports/isFilterImport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFilterImport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFilterImport() directly.

    YANG Description: Set a policy to filter received routes so that only given routes are added to the IP routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isFilterImport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports_isFilterImport, is_container='container', yang_name="isFilterImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFilterImport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isFilterImport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports_isFilterImport, is_container='container', yang_name="isFilterImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isFilterImport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFilterImport(self):
    self.__isFilterImport = YANGDynClass(base=yc_isFilterImport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports_isFilterImport, is_container='container', yang_name="isFilterImport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isFilterImport = __builtin__.property(_get_isFilterImport, _set_isFilterImport) # type: yc_isFilterImport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports_isFilterImport


  _pyangbind_elements = OrderedDict([('isFilterImport', isFilterImport), ])


class yc_isFilterExport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports_isFilterExport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set an export policy to filter the imported routes to be advertised.
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__processId','__policyType','__aclNumOrName','__acl6NumOrName','__ipPrefix','__ipv6Prefix','__routePolicyName','__routeFilterNameEntity',)

  _yang_name = 'isFilterExport'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__processId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFilterExports', 'isFilterExport']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/protocol (string)

    YANG Description: Route protocol, specifying which imported routes need to be filtered during route advertisement. The value can be Direct, Static, RIP, RIPNG, BGP, OSPF, OSPFV3, or other IS-IS processes. If this parameter is not set, all routes to be advertised are filtered.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Route protocol, specifying which imported routes need to be filtered during route advertisement. The value can be Direct, Static, RIP, RIPNG, BGP, OSPF, OSPFV3, or other IS-IS processes. If this parameter is not set, all routes to be advertised are filtered.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_processId(self):
    """
    Getter method for processId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/processId (uint32)

    YANG Description: Set the process ID. The process ID is required when the routing protocol is RIP, RIPNG, OSPF, OSPFV3, or IS-IS. The default value is 1.
    """
    return self.__processId
      
  def _set_processId(self, v, load=False):
    """
    Setter method for processId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/processId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processId() directly.

    YANG Description: Set the process ID. The process ID is required when the routing protocol is RIP, RIPNG, OSPF, OSPFV3, or IS-IS. The default value is 1.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__processId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processId(self):
    self.__processId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="processId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/policyType (string)

    YANG Description: Set the policy mode for route filtering. In ACL mode, the ACL Number parameter is available. In Route-Policy mode, the Route-Policy Name parameter is available. In IP Prefix mode, the IP Prefix parameter is available. In None mode, the ACL Number, Route-Policy Name, and IP Prefix parameters are all unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Set the policy mode for route filtering. In ACL mode, the ACL Number parameter is available. In Route-Policy mode, the Route-Policy Name parameter is available. In IP Prefix mode, the IP Prefix parameter is available. In None mode, the ACL Number, Route-Policy Name, and IP Prefix parameters are all unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_aclNumOrName(self):
    """
    Getter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/aclNumOrName (string)

    YANG Description: To set the ACL (Access Control List) number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with letter, and the ACL name is case-sensitive.
    """
    return self.__aclNumOrName
      
  def _set_aclNumOrName(self, v, load=False):
    """
    Setter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/aclNumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aclNumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aclNumOrName() directly.

    YANG Description: To set the ACL (Access Control List) number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with letter, and the ACL name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aclNumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__aclNumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aclNumOrName(self):
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_acl6NumOrName(self):
    """
    Getter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/acl6NumOrName (string)

    YANG Description: To set the ACL6 (Access Control List IPv6) number or name used for route filtering. The ACL6 number ranges from 2000 to 2999. The ACL6 name must start with a letter, and the ACL6 name is case-sensitive.
    """
    return self.__acl6NumOrName
      
  def _set_acl6NumOrName(self, v, load=False):
    """
    Setter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/acl6NumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl6NumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl6NumOrName() directly.

    YANG Description: To set the ACL6 (Access Control List IPv6) number or name used for route filtering. The ACL6 number ranges from 2000 to 2999. The ACL6 name must start with a letter, and the ACL6 name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl6NumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__acl6NumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl6NumOrName(self):
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipPrefix(self):
    """
    Getter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/ipPrefix (string)

    YANG Description: Name of the IP address prefix list.
    """
    return self.__ipPrefix
      
  def _set_ipPrefix(self, v, load=False):
    """
    Setter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/ipPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefix() directly.

    YANG Description: Name of the IP address prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefix(self):
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipv6Prefix(self):
    """
    Getter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/ipv6Prefix (string)

    YANG Description: Name of the IPv6 address prefix list.
    """
    return self.__ipv6Prefix
      
  def _set_ipv6Prefix(self, v, load=False):
    """
    Setter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/ipv6Prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Prefix() directly.

    YANG Description: Name of the IPv6 address prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipv6Prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Prefix(self):
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/routePolicyName (string)

    YANG Description: Name of the routing policy which defines that routes are filtered based on the label and other protocol parameters.
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Name of the routing policy which defines that routes are filtered based on the label and other protocol parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  processId = __builtin__.property(_get_processId, _set_processId)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  aclNumOrName = __builtin__.property(_get_aclNumOrName, _set_aclNumOrName)
  acl6NumOrName = __builtin__.property(_get_acl6NumOrName, _set_acl6NumOrName)
  ipPrefix = __builtin__.property(_get_ipPrefix, _set_ipPrefix)
  ipv6Prefix = __builtin__.property(_get_ipv6Prefix, _set_ipv6Prefix)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)


  _pyangbind_elements = OrderedDict([('protocol', protocol), ('processId', processId), ('policyType', policyType), ('aclNumOrName', aclNumOrName), ('acl6NumOrName', acl6NumOrName), ('ipPrefix', ipPrefix), ('ipv6Prefix', ipv6Prefix), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ])


class yc_isFilterExports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route export policy list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isFilterExport',)

  _yang_name = 'isFilterExports'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isFilterExport = YANGDynClass(base=YANGListType("protocol processId",yc_isFilterExport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports_isFilterExport, yang_name="isFilterExport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isFilterExport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFilterExports']

  def _get_isFilterExport(self):
    """
    Getter method for isFilterExport, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport (list)

    YANG Description: Set an export policy to filter the imported routes to be advertised.
    """
    return self.__isFilterExport
      
  def _set_isFilterExport(self, v, load=False):
    """
    Setter method for isFilterExport, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports/isFilterExport (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFilterExport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFilterExport() directly.

    YANG Description: Set an export policy to filter the imported routes to be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("protocol processId",yc_isFilterExport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports_isFilterExport, yang_name="isFilterExport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isFilterExport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFilterExport must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("protocol processId",yc_isFilterExport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports_isFilterExport, yang_name="isFilterExport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isFilterExport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isFilterExport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFilterExport(self):
    self.__isFilterExport = YANGDynClass(base=YANGListType("protocol processId",yc_isFilterExport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports_isFilterExport, yang_name="isFilterExport", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol processId', extensions=None), is_container='list', yang_name="isFilterExport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isFilterExport = __builtin__.property(_get_isFilterExport, _set_isFilterExport) # type: yc_isFilterExport_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports_isFilterExport


  _pyangbind_elements = OrderedDict([('isFilterExport', isFilterExport), ])


class yc_isLeakRouteLevel2ToLevel1_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s_isLeakRouteLevel2ToLevel1(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information used to control IS-IS to perform route leaking from level-2 to level-1. This command needs to be set on the level-1-2 router connected to the external areas.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tag','__policyType','__routePolicyName','__routeFilterNameEntity','__aclNumOrName','__acl6NumOrName','__ipPrefix','__ipv6Prefix','__allowFilter','__allowUpdown','__nosidflag',)

  _yang_name = 'isLeakRouteLevel2ToLevel1'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__allowFilter = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__allowUpdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowUpdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__nosidflag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isLeakRouteLevel2ToLevel1s', 'isLeakRouteLevel2ToLevel1']

  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/tag (uint32)

    YANG Description: Management label value assigned for imported routes. The label value is the name of route filtering during route leaking.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Management label value assigned for imported routes. The label value is the name of route filtering during route leaking.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/policyType (string)

    YANG Description: Mode of the policy used for route leaking. If the value is ACL, the ACL number parameter is available. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is IP Prefix, the IP Prefix parameter is available. In None mode, the ACL Number, Route-Policy Name, and IP Prefix parameters are all unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Mode of the policy used for route leaking. If the value is ACL, the ACL number parameter is available. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is IP Prefix, the IP Prefix parameter is available. In None mode, the ACL Number, Route-Policy Name, and IP Prefix parameters are all unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/routePolicyName (string)

    YANG Description: Name of the route filtering policy used during route leaking.
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Name of the route filtering policy used during route leaking.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_aclNumOrName(self):
    """
    Getter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/aclNumOrName (string)

    YANG Description: Set an ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    return self.__aclNumOrName
      
  def _set_aclNumOrName(self, v, load=False):
    """
    Setter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/aclNumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aclNumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aclNumOrName() directly.

    YANG Description: Set an ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aclNumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__aclNumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aclNumOrName(self):
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_acl6NumOrName(self):
    """
    Getter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/acl6NumOrName (string)

    YANG Description: Set an ACL6 number or name used for route filtering. The ACL6 number ranges from 2000 to 2999. The ACL6 name must start with a letter, and the ACL6 name is case-sensitive.
    """
    return self.__acl6NumOrName
      
  def _set_acl6NumOrName(self, v, load=False):
    """
    Setter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/acl6NumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl6NumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl6NumOrName() directly.

    YANG Description: Set an ACL6 number or name used for route filtering. The ACL6 number ranges from 2000 to 2999. The ACL6 name must start with a letter, and the ACL6 name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl6NumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__acl6NumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl6NumOrName(self):
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipPrefix(self):
    """
    Getter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/ipPrefix (string)

    YANG Description: Set the name of an IP prefix list. Only the routes that match the IP prefix list can leak into a level-1 area.
    """
    return self.__ipPrefix
      
  def _set_ipPrefix(self, v, load=False):
    """
    Setter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/ipPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefix() directly.

    YANG Description: Set the name of an IP prefix list. Only the routes that match the IP prefix list can leak into a level-1 area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefix(self):
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipv6Prefix(self):
    """
    Getter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/ipv6Prefix (string)

    YANG Description: Set the name of an IPv6 prefix list. Only the routes that match the IPv6 prefix list can leak into a level-1 area.
    """
    return self.__ipv6Prefix
      
  def _set_ipv6Prefix(self, v, load=False):
    """
    Setter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/ipv6Prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Prefix() directly.

    YANG Description: Set the name of an IPv6 prefix list. Only the routes that match the IPv6 prefix list can leak into a level-1 area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipv6Prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Prefix(self):
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_allowFilter(self):
    """
    Getter method for allowFilter, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/allowFilter (boolean)

    YANG Description: Set the name of a route-policy which filters routes based on the tag or other protocol parameters.
    """
    return self.__allowFilter
      
  def _set_allowFilter(self, v, load=False):
    """
    Setter method for allowFilter, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/allowFilter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowFilter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowFilter() directly.

    YANG Description: Set the name of a route-policy which filters routes based on the tag or other protocol parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowFilter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__allowFilter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowFilter(self):
    self.__allowFilter = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_allowUpdown(self):
    """
    Getter method for allowUpdown, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/allowUpdown (boolean)

    YANG Description: Set the Up/Down bit for routes.
    """
    return self.__allowUpdown
      
  def _set_allowUpdown(self, v, load=False):
    """
    Setter method for allowUpdown, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/allowUpdown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowUpdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowUpdown() directly.

    YANG Description: Set the Up/Down bit for routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowUpdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowUpdown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowUpdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__allowUpdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowUpdown(self):
    self.__allowUpdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowUpdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_nosidflag(self):
    """
    Getter method for nosidflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/nosidflag (boolean)

    YANG Description: prohibit sid when leak routes from level-2 to level-1.
    """
    return self.__nosidflag
      
  def _set_nosidflag(self, v, load=False):
    """
    Setter method for nosidflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1/nosidflag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nosidflag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nosidflag() directly.

    YANG Description: prohibit sid when leak routes from level-2 to level-1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nosidflag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__nosidflag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nosidflag(self):
    self.__nosidflag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  tag = __builtin__.property(_get_tag, _set_tag)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)
  aclNumOrName = __builtin__.property(_get_aclNumOrName, _set_aclNumOrName)
  acl6NumOrName = __builtin__.property(_get_acl6NumOrName, _set_acl6NumOrName)
  ipPrefix = __builtin__.property(_get_ipPrefix, _set_ipPrefix)
  ipv6Prefix = __builtin__.property(_get_ipv6Prefix, _set_ipv6Prefix)
  allowFilter = __builtin__.property(_get_allowFilter, _set_allowFilter)
  allowUpdown = __builtin__.property(_get_allowUpdown, _set_allowUpdown)
  nosidflag = __builtin__.property(_get_nosidflag, _set_nosidflag)


  _pyangbind_elements = OrderedDict([('tag', tag), ('policyType', policyType), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ('aclNumOrName', aclNumOrName), ('acl6NumOrName', acl6NumOrName), ('ipPrefix', ipPrefix), ('ipv6Prefix', ipv6Prefix), ('allowFilter', allowFilter), ('allowUpdown', allowUpdown), ('nosidflag', nosidflag), ])


class yc_isLeakRouteLevel2ToLevel1s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of level-2 to level-1 route leaking.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLeakRouteLevel2ToLevel1',)

  _yang_name = 'isLeakRouteLevel2ToLevel1s'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLeakRouteLevel2ToLevel1 = YANGDynClass(base=yc_isLeakRouteLevel2ToLevel1_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s_isLeakRouteLevel2ToLevel1, is_container='container', yang_name="isLeakRouteLevel2ToLevel1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isLeakRouteLevel2ToLevel1s']

  def _get_isLeakRouteLevel2ToLevel1(self):
    """
    Getter method for isLeakRouteLevel2ToLevel1, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1 (container)

    YANG Description: Information used to control IS-IS to perform route leaking from level-2 to level-1. This command needs to be set on the level-1-2 router connected to the external areas.
    """
    return self.__isLeakRouteLevel2ToLevel1
      
  def _set_isLeakRouteLevel2ToLevel1(self, v, load=False):
    """
    Setter method for isLeakRouteLevel2ToLevel1, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s/isLeakRouteLevel2ToLevel1 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLeakRouteLevel2ToLevel1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLeakRouteLevel2ToLevel1() directly.

    YANG Description: Information used to control IS-IS to perform route leaking from level-2 to level-1. This command needs to be set on the level-1-2 router connected to the external areas.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLeakRouteLevel2ToLevel1_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s_isLeakRouteLevel2ToLevel1, is_container='container', yang_name="isLeakRouteLevel2ToLevel1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLeakRouteLevel2ToLevel1 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLeakRouteLevel2ToLevel1_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s_isLeakRouteLevel2ToLevel1, is_container='container', yang_name="isLeakRouteLevel2ToLevel1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLeakRouteLevel2ToLevel1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLeakRouteLevel2ToLevel1(self):
    self.__isLeakRouteLevel2ToLevel1 = YANGDynClass(base=yc_isLeakRouteLevel2ToLevel1_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s_isLeakRouteLevel2ToLevel1, is_container='container', yang_name="isLeakRouteLevel2ToLevel1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isLeakRouteLevel2ToLevel1 = __builtin__.property(_get_isLeakRouteLevel2ToLevel1, _set_isLeakRouteLevel2ToLevel1) # type: yc_isLeakRouteLevel2ToLevel1_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s_isLeakRouteLevel2ToLevel1


  _pyangbind_elements = OrderedDict([('isLeakRouteLevel2ToLevel1', isLeakRouteLevel2ToLevel1), ])


class yc_isLeakRouteLevel1ToLevel2_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s_isLeakRouteLevel1ToLevel2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Control the leaking of the routes from a level-1 area to a level-2 area. This is convenient for route management. This command needs to be configured on the level-1-2 router connected to external areas.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tag','__policyType','__routePolicyName','__routeFilterNameEntity','__aclNumOrName','__acl6NumOrName','__ipPrefix','__ipv6Prefix','__leakEnableFlag','__allowFilter','__nosidflag',)

  _yang_name = 'isLeakRouteLevel1ToLevel2'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__leakEnableFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="leakEnableFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__allowFilter = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__nosidflag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isLeakRouteLevel1ToLevel2s', 'isLeakRouteLevel1ToLevel2']

  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/tag (uint32)

    YANG Description: Administrative tag assigned for imported routes.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Administrative tag assigned for imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/policyType (string)

    YANG Description: Mode of the policy used for route leaking. If the value is ACL, the ACL number parameter is available. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is IP Prefix, the IP Prefix parameter is available. In None mode, the ACL Number, Route Policy Name, and IP Prefix parameters are all unavailable.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Mode of the policy used for route leaking. If the value is ACL, the ACL number parameter is available. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is IP Prefix, the IP Prefix parameter is available. In None mode, the ACL Number, Route Policy Name, and IP Prefix parameters are all unavailable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/routePolicyName (string)

    YANG Description: Route-policy name used during route leaking.
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Route-policy name used during route leaking.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_aclNumOrName(self):
    """
    Getter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/aclNumOrName (string)

    YANG Description: Set an ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    return self.__aclNumOrName
      
  def _set_aclNumOrName(self, v, load=False):
    """
    Setter method for aclNumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/aclNumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aclNumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aclNumOrName() directly.

    YANG Description: Set an ACL number or name used for route filtering. The ACL number ranges from 2000 to 2999. The ACL name must start with a letter, and the ACL name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aclNumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__aclNumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aclNumOrName(self):
    self.__aclNumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aclNumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_acl6NumOrName(self):
    """
    Getter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/acl6NumOrName (string)

    YANG Description: Set an ACL6 number or name used for route filtering. The IPv6 ACL number ranges from 2000 to 2999. The IPv6 ACL name must start with a letter, and the IPv6 ACL name is case-sensitive.
    """
    return self.__acl6NumOrName
      
  def _set_acl6NumOrName(self, v, load=False):
    """
    Setter method for acl6NumOrName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/acl6NumOrName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl6NumOrName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl6NumOrName() directly.

    YANG Description: Set an ACL6 number or name used for route filtering. The IPv6 ACL number ranges from 2000 to 2999. The IPv6 ACL name must start with a letter, and the IPv6 ACL name is case-sensitive.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl6NumOrName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__acl6NumOrName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl6NumOrName(self):
    self.__acl6NumOrName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl6NumOrName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipPrefix(self):
    """
    Getter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/ipPrefix (string)

    YANG Description: Set the name of an IP prefix list. Only the routes that match the IP prefix list can leak into a level-2 area.
    """
    return self.__ipPrefix
      
  def _set_ipPrefix(self, v, load=False):
    """
    Setter method for ipPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/ipPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefix() directly.

    YANG Description: Set the name of an IP prefix list. Only the routes that match the IP prefix list can leak into a level-2 area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefix(self):
    self.__ipPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipv6Prefix(self):
    """
    Getter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/ipv6Prefix (string)

    YANG Description: Set the name of an IPv6 prefix list. Only the routes that match the IPv6 prefix list can leak into a level-2 area.
    """
    return self.__ipv6Prefix
      
  def _set_ipv6Prefix(self, v, load=False):
    """
    Setter method for ipv6Prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/ipv6Prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Prefix() directly.

    YANG Description: Set the name of an IPv6 prefix list. Only the routes that match the IPv6 prefix list can leak into a level-2 area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipv6Prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Prefix(self):
    self.__ipv6Prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6Prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_leakEnableFlag(self):
    """
    Getter method for leakEnableFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/leakEnableFlag (boolean)

    YANG Description: Enable level-1 to level-2 route filtering.
    """
    return self.__leakEnableFlag
      
  def _set_leakEnableFlag(self, v, load=False):
    """
    Setter method for leakEnableFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/leakEnableFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leakEnableFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leakEnableFlag() directly.

    YANG Description: Enable level-1 to level-2 route filtering.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="leakEnableFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leakEnableFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="leakEnableFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__leakEnableFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leakEnableFlag(self):
    self.__leakEnableFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="leakEnableFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_allowFilter(self):
    """
    Getter method for allowFilter, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/allowFilter (boolean)

    YANG Description: Set the name of a route-policy which filters routes based on the tag or other protocol parameters.
    """
    return self.__allowFilter
      
  def _set_allowFilter(self, v, load=False):
    """
    Setter method for allowFilter, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/allowFilter (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowFilter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowFilter() directly.

    YANG Description: Set the name of a route-policy which filters routes based on the tag or other protocol parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowFilter must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__allowFilter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowFilter(self):
    self.__allowFilter = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allowFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_nosidflag(self):
    """
    Getter method for nosidflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/nosidflag (boolean)

    YANG Description: prohibit sid when leak routes from level-1 to level-2.
    """
    return self.__nosidflag
      
  def _set_nosidflag(self, v, load=False):
    """
    Setter method for nosidflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2/nosidflag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nosidflag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nosidflag() directly.

    YANG Description: prohibit sid when leak routes from level-1 to level-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nosidflag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__nosidflag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nosidflag(self):
    self.__nosidflag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nosidflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  tag = __builtin__.property(_get_tag, _set_tag)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)
  aclNumOrName = __builtin__.property(_get_aclNumOrName, _set_aclNumOrName)
  acl6NumOrName = __builtin__.property(_get_acl6NumOrName, _set_acl6NumOrName)
  ipPrefix = __builtin__.property(_get_ipPrefix, _set_ipPrefix)
  ipv6Prefix = __builtin__.property(_get_ipv6Prefix, _set_ipv6Prefix)
  leakEnableFlag = __builtin__.property(_get_leakEnableFlag, _set_leakEnableFlag)
  allowFilter = __builtin__.property(_get_allowFilter, _set_allowFilter)
  nosidflag = __builtin__.property(_get_nosidflag, _set_nosidflag)


  _pyangbind_elements = OrderedDict([('tag', tag), ('policyType', policyType), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ('aclNumOrName', aclNumOrName), ('acl6NumOrName', acl6NumOrName), ('ipPrefix', ipPrefix), ('ipv6Prefix', ipv6Prefix), ('leakEnableFlag', leakEnableFlag), ('allowFilter', allowFilter), ('nosidflag', nosidflag), ])


class yc_isLeakRouteLevel1ToLevel2s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of level-1 to level-2 route leaking.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLeakRouteLevel1ToLevel2',)

  _yang_name = 'isLeakRouteLevel1ToLevel2s'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLeakRouteLevel1ToLevel2 = YANGDynClass(base=yc_isLeakRouteLevel1ToLevel2_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s_isLeakRouteLevel1ToLevel2, is_container='container', yang_name="isLeakRouteLevel1ToLevel2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isLeakRouteLevel1ToLevel2s']

  def _get_isLeakRouteLevel1ToLevel2(self):
    """
    Getter method for isLeakRouteLevel1ToLevel2, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2 (container)

    YANG Description: Control the leaking of the routes from a level-1 area to a level-2 area. This is convenient for route management. This command needs to be configured on the level-1-2 router connected to external areas.
    """
    return self.__isLeakRouteLevel1ToLevel2
      
  def _set_isLeakRouteLevel1ToLevel2(self, v, load=False):
    """
    Setter method for isLeakRouteLevel1ToLevel2, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s/isLeakRouteLevel1ToLevel2 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLeakRouteLevel1ToLevel2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLeakRouteLevel1ToLevel2() directly.

    YANG Description: Control the leaking of the routes from a level-1 area to a level-2 area. This is convenient for route management. This command needs to be configured on the level-1-2 router connected to external areas.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLeakRouteLevel1ToLevel2_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s_isLeakRouteLevel1ToLevel2, is_container='container', yang_name="isLeakRouteLevel1ToLevel2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLeakRouteLevel1ToLevel2 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLeakRouteLevel1ToLevel2_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s_isLeakRouteLevel1ToLevel2, is_container='container', yang_name="isLeakRouteLevel1ToLevel2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLeakRouteLevel1ToLevel2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLeakRouteLevel1ToLevel2(self):
    self.__isLeakRouteLevel1ToLevel2 = YANGDynClass(base=yc_isLeakRouteLevel1ToLevel2_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s_isLeakRouteLevel1ToLevel2, is_container='container', yang_name="isLeakRouteLevel1ToLevel2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isLeakRouteLevel1ToLevel2 = __builtin__.property(_get_isLeakRouteLevel1ToLevel2, _set_isLeakRouteLevel1ToLevel2) # type: yc_isLeakRouteLevel1ToLevel2_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s_isLeakRouteLevel1ToLevel2


  _pyangbind_elements = OrderedDict([('isLeakRouteLevel1ToLevel2', isLeakRouteLevel1ToLevel2), ])


class yc_isRoutePriority_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys_isRoutePriority(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set a route priority.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLevel','__priority','__useflag','__tag','__ipprefix','__ipv6prefix',)

  _yang_name = 'isRoutePriority'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLevel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__priority = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__useflag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="useflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__ipprefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipprefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipv6prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isRoutePrioritys', 'isRoutePriority']

  def _get_isLevel(self):
    """
    Getter method for isLevel, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/isLevel (string)

    YANG Description: Set a level type for the route priority, which can be level-1 or level-2.
    """
    return self.__isLevel
      
  def _set_isLevel(self, v, load=False):
    """
    Setter method for isLevel, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/isLevel (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLevel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLevel() directly.

    YANG Description: Set a level type for the route priority, which can be level-1 or level-2.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLevel must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__isLevel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLevel(self):
    self.__isLevel = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/priority (string)

    YANG Description: Set a route priority.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/priority (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Set a route priority.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_useflag(self):
    """
    Getter method for useflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/useflag (string)

    YANG Description: Set a filtering policy for the route priority.
    """
    return self.__useflag
      
  def _set_useflag(self, v, load=False):
    """
    Setter method for useflag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/useflag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_useflag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_useflag() directly.

    YANG Description: Set a filtering policy for the route priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="useflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """useflag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="useflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__useflag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_useflag(self):
    self.__useflag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="useflag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/tag (uint32)

    YANG Description: Set a tag for the route priority. The value is an integer. The default value is 0, which cannot be configured.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Set a tag for the route priority. The value is an integer. The default value is 0, which cannot be configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_ipprefix(self):
    """
    Getter method for ipprefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/ipprefix (string)

    YANG Description: Set the name of an IP prefix list.
    """
    return self.__ipprefix
      
  def _set_ipprefix(self, v, load=False):
    """
    Setter method for ipprefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/ipprefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipprefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipprefix() directly.

    YANG Description: Set the name of an IP prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipprefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipprefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipprefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipprefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipprefix(self):
    self.__ipprefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipprefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipv6prefix(self):
    """
    Getter method for ipv6prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/ipv6prefix (string)

    YANG Description: Set the name of an IPv6 prefix list.
    """
    return self.__ipv6prefix
      
  def _set_ipv6prefix(self, v, load=False):
    """
    Setter method for ipv6prefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority/ipv6prefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6prefix() directly.

    YANG Description: Set the name of an IPv6 prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipv6prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6prefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipv6prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6prefix(self):
    self.__ipv6prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipv6prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  isLevel = __builtin__.property(_get_isLevel, _set_isLevel)
  priority = __builtin__.property(_get_priority, _set_priority)
  useflag = __builtin__.property(_get_useflag, _set_useflag)
  tag = __builtin__.property(_get_tag, _set_tag)
  ipprefix = __builtin__.property(_get_ipprefix, _set_ipprefix)
  ipv6prefix = __builtin__.property(_get_ipv6prefix, _set_ipv6prefix)


  _pyangbind_elements = OrderedDict([('isLevel', isLevel), ('priority', priority), ('useflag', useflag), ('tag', tag), ('ipprefix', ipprefix), ('ipv6prefix', ipv6prefix), ])


class yc_isRoutePrioritys_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route priority list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isRoutePriority',)

  _yang_name = 'isRoutePrioritys'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isRoutePriority = YANGDynClass(base=YANGListType("isLevel priority",yc_isRoutePriority_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys_isRoutePriority, yang_name="isRoutePriority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='isLevel priority', extensions=None), is_container='list', yang_name="isRoutePriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isRoutePrioritys']

  def _get_isRoutePriority(self):
    """
    Getter method for isRoutePriority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority (list)

    YANG Description: Set a route priority.
    """
    return self.__isRoutePriority
      
  def _set_isRoutePriority(self, v, load=False):
    """
    Setter method for isRoutePriority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys/isRoutePriority (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isRoutePriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isRoutePriority() directly.

    YANG Description: Set a route priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("isLevel priority",yc_isRoutePriority_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys_isRoutePriority, yang_name="isRoutePriority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='isLevel priority', extensions=None), is_container='list', yang_name="isRoutePriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isRoutePriority must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("isLevel priority",yc_isRoutePriority_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys_isRoutePriority, yang_name="isRoutePriority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='isLevel priority', extensions=None), is_container='list', yang_name="isRoutePriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isRoutePriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isRoutePriority(self):
    self.__isRoutePriority = YANGDynClass(base=YANGListType("isLevel priority",yc_isRoutePriority_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys_isRoutePriority, yang_name="isRoutePriority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='isLevel priority', extensions=None), is_container='list', yang_name="isRoutePriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isRoutePriority = __builtin__.property(_get_isRoutePriority, _set_isRoutePriority) # type: yc_isRoutePriority_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys_isRoutePriority


  _pyangbind_elements = OrderedDict([('isRoutePriority', isRoutePriority), ])


class yc_isPreference_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences_isPreference(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set a priority for IS-IS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__policyType','__preferenceValue','__routePolicyName','__routeFilterNameEntity',)

  _yang_name = 'isPreference'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__preferenceValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(15), is_leaf=True, yang_name="preferenceValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isPreferences', 'isPreference']

  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/policyType (string)

    YANG Description: Mode of the policy used for applying the routing protocol priority. If the value is ACL, the ACL number parameter is available. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is IP Prefix, the IP Prefix parameter is available.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: Mode of the policy used for applying the routing protocol priority. If the value is ACL, the ACL number parameter is available. If the value is Route-Policy, the Route-Policy Name parameter is available. If the value is IP Prefix, the IP Prefix parameter is available.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_preferenceValue(self):
    """
    Getter method for preferenceValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/preferenceValue (uint32)

    YANG Description: Set the priority for protocols. The smaller the value, the higher the priority.
    """
    return self.__preferenceValue
      
  def _set_preferenceValue(self, v, load=False):
    """
    Setter method for preferenceValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/preferenceValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferenceValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferenceValue() directly.

    YANG Description: Set the priority for protocols. The smaller the value, the higher the priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(15), is_leaf=True, yang_name="preferenceValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferenceValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(15), is_leaf=True, yang_name="preferenceValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__preferenceValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferenceValue(self):
    self.__preferenceValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(15), is_leaf=True, yang_name="preferenceValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/routePolicyName (string)

    YANG Description: Name of a route filtering policy.
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: Name of a route filtering policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  policyType = __builtin__.property(_get_policyType, _set_policyType)
  preferenceValue = __builtin__.property(_get_preferenceValue, _set_preferenceValue)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)


  _pyangbind_elements = OrderedDict([('policyType', policyType), ('preferenceValue', preferenceValue), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ])


class yc_isPreferences_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Priority list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isPreference',)

  _yang_name = 'isPreferences'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isPreference = YANGDynClass(base=yc_isPreference_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences_isPreference, is_container='container', yang_name="isPreference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isPreferences']

  def _get_isPreference(self):
    """
    Getter method for isPreference, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference (container)

    YANG Description: Set a priority for IS-IS.
    """
    return self.__isPreference
      
  def _set_isPreference(self, v, load=False):
    """
    Setter method for isPreference, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences/isPreference (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPreference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPreference() directly.

    YANG Description: Set a priority for IS-IS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isPreference_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences_isPreference, is_container='container', yang_name="isPreference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPreference must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isPreference_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences_isPreference, is_container='container', yang_name="isPreference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isPreference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPreference(self):
    self.__isPreference = YANGDynClass(base=yc_isPreference_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences_isPreference, is_container='container', yang_name="isPreference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isPreference = __builtin__.property(_get_isPreference, _set_isPreference) # type: yc_isPreference_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences_isPreference


  _pyangbind_elements = OrderedDict([('isPreference', isPreference), ])


class yc_isRlfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isRlfa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RLFA enabling.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rlfaLevel1Enable','__rlfaLevel1MaxCost','__rlfaLevel1IpPrefix','__rlfaLevel2Enable','__rlfaLevel2MaxCost','__rlfaLevel2IpPrefix','__rlfaLevel1LdpType','__rlfaLevel2LdpType',)

  _yang_name = 'isRlfa'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rlfaLevel1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__rlfaLevel1MaxCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel1MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__rlfaLevel1IpPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rlfaLevel1IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__rlfaLevel2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__rlfaLevel2MaxCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel2MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__rlfaLevel2IpPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rlfaLevel2IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__rlfaLevel1LdpType = YANGDynClass(base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel1LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__rlfaLevel2LdpType = YANGDynClass(base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel2LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFrr', 'isRlfa']

  def _get_rlfaLevel1Enable(self):
    """
    Getter method for rlfaLevel1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1Enable (boolean)

    YANG Description: Enable level-1 remote LFA.
    """
    return self.__rlfaLevel1Enable
      
  def _set_rlfaLevel1Enable(self, v, load=False):
    """
    Setter method for rlfaLevel1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel1Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel1Enable() directly.

    YANG Description: Enable level-1 remote LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel1Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__rlfaLevel1Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel1Enable(self):
    self.__rlfaLevel1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_rlfaLevel1MaxCost(self):
    """
    Getter method for rlfaLevel1MaxCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1MaxCost (uint32)

    YANG Description: Remote-lfa tunnel ldp maximum-reachable-cost level-1.
    """
    return self.__rlfaLevel1MaxCost
      
  def _set_rlfaLevel1MaxCost(self, v, load=False):
    """
    Setter method for rlfaLevel1MaxCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1MaxCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel1MaxCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel1MaxCost() directly.

    YANG Description: Remote-lfa tunnel ldp maximum-reachable-cost level-1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel1MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel1MaxCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel1MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__rlfaLevel1MaxCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel1MaxCost(self):
    self.__rlfaLevel1MaxCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel1MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_rlfaLevel1IpPrefix(self):
    """
    Getter method for rlfaLevel1IpPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1IpPrefix (string)

    YANG Description: Filter PQ node.Those nodes which don't pass filter can't be PQ node
    """
    return self.__rlfaLevel1IpPrefix
      
  def _set_rlfaLevel1IpPrefix(self, v, load=False):
    """
    Setter method for rlfaLevel1IpPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1IpPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel1IpPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel1IpPrefix() directly.

    YANG Description: Filter PQ node.Those nodes which don't pass filter can't be PQ node
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rlfaLevel1IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel1IpPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rlfaLevel1IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__rlfaLevel1IpPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel1IpPrefix(self):
    self.__rlfaLevel1IpPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rlfaLevel1IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_rlfaLevel2Enable(self):
    """
    Getter method for rlfaLevel2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2Enable (boolean)

    YANG Description: Enable level-2 remote LFA.
    """
    return self.__rlfaLevel2Enable
      
  def _set_rlfaLevel2Enable(self, v, load=False):
    """
    Setter method for rlfaLevel2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel2Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel2Enable() directly.

    YANG Description: Enable level-2 remote LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel2Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__rlfaLevel2Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel2Enable(self):
    self.__rlfaLevel2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_rlfaLevel2MaxCost(self):
    """
    Getter method for rlfaLevel2MaxCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2MaxCost (uint32)

    YANG Description: Remote-lfa tunnel ldp maximum-reachable-cost level-2.
    """
    return self.__rlfaLevel2MaxCost
      
  def _set_rlfaLevel2MaxCost(self, v, load=False):
    """
    Setter method for rlfaLevel2MaxCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2MaxCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel2MaxCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel2MaxCost() directly.

    YANG Description: Remote-lfa tunnel ldp maximum-reachable-cost level-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel2MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel2MaxCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel2MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__rlfaLevel2MaxCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel2MaxCost(self):
    self.__rlfaLevel2MaxCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4261412864']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4261412864), is_leaf=True, yang_name="rlfaLevel2MaxCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_rlfaLevel2IpPrefix(self):
    """
    Getter method for rlfaLevel2IpPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2IpPrefix (string)

    YANG Description: Filter PQ node.Those nodes which don't pass filter can't be PQ node.
    """
    return self.__rlfaLevel2IpPrefix
      
  def _set_rlfaLevel2IpPrefix(self, v, load=False):
    """
    Setter method for rlfaLevel2IpPrefix, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2IpPrefix (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel2IpPrefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel2IpPrefix() directly.

    YANG Description: Filter PQ node.Those nodes which don't pass filter can't be PQ node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="rlfaLevel2IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel2IpPrefix must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rlfaLevel2IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__rlfaLevel2IpPrefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel2IpPrefix(self):
    self.__rlfaLevel2IpPrefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rlfaLevel2IpPrefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_rlfaLevel1LdpType(self):
    """
    Getter method for rlfaLevel1LdpType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1LdpType (string)

    YANG Description: Remote LFA Level-1 LDP Type Specify Level-1 RLFA LDP tunnel type.
    """
    return self.__rlfaLevel1LdpType
      
  def _set_rlfaLevel1LdpType(self, v, load=False):
    """
    Setter method for rlfaLevel1LdpType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel1LdpType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel1LdpType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel1LdpType() directly.

    YANG Description: Remote LFA Level-1 LDP Type Specify Level-1 RLFA LDP tunnel type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel1LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel1LdpType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel1LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__rlfaLevel1LdpType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel1LdpType(self):
    self.__rlfaLevel1LdpType = YANGDynClass(base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel1LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_rlfaLevel2LdpType(self):
    """
    Getter method for rlfaLevel2LdpType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2LdpType (string)

    YANG Description: Remote LFA Level-2 LDP Type Specify Level-2 RLFA LDP tunnel type.
    """
    return self.__rlfaLevel2LdpType
      
  def _set_rlfaLevel2LdpType(self, v, load=False):
    """
    Setter method for rlfaLevel2LdpType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa/rlfaLevel2LdpType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfaLevel2LdpType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfaLevel2LdpType() directly.

    YANG Description: Remote LFA Level-2 LDP Type Specify Level-2 RLFA LDP tunnel type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel2LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfaLevel2LdpType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel2LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__rlfaLevel2LdpType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfaLevel2LdpType(self):
    self.__rlfaLevel2LdpType = YANGDynClass(base=six.text_type, default=six.text_type("ipv4"), is_leaf=True, yang_name="rlfaLevel2LdpType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  rlfaLevel1Enable = __builtin__.property(_get_rlfaLevel1Enable, _set_rlfaLevel1Enable)
  rlfaLevel1MaxCost = __builtin__.property(_get_rlfaLevel1MaxCost, _set_rlfaLevel1MaxCost)
  rlfaLevel1IpPrefix = __builtin__.property(_get_rlfaLevel1IpPrefix, _set_rlfaLevel1IpPrefix)
  rlfaLevel2Enable = __builtin__.property(_get_rlfaLevel2Enable, _set_rlfaLevel2Enable)
  rlfaLevel2MaxCost = __builtin__.property(_get_rlfaLevel2MaxCost, _set_rlfaLevel2MaxCost)
  rlfaLevel2IpPrefix = __builtin__.property(_get_rlfaLevel2IpPrefix, _set_rlfaLevel2IpPrefix)
  rlfaLevel1LdpType = __builtin__.property(_get_rlfaLevel1LdpType, _set_rlfaLevel1LdpType)
  rlfaLevel2LdpType = __builtin__.property(_get_rlfaLevel2LdpType, _set_rlfaLevel2LdpType)


  _pyangbind_elements = OrderedDict([('rlfaLevel1Enable', rlfaLevel1Enable), ('rlfaLevel1MaxCost', rlfaLevel1MaxCost), ('rlfaLevel1IpPrefix', rlfaLevel1IpPrefix), ('rlfaLevel2Enable', rlfaLevel2Enable), ('rlfaLevel2MaxCost', rlfaLevel2MaxCost), ('rlfaLevel2IpPrefix', rlfaLevel2IpPrefix), ('rlfaLevel1LdpType', rlfaLevel1LdpType), ('rlfaLevel2LdpType', rlfaLevel2LdpType), ])


class yc_isFrrTieBreak_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isFrrTieBreak(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuring a Rule of Selecting a Backup Path for IS-IS Auto FRR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__l1nodeProtectPrefer','__l1lowcostPrefer','__l1nonEcmpPrefer','__l1srlgDisjointPrefer','__l2nodeProtectPrefer','__l2lowcostPrefer','__l2nonEcmpPrefer','__l2srlgDisjointPrefer',)

  _yang_name = 'isFrrTieBreak'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__l1nodeProtectPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l1nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l1lowcostPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l1lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l1nonEcmpPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l1nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l1srlgDisjointPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l1srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l2nodeProtectPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l2nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l2lowcostPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l2lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l2nonEcmpPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l2nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__l2srlgDisjointPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l2srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFrr', 'isFrrTieBreak']

  def _get_l1nodeProtectPrefer(self):
    """
    Getter method for l1nodeProtectPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1nodeProtectPrefer (uint8)

    YANG Description: Set the value of level1 node protect prefer,the default vale is 40.
    """
    return self.__l1nodeProtectPrefer
      
  def _set_l1nodeProtectPrefer(self, v, load=False):
    """
    Setter method for l1nodeProtectPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1nodeProtectPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1nodeProtectPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1nodeProtectPrefer() directly.

    YANG Description: Set the value of level1 node protect prefer,the default vale is 40.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l1nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1nodeProtectPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l1nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l1nodeProtectPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1nodeProtectPrefer(self):
    self.__l1nodeProtectPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l1nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l1lowcostPrefer(self):
    """
    Getter method for l1lowcostPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1lowcostPrefer (uint8)

    YANG Description: Set the value of level1 lowcost prefer,the default vale is 20.
    """
    return self.__l1lowcostPrefer
      
  def _set_l1lowcostPrefer(self, v, load=False):
    """
    Setter method for l1lowcostPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1lowcostPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1lowcostPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1lowcostPrefer() directly.

    YANG Description: Set the value of level1 lowcost prefer,the default vale is 20.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l1lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1lowcostPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l1lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l1lowcostPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1lowcostPrefer(self):
    self.__l1lowcostPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l1lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l1nonEcmpPrefer(self):
    """
    Getter method for l1nonEcmpPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1nonEcmpPrefer (uint8)

    YANG Description: Set the value of level1 non ecmp path prefer,the default vale is 10.
    """
    return self.__l1nonEcmpPrefer
      
  def _set_l1nonEcmpPrefer(self, v, load=False):
    """
    Setter method for l1nonEcmpPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1nonEcmpPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1nonEcmpPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1nonEcmpPrefer() directly.

    YANG Description: Set the value of level1 non ecmp path prefer,the default vale is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l1nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1nonEcmpPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l1nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l1nonEcmpPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1nonEcmpPrefer(self):
    self.__l1nonEcmpPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l1nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l1srlgDisjointPrefer(self):
    """
    Getter method for l1srlgDisjointPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1srlgDisjointPrefer (uint8)

    YANG Description: Set the value of level1 srlg-disjoint path prefer,the default vale is 5.
    """
    return self.__l1srlgDisjointPrefer
      
  def _set_l1srlgDisjointPrefer(self, v, load=False):
    """
    Setter method for l1srlgDisjointPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l1srlgDisjointPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1srlgDisjointPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1srlgDisjointPrefer() directly.

    YANG Description: Set the value of level1 srlg-disjoint path prefer,the default vale is 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l1srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1srlgDisjointPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l1srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l1srlgDisjointPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1srlgDisjointPrefer(self):
    self.__l1srlgDisjointPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l1srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l2nodeProtectPrefer(self):
    """
    Getter method for l2nodeProtectPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2nodeProtectPrefer (uint8)

    YANG Description: Set the value of level2 node protect prefer,the default vale is 40.
    """
    return self.__l2nodeProtectPrefer
      
  def _set_l2nodeProtectPrefer(self, v, load=False):
    """
    Setter method for l2nodeProtectPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2nodeProtectPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2nodeProtectPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2nodeProtectPrefer() directly.

    YANG Description: Set the value of level2 node protect prefer,the default vale is 40.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l2nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2nodeProtectPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l2nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l2nodeProtectPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2nodeProtectPrefer(self):
    self.__l2nodeProtectPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="l2nodeProtectPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l2lowcostPrefer(self):
    """
    Getter method for l2lowcostPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2lowcostPrefer (uint8)

    YANG Description: Set the value of level2 lowcost prefer,the default vale is 20.
    """
    return self.__l2lowcostPrefer
      
  def _set_l2lowcostPrefer(self, v, load=False):
    """
    Setter method for l2lowcostPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2lowcostPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2lowcostPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2lowcostPrefer() directly.

    YANG Description: Set the value of level2 lowcost prefer,the default vale is 20.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l2lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2lowcostPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l2lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l2lowcostPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2lowcostPrefer(self):
    self.__l2lowcostPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="l2lowcostPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l2nonEcmpPrefer(self):
    """
    Getter method for l2nonEcmpPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2nonEcmpPrefer (uint8)

    YANG Description: Set the value of level2 non ecmp path prefer,the default vale is 10.
    """
    return self.__l2nonEcmpPrefer
      
  def _set_l2nonEcmpPrefer(self, v, load=False):
    """
    Setter method for l2nonEcmpPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2nonEcmpPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2nonEcmpPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2nonEcmpPrefer() directly.

    YANG Description: Set the value of level2 non ecmp path prefer,the default vale is 10.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l2nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2nonEcmpPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l2nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l2nonEcmpPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2nonEcmpPrefer(self):
    self.__l2nonEcmpPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="l2nonEcmpPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_l2srlgDisjointPrefer(self):
    """
    Getter method for l2srlgDisjointPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2srlgDisjointPrefer (uint8)

    YANG Description: Set the value of level2 srlg-disjoint path prefer,the default vale is 5.
    """
    return self.__l2srlgDisjointPrefer
      
  def _set_l2srlgDisjointPrefer(self, v, load=False):
    """
    Setter method for l2srlgDisjointPrefer, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak/l2srlgDisjointPrefer (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2srlgDisjointPrefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2srlgDisjointPrefer() directly.

    YANG Description: Set the value of level2 srlg-disjoint path prefer,the default vale is 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l2srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2srlgDisjointPrefer must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l2srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__l2srlgDisjointPrefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2srlgDisjointPrefer(self):
    self.__l2srlgDisjointPrefer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(5), is_leaf=True, yang_name="l2srlgDisjointPrefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)

  l1nodeProtectPrefer = __builtin__.property(_get_l1nodeProtectPrefer, _set_l1nodeProtectPrefer)
  l1lowcostPrefer = __builtin__.property(_get_l1lowcostPrefer, _set_l1lowcostPrefer)
  l1nonEcmpPrefer = __builtin__.property(_get_l1nonEcmpPrefer, _set_l1nonEcmpPrefer)
  l1srlgDisjointPrefer = __builtin__.property(_get_l1srlgDisjointPrefer, _set_l1srlgDisjointPrefer)
  l2nodeProtectPrefer = __builtin__.property(_get_l2nodeProtectPrefer, _set_l2nodeProtectPrefer)
  l2lowcostPrefer = __builtin__.property(_get_l2lowcostPrefer, _set_l2lowcostPrefer)
  l2nonEcmpPrefer = __builtin__.property(_get_l2nonEcmpPrefer, _set_l2nonEcmpPrefer)
  l2srlgDisjointPrefer = __builtin__.property(_get_l2srlgDisjointPrefer, _set_l2srlgDisjointPrefer)


  _pyangbind_elements = OrderedDict([('l1nodeProtectPrefer', l1nodeProtectPrefer), ('l1lowcostPrefer', l1lowcostPrefer), ('l1nonEcmpPrefer', l1nonEcmpPrefer), ('l1srlgDisjointPrefer', l1srlgDisjointPrefer), ('l2nodeProtectPrefer', l2nodeProtectPrefer), ('l2lowcostPrefer', l2lowcostPrefer), ('l2nonEcmpPrefer', l2nonEcmpPrefer), ('l2srlgDisjointPrefer', l2srlgDisjointPrefer), ])


class yc_isTilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isTilfa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable TI-LFA.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tilfaL1Enable','__tilfaL2Enable',)

  _yang_name = 'isTilfa'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tilfaL1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__tilfaL2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFrr', 'isTilfa']

  def _get_tilfaL1Enable(self):
    """
    Getter method for tilfaL1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa/tilfaL1Enable (boolean)

    YANG Description: Enable Level-1 TI-LFA.
    """
    return self.__tilfaL1Enable
      
  def _set_tilfaL1Enable(self, v, load=False):
    """
    Setter method for tilfaL1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa/tilfaL1Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tilfaL1Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tilfaL1Enable() directly.

    YANG Description: Enable Level-1 TI-LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tilfaL1Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__tilfaL1Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tilfaL1Enable(self):
    self.__tilfaL1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_tilfaL2Enable(self):
    """
    Getter method for tilfaL2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa/tilfaL2Enable (boolean)

    YANG Description: Enable Level-2 TI-LFA.
    """
    return self.__tilfaL2Enable
      
  def _set_tilfaL2Enable(self, v, load=False):
    """
    Setter method for tilfaL2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa/tilfaL2Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tilfaL2Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tilfaL2Enable() directly.

    YANG Description: Enable Level-2 TI-LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tilfaL2Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__tilfaL2Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tilfaL2Enable(self):
    self.__tilfaL2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  tilfaL1Enable = __builtin__.property(_get_tilfaL1Enable, _set_tilfaL1Enable)
  tilfaL2Enable = __builtin__.property(_get_tilfaL2Enable, _set_tilfaL2Enable)


  _pyangbind_elements = OrderedDict([('tilfaL1Enable', tilfaL1Enable), ('tilfaL2Enable', tilfaL2Enable), ])


class yc_isIpv6Tilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isIpv6Tilfa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable IPv6 Ti-LFA.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6TilfaL1Enable','__ipv6TilfaL2Enable',)

  _yang_name = 'isIpv6Tilfa'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6TilfaL1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ipv6TilfaL2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFrr', 'isIpv6Tilfa']

  def _get_ipv6TilfaL1Enable(self):
    """
    Getter method for ipv6TilfaL1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa/ipv6TilfaL1Enable (boolean)

    YANG Description: Enable Level-1 IPv6 TI-LFA.
    """
    return self.__ipv6TilfaL1Enable
      
  def _set_ipv6TilfaL1Enable(self, v, load=False):
    """
    Setter method for ipv6TilfaL1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa/ipv6TilfaL1Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6TilfaL1Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6TilfaL1Enable() directly.

    YANG Description: Enable Level-1 IPv6 TI-LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6TilfaL1Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv6TilfaL1Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6TilfaL1Enable(self):
    self.__ipv6TilfaL1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ipv6TilfaL2Enable(self):
    """
    Getter method for ipv6TilfaL2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa/ipv6TilfaL2Enable (boolean)

    YANG Description: Enable Level-2 IPv6 TI-LFA.
    """
    return self.__ipv6TilfaL2Enable
      
  def _set_ipv6TilfaL2Enable(self, v, load=False):
    """
    Setter method for ipv6TilfaL2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa/ipv6TilfaL2Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6TilfaL2Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6TilfaL2Enable() directly.

    YANG Description: Enable Level-2 IPv6 TI-LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6TilfaL2Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv6TilfaL2Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6TilfaL2Enable(self):
    self.__ipv6TilfaL2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6TilfaL2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  ipv6TilfaL1Enable = __builtin__.property(_get_ipv6TilfaL1Enable, _set_ipv6TilfaL1Enable)
  ipv6TilfaL2Enable = __builtin__.property(_get_ipv6TilfaL2Enable, _set_ipv6TilfaL2Enable)


  _pyangbind_elements = OrderedDict([('ipv6TilfaL1Enable', ipv6TilfaL1Enable), ('ipv6TilfaL2Enable', ipv6TilfaL2Enable), ])


class yc_isFrr_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable FRR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frrEnable','__policyType','__routePolicyName','__routeFilterNameEntity','__lfaLevel1Enable','__lfaLevel2Enable','__ecmpLevel1Enable','__ecmpLevel2Enable','__isRlfa','__isFrrTieBreak','__isTilfa','__isIpv6Tilfa',)

  _yang_name = 'isFrr'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frrEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__lfaLevel1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__lfaLevel2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ecmpLevel1Enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ecmpLevel2Enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isRlfa = YANGDynClass(base=yc_isRlfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isRlfa, is_container='container', yang_name="isRlfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isFrrTieBreak = YANGDynClass(base=yc_isFrrTieBreak_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isFrrTieBreak, is_container='container', yang_name="isFrrTieBreak", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isTilfa = YANGDynClass(base=yc_isTilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isTilfa, is_container='container', yang_name="isTilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isIpv6Tilfa = YANGDynClass(base=yc_isIpv6Tilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isIpv6Tilfa, is_container='container', yang_name="isIpv6Tilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isFrr']

  def _get_frrEnable(self):
    """
    Getter method for frrEnable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/frrEnable (boolean)

    YANG Description: Enable FRR.
    """
    return self.__frrEnable
      
  def _set_frrEnable(self, v, load=False):
    """
    Setter method for frrEnable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/frrEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frrEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frrEnable() directly.

    YANG Description: Enable FRR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frrEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__frrEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frrEnable(self):
    self.__frrEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_policyType(self):
    """
    Getter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/policyType (string)

    YANG Description: LFA Policy type.
    """
    return self.__policyType
      
  def _set_policyType(self, v, load=False):
    """
    Setter method for policyType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/policyType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policyType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policyType() directly.

    YANG Description: LFA Policy type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policyType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__policyType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policyType(self):
    self.__policyType = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="policyType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routePolicyName(self):
    """
    Getter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/routePolicyName (string)

    YANG Description: LFA Policy name.
    """
    return self.__routePolicyName
      
  def _set_routePolicyName(self, v, load=False):
    """
    Setter method for routePolicyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/routePolicyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routePolicyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routePolicyName() directly.

    YANG Description: LFA Policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routePolicyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routePolicyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routePolicyName(self):
    self.__routePolicyName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..200']}), is_leaf=True, yang_name="routePolicyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_routeFilterNameEntity(self):
    """
    Getter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/routeFilterNameEntity (string)

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    return self.__routeFilterNameEntity
      
  def _set_routeFilterNameEntity(self, v, load=False):
    """
    Setter method for routeFilterNameEntity, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/routeFilterNameEntity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeFilterNameEntity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeFilterNameEntity() directly.

    YANG Description: Set a xpl route-policy name entity for default routes. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeFilterNameEntity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__routeFilterNameEntity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeFilterNameEntity(self):
    self.__routeFilterNameEntity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routeFilterNameEntity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_lfaLevel1Enable(self):
    """
    Getter method for lfaLevel1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/lfaLevel1Enable (boolean)

    YANG Description: Enable IS-IS auto FRR of Level-1 and calculate loop-free-alternate routes using the LFA arithmetic.
    """
    return self.__lfaLevel1Enable
      
  def _set_lfaLevel1Enable(self, v, load=False):
    """
    Setter method for lfaLevel1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/lfaLevel1Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lfaLevel1Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lfaLevel1Enable() directly.

    YANG Description: Enable IS-IS auto FRR of Level-1 and calculate loop-free-alternate routes using the LFA arithmetic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lfaLevel1Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__lfaLevel1Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lfaLevel1Enable(self):
    self.__lfaLevel1Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_lfaLevel2Enable(self):
    """
    Getter method for lfaLevel2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/lfaLevel2Enable (boolean)

    YANG Description: Enable IS-IS auto FRR of Level-2 and calculate loop-free-alternate routes using the LFA arithmetic.
    """
    return self.__lfaLevel2Enable
      
  def _set_lfaLevel2Enable(self, v, load=False):
    """
    Setter method for lfaLevel2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/lfaLevel2Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lfaLevel2Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lfaLevel2Enable() directly.

    YANG Description: Enable IS-IS auto FRR of Level-2 and calculate loop-free-alternate routes using the LFA arithmetic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lfaLevel2Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__lfaLevel2Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lfaLevel2Enable(self):
    self.__lfaLevel2Enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfaLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ecmpLevel1Enable(self):
    """
    Getter method for ecmpLevel1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/ecmpLevel1Enable (boolean)

    YANG Description: Enable Level-1 ECMP FRR and calculate backup paths for load sharing paths.
    """
    return self.__ecmpLevel1Enable
      
  def _set_ecmpLevel1Enable(self, v, load=False):
    """
    Setter method for ecmpLevel1Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/ecmpLevel1Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecmpLevel1Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecmpLevel1Enable() directly.

    YANG Description: Enable Level-1 ECMP FRR and calculate backup paths for load sharing paths.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecmpLevel1Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ecmpLevel1Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecmpLevel1Enable(self):
    self.__ecmpLevel1Enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel1Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ecmpLevel2Enable(self):
    """
    Getter method for ecmpLevel2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/ecmpLevel2Enable (boolean)

    YANG Description: Enable Level-2 ECMP FRR and calculate backup paths for load sharing paths.
    """
    return self.__ecmpLevel2Enable
      
  def _set_ecmpLevel2Enable(self, v, load=False):
    """
    Setter method for ecmpLevel2Enable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/ecmpLevel2Enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecmpLevel2Enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecmpLevel2Enable() directly.

    YANG Description: Enable Level-2 ECMP FRR and calculate backup paths for load sharing paths.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecmpLevel2Enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ecmpLevel2Enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecmpLevel2Enable(self):
    self.__ecmpLevel2Enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ecmpLevel2Enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isRlfa(self):
    """
    Getter method for isRlfa, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa (container)

    YANG Description: RLFA enabling.
    """
    return self.__isRlfa
      
  def _set_isRlfa(self, v, load=False):
    """
    Setter method for isRlfa, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isRlfa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isRlfa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isRlfa() directly.

    YANG Description: RLFA enabling.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isRlfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isRlfa, is_container='container', yang_name="isRlfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isRlfa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isRlfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isRlfa, is_container='container', yang_name="isRlfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isRlfa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isRlfa(self):
    self.__isRlfa = YANGDynClass(base=yc_isRlfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isRlfa, is_container='container', yang_name="isRlfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isFrrTieBreak(self):
    """
    Getter method for isFrrTieBreak, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak (container)

    YANG Description: Configuring a Rule of Selecting a Backup Path for IS-IS Auto FRR.
    """
    return self.__isFrrTieBreak
      
  def _set_isFrrTieBreak(self, v, load=False):
    """
    Setter method for isFrrTieBreak, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isFrrTieBreak (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFrrTieBreak is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFrrTieBreak() directly.

    YANG Description: Configuring a Rule of Selecting a Backup Path for IS-IS Auto FRR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isFrrTieBreak_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isFrrTieBreak, is_container='container', yang_name="isFrrTieBreak", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFrrTieBreak must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isFrrTieBreak_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isFrrTieBreak, is_container='container', yang_name="isFrrTieBreak", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isFrrTieBreak = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFrrTieBreak(self):
    self.__isFrrTieBreak = YANGDynClass(base=yc_isFrrTieBreak_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isFrrTieBreak, is_container='container', yang_name="isFrrTieBreak", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isTilfa(self):
    """
    Getter method for isTilfa, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa (container)

    YANG Description: Enable TI-LFA.
    """
    return self.__isTilfa
      
  def _set_isTilfa(self, v, load=False):
    """
    Setter method for isTilfa, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isTilfa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isTilfa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isTilfa() directly.

    YANG Description: Enable TI-LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isTilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isTilfa, is_container='container', yang_name="isTilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isTilfa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isTilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isTilfa, is_container='container', yang_name="isTilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isTilfa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isTilfa(self):
    self.__isTilfa = YANGDynClass(base=yc_isTilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isTilfa, is_container='container', yang_name="isTilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isIpv6Tilfa(self):
    """
    Getter method for isIpv6Tilfa, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa (container)

    YANG Description: Enable IPv6 Ti-LFA.
    """
    return self.__isIpv6Tilfa
      
  def _set_isIpv6Tilfa(self, v, load=False):
    """
    Setter method for isIpv6Tilfa, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr/isIpv6Tilfa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isIpv6Tilfa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isIpv6Tilfa() directly.

    YANG Description: Enable IPv6 Ti-LFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isIpv6Tilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isIpv6Tilfa, is_container='container', yang_name="isIpv6Tilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isIpv6Tilfa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isIpv6Tilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isIpv6Tilfa, is_container='container', yang_name="isIpv6Tilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isIpv6Tilfa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isIpv6Tilfa(self):
    self.__isIpv6Tilfa = YANGDynClass(base=yc_isIpv6Tilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isIpv6Tilfa, is_container='container', yang_name="isIpv6Tilfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  frrEnable = __builtin__.property(_get_frrEnable, _set_frrEnable)
  policyType = __builtin__.property(_get_policyType, _set_policyType)
  routePolicyName = __builtin__.property(_get_routePolicyName, _set_routePolicyName)
  routeFilterNameEntity = __builtin__.property(_get_routeFilterNameEntity, _set_routeFilterNameEntity)
  lfaLevel1Enable = __builtin__.property(_get_lfaLevel1Enable, _set_lfaLevel1Enable)
  lfaLevel2Enable = __builtin__.property(_get_lfaLevel2Enable, _set_lfaLevel2Enable)
  ecmpLevel1Enable = __builtin__.property(_get_ecmpLevel1Enable, _set_ecmpLevel1Enable)
  ecmpLevel2Enable = __builtin__.property(_get_ecmpLevel2Enable, _set_ecmpLevel2Enable)
  isRlfa = __builtin__.property(_get_isRlfa, _set_isRlfa) # type: yc_isRlfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isRlfa
  isFrrTieBreak = __builtin__.property(_get_isFrrTieBreak, _set_isFrrTieBreak) # type: yc_isFrrTieBreak_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isFrrTieBreak
  isTilfa = __builtin__.property(_get_isTilfa, _set_isTilfa) # type: yc_isTilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isTilfa
  isIpv6Tilfa = __builtin__.property(_get_isIpv6Tilfa, _set_isIpv6Tilfa) # type: yc_isIpv6Tilfa_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr_isIpv6Tilfa


  _pyangbind_elements = OrderedDict([('frrEnable', frrEnable), ('policyType', policyType), ('routePolicyName', routePolicyName), ('routeFilterNameEntity', routeFilterNameEntity), ('lfaLevel1Enable', lfaLevel1Enable), ('lfaLevel2Enable', lfaLevel2Enable), ('ecmpLevel1Enable', ecmpLevel1Enable), ('ecmpLevel2Enable', ecmpLevel2Enable), ('isRlfa', isRlfa), ('isFrrTieBreak', isFrrTieBreak), ('isTilfa', isTilfa), ('isIpv6Tilfa', isIpv6Tilfa), ])


class yc_isPrefixSid_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt_isPrefixSid(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information of prefix sid.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefixSidType','__prefixLabel','__nodeFlag',)

  _yang_name = 'isPrefixSid'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefixSidType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="prefixSidType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__prefixLabel = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="prefixLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__nodeFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="nodeFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isCircMts', 'isCircMt', 'isPrefixSid']

  def _get_prefixSidType(self):
    """
    Getter method for prefixSidType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid/prefixSidType (string)

    YANG Description: Set the type of prefix sid.
    """
    return self.__prefixSidType
      
  def _set_prefixSidType(self, v, load=False):
    """
    Setter method for prefixSidType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid/prefixSidType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixSidType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixSidType() directly.

    YANG Description: Set the type of prefix sid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="prefixSidType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixSidType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="prefixSidType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__prefixSidType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixSidType(self):
    self.__prefixSidType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="prefixSidType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_prefixLabel(self):
    """
    Getter method for prefixLabel, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid/prefixLabel (uint32)

    YANG Description: Set the label of prefix sid.
    """
    return self.__prefixLabel
      
  def _set_prefixLabel(self, v, load=False):
    """
    Setter method for prefixLabel, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid/prefixLabel (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixLabel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixLabel() directly.

    YANG Description: Set the label of prefix sid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="prefixLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixLabel must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="prefixLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__prefixLabel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixLabel(self):
    self.__prefixLabel = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1048575']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="prefixLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_nodeFlag(self):
    """
    Getter method for nodeFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid/nodeFlag (boolean)

    YANG Description: Set the node flag.
    """
    return self.__nodeFlag
      
  def _set_nodeFlag(self, v, load=False):
    """
    Setter method for nodeFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid/nodeFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodeFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodeFlag() directly.

    YANG Description: Set the node flag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="nodeFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodeFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="nodeFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__nodeFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodeFlag(self):
    self.__nodeFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="nodeFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  prefixSidType = __builtin__.property(_get_prefixSidType, _set_prefixSidType)
  prefixLabel = __builtin__.property(_get_prefixLabel, _set_prefixLabel)
  nodeFlag = __builtin__.property(_get_nodeFlag, _set_nodeFlag)


  _pyangbind_elements = OrderedDict([('prefixSidType', prefixSidType), ('prefixLabel', prefixLabel), ('nodeFlag', nodeFlag), ])


class yc_isCircMt_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set parameters for IS-IS multi-topology on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifName','__level1Cost','__level2Cost','__level1Tag','__level2Tag','__suppressReach','__bfdEnable','__bfdStaticEn','__bfdBlockEn','__bfdMinRx','__bfdMinTx','__bfdMultiplierNumber','__tosExpValue','__frrBindingFlag','__level1FrrBlock','__level2FrrBlock','__level1RemoteLFA','__level2RemoteLFA','__l1TilfaDisable','__l2TilfaDisable','__l1Ipv6TilfaDisable','__l2Ipv6TilfaDisable','__isPrefixSid','__bfdBitErrCfg','__incrCost',)

  _yang_name = 'isCircMt'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__level1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1Tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2Tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__suppressReach = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="suppressReach", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__bfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__bfdStaticEn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdStaticEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__bfdBlockEn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdBlockEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__bfdMinRx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__bfdMinTx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__bfdMultiplierNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultiplierNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__tosExpValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__frrBindingFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__l1TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__l2TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    self.__l1Ipv6TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__l2Ipv6TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isPrefixSid = YANGDynClass(base=yc_isPrefixSid_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt_isPrefixSid, is_container='container', yang_name="isPrefixSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__bfdBitErrCfg = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="bfdBitErrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__incrCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isCircMts', 'isCircMt']

  def _get_ifName(self):
    """
    Getter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/ifName (string)

    YANG Description: Interface name.
    """
    return self.__ifName
      
  def _set_ifName(self, v, load=False):
    """
    Setter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/ifName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifName() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ifName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifName(self):
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_level1Cost(self):
    """
    Getter method for level1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1Cost (uint32)

    YANG Description: Set the link cost for an interface during the level-1 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    return self.__level1Cost
      
  def _set_level1Cost(self, v, load=False):
    """
    Setter method for level1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1Cost() directly.

    YANG Description: Set the link cost for an interface during the level-1 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1Cost(self):
    self.__level1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2Cost(self):
    """
    Getter method for level2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2Cost (uint32)

    YANG Description: Set the link cost for an interface during the level-2 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    return self.__level2Cost
      
  def _set_level2Cost(self, v, load=False):
    """
    Setter method for level2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2Cost() directly.

    YANG Description: Set the link cost for an interface during the level-2 SPF calculation. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.The interface of LoopBack can use the value of 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2Cost(self):
    self.__level2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1Tag(self):
    """
    Getter method for level1Tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1Tag (uint32)

    YANG Description: Set the level-1 tag value for direct routes on the interface.
    """
    return self.__level1Tag
      
  def _set_level1Tag(self, v, load=False):
    """
    Setter method for level1Tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1Tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1Tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1Tag() directly.

    YANG Description: Set the level-1 tag value for direct routes on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1Tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1Tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1Tag(self):
    self.__level1Tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2Tag(self):
    """
    Getter method for level2Tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2Tag (uint32)

    YANG Description: Set the level-2 tag value for direct routes on the interface. 
    """
    return self.__level2Tag
      
  def _set_level2Tag(self, v, load=False):
    """
    Setter method for level2Tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2Tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2Tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2Tag() directly.

    YANG Description: Set the level-2 tag value for direct routes on the interface. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2Tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2Tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2Tag(self):
    self.__level2Tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2Tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_suppressReach(self):
    """
    Getter method for suppressReach, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/suppressReach (string)

    YANG Description: Suppress the advertisement of direct route. By default, direct routes can be advertised.
    """
    return self.__suppressReach
      
  def _set_suppressReach(self, v, load=False):
    """
    Setter method for suppressReach, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/suppressReach (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppressReach is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppressReach() directly.

    YANG Description: Suppress the advertisement of direct route. By default, direct routes can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="suppressReach", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppressReach must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="suppressReach", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__suppressReach = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppressReach(self):
    self.__suppressReach = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="suppressReach", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_bfdEnable(self):
    """
    Getter method for bfdEnable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdEnable (boolean)

    YANG Description: Enable dynamic BFD on an interface. By default, dynamic BFD is disabled.
    """
    return self.__bfdEnable
      
  def _set_bfdEnable(self, v, load=False):
    """
    Setter method for bfdEnable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdEnable() directly.

    YANG Description: Enable dynamic BFD on an interface. By default, dynamic BFD is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__bfdEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdEnable(self):
    self.__bfdEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_bfdStaticEn(self):
    """
    Getter method for bfdStaticEn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdStaticEn (boolean)

    YANG Description: Enable static BFD on an interface. By default, static BFD is disabled.
    """
    return self.__bfdStaticEn
      
  def _set_bfdStaticEn(self, v, load=False):
    """
    Setter method for bfdStaticEn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdStaticEn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdStaticEn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdStaticEn() directly.

    YANG Description: Enable static BFD on an interface. By default, static BFD is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdStaticEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdStaticEn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdStaticEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__bfdStaticEn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdStaticEn(self):
    self.__bfdStaticEn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdStaticEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_bfdBlockEn(self):
    """
    Getter method for bfdBlockEn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdBlockEn (boolean)

    YANG Description: Disable dynamic BFD from an interface. By default, dynamic BFD is not blocked.
    """
    return self.__bfdBlockEn
      
  def _set_bfdBlockEn(self, v, load=False):
    """
    Setter method for bfdBlockEn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdBlockEn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdBlockEn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdBlockEn() directly.

    YANG Description: Disable dynamic BFD from an interface. By default, dynamic BFD is not blocked.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdBlockEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdBlockEn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdBlockEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__bfdBlockEn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdBlockEn(self):
    self.__bfdBlockEn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="bfdBlockEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_bfdMinRx(self):
    """
    Getter method for bfdMinRx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdMinRx (uint32)

    YANG Description: Set the minimum interval at which BFD packets are received. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    return self.__bfdMinRx
      
  def _set_bfdMinRx(self, v, load=False):
    """
    Setter method for bfdMinRx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdMinRx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMinRx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMinRx() directly.

    YANG Description: Set the minimum interval at which BFD packets are received. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMinRx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bfdMinRx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMinRx(self):
    self.__bfdMinRx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_bfdMinTx(self):
    """
    Getter method for bfdMinTx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdMinTx (uint32)

    YANG Description: Set the minimum interval at which BFD packets are sent. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    return self.__bfdMinTx
      
  def _set_bfdMinTx(self, v, load=False):
    """
    Setter method for bfdMinTx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdMinTx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMinTx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMinTx() directly.

    YANG Description: Set the minimum interval at which BFD packets are sent. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMinTx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bfdMinTx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMinTx(self):
    self.__bfdMinTx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_bfdMultiplierNumber(self):
    """
    Getter method for bfdMultiplierNumber, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdMultiplierNumber (uint32)

    YANG Description: Set the detection multiplier of a BFD session. The default value is 3.
    """
    return self.__bfdMultiplierNumber
      
  def _set_bfdMultiplierNumber(self, v, load=False):
    """
    Setter method for bfdMultiplierNumber, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdMultiplierNumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMultiplierNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMultiplierNumber() directly.

    YANG Description: Set the detection multiplier of a BFD session. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultiplierNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMultiplierNumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultiplierNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bfdMultiplierNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMultiplierNumber(self):
    self.__bfdMultiplierNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultiplierNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_tosExpValue(self):
    """
    Getter method for tosExpValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/tosExpValue (uint8)

    YANG Description: Set the priority of BFD packets. The default value is 7.
    """
    return self.__tosExpValue
      
  def _set_tosExpValue(self, v, load=False):
    """
    Setter method for tosExpValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/tosExpValue (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tosExpValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tosExpValue() directly.

    YANG Description: Set the priority of BFD packets. The default value is 7.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tosExpValue must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__tosExpValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tosExpValue(self):
    self.__tosExpValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_frrBindingFlag(self):
    """
    Getter method for frrBindingFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/frrBindingFlag (boolean)

    YANG Description: Bind the BFD status to the link status of an interface.
    """
    return self.__frrBindingFlag
      
  def _set_frrBindingFlag(self, v, load=False):
    """
    Setter method for frrBindingFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/frrBindingFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frrBindingFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frrBindingFlag() directly.

    YANG Description: Bind the BFD status to the link status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frrBindingFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__frrBindingFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frrBindingFlag(self):
    self.__frrBindingFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1FrrBlock(self):
    """
    Getter method for level1FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1FrrBlock (boolean)

    YANG Description: Prevent an interface from participating Level-1 LFA Backup Interface calculation in a IPv6 base topology.
    """
    return self.__level1FrrBlock
      
  def _set_level1FrrBlock(self, v, load=False):
    """
    Setter method for level1FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1FrrBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1FrrBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1FrrBlock() directly.

    YANG Description: Prevent an interface from participating Level-1 LFA Backup Interface calculation in a IPv6 base topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1FrrBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1FrrBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1FrrBlock(self):
    self.__level1FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2FrrBlock(self):
    """
    Getter method for level2FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2FrrBlock (boolean)

    YANG Description: Prevent an interface from participating Level-2 LFA Backup Interface calculation in a topology.
    """
    return self.__level2FrrBlock
      
  def _set_level2FrrBlock(self, v, load=False):
    """
    Setter method for level2FrrBlock, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2FrrBlock (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2FrrBlock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2FrrBlock() directly.

    YANG Description: Prevent an interface from participating Level-2 LFA Backup Interface calculation in a topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2FrrBlock must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2FrrBlock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2FrrBlock(self):
    self.__level2FrrBlock = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2FrrBlock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1RemoteLFA(self):
    """
    Getter method for level1RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1RemoteLFA (boolean)

    YANG Description: Disable Level-1 RLFA of the Interface.
    """
    return self.__level1RemoteLFA
      
  def _set_level1RemoteLFA(self, v, load=False):
    """
    Setter method for level1RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level1RemoteLFA (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1RemoteLFA is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1RemoteLFA() directly.

    YANG Description: Disable Level-1 RLFA of the Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1RemoteLFA must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1RemoteLFA = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1RemoteLFA(self):
    self.__level1RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2RemoteLFA(self):
    """
    Getter method for level2RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2RemoteLFA (boolean)

    YANG Description: Disable Level-2 RLFA of the Interface.
    """
    return self.__level2RemoteLFA
      
  def _set_level2RemoteLFA(self, v, load=False):
    """
    Setter method for level2RemoteLFA, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/level2RemoteLFA (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2RemoteLFA is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2RemoteLFA() directly.

    YANG Description: Disable Level-2 RLFA of the Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2RemoteLFA must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2RemoteLFA = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2RemoteLFA(self):
    self.__level2RemoteLFA = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2RemoteLFA", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_l1TilfaDisable(self):
    """
    Getter method for l1TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l1TilfaDisable (boolean)

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-1 LFA calculation in the IPv4 MT.
    """
    return self.__l1TilfaDisable
      
  def _set_l1TilfaDisable(self, v, load=False):
    """
    Setter method for l1TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l1TilfaDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1TilfaDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1TilfaDisable() directly.

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-1 LFA calculation in the IPv4 MT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1TilfaDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__l1TilfaDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1TilfaDisable(self):
    self.__l1TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_l2TilfaDisable(self):
    """
    Getter method for l2TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l2TilfaDisable (boolean)

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-2 LFA calculation in the IPv4 MT.
    """
    return self.__l2TilfaDisable
      
  def _set_l2TilfaDisable(self, v, load=False):
    """
    Setter method for l2TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l2TilfaDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2TilfaDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2TilfaDisable() directly.

    YANG Description: Whether an interface is prevented from being calculated as a valid backup interface during Level-2 LFA calculation in the IPv4 MT.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2TilfaDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__l2TilfaDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2TilfaDisable(self):
    self.__l2TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)


  def _get_l1Ipv6TilfaDisable(self):
    """
    Getter method for l1Ipv6TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l1Ipv6TilfaDisable (boolean)

    YANG Description: Level-1 IPv6 TI-LFA disable or not.
    """
    return self.__l1Ipv6TilfaDisable
      
  def _set_l1Ipv6TilfaDisable(self, v, load=False):
    """
    Setter method for l1Ipv6TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l1Ipv6TilfaDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l1Ipv6TilfaDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l1Ipv6TilfaDisable() directly.

    YANG Description: Level-1 IPv6 TI-LFA disable or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l1Ipv6TilfaDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__l1Ipv6TilfaDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l1Ipv6TilfaDisable(self):
    self.__l1Ipv6TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l1Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_l2Ipv6TilfaDisable(self):
    """
    Getter method for l2Ipv6TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l2Ipv6TilfaDisable (boolean)

    YANG Description: Level-2 IPv6 TI-LFA disable or not.
    """
    return self.__l2Ipv6TilfaDisable
      
  def _set_l2Ipv6TilfaDisable(self, v, load=False):
    """
    Setter method for l2Ipv6TilfaDisable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/l2Ipv6TilfaDisable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2Ipv6TilfaDisable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2Ipv6TilfaDisable() directly.

    YANG Description: Level-2 IPv6 TI-LFA disable or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2Ipv6TilfaDisable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__l2Ipv6TilfaDisable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2Ipv6TilfaDisable(self):
    self.__l2Ipv6TilfaDisable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2Ipv6TilfaDisable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isPrefixSid(self):
    """
    Getter method for isPrefixSid, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid (container)

    YANG Description: Information of prefix sid.
    """
    return self.__isPrefixSid
      
  def _set_isPrefixSid(self, v, load=False):
    """
    Setter method for isPrefixSid, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/isPrefixSid (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPrefixSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPrefixSid() directly.

    YANG Description: Information of prefix sid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isPrefixSid_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt_isPrefixSid, is_container='container', yang_name="isPrefixSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPrefixSid must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isPrefixSid_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt_isPrefixSid, is_container='container', yang_name="isPrefixSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isPrefixSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPrefixSid(self):
    self.__isPrefixSid = YANGDynClass(base=yc_isPrefixSid_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt_isPrefixSid, is_container='container', yang_name="isPrefixSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_bfdBitErrCfg(self):
    """
    Getter method for bfdBitErrCfg, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdBitErrCfg (string)

    YANG Description: Enable or block BFD bit-error on an interface. By default, BFD bit-error is no_set.
    """
    return self.__bfdBitErrCfg
      
  def _set_bfdBitErrCfg(self, v, load=False):
    """
    Setter method for bfdBitErrCfg, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/bfdBitErrCfg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdBitErrCfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdBitErrCfg() directly.

    YANG Description: Enable or block BFD bit-error on an interface. By default, BFD bit-error is no_set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="bfdBitErrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdBitErrCfg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="bfdBitErrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__bfdBitErrCfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdBitErrCfg(self):
    self.__bfdBitErrCfg = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="bfdBitErrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_incrCost(self):
    """
    Getter method for incrCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/incrCost (uint32)

    YANG Description: Set the cost to be added if the link quality is low. The value is an integer ranging from 1 to 16777214. 
    """
    return self.__incrCost
      
  def _set_incrCost(self, v, load=False):
    """
    Setter method for incrCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt/incrCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_incrCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_incrCost() directly.

    YANG Description: Set the cost to be added if the link quality is low. The value is an integer ranging from 1 to 16777214. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """incrCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__incrCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_incrCost(self):
    self.__incrCost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="incrCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  ifName = __builtin__.property(_get_ifName, _set_ifName)
  level1Cost = __builtin__.property(_get_level1Cost, _set_level1Cost)
  level2Cost = __builtin__.property(_get_level2Cost, _set_level2Cost)
  level1Tag = __builtin__.property(_get_level1Tag, _set_level1Tag)
  level2Tag = __builtin__.property(_get_level2Tag, _set_level2Tag)
  suppressReach = __builtin__.property(_get_suppressReach, _set_suppressReach)
  bfdEnable = __builtin__.property(_get_bfdEnable, _set_bfdEnable)
  bfdStaticEn = __builtin__.property(_get_bfdStaticEn, _set_bfdStaticEn)
  bfdBlockEn = __builtin__.property(_get_bfdBlockEn, _set_bfdBlockEn)
  bfdMinRx = __builtin__.property(_get_bfdMinRx, _set_bfdMinRx)
  bfdMinTx = __builtin__.property(_get_bfdMinTx, _set_bfdMinTx)
  bfdMultiplierNumber = __builtin__.property(_get_bfdMultiplierNumber, _set_bfdMultiplierNumber)
  tosExpValue = __builtin__.property(_get_tosExpValue, _set_tosExpValue)
  frrBindingFlag = __builtin__.property(_get_frrBindingFlag, _set_frrBindingFlag)
  level1FrrBlock = __builtin__.property(_get_level1FrrBlock, _set_level1FrrBlock)
  level2FrrBlock = __builtin__.property(_get_level2FrrBlock, _set_level2FrrBlock)
  level1RemoteLFA = __builtin__.property(_get_level1RemoteLFA, _set_level1RemoteLFA)
  level2RemoteLFA = __builtin__.property(_get_level2RemoteLFA, _set_level2RemoteLFA)
  l1TilfaDisable = __builtin__.property(_get_l1TilfaDisable)
  l2TilfaDisable = __builtin__.property(_get_l2TilfaDisable)
  l1Ipv6TilfaDisable = __builtin__.property(_get_l1Ipv6TilfaDisable, _set_l1Ipv6TilfaDisable)
  l2Ipv6TilfaDisable = __builtin__.property(_get_l2Ipv6TilfaDisable, _set_l2Ipv6TilfaDisable)
  isPrefixSid = __builtin__.property(_get_isPrefixSid, _set_isPrefixSid) # type: yc_isPrefixSid_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt_isPrefixSid
  bfdBitErrCfg = __builtin__.property(_get_bfdBitErrCfg, _set_bfdBitErrCfg)
  incrCost = __builtin__.property(_get_incrCost, _set_incrCost)


  _pyangbind_elements = OrderedDict([('ifName', ifName), ('level1Cost', level1Cost), ('level2Cost', level2Cost), ('level1Tag', level1Tag), ('level2Tag', level2Tag), ('suppressReach', suppressReach), ('bfdEnable', bfdEnable), ('bfdStaticEn', bfdStaticEn), ('bfdBlockEn', bfdBlockEn), ('bfdMinRx', bfdMinRx), ('bfdMinTx', bfdMinTx), ('bfdMultiplierNumber', bfdMultiplierNumber), ('tosExpValue', tosExpValue), ('frrBindingFlag', frrBindingFlag), ('level1FrrBlock', level1FrrBlock), ('level2FrrBlock', level2FrrBlock), ('level1RemoteLFA', level1RemoteLFA), ('level2RemoteLFA', level2RemoteLFA), ('l1TilfaDisable', l1TilfaDisable), ('l2TilfaDisable', l2TilfaDisable), ('l1Ipv6TilfaDisable', l1Ipv6TilfaDisable), ('l2Ipv6TilfaDisable', l2Ipv6TilfaDisable), ('isPrefixSid', isPrefixSid), ('bfdBitErrCfg', bfdBitErrCfg), ('incrCost', incrCost), ])


class yc_isCircMts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface multi-topology list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isCircMt',)

  _yang_name = 'isCircMts'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isCircMt = YANGDynClass(base=YANGListType("ifName",yc_isCircMt_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt, yang_name="isCircMt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircMt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isCircMts']

  def _get_isCircMt(self):
    """
    Getter method for isCircMt, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt (list)

    YANG Description: Set parameters for IS-IS multi-topology on an interface.
    """
    return self.__isCircMt
      
  def _set_isCircMt(self, v, load=False):
    """
    Setter method for isCircMt, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts/isCircMt (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isCircMt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isCircMt() directly.

    YANG Description: Set parameters for IS-IS multi-topology on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ifName",yc_isCircMt_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt, yang_name="isCircMt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircMt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isCircMt must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ifName",yc_isCircMt_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt, yang_name="isCircMt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircMt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isCircMt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isCircMt(self):
    self.__isCircMt = YANGDynClass(base=YANGListType("ifName",yc_isCircMt_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt, yang_name="isCircMt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isCircMt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isCircMt = __builtin__.property(_get_isCircMt, _set_isCircMt) # type: yc_isCircMt_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts_isCircMt


  _pyangbind_elements = OrderedDict([('isCircMt', isCircMt), ])


class yc_isDispRouteStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss_isDispRouteStatistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routing statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__v4LearntRtNum','__v6LearntRtNum','__v4CriticalRtNum','__v4HighRtNum','__v4MediumRtNum','__v4LowRtNum','__v6CriticalRtNum','__v6HighRtNum','__v6MediumRtNum','__v6LowRtNum','__v4ForwardRtNum','__v6ForwardRtNum','__v4RtAdded2RM','__v4RtUnAdded2RM','__v6RtAdded2RM','__v6RtUnAdded2RM',)

  _yang_name = 'isDispRouteStatistics'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__v4LearntRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6LearntRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4CriticalRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4HighRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4MediumRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4LowRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6CriticalRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6HighRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6MediumRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6LowRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4ForwardRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6ForwardRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4RtAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v4RtUnAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6RtAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__v6RtUnAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispRouteStatisticss', 'isDispRouteStatistics']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/levelType (string)

    YANG Description: Level type, level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type, level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_v4LearntRtNum(self):
    """
    Getter method for v4LearntRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4LearntRtNum (uint32)

    YANG Description: Number of learned IPv4 routes.
    """
    return self.__v4LearntRtNum
      
  def _set_v4LearntRtNum(self, v, load=False):
    """
    Setter method for v4LearntRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4LearntRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4LearntRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4LearntRtNum() directly.

    YANG Description: Number of learned IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4LearntRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4LearntRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4LearntRtNum(self):
    self.__v4LearntRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6LearntRtNum(self):
    """
    Getter method for v6LearntRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6LearntRtNum (uint32)

    YANG Description: Number of learned IPv6 routes.
    """
    return self.__v6LearntRtNum
      
  def _set_v6LearntRtNum(self, v, load=False):
    """
    Setter method for v6LearntRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6LearntRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6LearntRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6LearntRtNum() directly.

    YANG Description: Number of learned IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6LearntRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6LearntRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6LearntRtNum(self):
    self.__v6LearntRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LearntRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4CriticalRtNum(self):
    """
    Getter method for v4CriticalRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4CriticalRtNum (uint32)

    YANG Description: Number of IPv4 routes with priority critical.
    """
    return self.__v4CriticalRtNum
      
  def _set_v4CriticalRtNum(self, v, load=False):
    """
    Setter method for v4CriticalRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4CriticalRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4CriticalRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4CriticalRtNum() directly.

    YANG Description: Number of IPv4 routes with priority critical.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4CriticalRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4CriticalRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4CriticalRtNum(self):
    self.__v4CriticalRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4HighRtNum(self):
    """
    Getter method for v4HighRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4HighRtNum (uint32)

    YANG Description: Number of IPv4 routes with priority high.
    """
    return self.__v4HighRtNum
      
  def _set_v4HighRtNum(self, v, load=False):
    """
    Setter method for v4HighRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4HighRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4HighRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4HighRtNum() directly.

    YANG Description: Number of IPv4 routes with priority high.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4HighRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4HighRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4HighRtNum(self):
    self.__v4HighRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4MediumRtNum(self):
    """
    Getter method for v4MediumRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4MediumRtNum (uint32)

    YANG Description: Number of IPv4 routes with priority medium.
    """
    return self.__v4MediumRtNum
      
  def _set_v4MediumRtNum(self, v, load=False):
    """
    Setter method for v4MediumRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4MediumRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4MediumRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4MediumRtNum() directly.

    YANG Description: Number of IPv4 routes with priority medium.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4MediumRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4MediumRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4MediumRtNum(self):
    self.__v4MediumRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4LowRtNum(self):
    """
    Getter method for v4LowRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4LowRtNum (uint32)

    YANG Description: Number of IPv4 routes with priority low.
    """
    return self.__v4LowRtNum
      
  def _set_v4LowRtNum(self, v, load=False):
    """
    Setter method for v4LowRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4LowRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4LowRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4LowRtNum() directly.

    YANG Description: Number of IPv4 routes with priority low.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4LowRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4LowRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4LowRtNum(self):
    self.__v4LowRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6CriticalRtNum(self):
    """
    Getter method for v6CriticalRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6CriticalRtNum (uint32)

    YANG Description: Number of IPv6 routes with priority critical.
    """
    return self.__v6CriticalRtNum
      
  def _set_v6CriticalRtNum(self, v, load=False):
    """
    Setter method for v6CriticalRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6CriticalRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6CriticalRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6CriticalRtNum() directly.

    YANG Description: Number of IPv6 routes with priority critical.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6CriticalRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6CriticalRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6CriticalRtNum(self):
    self.__v6CriticalRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6CriticalRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6HighRtNum(self):
    """
    Getter method for v6HighRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6HighRtNum (uint32)

    YANG Description: Number of IPv4 routes with priority high.
    """
    return self.__v6HighRtNum
      
  def _set_v6HighRtNum(self, v, load=False):
    """
    Setter method for v6HighRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6HighRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6HighRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6HighRtNum() directly.

    YANG Description: Number of IPv4 routes with priority high.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6HighRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6HighRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6HighRtNum(self):
    self.__v6HighRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6HighRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6MediumRtNum(self):
    """
    Getter method for v6MediumRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6MediumRtNum (uint32)

    YANG Description: Number of IPv6 routes with priority medium.
    """
    return self.__v6MediumRtNum
      
  def _set_v6MediumRtNum(self, v, load=False):
    """
    Setter method for v6MediumRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6MediumRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6MediumRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6MediumRtNum() directly.

    YANG Description: Number of IPv6 routes with priority medium.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6MediumRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6MediumRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6MediumRtNum(self):
    self.__v6MediumRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6MediumRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6LowRtNum(self):
    """
    Getter method for v6LowRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6LowRtNum (uint32)

    YANG Description: Number of IPv6 routes with priority low.
    """
    return self.__v6LowRtNum
      
  def _set_v6LowRtNum(self, v, load=False):
    """
    Setter method for v6LowRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6LowRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6LowRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6LowRtNum() directly.

    YANG Description: Number of IPv6 routes with priority low.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6LowRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6LowRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6LowRtNum(self):
    self.__v6LowRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6LowRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4ForwardRtNum(self):
    """
    Getter method for v4ForwardRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4ForwardRtNum (uint32)

    YANG Description: Number of IPv4 routes.
    """
    return self.__v4ForwardRtNum
      
  def _set_v4ForwardRtNum(self, v, load=False):
    """
    Setter method for v4ForwardRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4ForwardRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4ForwardRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4ForwardRtNum() directly.

    YANG Description: Number of IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4ForwardRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4ForwardRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4ForwardRtNum(self):
    self.__v4ForwardRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6ForwardRtNum(self):
    """
    Getter method for v6ForwardRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6ForwardRtNum (uint32)

    YANG Description: Number of IPv6 routes.
    """
    return self.__v6ForwardRtNum
      
  def _set_v6ForwardRtNum(self, v, load=False):
    """
    Setter method for v6ForwardRtNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6ForwardRtNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6ForwardRtNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6ForwardRtNum() directly.

    YANG Description: Number of IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6ForwardRtNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6ForwardRtNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6ForwardRtNum(self):
    self.__v6ForwardRtNum = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6ForwardRtNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4RtAdded2RM(self):
    """
    Getter method for v4RtAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4RtAdded2RM (uint32)

    YANG Description: Number of IPv4 routes added to the routing table.
    """
    return self.__v4RtAdded2RM
      
  def _set_v4RtAdded2RM(self, v, load=False):
    """
    Setter method for v4RtAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4RtAdded2RM (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4RtAdded2RM is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4RtAdded2RM() directly.

    YANG Description: Number of IPv4 routes added to the routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4RtAdded2RM must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4RtAdded2RM = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4RtAdded2RM(self):
    self.__v4RtAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v4RtUnAdded2RM(self):
    """
    Getter method for v4RtUnAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4RtUnAdded2RM (uint32)

    YANG Description: Number of IPv4 Routes that are not added to the routing table.
    """
    return self.__v4RtUnAdded2RM
      
  def _set_v4RtUnAdded2RM(self, v, load=False):
    """
    Setter method for v4RtUnAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v4RtUnAdded2RM (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v4RtUnAdded2RM is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v4RtUnAdded2RM() directly.

    YANG Description: Number of IPv4 Routes that are not added to the routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v4RtUnAdded2RM must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v4RtUnAdded2RM = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v4RtUnAdded2RM(self):
    self.__v4RtUnAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v4RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6RtAdded2RM(self):
    """
    Getter method for v6RtAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6RtAdded2RM (uint32)

    YANG Description: Number of IPv6 routes added to the routing table.
    """
    return self.__v6RtAdded2RM
      
  def _set_v6RtAdded2RM(self, v, load=False):
    """
    Setter method for v6RtAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6RtAdded2RM (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6RtAdded2RM is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6RtAdded2RM() directly.

    YANG Description: Number of IPv6 routes added to the routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6RtAdded2RM must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6RtAdded2RM = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6RtAdded2RM(self):
    self.__v6RtAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_v6RtUnAdded2RM(self):
    """
    Getter method for v6RtUnAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6RtUnAdded2RM (uint32)

    YANG Description: Number of IPv6 Routes that are not added to the routing table.
    """
    return self.__v6RtUnAdded2RM
      
  def _set_v6RtUnAdded2RM(self, v, load=False):
    """
    Setter method for v6RtUnAdded2RM, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics/v6RtUnAdded2RM (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_v6RtUnAdded2RM is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_v6RtUnAdded2RM() directly.

    YANG Description: Number of IPv6 Routes that are not added to the routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """v6RtUnAdded2RM must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__v6RtUnAdded2RM = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_v6RtUnAdded2RM(self):
    self.__v6RtUnAdded2RM = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="v6RtUnAdded2RM", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  v4LearntRtNum = __builtin__.property(_get_v4LearntRtNum)
  v6LearntRtNum = __builtin__.property(_get_v6LearntRtNum)
  v4CriticalRtNum = __builtin__.property(_get_v4CriticalRtNum)
  v4HighRtNum = __builtin__.property(_get_v4HighRtNum)
  v4MediumRtNum = __builtin__.property(_get_v4MediumRtNum)
  v4LowRtNum = __builtin__.property(_get_v4LowRtNum)
  v6CriticalRtNum = __builtin__.property(_get_v6CriticalRtNum)
  v6HighRtNum = __builtin__.property(_get_v6HighRtNum)
  v6MediumRtNum = __builtin__.property(_get_v6MediumRtNum)
  v6LowRtNum = __builtin__.property(_get_v6LowRtNum)
  v4ForwardRtNum = __builtin__.property(_get_v4ForwardRtNum)
  v6ForwardRtNum = __builtin__.property(_get_v6ForwardRtNum)
  v4RtAdded2RM = __builtin__.property(_get_v4RtAdded2RM)
  v4RtUnAdded2RM = __builtin__.property(_get_v4RtUnAdded2RM)
  v6RtAdded2RM = __builtin__.property(_get_v6RtAdded2RM)
  v6RtUnAdded2RM = __builtin__.property(_get_v6RtUnAdded2RM)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('v4LearntRtNum', v4LearntRtNum), ('v6LearntRtNum', v6LearntRtNum), ('v4CriticalRtNum', v4CriticalRtNum), ('v4HighRtNum', v4HighRtNum), ('v4MediumRtNum', v4MediumRtNum), ('v4LowRtNum', v4LowRtNum), ('v6CriticalRtNum', v6CriticalRtNum), ('v6HighRtNum', v6HighRtNum), ('v6MediumRtNum', v6MediumRtNum), ('v6LowRtNum', v6LowRtNum), ('v4ForwardRtNum', v4ForwardRtNum), ('v6ForwardRtNum', v6ForwardRtNum), ('v4RtAdded2RM', v4RtAdded2RM), ('v4RtUnAdded2RM', v4RtUnAdded2RM), ('v6RtAdded2RM', v6RtAdded2RM), ('v6RtUnAdded2RM', v6RtUnAdded2RM), ])


class yc_isDispRouteStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route statistics information list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispRouteStatistics',)

  _yang_name = 'isDispRouteStatisticss'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispRouteStatistics = YANGDynClass(base=YANGListType("levelType",yc_isDispRouteStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss_isDispRouteStatistics, yang_name="isDispRouteStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isDispRouteStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispRouteStatisticss']

  def _get_isDispRouteStatistics(self):
    """
    Getter method for isDispRouteStatistics, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics (list)

    YANG Description: Routing statistics.
    """
    return self.__isDispRouteStatistics
      
  def _set_isDispRouteStatistics(self, v, load=False):
    """
    Setter method for isDispRouteStatistics, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss/isDispRouteStatistics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispRouteStatistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispRouteStatistics() directly.

    YANG Description: Routing statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType",yc_isDispRouteStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss_isDispRouteStatistics, yang_name="isDispRouteStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isDispRouteStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispRouteStatistics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType",yc_isDispRouteStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss_isDispRouteStatistics, yang_name="isDispRouteStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isDispRouteStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispRouteStatistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispRouteStatistics(self):
    self.__isDispRouteStatistics = YANGDynClass(base=YANGListType("levelType",yc_isDispRouteStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss_isDispRouteStatistics, yang_name="isDispRouteStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType', extensions=None), is_container='list', yang_name="isDispRouteStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispRouteStatistics = __builtin__.property(_get_isDispRouteStatistics) # type: yc_isDispRouteStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss_isDispRouteStatistics


  _pyangbind_elements = OrderedDict([('isDispRouteStatistics', isDispRouteStatistics), ])


class yc_isDispV4Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes_isDispV4Route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IS-IS routing information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__ipv4Address','__ipv4Mask','__nextHop','__intCost','__extCost','__exitInterfaceName','__flags','__priority','__tag',)

  _yang_name = 'isDispV4Route'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__extCost = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__exitInterfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV4Routes', 'isDispV4Route']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/levelType (string)

    YANG Description: Level type, which can be level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type, which can be level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4Address(self):
    """
    Getter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/ipv4Address (string)

    YANG Description: IPv4 address prefix.
    """
    return self.__ipv4Address
      
  def _set_ipv4Address(self, v, load=False):
    """
    Setter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/ipv4Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Address() directly.

    YANG Description: IPv4 address prefix.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv4Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Address(self):
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4Mask(self):
    """
    Getter method for ipv4Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/ipv4Mask (uint32)

    YANG Description: IPv4 address mask.
    """
    return self.__ipv4Mask
      
  def _set_ipv4Mask(self, v, load=False):
    """
    Setter method for ipv4Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/ipv4Mask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Mask() directly.

    YANG Description: IPv4 address mask.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Mask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv4Mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Mask(self):
    self.__ipv4Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_nextHop(self):
    """
    Getter method for nextHop, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/nextHop (string)

    YANG Description: Next hop of a route.
    """
    return self.__nextHop
      
  def _set_nextHop(self, v, load=False):
    """
    Setter method for nextHop, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/nextHop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHop() directly.

    YANG Description: Next hop of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__nextHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHop(self):
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_intCost(self):
    """
    Getter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/intCost (uint32)

    YANG Description: Internal cost value of IPv4 routes.
    """
    return self.__intCost
      
  def _set_intCost(self, v, load=False):
    """
    Setter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/intCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intCost() directly.

    YANG Description: Internal cost value of IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__intCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intCost(self):
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_extCost(self):
    """
    Getter method for extCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/extCost (string)

    YANG Description: External cost value of IPv4 routes.
    """
    return self.__extCost
      
  def _set_extCost(self, v, load=False):
    """
    Setter method for extCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/extCost (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extCost() directly.

    YANG Description: External cost value of IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extCost must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__extCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extCost(self):
    self.__extCost = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_exitInterfaceName(self):
    """
    Getter method for exitInterfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/exitInterfaceName (string)

    YANG Description: Outbound interface name of a route.
    """
    return self.__exitInterfaceName
      
  def _set_exitInterfaceName(self, v, load=False):
    """
    Setter method for exitInterfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/exitInterfaceName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exitInterfaceName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exitInterfaceName() directly.

    YANG Description: Outbound interface name of a route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exitInterfaceName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__exitInterfaceName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exitInterfaceName(self):
    self.__exitInterfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_flags(self):
    """
    Getter method for flags, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/flags (string)

    YANG Description: Route Flags:
D: Direct
A: Added to URT
L: Advertised in LSPs
S: IGP Shortcut
U: Up/Down Bit Set
    """
    return self.__flags
      
  def _set_flags(self, v, load=False):
    """
    Setter method for flags, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/flags (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags() directly.

    YANG Description: Route Flags:
D: Direct
A: Added to URT
L: Advertised in LSPs
S: IGP Shortcut
U: Up/Down Bit Set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags(self):
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/priority (string)

    YANG Description: Route priority: Critical, High, Medium, or Low.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/priority (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Route priority: Critical, High, Medium, or Low.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/tag (string)

    YANG Description: Tag of a route.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Tag of a route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  ipv4Address = __builtin__.property(_get_ipv4Address)
  ipv4Mask = __builtin__.property(_get_ipv4Mask)
  nextHop = __builtin__.property(_get_nextHop)
  intCost = __builtin__.property(_get_intCost)
  extCost = __builtin__.property(_get_extCost)
  exitInterfaceName = __builtin__.property(_get_exitInterfaceName)
  flags = __builtin__.property(_get_flags)
  priority = __builtin__.property(_get_priority)
  tag = __builtin__.property(_get_tag)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('ipv4Address', ipv4Address), ('ipv4Mask', ipv4Mask), ('nextHop', nextHop), ('intCost', intCost), ('extCost', extCost), ('exitInterfaceName', exitInterfaceName), ('flags', flags), ('priority', priority), ('tag', tag), ])


class yc_isDispV4Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routing information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispV4Route',)

  _yang_name = 'isDispV4Routes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispV4Route = YANGDynClass(base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispV4Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes_isDispV4Route, yang_name="isDispV4Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispV4Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV4Routes']

  def _get_isDispV4Route(self):
    """
    Getter method for isDispV4Route, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route (list)

    YANG Description: IS-IS routing information.
    """
    return self.__isDispV4Route
      
  def _set_isDispV4Route(self, v, load=False):
    """
    Setter method for isDispV4Route, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes/isDispV4Route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV4Route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV4Route() directly.

    YANG Description: IS-IS routing information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispV4Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes_isDispV4Route, yang_name="isDispV4Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispV4Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV4Route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispV4Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes_isDispV4Route, yang_name="isDispV4Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispV4Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispV4Route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV4Route(self):
    self.__isDispV4Route = YANGDynClass(base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispV4Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes_isDispV4Route, yang_name="isDispV4Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispV4Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispV4Route = __builtin__.property(_get_isDispV4Route) # type: yc_isDispV4Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes_isDispV4Route


  _pyangbind_elements = OrderedDict([('isDispV4Route', isDispV4Route), ])


class yc_isDispV6Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes_isDispV6Route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about IPv6 routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__ipv6Address','__ipv6Mask','__nextHop','__exitInterfaceName','__costValue','__flags','__priority','__tag',)

  _yang_name = 'isDispV6Route'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv6Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv6Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__exitInterfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__costValue = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="costValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV6Routes', 'isDispV6Route']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/levelType (string)

    YANG Description: Level type: level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv6Address(self):
    """
    Getter method for ipv6Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/ipv6Address (string)

    YANG Description: IPv6 address prefix of a route.
    """
    return self.__ipv6Address
      
  def _set_ipv6Address(self, v, load=False):
    """
    Setter method for ipv6Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/ipv6Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Address() directly.

    YANG Description: IPv6 address prefix of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv6Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Address(self):
    self.__ipv6Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv6Mask(self):
    """
    Getter method for ipv6Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/ipv6Mask (uint32)

    YANG Description: IPv6 address mask of a route.
    """
    return self.__ipv6Mask
      
  def _set_ipv6Mask(self, v, load=False):
    """
    Setter method for ipv6Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/ipv6Mask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Mask() directly.

    YANG Description: IPv6 address mask of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Mask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv6Mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Mask(self):
    self.__ipv6Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_nextHop(self):
    """
    Getter method for nextHop, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/nextHop (string)

    YANG Description: Next hop of a route.
    """
    return self.__nextHop
      
  def _set_nextHop(self, v, load=False):
    """
    Setter method for nextHop, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/nextHop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHop() directly.

    YANG Description: Next hop of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__nextHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHop(self):
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_exitInterfaceName(self):
    """
    Getter method for exitInterfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/exitInterfaceName (string)

    YANG Description: Outbound interface name of a route.
    """
    return self.__exitInterfaceName
      
  def _set_exitInterfaceName(self, v, load=False):
    """
    Setter method for exitInterfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/exitInterfaceName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exitInterfaceName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exitInterfaceName() directly.

    YANG Description: Outbound interface name of a route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exitInterfaceName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__exitInterfaceName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exitInterfaceName(self):
    self.__exitInterfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_costValue(self):
    """
    Getter method for costValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/costValue (uint32)

    YANG Description: Cost value of IPv6 routes.
    """
    return self.__costValue
      
  def _set_costValue(self, v, load=False):
    """
    Setter method for costValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/costValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_costValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_costValue() directly.

    YANG Description: Cost value of IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="costValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """costValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="costValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__costValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_costValue(self):
    self.__costValue = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="costValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_flags(self):
    """
    Getter method for flags, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/flags (string)

    YANG Description: Route type.
    """
    return self.__flags
      
  def _set_flags(self, v, load=False):
    """
    Setter method for flags, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/flags (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags() directly.

    YANG Description: Route type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags(self):
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/priority (string)

    YANG Description: Route priority: Critical, High, Medium, or Low.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/priority (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Route priority: Critical, High, Medium, or Low.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/tag (string)

    YANG Description: Tag of a route.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Tag of a route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  ipv6Address = __builtin__.property(_get_ipv6Address)
  ipv6Mask = __builtin__.property(_get_ipv6Mask)
  nextHop = __builtin__.property(_get_nextHop)
  exitInterfaceName = __builtin__.property(_get_exitInterfaceName)
  costValue = __builtin__.property(_get_costValue)
  flags = __builtin__.property(_get_flags)
  priority = __builtin__.property(_get_priority)
  tag = __builtin__.property(_get_tag)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('ipv6Address', ipv6Address), ('ipv6Mask', ipv6Mask), ('nextHop', nextHop), ('exitInterfaceName', exitInterfaceName), ('costValue', costValue), ('flags', flags), ('priority', priority), ('tag', tag), ])


class yc_isDispV6Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the information about IPv6 routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispV6Route',)

  _yang_name = 'isDispV6Routes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispV6Route = YANGDynClass(base=YANGListType("levelType ipv6Address ipv6Mask nextHop",yc_isDispV6Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes_isDispV6Route, yang_name="isDispV6Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv6Address ipv6Mask nextHop', extensions=None), is_container='list', yang_name="isDispV6Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV6Routes']

  def _get_isDispV6Route(self):
    """
    Getter method for isDispV6Route, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route (list)

    YANG Description: Information about IPv6 routes.
    """
    return self.__isDispV6Route
      
  def _set_isDispV6Route(self, v, load=False):
    """
    Setter method for isDispV6Route, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes/isDispV6Route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV6Route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV6Route() directly.

    YANG Description: Information about IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType ipv6Address ipv6Mask nextHop",yc_isDispV6Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes_isDispV6Route, yang_name="isDispV6Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv6Address ipv6Mask nextHop', extensions=None), is_container='list', yang_name="isDispV6Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV6Route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType ipv6Address ipv6Mask nextHop",yc_isDispV6Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes_isDispV6Route, yang_name="isDispV6Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv6Address ipv6Mask nextHop', extensions=None), is_container='list', yang_name="isDispV6Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispV6Route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV6Route(self):
    self.__isDispV6Route = YANGDynClass(base=YANGListType("levelType ipv6Address ipv6Mask nextHop",yc_isDispV6Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes_isDispV6Route, yang_name="isDispV6Route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv6Address ipv6Mask nextHop', extensions=None), is_container='list', yang_name="isDispV6Route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispV6Route = __builtin__.property(_get_isDispV6Route) # type: yc_isDispV6Route_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes_isDispV6Route


  _pyangbind_elements = OrderedDict([('isDispV6Route', isDispV6Route), ])


class yc_isDispV4ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes_isDispV4ImportRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the imported IPv4 routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__routeProtocolType','__ipv4Address','__ipv4Mask','__intCost','__extCost','__tag',)

  _yang_name = 'isDispV4ImportRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__routeProtocolType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__extCost = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV4ImportRoutes', 'isDispV4ImportRoute']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/levelType (string)

    YANG Description: Level type: level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_routeProtocolType(self):
    """
    Getter method for routeProtocolType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/routeProtocolType (string)

    YANG Description: Protocol type of the imported routes.(S:STATIC, D:DIRECT, O:OSPF, B:BGP, I:ISIS, U:UNR, R:RIP)
    """
    return self.__routeProtocolType
      
  def _set_routeProtocolType(self, v, load=False):
    """
    Setter method for routeProtocolType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/routeProtocolType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeProtocolType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeProtocolType() directly.

    YANG Description: Protocol type of the imported routes.(S:STATIC, D:DIRECT, O:OSPF, B:BGP, I:ISIS, U:UNR, R:RIP)
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeProtocolType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__routeProtocolType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeProtocolType(self):
    self.__routeProtocolType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4Address(self):
    """
    Getter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/ipv4Address (string)

    YANG Description: IPv4 address prefix of the imported routes.
    """
    return self.__ipv4Address
      
  def _set_ipv4Address(self, v, load=False):
    """
    Setter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/ipv4Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Address() directly.

    YANG Description: IPv4 address prefix of the imported routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv4Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Address(self):
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4Mask(self):
    """
    Getter method for ipv4Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/ipv4Mask (uint32)

    YANG Description: IPv4 mask of the imported routes.
    """
    return self.__ipv4Mask
      
  def _set_ipv4Mask(self, v, load=False):
    """
    Setter method for ipv4Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/ipv4Mask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Mask() directly.

    YANG Description: IPv4 mask of the imported routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Mask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv4Mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Mask(self):
    self.__ipv4Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_intCost(self):
    """
    Getter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/intCost (uint32)

    YANG Description: IPv4 internal cost value of the imported routes.
    """
    return self.__intCost
      
  def _set_intCost(self, v, load=False):
    """
    Setter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/intCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intCost() directly.

    YANG Description: IPv4 internal cost value of the imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__intCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intCost(self):
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_extCost(self):
    """
    Getter method for extCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/extCost (string)

    YANG Description: IPv4 external cost value of the imported routes.
    """
    return self.__extCost
      
  def _set_extCost(self, v, load=False):
    """
    Setter method for extCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/extCost (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extCost() directly.

    YANG Description: IPv4 external cost value of the imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extCost must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__extCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extCost(self):
    self.__extCost = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/tag (string)

    YANG Description: Tag value of the imported routes.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Tag value of the imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  routeProtocolType = __builtin__.property(_get_routeProtocolType)
  ipv4Address = __builtin__.property(_get_ipv4Address)
  ipv4Mask = __builtin__.property(_get_ipv4Mask)
  intCost = __builtin__.property(_get_intCost)
  extCost = __builtin__.property(_get_extCost)
  tag = __builtin__.property(_get_tag)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('routeProtocolType', routeProtocolType), ('ipv4Address', ipv4Address), ('ipv4Mask', ipv4Mask), ('intCost', intCost), ('extCost', extCost), ('tag', tag), ])


class yc_isDispV4ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the information about the imported IPv4 routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispV4ImportRoute',)

  _yang_name = 'isDispV4ImportRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispV4ImportRoute = YANGDynClass(base=YANGListType("levelType routeProtocolType ipv4Address ipv4Mask",yc_isDispV4ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes_isDispV4ImportRoute, yang_name="isDispV4ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv4Address ipv4Mask', extensions=None), is_container='list', yang_name="isDispV4ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV4ImportRoutes']

  def _get_isDispV4ImportRoute(self):
    """
    Getter method for isDispV4ImportRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute (list)

    YANG Description: Information about the imported IPv4 routes.
    """
    return self.__isDispV4ImportRoute
      
  def _set_isDispV4ImportRoute(self, v, load=False):
    """
    Setter method for isDispV4ImportRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes/isDispV4ImportRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV4ImportRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV4ImportRoute() directly.

    YANG Description: Information about the imported IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType routeProtocolType ipv4Address ipv4Mask",yc_isDispV4ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes_isDispV4ImportRoute, yang_name="isDispV4ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv4Address ipv4Mask', extensions=None), is_container='list', yang_name="isDispV4ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV4ImportRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType routeProtocolType ipv4Address ipv4Mask",yc_isDispV4ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes_isDispV4ImportRoute, yang_name="isDispV4ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv4Address ipv4Mask', extensions=None), is_container='list', yang_name="isDispV4ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispV4ImportRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV4ImportRoute(self):
    self.__isDispV4ImportRoute = YANGDynClass(base=YANGListType("levelType routeProtocolType ipv4Address ipv4Mask",yc_isDispV4ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes_isDispV4ImportRoute, yang_name="isDispV4ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv4Address ipv4Mask', extensions=None), is_container='list', yang_name="isDispV4ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispV4ImportRoute = __builtin__.property(_get_isDispV4ImportRoute) # type: yc_isDispV4ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes_isDispV4ImportRoute


  _pyangbind_elements = OrderedDict([('isDispV4ImportRoute', isDispV4ImportRoute), ])


class yc_isDispV6ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes_isDispV6ImportRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the imported IPv6 routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__routeProtocolType','__ipv6Address','__ipv6Mask','__intCost','__tag',)

  _yang_name = 'isDispV6ImportRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__routeProtocolType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv6Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv6Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV6ImportRoutes', 'isDispV6ImportRoute']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/levelType (string)

    YANG Description: Level type: level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_routeProtocolType(self):
    """
    Getter method for routeProtocolType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/routeProtocolType (string)

    YANG Description: Protocol type of the imported routes.
    """
    return self.__routeProtocolType
      
  def _set_routeProtocolType(self, v, load=False):
    """
    Setter method for routeProtocolType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/routeProtocolType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routeProtocolType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routeProtocolType() directly.

    YANG Description: Protocol type of the imported routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routeProtocolType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__routeProtocolType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routeProtocolType(self):
    self.__routeProtocolType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="routeProtocolType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv6Address(self):
    """
    Getter method for ipv6Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/ipv6Address (string)

    YANG Description: IPv6 address prefix of the imported routes.
    """
    return self.__ipv6Address
      
  def _set_ipv6Address(self, v, load=False):
    """
    Setter method for ipv6Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/ipv6Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Address() directly.

    YANG Description: IPv6 address prefix of the imported routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv6Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Address(self):
    self.__ipv6Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv6Mask(self):
    """
    Getter method for ipv6Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/ipv6Mask (uint32)

    YANG Description: IPv6 mask of the imported routes.
    """
    return self.__ipv6Mask
      
  def _set_ipv6Mask(self, v, load=False):
    """
    Setter method for ipv6Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/ipv6Mask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6Mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6Mask() directly.

    YANG Description: IPv6 mask of the imported routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6Mask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv6Mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6Mask(self):
    self.__ipv6Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv6Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_intCost(self):
    """
    Getter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/intCost (uint32)

    YANG Description: IPv6 internal cost value of the imported routes.
    """
    return self.__intCost
      
  def _set_intCost(self, v, load=False):
    """
    Setter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/intCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intCost() directly.

    YANG Description: IPv6 internal cost value of the imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__intCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intCost(self):
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/tag (string)

    YANG Description: Tag value of the imported routes.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Tag value of the imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  routeProtocolType = __builtin__.property(_get_routeProtocolType)
  ipv6Address = __builtin__.property(_get_ipv6Address)
  ipv6Mask = __builtin__.property(_get_ipv6Mask)
  intCost = __builtin__.property(_get_intCost)
  tag = __builtin__.property(_get_tag)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('routeProtocolType', routeProtocolType), ('ipv6Address', ipv6Address), ('ipv6Mask', ipv6Mask), ('intCost', intCost), ('tag', tag), ])


class yc_isDispV6ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the information about the imported IPv6 routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispV6ImportRoute',)

  _yang_name = 'isDispV6ImportRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispV6ImportRoute = YANGDynClass(base=YANGListType("levelType routeProtocolType ipv6Address ipv6Mask",yc_isDispV6ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes_isDispV6ImportRoute, yang_name="isDispV6ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv6Address ipv6Mask', extensions=None), is_container='list', yang_name="isDispV6ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispV6ImportRoutes']

  def _get_isDispV6ImportRoute(self):
    """
    Getter method for isDispV6ImportRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute (list)

    YANG Description: Information about the imported IPv6 routes.
    """
    return self.__isDispV6ImportRoute
      
  def _set_isDispV6ImportRoute(self, v, load=False):
    """
    Setter method for isDispV6ImportRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes/isDispV6ImportRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV6ImportRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV6ImportRoute() directly.

    YANG Description: Information about the imported IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType routeProtocolType ipv6Address ipv6Mask",yc_isDispV6ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes_isDispV6ImportRoute, yang_name="isDispV6ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv6Address ipv6Mask', extensions=None), is_container='list', yang_name="isDispV6ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV6ImportRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType routeProtocolType ipv6Address ipv6Mask",yc_isDispV6ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes_isDispV6ImportRoute, yang_name="isDispV6ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv6Address ipv6Mask', extensions=None), is_container='list', yang_name="isDispV6ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispV6ImportRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV6ImportRoute(self):
    self.__isDispV6ImportRoute = YANGDynClass(base=YANGListType("levelType routeProtocolType ipv6Address ipv6Mask",yc_isDispV6ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes_isDispV6ImportRoute, yang_name="isDispV6ImportRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType routeProtocolType ipv6Address ipv6Mask', extensions=None), is_container='list', yang_name="isDispV6ImportRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispV6ImportRoute = __builtin__.property(_get_isDispV6ImportRoute) # type: yc_isDispV6ImportRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes_isDispV6ImportRoute


  _pyangbind_elements = OrderedDict([('isDispV6ImportRoute', isDispV6ImportRoute), ])


class yc_isDispMigpRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes_isDispMigpRoute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MIGP routing information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__ipv4Address','__ipv4Mask','__nextHop','__intCost','__extCost','__exitInterfaceName','__flags',)

  _yang_name = 'isDispMigpRoute'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__extCost = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__exitInterfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispMigpRoutes', 'isDispMigpRoute']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/levelType (string)

    YANG Description: Level type: level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4Address(self):
    """
    Getter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/ipv4Address (string)

    YANG Description: IPv4 address prefix of a route.
    """
    return self.__ipv4Address
      
  def _set_ipv4Address(self, v, load=False):
    """
    Setter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/ipv4Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Address() directly.

    YANG Description: IPv4 address prefix of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv4Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Address(self):
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4Mask(self):
    """
    Getter method for ipv4Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/ipv4Mask (uint32)

    YANG Description: IPv4 address mask of a route.
    """
    return self.__ipv4Mask
      
  def _set_ipv4Mask(self, v, load=False):
    """
    Setter method for ipv4Mask, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/ipv4Mask (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Mask() directly.

    YANG Description: IPv4 address mask of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Mask must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv4Mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Mask(self):
    self.__ipv4Mask = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ipv4Mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_nextHop(self):
    """
    Getter method for nextHop, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/nextHop (string)

    YANG Description: Next hop of a route.
    """
    return self.__nextHop
      
  def _set_nextHop(self, v, load=False):
    """
    Setter method for nextHop, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/nextHop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nextHop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nextHop() directly.

    YANG Description: Next hop of a route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nextHop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__nextHop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nextHop(self):
    self.__nextHop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="nextHop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_intCost(self):
    """
    Getter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/intCost (uint32)

    YANG Description: Internal cost value of IPv4 routes.
    """
    return self.__intCost
      
  def _set_intCost(self, v, load=False):
    """
    Setter method for intCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/intCost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intCost() directly.

    YANG Description: Internal cost value of IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intCost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__intCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intCost(self):
    self.__intCost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_extCost(self):
    """
    Getter method for extCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/extCost (string)

    YANG Description: External cost value of IPv4 routes.
    """
    return self.__extCost
      
  def _set_extCost(self, v, load=False):
    """
    Setter method for extCost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/extCost (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extCost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extCost() directly.

    YANG Description: External cost value of IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extCost must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__extCost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extCost(self):
    self.__extCost = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="extCost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_exitInterfaceName(self):
    """
    Getter method for exitInterfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/exitInterfaceName (string)

    YANG Description: Outbound interface name of a route.
    """
    return self.__exitInterfaceName
      
  def _set_exitInterfaceName(self, v, load=False):
    """
    Setter method for exitInterfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/exitInterfaceName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exitInterfaceName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exitInterfaceName() directly.

    YANG Description: Outbound interface name of a route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exitInterfaceName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__exitInterfaceName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exitInterfaceName(self):
    self.__exitInterfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="exitInterfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_flags(self):
    """
    Getter method for flags, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/flags (string)

    YANG Description: Route Flags:
A: Added to URT
U: Up/Down Bit Set
    """
    return self.__flags
      
  def _set_flags(self, v, load=False):
    """
    Setter method for flags, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute/flags (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags() directly.

    YANG Description: Route Flags:
A: Added to URT
U: Up/Down Bit Set
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags(self):
    self.__flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  ipv4Address = __builtin__.property(_get_ipv4Address)
  ipv4Mask = __builtin__.property(_get_ipv4Mask)
  nextHop = __builtin__.property(_get_nextHop)
  intCost = __builtin__.property(_get_intCost)
  extCost = __builtin__.property(_get_extCost)
  exitInterfaceName = __builtin__.property(_get_exitInterfaceName)
  flags = __builtin__.property(_get_flags)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('ipv4Address', ipv4Address), ('ipv4Mask', ipv4Mask), ('nextHop', nextHop), ('intCost', intCost), ('extCost', extCost), ('exitInterfaceName', exitInterfaceName), ('flags', flags), ])


class yc_isDispMigpRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of MIGP routing information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispMigpRoute',)

  _yang_name = 'isDispMigpRoutes'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispMigpRoute = YANGDynClass(base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispMigpRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes_isDispMigpRoute, yang_name="isDispMigpRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispMigpRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isDispMigpRoutes']

  def _get_isDispMigpRoute(self):
    """
    Getter method for isDispMigpRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute (list)

    YANG Description: MIGP routing information.
    """
    return self.__isDispMigpRoute
      
  def _set_isDispMigpRoute(self, v, load=False):
    """
    Setter method for isDispMigpRoute, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes/isDispMigpRoute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispMigpRoute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispMigpRoute() directly.

    YANG Description: MIGP routing information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispMigpRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes_isDispMigpRoute, yang_name="isDispMigpRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispMigpRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispMigpRoute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispMigpRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes_isDispMigpRoute, yang_name="isDispMigpRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispMigpRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispMigpRoute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispMigpRoute(self):
    self.__isDispMigpRoute = YANGDynClass(base=YANGListType("levelType ipv4Address ipv4Mask nextHop",yc_isDispMigpRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes_isDispMigpRoute, yang_name="isDispMigpRoute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType ipv4Address ipv4Mask nextHop', extensions=None), is_container='list', yang_name="isDispMigpRoute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispMigpRoute = __builtin__.property(_get_isDispMigpRoute) # type: yc_isDispMigpRoute_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes_isDispMigpRoute


  _pyangbind_elements = OrderedDict([('isDispMigpRoute', isDispMigpRoute), ])


class yc_isLinkGroupPort_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts_isLinkGroupPort(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: To set Link-group Interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifName','__linkgroupName','__linkGrouplevelType',)

  _yang_name = 'isLinkGroupPort'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__linkgroupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..32']}), is_leaf=True, yang_name="linkgroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__linkGrouplevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="linkGrouplevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isLinkGroupPorts', 'isLinkGroupPort']

  def _get_ifName(self):
    """
    Getter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort/ifName (string)

    YANG Description: Interface name.
    """
    return self.__ifName
      
  def _set_ifName(self, v, load=False):
    """
    Setter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort/ifName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifName() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ifName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifName(self):
    self.__ifName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_linkgroupName(self):
    """
    Getter method for linkgroupName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort/linkgroupName (string)

    YANG Description: To set Link-group Name
    """
    return self.__linkgroupName
      
  def _set_linkgroupName(self, v, load=False):
    """
    Setter method for linkgroupName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort/linkgroupName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linkgroupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linkgroupName() directly.

    YANG Description: To set Link-group Name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..32']}), is_leaf=True, yang_name="linkgroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linkgroupName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..32']}), is_leaf=True, yang_name="linkgroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__linkgroupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linkgroupName(self):
    self.__linkgroupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['0..32']}), is_leaf=True, yang_name="linkgroupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_linkGrouplevelType(self):
    """
    Getter method for linkGrouplevelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort/linkGrouplevelType (string)

    YANG Description: Level type. The available options are level-1 and level-2. 
    """
    return self.__linkGrouplevelType
      
  def _set_linkGrouplevelType(self, v, load=False):
    """
    Setter method for linkGrouplevelType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort/linkGrouplevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linkGrouplevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linkGrouplevelType() directly.

    YANG Description: Level type. The available options are level-1 and level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="linkGrouplevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linkGrouplevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="linkGrouplevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__linkGrouplevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linkGrouplevelType(self):
    self.__linkGrouplevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="linkGrouplevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  ifName = __builtin__.property(_get_ifName, _set_ifName)
  linkgroupName = __builtin__.property(_get_linkgroupName, _set_linkgroupName)
  linkGrouplevelType = __builtin__.property(_get_linkGrouplevelType, _set_linkGrouplevelType)


  _pyangbind_elements = OrderedDict([('ifName', ifName), ('linkgroupName', linkgroupName), ('linkGrouplevelType', linkGrouplevelType), ])


class yc_isLinkGroupPorts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Lists of Link-group Interface
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLinkGroupPort',)

  _yang_name = 'isLinkGroupPorts'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLinkGroupPort = YANGDynClass(base=YANGListType("ifName linkgroupName linkGrouplevelType",yc_isLinkGroupPort_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts_isLinkGroupPort, yang_name="isLinkGroupPort", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName linkgroupName linkGrouplevelType', extensions=None), is_container='list', yang_name="isLinkGroupPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isLinkGroupPorts']

  def _get_isLinkGroupPort(self):
    """
    Getter method for isLinkGroupPort, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort (list)

    YANG Description: To set Link-group Interface.
    """
    return self.__isLinkGroupPort
      
  def _set_isLinkGroupPort(self, v, load=False):
    """
    Setter method for isLinkGroupPort, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts/isLinkGroupPort (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLinkGroupPort is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLinkGroupPort() directly.

    YANG Description: To set Link-group Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ifName linkgroupName linkGrouplevelType",yc_isLinkGroupPort_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts_isLinkGroupPort, yang_name="isLinkGroupPort", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName linkgroupName linkGrouplevelType', extensions=None), is_container='list', yang_name="isLinkGroupPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLinkGroupPort must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ifName linkgroupName linkGrouplevelType",yc_isLinkGroupPort_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts_isLinkGroupPort, yang_name="isLinkGroupPort", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName linkgroupName linkGrouplevelType', extensions=None), is_container='list', yang_name="isLinkGroupPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isLinkGroupPort = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLinkGroupPort(self):
    self.__isLinkGroupPort = YANGDynClass(base=YANGListType("ifName linkgroupName linkGrouplevelType",yc_isLinkGroupPort_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts_isLinkGroupPort, yang_name="isLinkGroupPort", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName linkgroupName linkGrouplevelType', extensions=None), is_container='list', yang_name="isLinkGroupPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isLinkGroupPort = __builtin__.property(_get_isLinkGroupPort, _set_isLinkGroupPort) # type: yc_isLinkGroupPort_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts_isLinkGroupPort


  _pyangbind_elements = OrderedDict([('isLinkGroupPort', isLinkGroupPort), ])


class yc_isSrLspTrig_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSrLspTrig(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Run the sr-lsp-trig command.
  """
  __slots__ = ('_path_helper', '_extmethods', '__srLspTrigType','__ipPrefixName',)

  _yang_name = 'isSrLspTrig'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__srLspTrigType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="srLspTrigType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ipPrefixName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefixName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT', 'isSrLspTrig']

  def _get_srLspTrigType(self):
    """
    Getter method for srLspTrigType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig/srLspTrigType (string)

    YANG Description: Set the SR LSP trigger type.
    """
    return self.__srLspTrigType
      
  def _set_srLspTrigType(self, v, load=False):
    """
    Setter method for srLspTrigType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig/srLspTrigType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srLspTrigType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srLspTrigType() directly.

    YANG Description: Set the SR LSP trigger type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="srLspTrigType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srLspTrigType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="srLspTrigType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__srLspTrigType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srLspTrigType(self):
    self.__srLspTrigType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="srLspTrigType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ipPrefixName(self):
    """
    Getter method for ipPrefixName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig/ipPrefixName (string)

    YANG Description: Set the IP prefix name.
    """
    return self.__ipPrefixName
      
  def _set_ipPrefixName(self, v, load=False):
    """
    Setter method for ipPrefixName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig/ipPrefixName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipPrefixName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipPrefixName() directly.

    YANG Description: Set the IP prefix name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipPrefixName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipPrefixName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefixName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__ipPrefixName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipPrefixName(self):
    self.__ipPrefixName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipPrefixName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)

  srLspTrigType = __builtin__.property(_get_srLspTrigType, _set_srLspTrigType)
  ipPrefixName = __builtin__.property(_get_ipPrefixName, _set_ipPrefixName)


  _pyangbind_elements = OrderedDict([('srLspTrigType', srLspTrigType), ('ipPrefixName', ipPrefixName), ])


class yc_isSiteMT_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs/isSiteMT. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set multi-topology parameters for an IS-IS process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addressFamily','__mtId','__topologyName','__spfPriority','__maxLoadBalancing','__autoCostEnable','__autoCostEnableCompatible','__bandwidth','__level1Cost','__level2Cost','__overloadType','__overloadWaitType','__overloadNbrSysId','__overloadTimeout1','__overloadTimeout2','__overloadInterlevel','__overloadExternal','__level1TagValue','__level2TagValue','__allCircBfdOn','__frrBindingFlag','__bfdMinRx','__bfdMinTx','__bfdMultNum','__tosExpValue','__allCircBfdBitErrOn','__mtIndex','__attAdvControl','__attAvoidLearn','__applyQppb','__isNextHopWeights','__isSummaryRoutes','__isDefaultRoutes','__isImportRoutes','__isFilterImports','__isFilterExports','__isLeakRouteLevel2ToLevel1s','__isLeakRouteLevel1ToLevel2s','__isRoutePrioritys','__isPreferences','__isFrr','__isCircMts','__isDispRouteStatisticss','__isDispV4Routes','__isDispV6Routes','__isDispV4ImportRoutes','__isDispV6ImportRoutes','__isDispMigpRoutes','__isLinkGroupPorts','__isSrLspTrig',)

  _yang_name = 'isSiteMT'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addressFamily = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="addressFamily", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__mtId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="mtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__topologyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__spfPriority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="spfPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__maxLoadBalancing = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="maxLoadBalancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__autoCostEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__autoCostEnableCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__overloadType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="overloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__overloadWaitType = YANGDynClass(base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="overloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__overloadNbrSysId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="overloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__overloadTimeout1 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="overloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__overloadTimeout2 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="overloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__overloadInterlevel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__overloadExternal = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1TagValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2TagValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__allCircBfdOn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__frrBindingFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__bfdMinRx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__bfdMinTx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__bfdMultNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__tosExpValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__allCircBfdBitErrOn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdBitErrOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__mtIndex = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="mtIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__attAdvControl = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__attAvoidLearn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__applyQppb = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="applyQppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isNextHopWeights = YANGDynClass(base=yc_isNextHopWeights_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights, is_container='container', yang_name="isNextHopWeights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isSummaryRoutes = YANGDynClass(base=yc_isSummaryRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes, is_container='container', yang_name="isSummaryRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDefaultRoutes = YANGDynClass(base=yc_isDefaultRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes, is_container='container', yang_name="isDefaultRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isImportRoutes = YANGDynClass(base=yc_isImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes, is_container='container', yang_name="isImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isFilterImports = YANGDynClass(base=yc_isFilterImports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports, is_container='container', yang_name="isFilterImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isFilterExports = YANGDynClass(base=yc_isFilterExports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports, is_container='container', yang_name="isFilterExports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLeakRouteLevel2ToLevel1s = YANGDynClass(base=yc_isLeakRouteLevel2ToLevel1s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s, is_container='container', yang_name="isLeakRouteLevel2ToLevel1s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLeakRouteLevel1ToLevel2s = YANGDynClass(base=yc_isLeakRouteLevel1ToLevel2s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s, is_container='container', yang_name="isLeakRouteLevel1ToLevel2s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isRoutePrioritys = YANGDynClass(base=yc_isRoutePrioritys_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys, is_container='container', yang_name="isRoutePrioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isPreferences = YANGDynClass(base=yc_isPreferences_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences, is_container='container', yang_name="isPreferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isFrr = YANGDynClass(base=yc_isFrr_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr, is_container='container', yang_name="isFrr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isCircMts = YANGDynClass(base=yc_isCircMts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts, is_container='container', yang_name="isCircMts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispRouteStatisticss = YANGDynClass(base=yc_isDispRouteStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss, is_container='container', yang_name="isDispRouteStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispV4Routes = YANGDynClass(base=yc_isDispV4Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes, is_container='container', yang_name="isDispV4Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispV6Routes = YANGDynClass(base=yc_isDispV6Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes, is_container='container', yang_name="isDispV6Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispV4ImportRoutes = YANGDynClass(base=yc_isDispV4ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes, is_container='container', yang_name="isDispV4ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispV6ImportRoutes = YANGDynClass(base=yc_isDispV6ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes, is_container='container', yang_name="isDispV6ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispMigpRoutes = YANGDynClass(base=yc_isDispMigpRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes, is_container='container', yang_name="isDispMigpRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLinkGroupPorts = YANGDynClass(base=yc_isLinkGroupPorts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts, is_container='container', yang_name="isLinkGroupPorts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isSrLspTrig = YANGDynClass(base=yc_isSrLspTrig_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSrLspTrig, is_container='container', yang_name="isSrLspTrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs', 'isSiteMT']

  def _get_addressFamily(self):
    """
    Getter method for addressFamily, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/addressFamily (string)

    YANG Description: Address family type of the multi-topology, which can be IPv4 Address Family or IPv6 Address Family. 
    """
    return self.__addressFamily
      
  def _set_addressFamily(self, v, load=False):
    """
    Setter method for addressFamily, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/addressFamily (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addressFamily is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addressFamily() directly.

    YANG Description: Address family type of the multi-topology, which can be IPv4 Address Family or IPv6 Address Family. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="addressFamily", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addressFamily must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="addressFamily", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__addressFamily = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addressFamily(self):
    self.__addressFamily = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="addressFamily", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_mtId(self):
    """
    Getter method for mtId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/mtId (uint32)

    YANG Description: IS-IS Multi-topology ID.
    """
    return self.__mtId
      
  def _set_mtId(self, v, load=False):
    """
    Setter method for mtId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/mtId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtId() directly.

    YANG Description: IS-IS Multi-topology ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="mtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="mtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__mtId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtId(self):
    self.__mtId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4095']}), is_leaf=True, yang_name="mtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_topologyName(self):
    """
    Getter method for topologyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/topologyName (string)

    YANG Description: Multi-topology name.
    """
    return self.__topologyName
      
  def _set_topologyName(self, v, load=False):
    """
    Setter method for topologyName, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/topologyName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topologyName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topologyName() directly.

    YANG Description: Multi-topology name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="topologyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topologyName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__topologyName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topologyName(self):
    self.__topologyName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="topologyName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_spfPriority(self):
    """
    Getter method for spfPriority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/spfPriority (uint32)

    YANG Description: Set a priority for multi-topology.
    """
    return self.__spfPriority
      
  def _set_spfPriority(self, v, load=False):
    """
    Setter method for spfPriority, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/spfPriority (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spfPriority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spfPriority() directly.

    YANG Description: Set a priority for multi-topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="spfPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spfPriority must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="spfPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__spfPriority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spfPriority(self):
    self.__spfPriority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['64']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="spfPriority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_maxLoadBalancing(self):
    """
    Getter method for maxLoadBalancing, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/maxLoadBalancing (uint32)

    YANG Description: Set the maximum number of equal-cost routes for load balancing. 
    """
    return self.__maxLoadBalancing
      
  def _set_maxLoadBalancing(self, v, load=False):
    """
    Setter method for maxLoadBalancing, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/maxLoadBalancing (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxLoadBalancing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxLoadBalancing() directly.

    YANG Description: Set the maximum number of equal-cost routes for load balancing. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="maxLoadBalancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxLoadBalancing must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="maxLoadBalancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__maxLoadBalancing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxLoadBalancing(self):
    self.__maxLoadBalancing = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="maxLoadBalancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_autoCostEnable(self):
    """
    Getter method for autoCostEnable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/autoCostEnable (boolean)

    YANG Description: Enable automatic cost calculation for the system. By default, the function is disabled.
    """
    return self.__autoCostEnable
      
  def _set_autoCostEnable(self, v, load=False):
    """
    Setter method for autoCostEnable, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/autoCostEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoCostEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoCostEnable() directly.

    YANG Description: Enable automatic cost calculation for the system. By default, the function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoCostEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__autoCostEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoCostEnable(self):
    self.__autoCostEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_autoCostEnableCompatible(self):
    """
    Getter method for autoCostEnableCompatible, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/autoCostEnableCompatible (boolean)

    YANG Description: Enable automatic cost calculation compatibly for the system. By default, the function is disabled.
    """
    return self.__autoCostEnableCompatible
      
  def _set_autoCostEnableCompatible(self, v, load=False):
    """
    Setter method for autoCostEnableCompatible, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/autoCostEnableCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoCostEnableCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoCostEnableCompatible() directly.

    YANG Description: Enable automatic cost calculation compatibly for the system. By default, the function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoCostEnableCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__autoCostEnableCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoCostEnableCompatible(self):
    self.__autoCostEnableCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="autoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bandwidth (uint32)

    YANG Description: Set the bandwidth reference used for the automatic cost calculation on an interface.The value is expressed in Mbit/s. The default value is 100.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Set the bandwidth reference used for the automatic cost calculation on an interface.The value is expressed in Mbit/s. The default value is 100.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1Cost(self):
    """
    Getter method for level1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level1Cost (uint32)

    YANG Description: Set the level-1 cost for an interface. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    return self.__level1Cost
      
  def _set_level1Cost(self, v, load=False):
    """
    Setter method for level1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level1Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1Cost() directly.

    YANG Description: Set the level-1 cost for an interface. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1Cost(self):
    self.__level1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2Cost(self):
    """
    Getter method for level2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level2Cost (uint32)

    YANG Description: Set the level-2 cost for an interface. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    return self.__level2Cost
      
  def _set_level2Cost(self, v, load=False):
    """
    Setter method for level2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level2Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2Cost() directly.

    YANG Description: Set the level-2 cost for an interface. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2Cost(self):
    self.__level2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="level2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_overloadType(self):
    """
    Getter method for overloadType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadType (string)

    YANG Description: Configure the router to notify others that it is overloaded. The value can be No Setting, Restart Setting, or Manual Setting. The default value is No Setting.
    """
    return self.__overloadType
      
  def _set_overloadType(self, v, load=False):
    """
    Setter method for overloadType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadType() directly.

    YANG Description: Configure the router to notify others that it is overloaded. The value can be No Setting, Restart Setting, or Manual Setting. The default value is No Setting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="overloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="overloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__overloadType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadType(self):
    self.__overloadType = YANGDynClass(base=six.text_type, default=six.text_type("no_set"), is_leaf=True, yang_name="overloadType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_overloadWaitType(self):
    """
    Getter method for overloadWaitType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadWaitType (string)

    YANG Description: Set the overload type. The value can be Wait for BGP Convergence, Wait for Neighbor, or Not Wait. The default value is Not Wait.
    """
    return self.__overloadWaitType
      
  def _set_overloadWaitType(self, v, load=False):
    """
    Setter method for overloadWaitType, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadWaitType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadWaitType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadWaitType() directly.

    YANG Description: Set the overload type. The value can be Wait for BGP Convergence, Wait for Neighbor, or Not Wait. The default value is Not Wait.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="overloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadWaitType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="overloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__overloadWaitType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadWaitType(self):
    self.__overloadWaitType = YANGDynClass(base=six.text_type, default=six.text_type("no_wait"), is_leaf=True, yang_name="overloadWaitType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_overloadNbrSysId(self):
    """
    Getter method for overloadNbrSysId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadNbrSysId (string)

    YANG Description: Set the system ID of the neighbor. The duration for the system to keep the overload bit is set according to the status of the neighbor specified by the system ID. The length of the value is 6 bytes, in the format of XXXX.XXXX.XXXX, in which X is a hexadecimal case-insensitive character. 
    """
    return self.__overloadNbrSysId
      
  def _set_overloadNbrSysId(self, v, load=False):
    """
    Setter method for overloadNbrSysId, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadNbrSysId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadNbrSysId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadNbrSysId() directly.

    YANG Description: Set the system ID of the neighbor. The duration for the system to keep the overload bit is set according to the status of the neighbor specified by the system ID. The length of the value is 6 bytes, in the format of XXXX.XXXX.XXXX, in which X is a hexadecimal case-insensitive character. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="overloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadNbrSysId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="overloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__overloadNbrSysId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadNbrSysId(self):
    self.__overloadNbrSysId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([0-9]|[a-f]|[A-F]){4}\\.){2}([0-9]|[a-f]|[A-F]){4})', 'length': ['1..15']}), is_leaf=True, yang_name="overloadNbrSysId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_overloadTimeout1(self):
    """
    Getter method for overloadTimeout1, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadTimeout1 (uint32)

    YANG Description: If the specified neighbor does not become Up before the neighbor holdtime expires, the holdtime of the system overload flag is the neighbor holdtime. The value of neighbor holdtime is expressed in seconds, ranging from 5 to 86400. The default value is 1200.
    """
    return self.__overloadTimeout1
      
  def _set_overloadTimeout1(self, v, load=False):
    """
    Setter method for overloadTimeout1, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadTimeout1 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadTimeout1 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadTimeout1() directly.

    YANG Description: If the specified neighbor does not become Up before the neighbor holdtime expires, the holdtime of the system overload flag is the neighbor holdtime. The value of neighbor holdtime is expressed in seconds, ranging from 5 to 86400. The default value is 1200.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="overloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadTimeout1 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="overloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__overloadTimeout1 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadTimeout1(self):
    self.__overloadTimeout1 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="overloadTimeout1", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_overloadTimeout2(self):
    """
    Getter method for overloadTimeout2, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadTimeout2 (uint32)

    YANG Description: If the specified neighbor becomes Up before the neighbor holdtime expires, the system overload flag keeps the neighbor timeout period. The neighbor timeout period is expressed in seconds, ranging from 5 to 86400. The default value is 600.
    """
    return self.__overloadTimeout2
      
  def _set_overloadTimeout2(self, v, load=False):
    """
    Setter method for overloadTimeout2, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadTimeout2 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadTimeout2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadTimeout2() directly.

    YANG Description: If the specified neighbor becomes Up before the neighbor holdtime expires, the system overload flag keeps the neighbor timeout period. The neighbor timeout period is expressed in seconds, ranging from 5 to 86400. The default value is 600.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="overloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadTimeout2 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="overloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__overloadTimeout2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadTimeout2(self):
    self.__overloadTimeout2 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..86400']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="overloadTimeout2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_overloadInterlevel(self):
    """
    Getter method for overloadInterlevel, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadInterlevel (boolean)

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from the IS-IS routes at different levels. By default, such IP address prefixes cannot be advertised.
    """
    return self.__overloadInterlevel
      
  def _set_overloadInterlevel(self, v, load=False):
    """
    Setter method for overloadInterlevel, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadInterlevel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadInterlevel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadInterlevel() directly.

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from the IS-IS routes at different levels. By default, such IP address prefixes cannot be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadInterlevel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__overloadInterlevel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadInterlevel(self):
    self.__overloadInterlevel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadInterlevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_overloadExternal(self):
    """
    Getter method for overloadExternal, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadExternal (boolean)

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from other protocols. By default, such IP address prefixes cannot be advertised.
    """
    return self.__overloadExternal
      
  def _set_overloadExternal(self, v, load=False):
    """
    Setter method for overloadExternal, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/overloadExternal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadExternal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadExternal() directly.

    YANG Description: Determine whether a device can advertise the IP address prefixes learned from other protocols. By default, such IP address prefixes cannot be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadExternal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__overloadExternal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadExternal(self):
    self.__overloadExternal = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="overloadExternal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1TagValue(self):
    """
    Getter method for level1TagValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level1TagValue (uint32)

    YANG Description: Set the level-1 tag for an IS-IS interface. 
    """
    return self.__level1TagValue
      
  def _set_level1TagValue(self, v, load=False):
    """
    Setter method for level1TagValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level1TagValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1TagValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1TagValue() directly.

    YANG Description: Set the level-1 tag for an IS-IS interface. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1TagValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1TagValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1TagValue(self):
    self.__level1TagValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level1TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2TagValue(self):
    """
    Getter method for level2TagValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level2TagValue (uint32)

    YANG Description: Set the level-2 tag for an IS-IS interface. 
    """
    return self.__level2TagValue
      
  def _set_level2TagValue(self, v, load=False):
    """
    Setter method for level2TagValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/level2TagValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2TagValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2TagValue() directly.

    YANG Description: Set the level-2 tag for an IS-IS interface. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2TagValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2TagValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2TagValue(self):
    self.__level2TagValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="level2TagValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_allCircBfdOn(self):
    """
    Getter method for allCircBfdOn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/allCircBfdOn (boolean)

    YANG Description: Enable BFD on all interfaces.
    """
    return self.__allCircBfdOn
      
  def _set_allCircBfdOn(self, v, load=False):
    """
    Setter method for allCircBfdOn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/allCircBfdOn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allCircBfdOn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allCircBfdOn() directly.

    YANG Description: Enable BFD on all interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allCircBfdOn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__allCircBfdOn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allCircBfdOn(self):
    self.__allCircBfdOn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_frrBindingFlag(self):
    """
    Getter method for frrBindingFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/frrBindingFlag (boolean)

    YANG Description: Bind the BFD status to the link status of an interface.
    """
    return self.__frrBindingFlag
      
  def _set_frrBindingFlag(self, v, load=False):
    """
    Setter method for frrBindingFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/frrBindingFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frrBindingFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frrBindingFlag() directly.

    YANG Description: Bind the BFD status to the link status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frrBindingFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__frrBindingFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frrBindingFlag(self):
    self.__frrBindingFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frrBindingFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_bfdMinRx(self):
    """
    Getter method for bfdMinRx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bfdMinRx (uint32)

    YANG Description: Set the minimum interval at which BFD packets are received. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    return self.__bfdMinRx
      
  def _set_bfdMinRx(self, v, load=False):
    """
    Setter method for bfdMinRx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bfdMinRx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMinRx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMinRx() directly.

    YANG Description: Set the minimum interval at which BFD packets are received. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMinRx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bfdMinRx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMinRx(self):
    self.__bfdMinRx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_bfdMinTx(self):
    """
    Getter method for bfdMinTx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bfdMinTx (uint32)

    YANG Description: Set the minimum interval at which BFD packets are sent. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    return self.__bfdMinTx
      
  def _set_bfdMinTx(self, v, load=False):
    """
    Setter method for bfdMinTx, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bfdMinTx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMinTx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMinTx() directly.

    YANG Description: Set the minimum interval at which BFD packets are sent. The value is expressed in milliseconds. The default value is 10. The value supported by the CX and PTN and ATN product ranges from 3 to 1000, and the value supported by other products ranges from 10 to 1000. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMinTx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bfdMinTx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMinTx(self):
    self.__bfdMinTx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_bfdMultNum(self):
    """
    Getter method for bfdMultNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bfdMultNum (uint32)

    YANG Description: Set the detection multiplier of a BFD session. The default value is 3.
    """
    return self.__bfdMultNum
      
  def _set_bfdMultNum(self, v, load=False):
    """
    Setter method for bfdMultNum, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/bfdMultNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMultNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMultNum() directly.

    YANG Description: Set the detection multiplier of a BFD session. The default value is 3.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMultNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bfdMultNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMultNum(self):
    self.__bfdMultNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="bfdMultNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_tosExpValue(self):
    """
    Getter method for tosExpValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/tosExpValue (uint8)

    YANG Description: Set the priority of BFD packets.
    """
    return self.__tosExpValue
      
  def _set_tosExpValue(self, v, load=False):
    """
    Setter method for tosExpValue, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/tosExpValue (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tosExpValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tosExpValue() directly.

    YANG Description: Set the priority of BFD packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tosExpValue must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__tosExpValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tosExpValue(self):
    self.__tosExpValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..7']}), is_leaf=True, yang_name="tosExpValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_allCircBfdBitErrOn(self):
    """
    Getter method for allCircBfdBitErrOn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/allCircBfdBitErrOn (boolean)

    YANG Description: Enable BFD bit-error on all interfaces.
    """
    return self.__allCircBfdBitErrOn
      
  def _set_allCircBfdBitErrOn(self, v, load=False):
    """
    Setter method for allCircBfdBitErrOn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/allCircBfdBitErrOn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allCircBfdBitErrOn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allCircBfdBitErrOn() directly.

    YANG Description: Enable BFD bit-error on all interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdBitErrOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allCircBfdBitErrOn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdBitErrOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__allCircBfdBitErrOn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allCircBfdBitErrOn(self):
    self.__allCircBfdBitErrOn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allCircBfdBitErrOn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_mtIndex(self):
    """
    Getter method for mtIndex, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/mtIndex (uint32)

    YANG Description: IS-IS multi-topology index.
    """
    return self.__mtIndex
      
  def _set_mtIndex(self, v, load=False):
    """
    Setter method for mtIndex, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/mtIndex (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtIndex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtIndex() directly.

    YANG Description: IS-IS multi-topology index.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="mtIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtIndex must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="mtIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__mtIndex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtIndex(self):
    self.__mtIndex = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="mtIndex", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_attAdvControl(self):
    """
    Getter method for attAdvControl, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/attAdvControl (string)

    YANG Description: Control to advertise the ATT bit.
    """
    return self.__attAdvControl
      
  def _set_attAdvControl(self, v, load=False):
    """
    Setter method for attAdvControl, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/attAdvControl (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attAdvControl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attAdvControl() directly.

    YANG Description: Control to advertise the ATT bit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attAdvControl must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__attAdvControl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attAdvControl(self):
    self.__attAdvControl = YANGDynClass(base=six.text_type, default=six.text_type("noType"), is_leaf=True, yang_name="attAdvControl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_attAvoidLearn(self):
    """
    Getter method for attAvoidLearn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/attAvoidLearn (boolean)

    YANG Description: Prevent the device from learning the LSPs with the ATT bit.
    """
    return self.__attAvoidLearn
      
  def _set_attAvoidLearn(self, v, load=False):
    """
    Setter method for attAvoidLearn, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/attAvoidLearn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attAvoidLearn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attAvoidLearn() directly.

    YANG Description: Prevent the device from learning the LSPs with the ATT bit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attAvoidLearn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__attAvoidLearn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attAvoidLearn(self):
    self.__attAvoidLearn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="attAvoidLearn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_applyQppb(self):
    """
    Getter method for applyQppb, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/applyQppb (boolean)

    YANG Description: IPv6 Qppb.
    """
    return self.__applyQppb
      
  def _set_applyQppb(self, v, load=False):
    """
    Setter method for applyQppb, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/applyQppb (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_applyQppb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_applyQppb() directly.

    YANG Description: IPv6 Qppb.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="applyQppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """applyQppb must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="applyQppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__applyQppb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_applyQppb(self):
    self.__applyQppb = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="applyQppb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isNextHopWeights(self):
    """
    Getter method for isNextHopWeights, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights (container)

    YANG Description: List of next hop weights.
    """
    return self.__isNextHopWeights
      
  def _set_isNextHopWeights(self, v, load=False):
    """
    Setter method for isNextHopWeights, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isNextHopWeights (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNextHopWeights is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNextHopWeights() directly.

    YANG Description: List of next hop weights.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isNextHopWeights_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights, is_container='container', yang_name="isNextHopWeights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNextHopWeights must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isNextHopWeights_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights, is_container='container', yang_name="isNextHopWeights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isNextHopWeights = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNextHopWeights(self):
    self.__isNextHopWeights = YANGDynClass(base=yc_isNextHopWeights_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights, is_container='container', yang_name="isNextHopWeights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isSummaryRoutes(self):
    """
    Getter method for isSummaryRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes (container)

    YANG Description: List of summary routes.
    """
    return self.__isSummaryRoutes
      
  def _set_isSummaryRoutes(self, v, load=False):
    """
    Setter method for isSummaryRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSummaryRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSummaryRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSummaryRoutes() directly.

    YANG Description: List of summary routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSummaryRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes, is_container='container', yang_name="isSummaryRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSummaryRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSummaryRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes, is_container='container', yang_name="isSummaryRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSummaryRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSummaryRoutes(self):
    self.__isSummaryRoutes = YANGDynClass(base=yc_isSummaryRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes, is_container='container', yang_name="isSummaryRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDefaultRoutes(self):
    """
    Getter method for isDefaultRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes (container)

    YANG Description: Default route list.
    """
    return self.__isDefaultRoutes
      
  def _set_isDefaultRoutes(self, v, load=False):
    """
    Setter method for isDefaultRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDefaultRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDefaultRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDefaultRoutes() directly.

    YANG Description: Default route list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDefaultRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes, is_container='container', yang_name="isDefaultRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDefaultRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDefaultRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes, is_container='container', yang_name="isDefaultRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDefaultRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDefaultRoutes(self):
    self.__isDefaultRoutes = YANGDynClass(base=yc_isDefaultRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes, is_container='container', yang_name="isDefaultRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isImportRoutes(self):
    """
    Getter method for isImportRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes (container)

    YANG Description: Import routes.
    """
    return self.__isImportRoutes
      
  def _set_isImportRoutes(self, v, load=False):
    """
    Setter method for isImportRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isImportRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isImportRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isImportRoutes() directly.

    YANG Description: Import routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes, is_container='container', yang_name="isImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isImportRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes, is_container='container', yang_name="isImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isImportRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isImportRoutes(self):
    self.__isImportRoutes = YANGDynClass(base=yc_isImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes, is_container='container', yang_name="isImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isFilterImports(self):
    """
    Getter method for isFilterImports, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports (container)

    YANG Description: Route import policy list.
    """
    return self.__isFilterImports
      
  def _set_isFilterImports(self, v, load=False):
    """
    Setter method for isFilterImports, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterImports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFilterImports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFilterImports() directly.

    YANG Description: Route import policy list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isFilterImports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports, is_container='container', yang_name="isFilterImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFilterImports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isFilterImports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports, is_container='container', yang_name="isFilterImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isFilterImports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFilterImports(self):
    self.__isFilterImports = YANGDynClass(base=yc_isFilterImports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports, is_container='container', yang_name="isFilterImports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isFilterExports(self):
    """
    Getter method for isFilterExports, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports (container)

    YANG Description: Route export policy list.
    """
    return self.__isFilterExports
      
  def _set_isFilterExports(self, v, load=False):
    """
    Setter method for isFilterExports, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFilterExports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFilterExports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFilterExports() directly.

    YANG Description: Route export policy list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isFilterExports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports, is_container='container', yang_name="isFilterExports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFilterExports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isFilterExports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports, is_container='container', yang_name="isFilterExports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isFilterExports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFilterExports(self):
    self.__isFilterExports = YANGDynClass(base=yc_isFilterExports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports, is_container='container', yang_name="isFilterExports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLeakRouteLevel2ToLevel1s(self):
    """
    Getter method for isLeakRouteLevel2ToLevel1s, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s (container)

    YANG Description: List of level-2 to level-1 route leaking.
    """
    return self.__isLeakRouteLevel2ToLevel1s
      
  def _set_isLeakRouteLevel2ToLevel1s(self, v, load=False):
    """
    Setter method for isLeakRouteLevel2ToLevel1s, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel2ToLevel1s (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLeakRouteLevel2ToLevel1s is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLeakRouteLevel2ToLevel1s() directly.

    YANG Description: List of level-2 to level-1 route leaking.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLeakRouteLevel2ToLevel1s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s, is_container='container', yang_name="isLeakRouteLevel2ToLevel1s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLeakRouteLevel2ToLevel1s must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLeakRouteLevel2ToLevel1s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s, is_container='container', yang_name="isLeakRouteLevel2ToLevel1s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLeakRouteLevel2ToLevel1s = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLeakRouteLevel2ToLevel1s(self):
    self.__isLeakRouteLevel2ToLevel1s = YANGDynClass(base=yc_isLeakRouteLevel2ToLevel1s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s, is_container='container', yang_name="isLeakRouteLevel2ToLevel1s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLeakRouteLevel1ToLevel2s(self):
    """
    Getter method for isLeakRouteLevel1ToLevel2s, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s (container)

    YANG Description: List of level-1 to level-2 route leaking.
    """
    return self.__isLeakRouteLevel1ToLevel2s
      
  def _set_isLeakRouteLevel1ToLevel2s(self, v, load=False):
    """
    Setter method for isLeakRouteLevel1ToLevel2s, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLeakRouteLevel1ToLevel2s (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLeakRouteLevel1ToLevel2s is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLeakRouteLevel1ToLevel2s() directly.

    YANG Description: List of level-1 to level-2 route leaking.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLeakRouteLevel1ToLevel2s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s, is_container='container', yang_name="isLeakRouteLevel1ToLevel2s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLeakRouteLevel1ToLevel2s must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLeakRouteLevel1ToLevel2s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s, is_container='container', yang_name="isLeakRouteLevel1ToLevel2s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLeakRouteLevel1ToLevel2s = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLeakRouteLevel1ToLevel2s(self):
    self.__isLeakRouteLevel1ToLevel2s = YANGDynClass(base=yc_isLeakRouteLevel1ToLevel2s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s, is_container='container', yang_name="isLeakRouteLevel1ToLevel2s", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isRoutePrioritys(self):
    """
    Getter method for isRoutePrioritys, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys (container)

    YANG Description: Route priority list.
    """
    return self.__isRoutePrioritys
      
  def _set_isRoutePrioritys(self, v, load=False):
    """
    Setter method for isRoutePrioritys, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isRoutePrioritys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isRoutePrioritys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isRoutePrioritys() directly.

    YANG Description: Route priority list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isRoutePrioritys_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys, is_container='container', yang_name="isRoutePrioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isRoutePrioritys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isRoutePrioritys_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys, is_container='container', yang_name="isRoutePrioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isRoutePrioritys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isRoutePrioritys(self):
    self.__isRoutePrioritys = YANGDynClass(base=yc_isRoutePrioritys_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys, is_container='container', yang_name="isRoutePrioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isPreferences(self):
    """
    Getter method for isPreferences, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences (container)

    YANG Description: Priority list.
    """
    return self.__isPreferences
      
  def _set_isPreferences(self, v, load=False):
    """
    Setter method for isPreferences, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isPreferences (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPreferences is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPreferences() directly.

    YANG Description: Priority list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isPreferences_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences, is_container='container', yang_name="isPreferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPreferences must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isPreferences_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences, is_container='container', yang_name="isPreferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isPreferences = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPreferences(self):
    self.__isPreferences = YANGDynClass(base=yc_isPreferences_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences, is_container='container', yang_name="isPreferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isFrr(self):
    """
    Getter method for isFrr, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr (container)

    YANG Description: Enable FRR.
    """
    return self.__isFrr
      
  def _set_isFrr(self, v, load=False):
    """
    Setter method for isFrr, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isFrr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFrr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFrr() directly.

    YANG Description: Enable FRR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isFrr_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr, is_container='container', yang_name="isFrr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFrr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isFrr_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr, is_container='container', yang_name="isFrr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isFrr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFrr(self):
    self.__isFrr = YANGDynClass(base=yc_isFrr_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr, is_container='container', yang_name="isFrr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isCircMts(self):
    """
    Getter method for isCircMts, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts (container)

    YANG Description: Interface multi-topology list.
    """
    return self.__isCircMts
      
  def _set_isCircMts(self, v, load=False):
    """
    Setter method for isCircMts, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isCircMts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isCircMts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isCircMts() directly.

    YANG Description: Interface multi-topology list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isCircMts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts, is_container='container', yang_name="isCircMts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isCircMts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isCircMts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts, is_container='container', yang_name="isCircMts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isCircMts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isCircMts(self):
    self.__isCircMts = YANGDynClass(base=yc_isCircMts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts, is_container='container', yang_name="isCircMts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispRouteStatisticss(self):
    """
    Getter method for isDispRouteStatisticss, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss (container)

    YANG Description: Route statistics information list.
    """
    return self.__isDispRouteStatisticss
      
  def _set_isDispRouteStatisticss(self, v, load=False):
    """
    Setter method for isDispRouteStatisticss, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispRouteStatisticss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispRouteStatisticss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispRouteStatisticss() directly.

    YANG Description: Route statistics information list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispRouteStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss, is_container='container', yang_name="isDispRouteStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispRouteStatisticss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispRouteStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss, is_container='container', yang_name="isDispRouteStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispRouteStatisticss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispRouteStatisticss(self):
    self.__isDispRouteStatisticss = YANGDynClass(base=yc_isDispRouteStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss, is_container='container', yang_name="isDispRouteStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispV4Routes(self):
    """
    Getter method for isDispV4Routes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes (container)

    YANG Description: List of routing information.
    """
    return self.__isDispV4Routes
      
  def _set_isDispV4Routes(self, v, load=False):
    """
    Setter method for isDispV4Routes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4Routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV4Routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV4Routes() directly.

    YANG Description: List of routing information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispV4Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes, is_container='container', yang_name="isDispV4Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV4Routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispV4Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes, is_container='container', yang_name="isDispV4Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispV4Routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV4Routes(self):
    self.__isDispV4Routes = YANGDynClass(base=yc_isDispV4Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes, is_container='container', yang_name="isDispV4Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispV6Routes(self):
    """
    Getter method for isDispV6Routes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes (container)

    YANG Description: List of the information about IPv6 routes.
    """
    return self.__isDispV6Routes
      
  def _set_isDispV6Routes(self, v, load=False):
    """
    Setter method for isDispV6Routes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6Routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV6Routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV6Routes() directly.

    YANG Description: List of the information about IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispV6Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes, is_container='container', yang_name="isDispV6Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV6Routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispV6Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes, is_container='container', yang_name="isDispV6Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispV6Routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV6Routes(self):
    self.__isDispV6Routes = YANGDynClass(base=yc_isDispV6Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes, is_container='container', yang_name="isDispV6Routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispV4ImportRoutes(self):
    """
    Getter method for isDispV4ImportRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes (container)

    YANG Description: List of the information about the imported IPv4 routes.
    """
    return self.__isDispV4ImportRoutes
      
  def _set_isDispV4ImportRoutes(self, v, load=False):
    """
    Setter method for isDispV4ImportRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV4ImportRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV4ImportRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV4ImportRoutes() directly.

    YANG Description: List of the information about the imported IPv4 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispV4ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes, is_container='container', yang_name="isDispV4ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV4ImportRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispV4ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes, is_container='container', yang_name="isDispV4ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispV4ImportRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV4ImportRoutes(self):
    self.__isDispV4ImportRoutes = YANGDynClass(base=yc_isDispV4ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes, is_container='container', yang_name="isDispV4ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispV6ImportRoutes(self):
    """
    Getter method for isDispV6ImportRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes (container)

    YANG Description: List of the information about the imported IPv6 routes.
    """
    return self.__isDispV6ImportRoutes
      
  def _set_isDispV6ImportRoutes(self, v, load=False):
    """
    Setter method for isDispV6ImportRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispV6ImportRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispV6ImportRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispV6ImportRoutes() directly.

    YANG Description: List of the information about the imported IPv6 routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispV6ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes, is_container='container', yang_name="isDispV6ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispV6ImportRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispV6ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes, is_container='container', yang_name="isDispV6ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispV6ImportRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispV6ImportRoutes(self):
    self.__isDispV6ImportRoutes = YANGDynClass(base=yc_isDispV6ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes, is_container='container', yang_name="isDispV6ImportRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispMigpRoutes(self):
    """
    Getter method for isDispMigpRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes (container)

    YANG Description: List of MIGP routing information.
    """
    return self.__isDispMigpRoutes
      
  def _set_isDispMigpRoutes(self, v, load=False):
    """
    Setter method for isDispMigpRoutes, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isDispMigpRoutes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispMigpRoutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispMigpRoutes() directly.

    YANG Description: List of MIGP routing information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispMigpRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes, is_container='container', yang_name="isDispMigpRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispMigpRoutes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispMigpRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes, is_container='container', yang_name="isDispMigpRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispMigpRoutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispMigpRoutes(self):
    self.__isDispMigpRoutes = YANGDynClass(base=yc_isDispMigpRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes, is_container='container', yang_name="isDispMigpRoutes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLinkGroupPorts(self):
    """
    Getter method for isLinkGroupPorts, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts (container)

    YANG Description: Lists of Link-group Interface
    """
    return self.__isLinkGroupPorts
      
  def _set_isLinkGroupPorts(self, v, load=False):
    """
    Setter method for isLinkGroupPorts, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isLinkGroupPorts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLinkGroupPorts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLinkGroupPorts() directly.

    YANG Description: Lists of Link-group Interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLinkGroupPorts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts, is_container='container', yang_name="isLinkGroupPorts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLinkGroupPorts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLinkGroupPorts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts, is_container='container', yang_name="isLinkGroupPorts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLinkGroupPorts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLinkGroupPorts(self):
    self.__isLinkGroupPorts = YANGDynClass(base=yc_isLinkGroupPorts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts, is_container='container', yang_name="isLinkGroupPorts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isSrLspTrig(self):
    """
    Getter method for isSrLspTrig, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig (container)

    YANG Description: Run the sr-lsp-trig command.
    """
    return self.__isSrLspTrig
      
  def _set_isSrLspTrig(self, v, load=False):
    """
    Setter method for isSrLspTrig, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT/isSrLspTrig (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrLspTrig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrLspTrig() directly.

    YANG Description: Run the sr-lsp-trig command.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSrLspTrig_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSrLspTrig, is_container='container', yang_name="isSrLspTrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrLspTrig must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSrLspTrig_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSrLspTrig, is_container='container', yang_name="isSrLspTrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSrLspTrig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrLspTrig(self):
    self.__isSrLspTrig = YANGDynClass(base=yc_isSrLspTrig_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSrLspTrig, is_container='container', yang_name="isSrLspTrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  addressFamily = __builtin__.property(_get_addressFamily, _set_addressFamily)
  mtId = __builtin__.property(_get_mtId, _set_mtId)
  topologyName = __builtin__.property(_get_topologyName, _set_topologyName)
  spfPriority = __builtin__.property(_get_spfPriority, _set_spfPriority)
  maxLoadBalancing = __builtin__.property(_get_maxLoadBalancing, _set_maxLoadBalancing)
  autoCostEnable = __builtin__.property(_get_autoCostEnable, _set_autoCostEnable)
  autoCostEnableCompatible = __builtin__.property(_get_autoCostEnableCompatible, _set_autoCostEnableCompatible)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  level1Cost = __builtin__.property(_get_level1Cost, _set_level1Cost)
  level2Cost = __builtin__.property(_get_level2Cost, _set_level2Cost)
  overloadType = __builtin__.property(_get_overloadType, _set_overloadType)
  overloadWaitType = __builtin__.property(_get_overloadWaitType, _set_overloadWaitType)
  overloadNbrSysId = __builtin__.property(_get_overloadNbrSysId, _set_overloadNbrSysId)
  overloadTimeout1 = __builtin__.property(_get_overloadTimeout1, _set_overloadTimeout1)
  overloadTimeout2 = __builtin__.property(_get_overloadTimeout2, _set_overloadTimeout2)
  overloadInterlevel = __builtin__.property(_get_overloadInterlevel, _set_overloadInterlevel)
  overloadExternal = __builtin__.property(_get_overloadExternal, _set_overloadExternal)
  level1TagValue = __builtin__.property(_get_level1TagValue, _set_level1TagValue)
  level2TagValue = __builtin__.property(_get_level2TagValue, _set_level2TagValue)
  allCircBfdOn = __builtin__.property(_get_allCircBfdOn, _set_allCircBfdOn)
  frrBindingFlag = __builtin__.property(_get_frrBindingFlag, _set_frrBindingFlag)
  bfdMinRx = __builtin__.property(_get_bfdMinRx, _set_bfdMinRx)
  bfdMinTx = __builtin__.property(_get_bfdMinTx, _set_bfdMinTx)
  bfdMultNum = __builtin__.property(_get_bfdMultNum, _set_bfdMultNum)
  tosExpValue = __builtin__.property(_get_tosExpValue, _set_tosExpValue)
  allCircBfdBitErrOn = __builtin__.property(_get_allCircBfdBitErrOn, _set_allCircBfdBitErrOn)
  mtIndex = __builtin__.property(_get_mtIndex, _set_mtIndex)
  attAdvControl = __builtin__.property(_get_attAdvControl, _set_attAdvControl)
  attAvoidLearn = __builtin__.property(_get_attAvoidLearn, _set_attAvoidLearn)
  applyQppb = __builtin__.property(_get_applyQppb, _set_applyQppb)
  isNextHopWeights = __builtin__.property(_get_isNextHopWeights, _set_isNextHopWeights) # type: yc_isNextHopWeights_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isNextHopWeights
  isSummaryRoutes = __builtin__.property(_get_isSummaryRoutes, _set_isSummaryRoutes) # type: yc_isSummaryRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSummaryRoutes
  isDefaultRoutes = __builtin__.property(_get_isDefaultRoutes, _set_isDefaultRoutes) # type: yc_isDefaultRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDefaultRoutes
  isImportRoutes = __builtin__.property(_get_isImportRoutes, _set_isImportRoutes) # type: yc_isImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isImportRoutes
  isFilterImports = __builtin__.property(_get_isFilterImports, _set_isFilterImports) # type: yc_isFilterImports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterImports
  isFilterExports = __builtin__.property(_get_isFilterExports, _set_isFilterExports) # type: yc_isFilterExports_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFilterExports
  isLeakRouteLevel2ToLevel1s = __builtin__.property(_get_isLeakRouteLevel2ToLevel1s, _set_isLeakRouteLevel2ToLevel1s) # type: yc_isLeakRouteLevel2ToLevel1s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel2ToLevel1s
  isLeakRouteLevel1ToLevel2s = __builtin__.property(_get_isLeakRouteLevel1ToLevel2s, _set_isLeakRouteLevel1ToLevel2s) # type: yc_isLeakRouteLevel1ToLevel2s_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLeakRouteLevel1ToLevel2s
  isRoutePrioritys = __builtin__.property(_get_isRoutePrioritys, _set_isRoutePrioritys) # type: yc_isRoutePrioritys_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isRoutePrioritys
  isPreferences = __builtin__.property(_get_isPreferences, _set_isPreferences) # type: yc_isPreferences_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isPreferences
  isFrr = __builtin__.property(_get_isFrr, _set_isFrr) # type: yc_isFrr_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isFrr
  isCircMts = __builtin__.property(_get_isCircMts, _set_isCircMts) # type: yc_isCircMts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isCircMts
  isDispRouteStatisticss = __builtin__.property(_get_isDispRouteStatisticss, _set_isDispRouteStatisticss) # type: yc_isDispRouteStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispRouteStatisticss
  isDispV4Routes = __builtin__.property(_get_isDispV4Routes, _set_isDispV4Routes) # type: yc_isDispV4Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4Routes
  isDispV6Routes = __builtin__.property(_get_isDispV6Routes, _set_isDispV6Routes) # type: yc_isDispV6Routes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6Routes
  isDispV4ImportRoutes = __builtin__.property(_get_isDispV4ImportRoutes, _set_isDispV4ImportRoutes) # type: yc_isDispV4ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV4ImportRoutes
  isDispV6ImportRoutes = __builtin__.property(_get_isDispV6ImportRoutes, _set_isDispV6ImportRoutes) # type: yc_isDispV6ImportRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispV6ImportRoutes
  isDispMigpRoutes = __builtin__.property(_get_isDispMigpRoutes, _set_isDispMigpRoutes) # type: yc_isDispMigpRoutes_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isDispMigpRoutes
  isLinkGroupPorts = __builtin__.property(_get_isLinkGroupPorts, _set_isLinkGroupPorts) # type: yc_isLinkGroupPorts_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isLinkGroupPorts
  isSrLspTrig = __builtin__.property(_get_isSrLspTrig, _set_isSrLspTrig) # type: yc_isSrLspTrig_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT_isSrLspTrig


  _pyangbind_elements = OrderedDict([('addressFamily', addressFamily), ('mtId', mtId), ('topologyName', topologyName), ('spfPriority', spfPriority), ('maxLoadBalancing', maxLoadBalancing), ('autoCostEnable', autoCostEnable), ('autoCostEnableCompatible', autoCostEnableCompatible), ('bandwidth', bandwidth), ('level1Cost', level1Cost), ('level2Cost', level2Cost), ('overloadType', overloadType), ('overloadWaitType', overloadWaitType), ('overloadNbrSysId', overloadNbrSysId), ('overloadTimeout1', overloadTimeout1), ('overloadTimeout2', overloadTimeout2), ('overloadInterlevel', overloadInterlevel), ('overloadExternal', overloadExternal), ('level1TagValue', level1TagValue), ('level2TagValue', level2TagValue), ('allCircBfdOn', allCircBfdOn), ('frrBindingFlag', frrBindingFlag), ('bfdMinRx', bfdMinRx), ('bfdMinTx', bfdMinTx), ('bfdMultNum', bfdMultNum), ('tosExpValue', tosExpValue), ('allCircBfdBitErrOn', allCircBfdBitErrOn), ('mtIndex', mtIndex), ('attAdvControl', attAdvControl), ('attAvoidLearn', attAvoidLearn), ('applyQppb', applyQppb), ('isNextHopWeights', isNextHopWeights), ('isSummaryRoutes', isSummaryRoutes), ('isDefaultRoutes', isDefaultRoutes), ('isImportRoutes', isImportRoutes), ('isFilterImports', isFilterImports), ('isFilterExports', isFilterExports), ('isLeakRouteLevel2ToLevel1s', isLeakRouteLevel2ToLevel1s), ('isLeakRouteLevel1ToLevel2s', isLeakRouteLevel1ToLevel2s), ('isRoutePrioritys', isRoutePrioritys), ('isPreferences', isPreferences), ('isFrr', isFrr), ('isCircMts', isCircMts), ('isDispRouteStatisticss', isDispRouteStatisticss), ('isDispV4Routes', isDispV4Routes), ('isDispV6Routes', isDispV6Routes), ('isDispV4ImportRoutes', isDispV4ImportRoutes), ('isDispV6ImportRoutes', isDispV6ImportRoutes), ('isDispMigpRoutes', isDispMigpRoutes), ('isLinkGroupPorts', isLinkGroupPorts), ('isSrLspTrig', isSrLspTrig), ])


class yc_isSiteMTs_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSiteMTs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-topology list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isSiteMT',)

  _yang_name = 'isSiteMTs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isSiteMT = YANGDynClass(base=YANGListType("addressFamily mtId",yc_isSiteMT_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT, yang_name="isSiteMT", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressFamily mtId', extensions=None), is_container='list', yang_name="isSiteMT", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSiteMTs']

  def _get_isSiteMT(self):
    """
    Getter method for isSiteMT, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT (list)

    YANG Description: Set multi-topology parameters for an IS-IS process.
    """
    return self.__isSiteMT
      
  def _set_isSiteMT(self, v, load=False):
    """
    Setter method for isSiteMT, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs/isSiteMT (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSiteMT is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSiteMT() directly.

    YANG Description: Set multi-topology parameters for an IS-IS process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("addressFamily mtId",yc_isSiteMT_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT, yang_name="isSiteMT", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressFamily mtId', extensions=None), is_container='list', yang_name="isSiteMT", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSiteMT must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("addressFamily mtId",yc_isSiteMT_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT, yang_name="isSiteMT", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressFamily mtId', extensions=None), is_container='list', yang_name="isSiteMT", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isSiteMT = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSiteMT(self):
    self.__isSiteMT = YANGDynClass(base=YANGListType("addressFamily mtId",yc_isSiteMT_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT, yang_name="isSiteMT", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressFamily mtId', extensions=None), is_container='list', yang_name="isSiteMT", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isSiteMT = __builtin__.property(_get_isSiteMT, _set_isSiteMT) # type: yc_isSiteMT_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs_isSiteMT


  _pyangbind_elements = OrderedDict([('isSiteMT', isSiteMT), ])


class yc_isDispLsdb_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs_isDispLsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the LSDB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lspLevelType','__lspId','__seqenceNumber','__checkSum','__lspLength','__attBit','__partitionBit','__overloadBit','__holdTime','__isLocalLsp',)

  _yang_name = 'isDispLsdb'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lspLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__lspId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="lspId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__seqenceNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="seqenceNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__checkSum = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="checkSum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__lspLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..2000']}), is_leaf=True, yang_name="lspLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__attBit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="attBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__partitionBit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="partitionBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__overloadBit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="overloadBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__isLocalLsp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isLocalLsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispLsdbs', 'isDispLsdb']

  def _get_lspLevelType(self):
    """
    Getter method for lspLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/lspLevelType (string)

    YANG Description: Level type: level-1 or level-2. 
    """
    return self.__lspLevelType
      
  def _set_lspLevelType(self, v, load=False):
    """
    Setter method for lspLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/lspLevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspLevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspLevelType() directly.

    YANG Description: Level type: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspLevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__lspLevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspLevelType(self):
    self.__lspLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_lspId(self):
    """
    Getter method for lspId, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/lspId (string)

    YANG Description: ID of an LSP.
    """
    return self.__lspId
      
  def _set_lspId(self, v, load=False):
    """
    Setter method for lspId, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/lspId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspId() directly.

    YANG Description: ID of an LSP.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="lspId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="lspId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__lspId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspId(self):
    self.__lspId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="lspId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_seqenceNumber(self):
    """
    Getter method for seqenceNumber, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/seqenceNumber (string)

    YANG Description: Serial number of an LSP.
    """
    return self.__seqenceNumber
      
  def _set_seqenceNumber(self, v, load=False):
    """
    Setter method for seqenceNumber, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/seqenceNumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seqenceNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seqenceNumber() directly.

    YANG Description: Serial number of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="seqenceNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seqenceNumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="seqenceNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__seqenceNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seqenceNumber(self):
    self.__seqenceNumber = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="seqenceNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_checkSum(self):
    """
    Getter method for checkSum, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/checkSum (string)

    YANG Description: Checksum of an LSP.
    """
    return self.__checkSum
      
  def _set_checkSum(self, v, load=False):
    """
    Setter method for checkSum, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/checkSum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checkSum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checkSum() directly.

    YANG Description: Checksum of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="checkSum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checkSum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="checkSum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__checkSum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checkSum(self):
    self.__checkSum = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="checkSum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_lspLength(self):
    """
    Getter method for lspLength, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/lspLength (uint32)

    YANG Description: Length of an LSP.
    """
    return self.__lspLength
      
  def _set_lspLength(self, v, load=False):
    """
    Setter method for lspLength, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/lspLength (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspLength() directly.

    YANG Description: Length of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..2000']}), is_leaf=True, yang_name="lspLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspLength must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..2000']}), is_leaf=True, yang_name="lspLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__lspLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspLength(self):
    self.__lspLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..2000']}), is_leaf=True, yang_name="lspLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_attBit(self):
    """
    Getter method for attBit, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/attBit (uint32)

    YANG Description: ATT flag of an LSP.
    """
    return self.__attBit
      
  def _set_attBit(self, v, load=False):
    """
    Setter method for attBit, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/attBit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attBit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attBit() directly.

    YANG Description: ATT flag of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="attBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attBit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="attBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__attBit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attBit(self):
    self.__attBit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="attBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_partitionBit(self):
    """
    Getter method for partitionBit, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/partitionBit (uint32)

    YANG Description: Split flag of an LSP.
    """
    return self.__partitionBit
      
  def _set_partitionBit(self, v, load=False):
    """
    Setter method for partitionBit, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/partitionBit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partitionBit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partitionBit() directly.

    YANG Description: Split flag of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="partitionBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partitionBit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="partitionBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__partitionBit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partitionBit(self):
    self.__partitionBit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="partitionBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_overloadBit(self):
    """
    Getter method for overloadBit, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/overloadBit (uint32)

    YANG Description: Overload flag of an LSP.
    """
    return self.__overloadBit
      
  def _set_overloadBit(self, v, load=False):
    """
    Setter method for overloadBit, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/overloadBit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_overloadBit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_overloadBit() directly.

    YANG Description: Overload flag of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="overloadBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """overloadBit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="overloadBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__overloadBit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_overloadBit(self):
    self.__overloadBit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1']}), is_leaf=True, yang_name="overloadBit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/holdTime (string)

    YANG Description: Holdtime of an LSP.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/holdTime (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Holdtime of an LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_isLocalLsp(self):
    """
    Getter method for isLocalLsp, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/isLocalLsp (boolean)

    YANG Description: Local LSP flag.
    """
    return self.__isLocalLsp
      
  def _set_isLocalLsp(self, v, load=False):
    """
    Setter method for isLocalLsp, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb/isLocalLsp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLocalLsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLocalLsp() directly.

    YANG Description: Local LSP flag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="isLocalLsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLocalLsp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isLocalLsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)""",
        })

    self.__isLocalLsp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLocalLsp(self):
    self.__isLocalLsp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="isLocalLsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=False)

  lspLevelType = __builtin__.property(_get_lspLevelType)
  lspId = __builtin__.property(_get_lspId)
  seqenceNumber = __builtin__.property(_get_seqenceNumber)
  checkSum = __builtin__.property(_get_checkSum)
  lspLength = __builtin__.property(_get_lspLength)
  attBit = __builtin__.property(_get_attBit)
  partitionBit = __builtin__.property(_get_partitionBit)
  overloadBit = __builtin__.property(_get_overloadBit)
  holdTime = __builtin__.property(_get_holdTime)
  isLocalLsp = __builtin__.property(_get_isLocalLsp)


  _pyangbind_elements = OrderedDict([('lspLevelType', lspLevelType), ('lspId', lspId), ('seqenceNumber', seqenceNumber), ('checkSum', checkSum), ('lspLength', lspLength), ('attBit', attBit), ('partitionBit', partitionBit), ('overloadBit', overloadBit), ('holdTime', holdTime), ('isLocalLsp', isLocalLsp), ])


class yc_isDispLsdbs_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispLsdbs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LSDB information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispLsdb',)

  _yang_name = 'isDispLsdbs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispLsdb = YANGDynClass(base=YANGListType("lspLevelType lspId",yc_isDispLsdb_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs_isDispLsdb, yang_name="isDispLsdb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType lspId', extensions=None), is_container='list', yang_name="isDispLsdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispLsdbs']

  def _get_isDispLsdb(self):
    """
    Getter method for isDispLsdb, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb (list)

    YANG Description: Information about the LSDB.
    """
    return self.__isDispLsdb
      
  def _set_isDispLsdb(self, v, load=False):
    """
    Setter method for isDispLsdb, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs/isDispLsdb (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispLsdb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispLsdb() directly.

    YANG Description: Information about the LSDB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lspLevelType lspId",yc_isDispLsdb_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs_isDispLsdb, yang_name="isDispLsdb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType lspId', extensions=None), is_container='list', yang_name="isDispLsdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispLsdb must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lspLevelType lspId",yc_isDispLsdb_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs_isDispLsdb, yang_name="isDispLsdb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType lspId', extensions=None), is_container='list', yang_name="isDispLsdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispLsdb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispLsdb(self):
    self.__isDispLsdb = YANGDynClass(base=YANGListType("lspLevelType lspId",yc_isDispLsdb_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs_isDispLsdb, yang_name="isDispLsdb", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType lspId', extensions=None), is_container='list', yang_name="isDispLsdb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispLsdb = __builtin__.property(_get_isDispLsdb) # type: yc_isDispLsdb_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs_isDispLsdb


  _pyangbind_elements = OrderedDict([('isDispLsdb', isDispLsdb), ])


class yc_isPeerIpv4Addr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs_isPeerIpv4Addr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs/isPeerIpv4Addr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Neighbor IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerIpv4Address',)

  _yang_name = 'isPeerIpv4Addr'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerIpv4Address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer', 'isPeerIpv4Addrs', 'isPeerIpv4Addr']

  def _get_peerIpv4Address(self):
    """
    Getter method for peerIpv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs/isPeerIpv4Addr/peerIpv4Address (inet:ipv4-address-no-zone)

    YANG Description: IPv4 address of a neighbor.
    """
    return self.__peerIpv4Address
      
  def _set_peerIpv4Address(self, v, load=False):
    """
    Setter method for peerIpv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs/isPeerIpv4Addr/peerIpv4Address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerIpv4Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerIpv4Address() directly.

    YANG Description: IPv4 address of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerIpv4Address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__peerIpv4Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerIpv4Address(self):
    self.__peerIpv4Address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)

  peerIpv4Address = __builtin__.property(_get_peerIpv4Address)


  _pyangbind_elements = OrderedDict([('peerIpv4Address', peerIpv4Address), ])


class yc_isPeerIpv4Addrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbor IPv4 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isPeerIpv4Addr',)

  _yang_name = 'isPeerIpv4Addrs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isPeerIpv4Addr = YANGDynClass(base=YANGListType("peerIpv4Address",yc_isPeerIpv4Addr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs_isPeerIpv4Addr, yang_name="isPeerIpv4Addr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerIpv4Address', extensions=None), is_container='list', yang_name="isPeerIpv4Addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer', 'isPeerIpv4Addrs']

  def _get_isPeerIpv4Addr(self):
    """
    Getter method for isPeerIpv4Addr, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs/isPeerIpv4Addr (list)

    YANG Description: Neighbor IPv4 address.
    """
    return self.__isPeerIpv4Addr
      
  def _set_isPeerIpv4Addr(self, v, load=False):
    """
    Setter method for isPeerIpv4Addr, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs/isPeerIpv4Addr (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPeerIpv4Addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPeerIpv4Addr() directly.

    YANG Description: Neighbor IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerIpv4Address",yc_isPeerIpv4Addr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs_isPeerIpv4Addr, yang_name="isPeerIpv4Addr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerIpv4Address', extensions=None), is_container='list', yang_name="isPeerIpv4Addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPeerIpv4Addr must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerIpv4Address",yc_isPeerIpv4Addr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs_isPeerIpv4Addr, yang_name="isPeerIpv4Addr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerIpv4Address', extensions=None), is_container='list', yang_name="isPeerIpv4Addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isPeerIpv4Addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPeerIpv4Addr(self):
    self.__isPeerIpv4Addr = YANGDynClass(base=YANGListType("peerIpv4Address",yc_isPeerIpv4Addr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs_isPeerIpv4Addr, yang_name="isPeerIpv4Addr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerIpv4Address', extensions=None), is_container='list', yang_name="isPeerIpv4Addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isPeerIpv4Addr = __builtin__.property(_get_isPeerIpv4Addr) # type: yc_isPeerIpv4Addr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs_isPeerIpv4Addr


  _pyangbind_elements = OrderedDict([('isPeerIpv4Addr', isPeerIpv4Addr), ])


class yc_isPeerIpv6GlbAddr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs_isPeerIpv6GlbAddr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs/isPeerIpv6GlbAddr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Neighbor IPv6 global address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6GlbAddress',)

  _yang_name = 'isPeerIpv6GlbAddr'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6GlbAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6GlbAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer', 'isPeerIpv6GlbAddrs', 'isPeerIpv6GlbAddr']

  def _get_ipv6GlbAddress(self):
    """
    Getter method for ipv6GlbAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs/isPeerIpv6GlbAddr/ipv6GlbAddress (string)

    YANG Description: IPv6 global address of a neighbor.
    """
    return self.__ipv6GlbAddress
      
  def _set_ipv6GlbAddress(self, v, load=False):
    """
    Setter method for ipv6GlbAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs/isPeerIpv6GlbAddr/ipv6GlbAddress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6GlbAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6GlbAddress() directly.

    YANG Description: IPv6 global address of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6GlbAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6GlbAddress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6GlbAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv6GlbAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6GlbAddress(self):
    self.__ipv6GlbAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="ipv6GlbAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  ipv6GlbAddress = __builtin__.property(_get_ipv6GlbAddress)


  _pyangbind_elements = OrderedDict([('ipv6GlbAddress', ipv6GlbAddress), ])


class yc_isPeerIpv6GlbAddrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbor IPv6 global addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isPeerIpv6GlbAddr',)

  _yang_name = 'isPeerIpv6GlbAddrs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isPeerIpv6GlbAddr = YANGDynClass(base=YANGListType("ipv6GlbAddress",yc_isPeerIpv6GlbAddr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs_isPeerIpv6GlbAddr, yang_name="isPeerIpv6GlbAddr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6GlbAddress', extensions=None), is_container='list', yang_name="isPeerIpv6GlbAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer', 'isPeerIpv6GlbAddrs']

  def _get_isPeerIpv6GlbAddr(self):
    """
    Getter method for isPeerIpv6GlbAddr, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs/isPeerIpv6GlbAddr (list)

    YANG Description: Neighbor IPv6 global address.
    """
    return self.__isPeerIpv6GlbAddr
      
  def _set_isPeerIpv6GlbAddr(self, v, load=False):
    """
    Setter method for isPeerIpv6GlbAddr, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs/isPeerIpv6GlbAddr (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPeerIpv6GlbAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPeerIpv6GlbAddr() directly.

    YANG Description: Neighbor IPv6 global address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv6GlbAddress",yc_isPeerIpv6GlbAddr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs_isPeerIpv6GlbAddr, yang_name="isPeerIpv6GlbAddr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6GlbAddress', extensions=None), is_container='list', yang_name="isPeerIpv6GlbAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPeerIpv6GlbAddr must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv6GlbAddress",yc_isPeerIpv6GlbAddr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs_isPeerIpv6GlbAddr, yang_name="isPeerIpv6GlbAddr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6GlbAddress', extensions=None), is_container='list', yang_name="isPeerIpv6GlbAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isPeerIpv6GlbAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPeerIpv6GlbAddr(self):
    self.__isPeerIpv6GlbAddr = YANGDynClass(base=YANGListType("ipv6GlbAddress",yc_isPeerIpv6GlbAddr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs_isPeerIpv6GlbAddr, yang_name="isPeerIpv6GlbAddr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv6GlbAddress', extensions=None), is_container='list', yang_name="isPeerIpv6GlbAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isPeerIpv6GlbAddr = __builtin__.property(_get_isPeerIpv6GlbAddr) # type: yc_isPeerIpv6GlbAddr_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs_isPeerIpv6GlbAddr


  _pyangbind_elements = OrderedDict([('isPeerIpv6GlbAddr', isPeerIpv6GlbAddr), ])


class yc_isEndXSid_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids_isEndXSid(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Neighbor End.X Sid information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__endXSid','__maskLength','__type',)

  _yang_name = 'isEndXSid'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__endXSid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=False)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer', 'isEndXSids', 'isEndXSid']

  def _get_endXSid(self):
    """
    Getter method for endXSid, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid/endXSid (inet:ipv6-address-no-zone)

    YANG Description: End.X Sid of a neighbor.
    """
    return self.__endXSid
      
  def _set_endXSid(self, v, load=False):
    """
    Setter method for endXSid, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid/endXSid (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endXSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endXSid() directly.

    YANG Description: End.X Sid of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endXSid must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__endXSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endXSid(self):
    self.__endXSid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="endXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_maskLength(self):
    """
    Getter method for maskLength, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid/maskLength (uint16)

    YANG Description: End.X Sid mask length of a neighbor.
    """
    return self.__maskLength
      
  def _set_maskLength(self, v, load=False):
    """
    Setter method for maskLength, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid/maskLength (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maskLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maskLength() directly.

    YANG Description: End.X Sid mask length of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maskLength must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=False)""",
        })

    self.__maskLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maskLength(self):
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid/type (string)

    YANG Description: End.X Sid type of a neighbor.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: End.X Sid type of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  endXSid = __builtin__.property(_get_endXSid)
  maskLength = __builtin__.property(_get_maskLength)
  type = __builtin__.property(_get_type)


  _pyangbind_elements = OrderedDict([('endXSid', endXSid), ('maskLength', maskLength), ('type', type), ])


class yc_isEndXSids_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbor End.X Sid information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isEndXSid',)

  _yang_name = 'isEndXSids'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isEndXSid = YANGDynClass(base=YANGListType("endXSid maskLength type",yc_isEndXSid_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids_isEndXSid, yang_name="isEndXSid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSid maskLength type', extensions=None), is_container='list', yang_name="isEndXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer', 'isEndXSids']

  def _get_isEndXSid(self):
    """
    Getter method for isEndXSid, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid (list)

    YANG Description: Neighbor End.X Sid information.
    """
    return self.__isEndXSid
      
  def _set_isEndXSid(self, v, load=False):
    """
    Setter method for isEndXSid, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids/isEndXSid (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isEndXSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isEndXSid() directly.

    YANG Description: Neighbor End.X Sid information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("endXSid maskLength type",yc_isEndXSid_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids_isEndXSid, yang_name="isEndXSid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSid maskLength type', extensions=None), is_container='list', yang_name="isEndXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isEndXSid must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("endXSid maskLength type",yc_isEndXSid_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids_isEndXSid, yang_name="isEndXSid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSid maskLength type', extensions=None), is_container='list', yang_name="isEndXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isEndXSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isEndXSid(self):
    self.__isEndXSid = YANGDynClass(base=YANGListType("endXSid maskLength type",yc_isEndXSid_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids_isEndXSid, yang_name="isEndXSid", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='endXSid maskLength type', extensions=None), is_container='list', yang_name="isEndXSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isEndXSid = __builtin__.property(_get_isEndXSid) # type: yc_isEndXSid_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids_isEndXSid


  _pyangbind_elements = OrderedDict([('isEndXSid', isEndXSid), ])


class yc_isDispPeer_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers/isDispPeer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IS-IS neighbor information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerSystemId','__levelType','__circuitId','__interfaceName','__hostName','__status','__holdTime','__priority','__areaAddress','__upTime','__upTimeStamp','__adjMtId','__localMtId','__protocol','__restartCapable','__suppressedAdj','__adjSid','__peerIpv6Address','__isPeerIpv4Addrs','__isPeerIpv6GlbAddrs','__isEndXSids',)

  _yang_name = 'isDispPeer'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerSystemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="peerSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__circuitId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..260']}), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__interfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__hostName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__areaAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..120']}), is_leaf=True, yang_name="areaAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__upTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..30']}), is_leaf=True, yang_name="upTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__upTimeStamp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="upTimeStamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='yang:date-and-time', is_config=False)
    self.__adjMtId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__localMtId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..200']}), is_leaf=True, yang_name="localMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__restartCapable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="restartCapable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__suppressedAdj = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="suppressedAdj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__adjSid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__peerIpv6Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="peerIpv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__isPeerIpv4Addrs = YANGDynClass(base=yc_isPeerIpv4Addrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs, is_container='container', yang_name="isPeerIpv4Addrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)
    self.__isPeerIpv6GlbAddrs = YANGDynClass(base=yc_isPeerIpv6GlbAddrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs, is_container='container', yang_name="isPeerIpv6GlbAddrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)
    self.__isEndXSids = YANGDynClass(base=yc_isEndXSids_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids, is_container='container', yang_name="isEndXSids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers', 'isDispPeer']

  def _get_peerSystemId(self):
    """
    Getter method for peerSystemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/peerSystemId (string)

    YANG Description: Neighbor system ID.
    """
    return self.__peerSystemId
      
  def _set_peerSystemId(self, v, load=False):
    """
    Setter method for peerSystemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/peerSystemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerSystemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerSystemId() directly.

    YANG Description: Neighbor system ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="peerSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerSystemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="peerSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__peerSystemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerSystemId(self):
    self.__peerSystemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="peerSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/levelType (string)

    YANG Description: Level type of a neighbor: level-1, level-2, or level-1-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type of a neighbor: level-1, level-2, or level-1-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_circuitId(self):
    """
    Getter method for circuitId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/circuitId (string)

    YANG Description: Interface ID of a neighbor.
    """
    return self.__circuitId
      
  def _set_circuitId(self, v, load=False):
    """
    Setter method for circuitId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/circuitId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitId() directly.

    YANG Description: Interface ID of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..260']}), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..260']}), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__circuitId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitId(self):
    self.__circuitId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..260']}), is_leaf=True, yang_name="circuitId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_interfaceName(self):
    """
    Getter method for interfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/interfaceName (string)

    YANG Description: Interface name of a neighbor.
    """
    return self.__interfaceName
      
  def _set_interfaceName(self, v, load=False):
    """
    Setter method for interfaceName, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/interfaceName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaceName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaceName() directly.

    YANG Description: Interface name of a neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaceName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__interfaceName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaceName(self):
    self.__interfaceName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="interfaceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_hostName(self):
    """
    Getter method for hostName, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/hostName (string)

    YANG Description: System name of a neighbor.
    """
    return self.__hostName
      
  def _set_hostName(self, v, load=False):
    """
    Setter method for hostName, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/hostName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostName() directly.

    YANG Description: System name of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__hostName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostName(self):
    self.__hostName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/status (string)

    YANG Description: Status of a neighbor.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Status of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_holdTime(self):
    """
    Getter method for holdTime, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/holdTime (uint32)

    YANG Description: Holdtime of a neighbor.
    """
    return self.__holdTime
      
  def _set_holdTime(self, v, load=False):
    """
    Setter method for holdTime, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/holdTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdTime() directly.

    YANG Description: Holdtime of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__holdTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdTime(self):
    self.__holdTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="holdTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/priority (string)

    YANG Description: Priority of a neighbor.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/priority (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Priority of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..4']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_areaAddress(self):
    """
    Getter method for areaAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/areaAddress (string)

    YANG Description: Area address of a neighbor.
    """
    return self.__areaAddress
      
  def _set_areaAddress(self, v, load=False):
    """
    Setter method for areaAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/areaAddress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_areaAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_areaAddress() directly.

    YANG Description: Area address of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..120']}), is_leaf=True, yang_name="areaAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """areaAddress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..120']}), is_leaf=True, yang_name="areaAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__areaAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_areaAddress(self):
    self.__areaAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..120']}), is_leaf=True, yang_name="areaAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_upTime(self):
    """
    Getter method for upTime, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/upTime (string)

    YANG Description: Up time of a neighbor.
    """
    return self.__upTime
      
  def _set_upTime(self, v, load=False):
    """
    Setter method for upTime, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/upTime (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upTime() directly.

    YANG Description: Up time of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..30']}), is_leaf=True, yang_name="upTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upTime must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..30']}), is_leaf=True, yang_name="upTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__upTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upTime(self):
    self.__upTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..30']}), is_leaf=True, yang_name="upTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_upTimeStamp(self):
    """
    Getter method for upTimeStamp, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/upTimeStamp (yang:date-and-time)

    YANG Description: Up time stamp of a neighbor.
    """
    return self.__upTimeStamp
      
  def _set_upTimeStamp(self, v, load=False):
    """
    Setter method for upTimeStamp, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/upTimeStamp (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upTimeStamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upTimeStamp() directly.

    YANG Description: Up time stamp of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="upTimeStamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upTimeStamp must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="upTimeStamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__upTimeStamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upTimeStamp(self):
    self.__upTimeStamp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="upTimeStamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='yang:date-and-time', is_config=False)


  def _get_adjMtId(self):
    """
    Getter method for adjMtId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/adjMtId (string)

    YANG Description: Neighbor MT ID.
    """
    return self.__adjMtId
      
  def _set_adjMtId(self, v, load=False):
    """
    Setter method for adjMtId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/adjMtId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjMtId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjMtId() directly.

    YANG Description: Neighbor MT ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjMtId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__adjMtId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjMtId(self):
    self.__adjMtId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_localMtId(self):
    """
    Getter method for localMtId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/localMtId (string)

    YANG Description: Local MT ID.
    """
    return self.__localMtId
      
  def _set_localMtId(self, v, load=False):
    """
    Setter method for localMtId, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/localMtId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localMtId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localMtId() directly.

    YANG Description: Local MT ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..200']}), is_leaf=True, yang_name="localMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localMtId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..200']}), is_leaf=True, yang_name="localMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__localMtId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localMtId(self):
    self.__localMtId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..200']}), is_leaf=True, yang_name="localMtId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/protocol (string)

    YANG Description: Neighbor's supported IP protocols.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Neighbor's supported IP protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_restartCapable(self):
    """
    Getter method for restartCapable, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/restartCapable (string)

    YANG Description: Restart setting.
    """
    return self.__restartCapable
      
  def _set_restartCapable(self, v, load=False):
    """
    Setter method for restartCapable, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/restartCapable (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restartCapable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restartCapable() directly.

    YANG Description: Restart setting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="restartCapable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restartCapable must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="restartCapable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__restartCapable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restartCapable(self):
    self.__restartCapable = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="restartCapable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_suppressedAdj(self):
    """
    Getter method for suppressedAdj, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/suppressedAdj (string)

    YANG Description: Suppress advertise adjacency setting.
    """
    return self.__suppressedAdj
      
  def _set_suppressedAdj(self, v, load=False):
    """
    Setter method for suppressedAdj, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/suppressedAdj (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppressedAdj is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppressedAdj() directly.

    YANG Description: Suppress advertise adjacency setting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="suppressedAdj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppressedAdj must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="suppressedAdj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__suppressedAdj = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppressedAdj(self):
    self.__suppressedAdj = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..5']}), is_leaf=True, yang_name="suppressedAdj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_adjSid(self):
    """
    Getter method for adjSid, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/adjSid (string)

    YANG Description: Neighbor SID.
    """
    return self.__adjSid
      
  def _set_adjSid(self, v, load=False):
    """
    Setter method for adjSid, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/adjSid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjSid() directly.

    YANG Description: Neighbor SID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjSid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__adjSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjSid(self):
    self.__adjSid = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="adjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_peerIpv6Address(self):
    """
    Getter method for peerIpv6Address, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/peerIpv6Address (string)

    YANG Description: Neighbor IPV6 link-local address.
    """
    return self.__peerIpv6Address
      
  def _set_peerIpv6Address(self, v, load=False):
    """
    Setter method for peerIpv6Address, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/peerIpv6Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerIpv6Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerIpv6Address() directly.

    YANG Description: Neighbor IPV6 link-local address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="peerIpv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerIpv6Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="peerIpv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__peerIpv6Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerIpv6Address(self):
    self.__peerIpv6Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..60']}), is_leaf=True, yang_name="peerIpv6Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_isPeerIpv4Addrs(self):
    """
    Getter method for isPeerIpv4Addrs, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs (container)

    YANG Description: List of neighbor IPv4 addresses.
    """
    return self.__isPeerIpv4Addrs
      
  def _set_isPeerIpv4Addrs(self, v, load=False):
    """
    Setter method for isPeerIpv4Addrs, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv4Addrs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPeerIpv4Addrs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPeerIpv4Addrs() directly.

    YANG Description: List of neighbor IPv4 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isPeerIpv4Addrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs, is_container='container', yang_name="isPeerIpv4Addrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPeerIpv4Addrs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isPeerIpv4Addrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs, is_container='container', yang_name="isPeerIpv4Addrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)""",
        })

    self.__isPeerIpv4Addrs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPeerIpv4Addrs(self):
    self.__isPeerIpv4Addrs = YANGDynClass(base=yc_isPeerIpv4Addrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs, is_container='container', yang_name="isPeerIpv4Addrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)


  def _get_isPeerIpv6GlbAddrs(self):
    """
    Getter method for isPeerIpv6GlbAddrs, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs (container)

    YANG Description: List of neighbor IPv6 global addresses.
    """
    return self.__isPeerIpv6GlbAddrs
      
  def _set_isPeerIpv6GlbAddrs(self, v, load=False):
    """
    Setter method for isPeerIpv6GlbAddrs, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isPeerIpv6GlbAddrs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isPeerIpv6GlbAddrs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isPeerIpv6GlbAddrs() directly.

    YANG Description: List of neighbor IPv6 global addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isPeerIpv6GlbAddrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs, is_container='container', yang_name="isPeerIpv6GlbAddrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isPeerIpv6GlbAddrs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isPeerIpv6GlbAddrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs, is_container='container', yang_name="isPeerIpv6GlbAddrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)""",
        })

    self.__isPeerIpv6GlbAddrs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isPeerIpv6GlbAddrs(self):
    self.__isPeerIpv6GlbAddrs = YANGDynClass(base=yc_isPeerIpv6GlbAddrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs, is_container='container', yang_name="isPeerIpv6GlbAddrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)


  def _get_isEndXSids(self):
    """
    Getter method for isEndXSids, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids (container)

    YANG Description: List of neighbor End.X Sid information.
    """
    return self.__isEndXSids
      
  def _set_isEndXSids(self, v, load=False):
    """
    Setter method for isEndXSids, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer/isEndXSids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isEndXSids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isEndXSids() directly.

    YANG Description: List of neighbor End.X Sid information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isEndXSids_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids, is_container='container', yang_name="isEndXSids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isEndXSids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isEndXSids_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids, is_container='container', yang_name="isEndXSids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)""",
        })

    self.__isEndXSids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isEndXSids(self):
    self.__isEndXSids = YANGDynClass(base=yc_isEndXSids_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids, is_container='container', yang_name="isEndXSids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=False)

  peerSystemId = __builtin__.property(_get_peerSystemId)
  levelType = __builtin__.property(_get_levelType)
  circuitId = __builtin__.property(_get_circuitId)
  interfaceName = __builtin__.property(_get_interfaceName)
  hostName = __builtin__.property(_get_hostName)
  status = __builtin__.property(_get_status)
  holdTime = __builtin__.property(_get_holdTime)
  priority = __builtin__.property(_get_priority)
  areaAddress = __builtin__.property(_get_areaAddress)
  upTime = __builtin__.property(_get_upTime)
  upTimeStamp = __builtin__.property(_get_upTimeStamp)
  adjMtId = __builtin__.property(_get_adjMtId)
  localMtId = __builtin__.property(_get_localMtId)
  protocol = __builtin__.property(_get_protocol)
  restartCapable = __builtin__.property(_get_restartCapable)
  suppressedAdj = __builtin__.property(_get_suppressedAdj)
  adjSid = __builtin__.property(_get_adjSid)
  peerIpv6Address = __builtin__.property(_get_peerIpv6Address)
  isPeerIpv4Addrs = __builtin__.property(_get_isPeerIpv4Addrs) # type: yc_isPeerIpv4Addrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv4Addrs
  isPeerIpv6GlbAddrs = __builtin__.property(_get_isPeerIpv6GlbAddrs) # type: yc_isPeerIpv6GlbAddrs_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isPeerIpv6GlbAddrs
  isEndXSids = __builtin__.property(_get_isEndXSids) # type: yc_isEndXSids_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer_isEndXSids


  _pyangbind_elements = OrderedDict([('peerSystemId', peerSystemId), ('levelType', levelType), ('circuitId', circuitId), ('interfaceName', interfaceName), ('hostName', hostName), ('status', status), ('holdTime', holdTime), ('priority', priority), ('areaAddress', areaAddress), ('upTime', upTime), ('upTimeStamp', upTimeStamp), ('adjMtId', adjMtId), ('localMtId', localMtId), ('protocol', protocol), ('restartCapable', restartCapable), ('suppressedAdj', suppressedAdj), ('adjSid', adjSid), ('peerIpv6Address', peerIpv6Address), ('isPeerIpv4Addrs', isPeerIpv4Addrs), ('isPeerIpv6GlbAddrs', isPeerIpv6GlbAddrs), ('isEndXSids', isEndXSids), ])


class yc_isDispPeers_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispPeers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbor information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispPeer',)

  _yang_name = 'isDispPeers'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispPeer = YANGDynClass(base=YANGListType("peerSystemId levelType circuitId interfaceName",yc_isDispPeer_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer, yang_name="isDispPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSystemId levelType circuitId interfaceName', extensions=None), is_container='list', yang_name="isDispPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispPeers']

  def _get_isDispPeer(self):
    """
    Getter method for isDispPeer, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer (list)

    YANG Description: IS-IS neighbor information.
    """
    return self.__isDispPeer
      
  def _set_isDispPeer(self, v, load=False):
    """
    Setter method for isDispPeer, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers/isDispPeer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispPeer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispPeer() directly.

    YANG Description: IS-IS neighbor information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerSystemId levelType circuitId interfaceName",yc_isDispPeer_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer, yang_name="isDispPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSystemId levelType circuitId interfaceName', extensions=None), is_container='list', yang_name="isDispPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispPeer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerSystemId levelType circuitId interfaceName",yc_isDispPeer_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer, yang_name="isDispPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSystemId levelType circuitId interfaceName', extensions=None), is_container='list', yang_name="isDispPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispPeer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispPeer(self):
    self.__isDispPeer = YANGDynClass(base=YANGListType("peerSystemId levelType circuitId interfaceName",yc_isDispPeer_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer, yang_name="isDispPeer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerSystemId levelType circuitId interfaceName', extensions=None), is_container='list', yang_name="isDispPeer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispPeer = __builtin__.property(_get_isDispPeer) # type: yc_isDispPeer_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers_isDispPeer


  _pyangbind_elements = OrderedDict([('isDispPeer', isDispPeer), ])


class yc_isDispCirc_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs_isDispCirc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispCircs/isDispCirc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IS-IS circuit information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifName','__ipv4L1Cost','__ipv4L2Cost','__ipv6L1Cost','__ipv6L2Cost',)

  _yang_name = 'isDispCirc'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__ipv4L1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__ipv4L2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__ipv6L1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__ipv6L2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispCircs', 'isDispCirc']

  def _get_ifName(self):
    """
    Getter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ifName (string)

    YANG Description: Name of the circuit.
    """
    return self.__ifName
      
  def _set_ifName(self, v, load=False):
    """
    Setter method for ifName, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ifName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifName() directly.

    YANG Description: Name of the circuit.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ifName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifName(self):
    self.__ifName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="ifName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_ipv4L1Cost(self):
    """
    Getter method for ipv4L1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv4L1Cost (uint32)

    YANG Description: Level1 Cost Of Ipv4.
    """
    return self.__ipv4L1Cost
      
  def _set_ipv4L1Cost(self, v, load=False):
    """
    Setter method for ipv4L1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv4L1Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4L1Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4L1Cost() directly.

    YANG Description: Level1 Cost Of Ipv4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4L1Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv4L1Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4L1Cost(self):
    self.__ipv4L1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_ipv4L2Cost(self):
    """
    Getter method for ipv4L2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv4L2Cost (uint32)

    YANG Description: Level2 Cost Of Ipv4.
    """
    return self.__ipv4L2Cost
      
  def _set_ipv4L2Cost(self, v, load=False):
    """
    Setter method for ipv4L2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv4L2Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4L2Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4L2Cost() directly.

    YANG Description: Level2 Cost Of Ipv4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4L2Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv4L2Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4L2Cost(self):
    self.__ipv4L2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv4L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_ipv6L1Cost(self):
    """
    Getter method for ipv6L1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv6L1Cost (uint32)

    YANG Description: Level1 Cost Of Ipv6.
    """
    return self.__ipv6L1Cost
      
  def _set_ipv6L1Cost(self, v, load=False):
    """
    Setter method for ipv6L1Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv6L1Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6L1Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6L1Cost() directly.

    YANG Description: Level1 Cost Of Ipv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6L1Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv6L1Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6L1Cost(self):
    self.__ipv6L1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_ipv6L2Cost(self):
    """
    Getter method for ipv6L2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv6L2Cost (uint32)

    YANG Description: Level2 Cost Of Ipv6.
    """
    return self.__ipv6L2Cost
      
  def _set_ipv6L2Cost(self, v, load=False):
    """
    Setter method for ipv6L2Cost, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc/ipv6L2Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6L2Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6L2Cost() directly.

    YANG Description: Level2 Cost Of Ipv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6L2Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__ipv6L2Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6L2Cost(self):
    self.__ipv6L2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777215']}), is_leaf=True, yang_name="ipv6L2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

  ifName = __builtin__.property(_get_ifName)
  ipv4L1Cost = __builtin__.property(_get_ipv4L1Cost)
  ipv4L2Cost = __builtin__.property(_get_ipv4L2Cost)
  ipv6L1Cost = __builtin__.property(_get_ipv6L1Cost)
  ipv6L2Cost = __builtin__.property(_get_ipv6L2Cost)


  _pyangbind_elements = OrderedDict([('ifName', ifName), ('ipv4L1Cost', ipv4L1Cost), ('ipv4L2Cost', ipv4L2Cost), ('ipv6L1Cost', ipv6L1Cost), ('ipv6L2Cost', ipv6L2Cost), ])


class yc_isDispCircs_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispCircs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of circuit information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispCirc',)

  _yang_name = 'isDispCircs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispCirc = YANGDynClass(base=YANGListType("ifName",yc_isDispCirc_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs_isDispCirc, yang_name="isDispCirc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isDispCirc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispCircs']

  def _get_isDispCirc(self):
    """
    Getter method for isDispCirc, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc (list)

    YANG Description: IS-IS circuit information.
    """
    return self.__isDispCirc
      
  def _set_isDispCirc(self, v, load=False):
    """
    Setter method for isDispCirc, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs/isDispCirc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispCirc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispCirc() directly.

    YANG Description: IS-IS circuit information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ifName",yc_isDispCirc_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs_isDispCirc, yang_name="isDispCirc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isDispCirc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispCirc must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ifName",yc_isDispCirc_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs_isDispCirc, yang_name="isDispCirc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isDispCirc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispCirc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispCirc(self):
    self.__isDispCirc = YANGDynClass(base=YANGListType("ifName",yc_isDispCirc_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs_isDispCirc, yang_name="isDispCirc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ifName', extensions=None), is_container='list', yang_name="isDispCirc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispCirc = __builtin__.property(_get_isDispCirc) # type: yc_isDispCirc_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs_isDispCirc


  _pyangbind_elements = OrderedDict([('isDispCirc', isDispCirc), ])


class yc_isDispLspStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss_isDispLspStatistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LSP statistics (local LSP statistics in an IS-IS process). 
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__systemId','__usedFragsNumber',)

  _yang_name = 'isDispLspStatistics'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__usedFragsNumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="usedFragsNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispLspStatisticss', 'isDispLspStatistics']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics/levelType (string)

    YANG Description: Level type: level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Level type: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_systemId(self):
    """
    Getter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics/systemId (string)

    YANG Description: System ID.
    """
    return self.__systemId
      
  def _set_systemId(self, v, load=False):
    """
    Setter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics/systemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_systemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_systemId() directly.

    YANG Description: System ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """systemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__systemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_systemId(self):
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_usedFragsNumber(self):
    """
    Getter method for usedFragsNumber, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics/usedFragsNumber (uint32)

    YANG Description: Number of fragments.
    """
    return self.__usedFragsNumber
      
  def _set_usedFragsNumber(self, v, load=False):
    """
    Setter method for usedFragsNumber, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics/usedFragsNumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_usedFragsNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_usedFragsNumber() directly.

    YANG Description: Number of fragments.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="usedFragsNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """usedFragsNumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="usedFragsNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__usedFragsNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_usedFragsNumber(self):
    self.__usedFragsNumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="usedFragsNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  systemId = __builtin__.property(_get_systemId)
  usedFragsNumber = __builtin__.property(_get_usedFragsNumber)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('systemId', systemId), ('usedFragsNumber', usedFragsNumber), ])


class yc_isDispLspStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispLspStatisticss. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LSP statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispLspStatistics',)

  _yang_name = 'isDispLspStatisticss'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispLspStatistics = YANGDynClass(base=YANGListType("levelType systemId",yc_isDispLspStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss_isDispLspStatistics, yang_name="isDispLspStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType systemId', extensions=None), is_container='list', yang_name="isDispLspStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispLspStatisticss']

  def _get_isDispLspStatistics(self):
    """
    Getter method for isDispLspStatistics, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics (list)

    YANG Description: LSP statistics (local LSP statistics in an IS-IS process). 
    """
    return self.__isDispLspStatistics
      
  def _set_isDispLspStatistics(self, v, load=False):
    """
    Setter method for isDispLspStatistics, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss/isDispLspStatistics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispLspStatistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispLspStatistics() directly.

    YANG Description: LSP statistics (local LSP statistics in an IS-IS process). 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType systemId",yc_isDispLspStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss_isDispLspStatistics, yang_name="isDispLspStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType systemId', extensions=None), is_container='list', yang_name="isDispLspStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispLspStatistics must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType systemId",yc_isDispLspStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss_isDispLspStatistics, yang_name="isDispLspStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType systemId', extensions=None), is_container='list', yang_name="isDispLspStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispLspStatistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispLspStatistics(self):
    self.__isDispLspStatistics = YANGDynClass(base=YANGListType("levelType systemId",yc_isDispLspStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss_isDispLspStatistics, yang_name="isDispLspStatistics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType systemId', extensions=None), is_container='list', yang_name="isDispLspStatistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispLspStatistics = __builtin__.property(_get_isDispLspStatistics) # type: yc_isDispLspStatistics_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss_isDispLspStatistics


  _pyangbind_elements = OrderedDict([('isDispLspStatistics', isDispLspStatistics), ])


class yc_isDispBfdSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions_isDispBfdSession(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about a BFD session.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerLevelType','__peerIpAddress','__localIpAddress','__bfdState','__bfdMinTx','__bfdMinRx','__bfdMulNumber','__systemId','__circuitName',)

  _yang_name = 'isDispBfdSession'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__peerIpAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)
    self.__localIpAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)
    self.__bfdState = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__bfdMinTx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__bfdMinRx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__bfdMulNumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMulNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__circuitName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispBfdSessions', 'isDispBfdSession']

  def _get_peerLevelType(self):
    """
    Getter method for peerLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/peerLevelType (string)

    YANG Description: Level type of the neighbor: level-1 or level-2. 
    """
    return self.__peerLevelType
      
  def _set_peerLevelType(self, v, load=False):
    """
    Setter method for peerLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/peerLevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerLevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerLevelType() directly.

    YANG Description: Level type of the neighbor: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerLevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__peerLevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerLevelType(self):
    self.__peerLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_peerIpAddress(self):
    """
    Getter method for peerIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/peerIpAddress (inet:ip-address-no-zone)

    YANG Description: IP address of the neighbor interface.
    """
    return self.__peerIpAddress
      
  def _set_peerIpAddress(self, v, load=False):
    """
    Setter method for peerIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/peerIpAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerIpAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerIpAddress() directly.

    YANG Description: IP address of the neighbor interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerIpAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)""",
        })

    self.__peerIpAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerIpAddress(self):
    self.__peerIpAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)


  def _get_localIpAddress(self):
    """
    Getter method for localIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/localIpAddress (inet:ip-address-no-zone)

    YANG Description: IP address of the local interface.
    """
    return self.__localIpAddress
      
  def _set_localIpAddress(self, v, load=False):
    """
    Setter method for localIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/localIpAddress (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIpAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIpAddress() directly.

    YANG Description: IP address of the local interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIpAddress must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)""",
        })

    self.__localIpAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIpAddress(self):
    self.__localIpAddress = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ip-address-no-zone', is_config=False)


  def _get_bfdState(self):
    """
    Getter method for bfdState, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdState (string)

    YANG Description: BFD status of a session.
    """
    return self.__bfdState
      
  def _set_bfdState(self, v, load=False):
    """
    Setter method for bfdState, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdState() directly.

    YANG Description: BFD status of a session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__bfdState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdState(self):
    self.__bfdState = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_bfdMinTx(self):
    """
    Getter method for bfdMinTx, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdMinTx (uint32)

    YANG Description: Minimum interval at which BFD packets are sent after negotiation.
    """
    return self.__bfdMinTx
      
  def _set_bfdMinTx(self, v, load=False):
    """
    Setter method for bfdMinTx, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdMinTx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMinTx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMinTx() directly.

    YANG Description: Minimum interval at which BFD packets are sent after negotiation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMinTx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__bfdMinTx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMinTx(self):
    self.__bfdMinTx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinTx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_bfdMinRx(self):
    """
    Getter method for bfdMinRx, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdMinRx (uint32)

    YANG Description: Minimum interval at which BFD packets are received after negotiation.
    """
    return self.__bfdMinRx
      
  def _set_bfdMinRx(self, v, load=False):
    """
    Setter method for bfdMinRx, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdMinRx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMinRx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMinRx() directly.

    YANG Description: Minimum interval at which BFD packets are received after negotiation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMinRx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__bfdMinRx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMinRx(self):
    self.__bfdMinRx = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMinRx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_bfdMulNumber(self):
    """
    Getter method for bfdMulNumber, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdMulNumber (uint32)

    YANG Description: Remote BFD detection multiplier.
    """
    return self.__bfdMulNumber
      
  def _set_bfdMulNumber(self, v, load=False):
    """
    Setter method for bfdMulNumber, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/bfdMulNumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdMulNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdMulNumber() directly.

    YANG Description: Remote BFD detection multiplier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMulNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdMulNumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMulNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__bfdMulNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdMulNumber(self):
    self.__bfdMulNumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bfdMulNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_systemId(self):
    """
    Getter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/systemId (string)

    YANG Description: System ID of the neighbor.
    """
    return self.__systemId
      
  def _set_systemId(self, v, load=False):
    """
    Setter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/systemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_systemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_systemId() directly.

    YANG Description: System ID of the neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """systemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__systemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_systemId(self):
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_circuitName(self):
    """
    Getter method for circuitName, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/circuitName (string)

    YANG Description: Interface name.
    """
    return self.__circuitName
      
  def _set_circuitName(self, v, load=False):
    """
    Setter method for circuitName, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession/circuitName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitName() directly.

    YANG Description: Interface name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__circuitName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitName(self):
    self.__circuitName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  peerLevelType = __builtin__.property(_get_peerLevelType)
  peerIpAddress = __builtin__.property(_get_peerIpAddress)
  localIpAddress = __builtin__.property(_get_localIpAddress)
  bfdState = __builtin__.property(_get_bfdState)
  bfdMinTx = __builtin__.property(_get_bfdMinTx)
  bfdMinRx = __builtin__.property(_get_bfdMinRx)
  bfdMulNumber = __builtin__.property(_get_bfdMulNumber)
  systemId = __builtin__.property(_get_systemId)
  circuitName = __builtin__.property(_get_circuitName)


  _pyangbind_elements = OrderedDict([('peerLevelType', peerLevelType), ('peerIpAddress', peerIpAddress), ('localIpAddress', localIpAddress), ('bfdState', bfdState), ('bfdMinTx', bfdMinTx), ('bfdMinRx', bfdMinRx), ('bfdMulNumber', bfdMulNumber), ('systemId', systemId), ('circuitName', circuitName), ])


class yc_isDispBfdSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispBfdSessions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BFD session information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispBfdSession',)

  _yang_name = 'isDispBfdSessions'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispBfdSession = YANGDynClass(base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions_isDispBfdSession, yang_name="isDispBfdSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispBfdSessions']

  def _get_isDispBfdSession(self):
    """
    Getter method for isDispBfdSession, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession (list)

    YANG Description: Information about a BFD session.
    """
    return self.__isDispBfdSession
      
  def _set_isDispBfdSession(self, v, load=False):
    """
    Setter method for isDispBfdSession, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions/isDispBfdSession (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispBfdSession is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispBfdSession() directly.

    YANG Description: Information about a BFD session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions_isDispBfdSession, yang_name="isDispBfdSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispBfdSession must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions_isDispBfdSession, yang_name="isDispBfdSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispBfdSession = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispBfdSession(self):
    self.__isDispBfdSession = YANGDynClass(base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions_isDispBfdSession, yang_name="isDispBfdSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispBfdSession = __builtin__.property(_get_isDispBfdSession) # type: yc_isDispBfdSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions_isDispBfdSession


  _pyangbind_elements = OrderedDict([('isDispBfdSession', isDispBfdSession), ])


class yc_isDispBfdBitErrSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions_isDispBfdBitErrSession(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about a BFD bit-error session.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peerLevelType','__peerIpAddress','__localIpAddress','__bfdState','__systemId','__circuitName',)

  _yang_name = 'isDispBfdBitErrSession'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peerLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__peerIpAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__localIpAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__bfdState = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__circuitName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispBfdBitErrSessions', 'isDispBfdBitErrSession']

  def _get_peerLevelType(self):
    """
    Getter method for peerLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/peerLevelType (string)

    YANG Description: Level type of the neighbor: level-1 or level-2. 
    """
    return self.__peerLevelType
      
  def _set_peerLevelType(self, v, load=False):
    """
    Setter method for peerLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/peerLevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerLevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerLevelType() directly.

    YANG Description: Level type of the neighbor: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerLevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__peerLevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerLevelType(self):
    self.__peerLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peerLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_peerIpAddress(self):
    """
    Getter method for peerIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/peerIpAddress (inet:ipv4-address-no-zone)

    YANG Description: IP address of the neighbor interface.
    """
    return self.__peerIpAddress
      
  def _set_peerIpAddress(self, v, load=False):
    """
    Setter method for peerIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/peerIpAddress (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerIpAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerIpAddress() directly.

    YANG Description: IP address of the neighbor interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerIpAddress must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__peerIpAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerIpAddress(self):
    self.__peerIpAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peerIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_localIpAddress(self):
    """
    Getter method for localIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/localIpAddress (inet:ipv4-address-no-zone)

    YANG Description: IP address of the local interface.
    """
    return self.__localIpAddress
      
  def _set_localIpAddress(self, v, load=False):
    """
    Setter method for localIpAddress, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/localIpAddress (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localIpAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localIpAddress() directly.

    YANG Description: IP address of the local interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localIpAddress must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__localIpAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localIpAddress(self):
    self.__localIpAddress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="localIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_bfdState(self):
    """
    Getter method for bfdState, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/bfdState (string)

    YANG Description: BFD bit-error status of a session.
    """
    return self.__bfdState
      
  def _set_bfdState(self, v, load=False):
    """
    Setter method for bfdState, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/bfdState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfdState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfdState() directly.

    YANG Description: BFD bit-error status of a session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfdState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__bfdState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfdState(self):
    self.__bfdState = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bfdState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_systemId(self):
    """
    Getter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/systemId (string)

    YANG Description: System ID of the neighbor.
    """
    return self.__systemId
      
  def _set_systemId(self, v, load=False):
    """
    Setter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/systemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_systemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_systemId() directly.

    YANG Description: System ID of the neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """systemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__systemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_systemId(self):
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_circuitName(self):
    """
    Getter method for circuitName, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/circuitName (string)

    YANG Description: Interface name.
    """
    return self.__circuitName
      
  def _set_circuitName(self, v, load=False):
    """
    Setter method for circuitName, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession/circuitName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuitName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuitName() directly.

    YANG Description: Interface name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuitName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__circuitName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuitName(self):
    self.__circuitName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="circuitName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  peerLevelType = __builtin__.property(_get_peerLevelType)
  peerIpAddress = __builtin__.property(_get_peerIpAddress)
  localIpAddress = __builtin__.property(_get_localIpAddress)
  bfdState = __builtin__.property(_get_bfdState)
  systemId = __builtin__.property(_get_systemId)
  circuitName = __builtin__.property(_get_circuitName)


  _pyangbind_elements = OrderedDict([('peerLevelType', peerLevelType), ('peerIpAddress', peerIpAddress), ('localIpAddress', localIpAddress), ('bfdState', bfdState), ('systemId', systemId), ('circuitName', circuitName), ])


class yc_isDispBfdBitErrSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispBfdBitErrSessions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BFD bit-error session information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispBfdBitErrSession',)

  _yang_name = 'isDispBfdBitErrSessions'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispBfdBitErrSession = YANGDynClass(base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdBitErrSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions_isDispBfdBitErrSession, yang_name="isDispBfdBitErrSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdBitErrSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispBfdBitErrSessions']

  def _get_isDispBfdBitErrSession(self):
    """
    Getter method for isDispBfdBitErrSession, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession (list)

    YANG Description: Information about a BFD bit-error session.
    """
    return self.__isDispBfdBitErrSession
      
  def _set_isDispBfdBitErrSession(self, v, load=False):
    """
    Setter method for isDispBfdBitErrSession, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions/isDispBfdBitErrSession (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispBfdBitErrSession is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispBfdBitErrSession() directly.

    YANG Description: Information about a BFD bit-error session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdBitErrSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions_isDispBfdBitErrSession, yang_name="isDispBfdBitErrSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdBitErrSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispBfdBitErrSession must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdBitErrSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions_isDispBfdBitErrSession, yang_name="isDispBfdBitErrSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdBitErrSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispBfdBitErrSession = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispBfdBitErrSession(self):
    self.__isDispBfdBitErrSession = YANGDynClass(base=YANGListType("peerLevelType peerIpAddress localIpAddress",yc_isDispBfdBitErrSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions_isDispBfdBitErrSession, yang_name="isDispBfdBitErrSession", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peerLevelType peerIpAddress localIpAddress', extensions=None), is_container='list', yang_name="isDispBfdBitErrSession", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispBfdBitErrSession = __builtin__.property(_get_isDispBfdBitErrSession) # type: yc_isDispBfdBitErrSession_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions_isDispBfdBitErrSession


  _pyangbind_elements = OrderedDict([('isDispBfdBitErrSession', isDispBfdBitErrSession), ])


class yc_isDispNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables_isDispNameTable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Name mapping table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__levelType','__hostType','__systemId','__hostName',)

  _yang_name = 'isDispNameTable'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__hostType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..32']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__hostName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispNameTables', 'isDispNameTable']

  def _get_levelType(self):
    """
    Getter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/levelType (string)

    YANG Description: Type of the system level: level-1 or level-2. 
    """
    return self.__levelType
      
  def _set_levelType(self, v, load=False):
    """
    Setter method for levelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/levelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_levelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_levelType() directly.

    YANG Description: Type of the system level: level-1 or level-2. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """levelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__levelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_levelType(self):
    self.__levelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="levelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_hostType(self):
    """
    Getter method for hostType, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/hostType (string)

    YANG Description: Type of the mapping between the system ID and host name.
    """
    return self.__hostType
      
  def _set_hostType(self, v, load=False):
    """
    Setter method for hostType, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/hostType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostType() directly.

    YANG Description: Type of the mapping between the system ID and host name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hostType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__hostType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostType(self):
    self.__hostType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_systemId(self):
    """
    Getter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/systemId (string)

    YANG Description: IS-IS system ID or pseudo node ID to be mapped. 
    """
    return self.__systemId
      
  def _set_systemId(self, v, load=False):
    """
    Setter method for systemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/systemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_systemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_systemId() directly.

    YANG Description: IS-IS system ID or pseudo node ID to be mapped. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..32']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """systemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..32']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__systemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_systemId(self):
    self.__systemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..32']}), is_leaf=True, yang_name="systemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_hostName(self):
    """
    Getter method for hostName, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/hostName (string)

    YANG Description: Host name (alias) mapped to the IS-IS system.
    """
    return self.__hostName
      
  def _set_hostName(self, v, load=False):
    """
    Setter method for hostName, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable/hostName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostName() directly.

    YANG Description: Host name (alias) mapped to the IS-IS system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__hostName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostName(self):
    self.__hostName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="hostName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  levelType = __builtin__.property(_get_levelType)
  hostType = __builtin__.property(_get_hostType)
  systemId = __builtin__.property(_get_systemId)
  hostName = __builtin__.property(_get_hostName)


  _pyangbind_elements = OrderedDict([('levelType', levelType), ('hostType', hostType), ('systemId', systemId), ('hostName', hostName), ])


class yc_isDispNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispNameTables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Name mapping table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispNameTable',)

  _yang_name = 'isDispNameTables'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispNameTable = YANGDynClass(base=YANGListType("levelType hostType systemId",yc_isDispNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables_isDispNameTable, yang_name="isDispNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType hostType systemId', extensions=None), is_container='list', yang_name="isDispNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispNameTables']

  def _get_isDispNameTable(self):
    """
    Getter method for isDispNameTable, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable (list)

    YANG Description: Name mapping table.
    """
    return self.__isDispNameTable
      
  def _set_isDispNameTable(self, v, load=False):
    """
    Setter method for isDispNameTable, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables/isDispNameTable (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispNameTable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispNameTable() directly.

    YANG Description: Name mapping table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("levelType hostType systemId",yc_isDispNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables_isDispNameTable, yang_name="isDispNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType hostType systemId', extensions=None), is_container='list', yang_name="isDispNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispNameTable must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("levelType hostType systemId",yc_isDispNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables_isDispNameTable, yang_name="isDispNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType hostType systemId', extensions=None), is_container='list', yang_name="isDispNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispNameTable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispNameTable(self):
    self.__isDispNameTable = YANGDynClass(base=YANGListType("levelType hostType systemId",yc_isDispNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables_isDispNameTable, yang_name="isDispNameTable", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='levelType hostType systemId', extensions=None), is_container='list', yang_name="isDispNameTable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispNameTable = __builtin__.property(_get_isDispNameTable) # type: yc_isDispNameTable_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables_isDispNameTable


  _pyangbind_elements = OrderedDict([('isDispNameTable', isDispNameTable), ])


class yc_isLinkGroup_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups_isLinkGroup(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about link group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__groupName','__minMembers','__revertMembers','__costOffset',)

  _yang_name = 'isLinkGroup'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__groupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..32']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__minMembers = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="minMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__revertMembers = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="revertMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__costOffset = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="costOffset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLinkGroups', 'isLinkGroup']

  def _get_groupName(self):
    """
    Getter method for groupName, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/groupName (string)

    YANG Description: Group Name.
    """
    return self.__groupName
      
  def _set_groupName(self, v, load=False):
    """
    Setter method for groupName, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/groupName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groupName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groupName() directly.

    YANG Description: Group Name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..32']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groupName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..32']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__groupName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groupName(self):
    self.__groupName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '.*\\S.*', 'length': ['1..32']}), is_leaf=True, yang_name="groupName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_minMembers(self):
    """
    Getter method for minMembers, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/minMembers (uint8)

    YANG Description: Min members of link group
    """
    return self.__minMembers
      
  def _set_minMembers(self, v, load=False):
    """
    Setter method for minMembers, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/minMembers (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minMembers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minMembers() directly.

    YANG Description: Min members of link group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="minMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minMembers must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="minMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__minMembers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minMembers(self):
    self.__minMembers = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="minMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_revertMembers(self):
    """
    Getter method for revertMembers, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/revertMembers (uint8)

    YANG Description: Members of revert cost
    """
    return self.__revertMembers
      
  def _set_revertMembers(self, v, load=False):
    """
    Setter method for revertMembers, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/revertMembers (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertMembers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertMembers() directly.

    YANG Description: Members of revert cost
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="revertMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertMembers must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="revertMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__revertMembers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertMembers(self):
    self.__revertMembers = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['2..64']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="revertMembers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_costOffset(self):
    """
    Getter method for costOffset, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/costOffset (uint32)

    YANG Description: OffSet of cost.
    """
    return self.__costOffset
      
  def _set_costOffset(self, v, load=False):
    """
    Setter method for costOffset, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup/costOffset (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_costOffset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_costOffset() directly.

    YANG Description: OffSet of cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="costOffset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """costOffset must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="costOffset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__costOffset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_costOffset(self):
    self.__costOffset = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="costOffset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  groupName = __builtin__.property(_get_groupName, _set_groupName)
  minMembers = __builtin__.property(_get_minMembers, _set_minMembers)
  revertMembers = __builtin__.property(_get_revertMembers, _set_revertMembers)
  costOffset = __builtin__.property(_get_costOffset, _set_costOffset)


  _pyangbind_elements = OrderedDict([('groupName', groupName), ('minMembers', minMembers), ('revertMembers', revertMembers), ('costOffset', costOffset), ])


class yc_isLinkGroups_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isLinkGroups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of link group
  """
  __slots__ = ('_path_helper', '_extmethods', '__isLinkGroup',)

  _yang_name = 'isLinkGroups'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isLinkGroup = YANGDynClass(base=YANGListType("groupName",yc_isLinkGroup_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups_isLinkGroup, yang_name="isLinkGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="isLinkGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isLinkGroups']

  def _get_isLinkGroup(self):
    """
    Getter method for isLinkGroup, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup (list)

    YANG Description: Information about link group.
    """
    return self.__isLinkGroup
      
  def _set_isLinkGroup(self, v, load=False):
    """
    Setter method for isLinkGroup, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups/isLinkGroup (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLinkGroup is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLinkGroup() directly.

    YANG Description: Information about link group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("groupName",yc_isLinkGroup_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups_isLinkGroup, yang_name="isLinkGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="isLinkGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLinkGroup must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("groupName",yc_isLinkGroup_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups_isLinkGroup, yang_name="isLinkGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="isLinkGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isLinkGroup = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLinkGroup(self):
    self.__isLinkGroup = YANGDynClass(base=YANGListType("groupName",yc_isLinkGroup_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups_isLinkGroup, yang_name="isLinkGroup", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='groupName', extensions=None), is_container='list', yang_name="isLinkGroup", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isLinkGroup = __builtin__.property(_get_isLinkGroup, _set_isLinkGroup) # type: yc_isLinkGroup_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups_isLinkGroup


  _pyangbind_elements = OrderedDict([('isLinkGroup', isLinkGroup), ])


class yc_isDispVirtualAcc_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs_isDispVirtualAcc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Display the virtual access information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lspLevelType','__dispLspID','__routerID','__apID','__apRole',)

  _yang_name = 'isDispVirtualAcc'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lspLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__dispLspID = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="dispLspID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__routerID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__apID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="apID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__apRole = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="apRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispVirtualAccs', 'isDispVirtualAcc']

  def _get_lspLevelType(self):
    """
    Getter method for lspLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/lspLevelType (string)

    YANG Description: Display the level type.
    """
    return self.__lspLevelType
      
  def _set_lspLevelType(self, v, load=False):
    """
    Setter method for lspLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/lspLevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspLevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspLevelType() directly.

    YANG Description: Display the level type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspLevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__lspLevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspLevelType(self):
    self.__lspLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_dispLspID(self):
    """
    Getter method for dispLspID, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/dispLspID (string)

    YANG Description: Display the LSP ID.
    """
    return self.__dispLspID
      
  def _set_dispLspID(self, v, load=False):
    """
    Setter method for dispLspID, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/dispLspID (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dispLspID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dispLspID() directly.

    YANG Description: Display the LSP ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="dispLspID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dispLspID must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="dispLspID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__dispLspID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dispLspID(self):
    self.__dispLspID = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..512']}), is_leaf=True, yang_name="dispLspID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_routerID(self):
    """
    Getter method for routerID, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/routerID (inet:ipv4-address-no-zone)

    YANG Description: Display the router ID.
    """
    return self.__routerID
      
  def _set_routerID(self, v, load=False):
    """
    Setter method for routerID, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/routerID (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routerID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routerID() directly.

    YANG Description: Display the router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routerID must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__routerID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routerID(self):
    self.__routerID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="routerID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_apID(self):
    """
    Getter method for apID, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/apID (inet:ipv4-address-no-zone)

    YANG Description: Display the AP ID.
    """
    return self.__apID
      
  def _set_apID(self, v, load=False):
    """
    Setter method for apID, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/apID (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apID() directly.

    YANG Description: Display the AP ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="apID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apID must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="apID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__apID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apID(self):
    self.__apID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="apID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_apRole(self):
    """
    Getter method for apRole, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/apRole (string)

    YANG Description: Display the AP role.
    """
    return self.__apRole
      
  def _set_apRole(self, v, load=False):
    """
    Setter method for apRole, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc/apRole (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apRole is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apRole() directly.

    YANG Description: Display the AP role.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="apRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apRole must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="apRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__apRole = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apRole(self):
    self.__apRole = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="apRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  lspLevelType = __builtin__.property(_get_lspLevelType)
  dispLspID = __builtin__.property(_get_dispLspID)
  routerID = __builtin__.property(_get_routerID)
  apID = __builtin__.property(_get_apID)
  apRole = __builtin__.property(_get_apRole)


  _pyangbind_elements = OrderedDict([('lspLevelType', lspLevelType), ('dispLspID', dispLspID), ('routerID', routerID), ('apID', apID), ('apRole', apRole), ])


class yc_isDispVirtualAccs_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispVirtualAccs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Display the virtual access information list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispVirtualAcc',)

  _yang_name = 'isDispVirtualAccs'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispVirtualAcc = YANGDynClass(base=YANGListType("lspLevelType dispLspID",yc_isDispVirtualAcc_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs_isDispVirtualAcc, yang_name="isDispVirtualAcc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType dispLspID', extensions=None), is_container='list', yang_name="isDispVirtualAcc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispVirtualAccs']

  def _get_isDispVirtualAcc(self):
    """
    Getter method for isDispVirtualAcc, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc (list)

    YANG Description: Display the virtual access information.
    """
    return self.__isDispVirtualAcc
      
  def _set_isDispVirtualAcc(self, v, load=False):
    """
    Setter method for isDispVirtualAcc, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs/isDispVirtualAcc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispVirtualAcc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispVirtualAcc() directly.

    YANG Description: Display the virtual access information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lspLevelType dispLspID",yc_isDispVirtualAcc_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs_isDispVirtualAcc, yang_name="isDispVirtualAcc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType dispLspID', extensions=None), is_container='list', yang_name="isDispVirtualAcc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispVirtualAcc must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lspLevelType dispLspID",yc_isDispVirtualAcc_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs_isDispVirtualAcc, yang_name="isDispVirtualAcc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType dispLspID', extensions=None), is_container='list', yang_name="isDispVirtualAcc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispVirtualAcc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispVirtualAcc(self):
    self.__isDispVirtualAcc = YANGDynClass(base=YANGListType("lspLevelType dispLspID",yc_isDispVirtualAcc_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs_isDispVirtualAcc, yang_name="isDispVirtualAcc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType dispLspID', extensions=None), is_container='list', yang_name="isDispVirtualAcc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispVirtualAcc = __builtin__.property(_get_isDispVirtualAcc) # type: yc_isDispVirtualAcc_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs_isDispVirtualAcc


  _pyangbind_elements = OrderedDict([('isDispVirtualAcc', isDispVirtualAcc), ])


class yc_isSegrCfg_huawei_isiscomm__isiscomm_isSites_isSite_isSegrCfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSegrCfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration about ISIS segment-routing
  """
  __slots__ = ('_path_helper', '_extmethods', '__isAutoAdjSid','__isSrmsRecvFlag','__isSrmsSendFlag','__isAdvStaticSid',)

  _yang_name = 'isSegrCfg'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isAutoAdjSid = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isAutoAdjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isSrmsRecvFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isSrmsRecvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isSrmsSendFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSrmsSendFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isAdvStaticSid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isAdvStaticSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSegrCfg']

  def _get_isAutoAdjSid(self):
    """
    Getter method for isAutoAdjSid, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isAutoAdjSid (boolean)

    YANG Description: Apply adj label when build Adjency
    """
    return self.__isAutoAdjSid
      
  def _set_isAutoAdjSid(self, v, load=False):
    """
    Setter method for isAutoAdjSid, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isAutoAdjSid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isAutoAdjSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isAutoAdjSid() directly.

    YANG Description: Apply adj label when build Adjency
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isAutoAdjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isAutoAdjSid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isAutoAdjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__isAutoAdjSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isAutoAdjSid(self):
    self.__isAutoAdjSid = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isAutoAdjSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isSrmsRecvFlag(self):
    """
    Getter method for isSrmsRecvFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isSrmsRecvFlag (boolean)

    YANG Description: Receive remote prefix-SID mappings.
    """
    return self.__isSrmsRecvFlag
      
  def _set_isSrmsRecvFlag(self, v, load=False):
    """
    Setter method for isSrmsRecvFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isSrmsRecvFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrmsRecvFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrmsRecvFlag() directly.

    YANG Description: Receive remote prefix-SID mappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isSrmsRecvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrmsRecvFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isSrmsRecvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__isSrmsRecvFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrmsRecvFlag(self):
    self.__isSrmsRecvFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="isSrmsRecvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isSrmsSendFlag(self):
    """
    Getter method for isSrmsSendFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isSrmsSendFlag (boolean)

    YANG Description: Advertise active local prefix-SID mappings.
    """
    return self.__isSrmsSendFlag
      
  def _set_isSrmsSendFlag(self, v, load=False):
    """
    Setter method for isSrmsSendFlag, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isSrmsSendFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrmsSendFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrmsSendFlag() directly.

    YANG Description: Advertise active local prefix-SID mappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSrmsSendFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrmsSendFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSrmsSendFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__isSrmsSendFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrmsSendFlag(self):
    self.__isSrmsSendFlag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSrmsSendFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isAdvStaticSid(self):
    """
    Getter method for isAdvStaticSid, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isAdvStaticSid (boolean)

    YANG Description: Enable ISIS to advertise static SID capabilities, support static Adjacency-SID distribution in LSP.
    """
    return self.__isAdvStaticSid
      
  def _set_isAdvStaticSid(self, v, load=False):
    """
    Setter method for isAdvStaticSid, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg/isAdvStaticSid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isAdvStaticSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isAdvStaticSid() directly.

    YANG Description: Enable ISIS to advertise static SID capabilities, support static Adjacency-SID distribution in LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isAdvStaticSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isAdvStaticSid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isAdvStaticSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__isAdvStaticSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isAdvStaticSid(self):
    self.__isAdvStaticSid = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isAdvStaticSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  isAutoAdjSid = __builtin__.property(_get_isAutoAdjSid, _set_isAutoAdjSid)
  isSrmsRecvFlag = __builtin__.property(_get_isSrmsRecvFlag, _set_isSrmsRecvFlag)
  isSrmsSendFlag = __builtin__.property(_get_isSrmsSendFlag, _set_isSrmsSendFlag)
  isAdvStaticSid = __builtin__.property(_get_isAdvStaticSid, _set_isAdvStaticSid)


  _pyangbind_elements = OrderedDict([('isAutoAdjSid', isAutoAdjSid), ('isSrmsRecvFlag', isSrmsRecvFlag), ('isSrmsSendFlag', isSrmsSendFlag), ('isAdvStaticSid', isAdvStaticSid), ])


class yc_isDispMapSvrInfo_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos_isDispMapSvrInfo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Prefix and SID mapping list.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv4Address','__maskLength','__advSystemId','__sidValue',)

  _yang_name = 'isDispMapSvrInfo'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__advSystemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="advSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__sidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65534']}), is_leaf=True, yang_name="sidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispMapSvrInfos', 'isDispMapSvrInfo']

  def _get_ipv4Address(self):
    """
    Getter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/ipv4Address (string)

    YANG Description: Address prefix.
    """
    return self.__ipv4Address
      
  def _set_ipv4Address(self, v, load=False):
    """
    Setter method for ipv4Address, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/ipv4Address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4Address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4Address() directly.

    YANG Description: Address prefix.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4Address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__ipv4Address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4Address(self):
    self.__ipv4Address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..20']}), is_leaf=True, yang_name="ipv4Address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_maskLength(self):
    """
    Getter method for maskLength, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/maskLength (uint32)

    YANG Description: Mask length. 
    """
    return self.__maskLength
      
  def _set_maskLength(self, v, load=False):
    """
    Setter method for maskLength, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/maskLength (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maskLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maskLength() directly.

    YANG Description: Mask length. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maskLength must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__maskLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maskLength(self):
    self.__maskLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="maskLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_advSystemId(self):
    """
    Getter method for advSystemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/advSystemId (string)

    YANG Description: Advertiser system ID.
    """
    return self.__advSystemId
      
  def _set_advSystemId(self, v, load=False):
    """
    Setter method for advSystemId, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/advSystemId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advSystemId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advSystemId() directly.

    YANG Description: Advertiser system ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="advSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advSystemId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="advSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__advSystemId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advSystemId(self):
    self.__advSystemId = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..32']}), is_leaf=True, yang_name="advSystemId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_sidValue(self):
    """
    Getter method for sidValue, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/sidValue (uint32)

    YANG Description: SID.
    """
    return self.__sidValue
      
  def _set_sidValue(self, v, load=False):
    """
    Setter method for sidValue, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo/sidValue (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sidValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sidValue() directly.

    YANG Description: SID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65534']}), is_leaf=True, yang_name="sidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sidValue must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65534']}), is_leaf=True, yang_name="sidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__sidValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sidValue(self):
    self.__sidValue = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65534']}), is_leaf=True, yang_name="sidValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

  ipv4Address = __builtin__.property(_get_ipv4Address)
  maskLength = __builtin__.property(_get_maskLength)
  advSystemId = __builtin__.property(_get_advSystemId)
  sidValue = __builtin__.property(_get_sidValue)


  _pyangbind_elements = OrderedDict([('ipv4Address', ipv4Address), ('maskLength', maskLength), ('advSystemId', advSystemId), ('sidValue', sidValue), ])


class yc_isDispMapSvrInfos_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispMapSvrInfos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Prefix and SID mapping information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispMapSvrInfo',)

  _yang_name = 'isDispMapSvrInfos'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispMapSvrInfo = YANGDynClass(base=YANGListType("ipv4Address maskLength",yc_isDispMapSvrInfo_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos_isDispMapSvrInfo, yang_name="isDispMapSvrInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4Address maskLength', extensions=None), is_container='list', yang_name="isDispMapSvrInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispMapSvrInfos']

  def _get_isDispMapSvrInfo(self):
    """
    Getter method for isDispMapSvrInfo, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo (list)

    YANG Description: Prefix and SID mapping list.
    """
    return self.__isDispMapSvrInfo
      
  def _set_isDispMapSvrInfo(self, v, load=False):
    """
    Setter method for isDispMapSvrInfo, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos/isDispMapSvrInfo (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispMapSvrInfo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispMapSvrInfo() directly.

    YANG Description: Prefix and SID mapping list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ipv4Address maskLength",yc_isDispMapSvrInfo_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos_isDispMapSvrInfo, yang_name="isDispMapSvrInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4Address maskLength', extensions=None), is_container='list', yang_name="isDispMapSvrInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispMapSvrInfo must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ipv4Address maskLength",yc_isDispMapSvrInfo_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos_isDispMapSvrInfo, yang_name="isDispMapSvrInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4Address maskLength', extensions=None), is_container='list', yang_name="isDispMapSvrInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispMapSvrInfo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispMapSvrInfo(self):
    self.__isDispMapSvrInfo = YANGDynClass(base=YANGListType("ipv4Address maskLength",yc_isDispMapSvrInfo_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos_isDispMapSvrInfo, yang_name="isDispMapSvrInfo", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ipv4Address maskLength', extensions=None), is_container='list', yang_name="isDispMapSvrInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispMapSvrInfo = __builtin__.property(_get_isDispMapSvrInfo) # type: yc_isDispMapSvrInfo_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos_isDispMapSvrInfo


  _pyangbind_elements = OrderedDict([('isDispMapSvrInfo', isDispMapSvrInfo), ])


class yc_isSrv6Cfg_huawei_isiscomm__isiscomm_isSites_isSite_isSrv6Cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isSrv6Cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration about ISIS segment-routing IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defaultLocator','__locatorName','__autoSid',)

  _yang_name = 'isSrv6Cfg'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defaultLocator = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__locatorName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='leafref', is_config=True)
    self.__autoSid = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isSrv6Cfg']

  def _get_defaultLocator(self):
    """
    Getter method for defaultLocator, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg/defaultLocator (boolean)

    YANG Description: Enable ISIS segment-routing IPv6 with default Locator.
    """
    return self.__defaultLocator
      
  def _set_defaultLocator(self, v, load=False):
    """
    Setter method for defaultLocator, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg/defaultLocator (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultLocator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultLocator() directly.

    YANG Description: Enable ISIS segment-routing IPv6 with default Locator.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultLocator must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__defaultLocator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultLocator(self):
    self.__defaultLocator = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="defaultLocator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_locatorName(self):
    """
    Getter method for locatorName, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg/locatorName (leafref)

    YANG Description: Enable ISIS segment-routing IPv6 with specified Locator.
    """
    return self.__locatorName
      
  def _set_locatorName(self, v, load=False):
    """
    Setter method for locatorName, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg/locatorName (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locatorName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locatorName() directly.

    YANG Description: Enable ISIS segment-routing IPv6 with specified Locator.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locatorName must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='leafref', is_config=True)""",
        })

    self.__locatorName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locatorName(self):
    self.__locatorName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="locatorName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='leafref', is_config=True)


  def _get_autoSid(self):
    """
    Getter method for autoSid, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg/autoSid (boolean)

    YANG Description: Automatic application for SID.
    """
    return self.__autoSid
      
  def _set_autoSid(self, v, load=False):
    """
    Setter method for autoSid, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg/autoSid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoSid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoSid() directly.

    YANG Description: Automatic application for SID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """autoSid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__autoSid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_autoSid(self):
    self.__autoSid = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="autoSid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)

  defaultLocator = __builtin__.property(_get_defaultLocator, _set_defaultLocator)
  locatorName = __builtin__.property(_get_locatorName, _set_locatorName)
  autoSid = __builtin__.property(_get_autoSid, _set_autoSid)


  _pyangbind_elements = OrderedDict([('defaultLocator', defaultLocator), ('locatorName', locatorName), ('autoSid', autoSid), ])


class yc_isIPv6SrAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isIPv6SrAvoidMicroLoopSet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 segment-routing avoid-microloop.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv6SrAvoidLoopEnable','__ipv6SrAvoidLoopDelayVal',)

  _yang_name = 'isIPv6SrAvoidMicroLoopSet'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv6SrAvoidLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6SrAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__ipv6SrAvoidLoopDelayVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="ipv6SrAvoidLoopDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isIPv6SrAvoidMicroLoopSet']

  def _get_ipv6SrAvoidLoopEnable(self):
    """
    Getter method for ipv6SrAvoidLoopEnable, mapped from YANG variable /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet/ipv6SrAvoidLoopEnable (boolean)

    YANG Description: Enable IPv6 segment-routing avoid-microloop.
    """
    return self.__ipv6SrAvoidLoopEnable
      
  def _set_ipv6SrAvoidLoopEnable(self, v, load=False):
    """
    Setter method for ipv6SrAvoidLoopEnable, mapped from YANG variable /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet/ipv6SrAvoidLoopEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6SrAvoidLoopEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6SrAvoidLoopEnable() directly.

    YANG Description: Enable IPv6 segment-routing avoid-microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6SrAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6SrAvoidLoopEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6SrAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv6SrAvoidLoopEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6SrAvoidLoopEnable(self):
    self.__ipv6SrAvoidLoopEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv6SrAvoidLoopEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_ipv6SrAvoidLoopDelayVal(self):
    """
    Getter method for ipv6SrAvoidLoopDelayVal, mapped from YANG variable /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet/ipv6SrAvoidLoopDelayVal (uint16)

    YANG Description: Set the route delivery delay for IPv6 segment-routing avoid-microloop.
    """
    return self.__ipv6SrAvoidLoopDelayVal
      
  def _set_ipv6SrAvoidLoopDelayVal(self, v, load=False):
    """
    Setter method for ipv6SrAvoidLoopDelayVal, mapped from YANG variable /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet/ipv6SrAvoidLoopDelayVal (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6SrAvoidLoopDelayVal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6SrAvoidLoopDelayVal() directly.

    YANG Description: Set the route delivery delay for IPv6 segment-routing avoid-microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="ipv6SrAvoidLoopDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6SrAvoidLoopDelayVal must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="ipv6SrAvoidLoopDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)""",
        })

    self.__ipv6SrAvoidLoopDelayVal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6SrAvoidLoopDelayVal(self):
    self.__ipv6SrAvoidLoopDelayVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1000..10000']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(5000), is_leaf=True, yang_name="ipv6SrAvoidLoopDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)

  ipv6SrAvoidLoopEnable = __builtin__.property(_get_ipv6SrAvoidLoopEnable, _set_ipv6SrAvoidLoopEnable)
  ipv6SrAvoidLoopDelayVal = __builtin__.property(_get_ipv6SrAvoidLoopDelayVal, _set_ipv6SrAvoidLoopDelayVal)


  _pyangbind_elements = OrderedDict([('ipv6SrAvoidLoopEnable', ipv6SrAvoidLoopEnable), ('ipv6SrAvoidLoopDelayVal', ipv6SrAvoidLoopDelayVal), ])


class yc_isDispFrrSummry_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys_isDispFrrSummry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: All route protection rate
  """
  __slots__ = ('_path_helper', '_extmethods', '__lspLevelType','__criticalCnt','__criticalProtCnt','__highCnt','__highProtCnt','__mediumCnt','__mediumProtCnt','__lowCnt','__lowProtCnt','__totalCnt','__totalProtCnt','__criticalCover','__highCover','__mediumCover','__lowCover','__totalCover',)

  _yang_name = 'isDispFrrSummry'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lspLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__criticalCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__criticalProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__highCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__highProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__mediumCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__mediumProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__lowCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__lowProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__totalCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__totalProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__criticalCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="criticalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__highCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="highCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__mediumCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="mediumCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__lowCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="lowCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    self.__totalCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="totalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispFrrSummrys', 'isDispFrrSummry']

  def _get_lspLevelType(self):
    """
    Getter method for lspLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lspLevelType (string)

    YANG Description: Route level
    """
    return self.__lspLevelType
      
  def _set_lspLevelType(self, v, load=False):
    """
    Setter method for lspLevelType, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lspLevelType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspLevelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspLevelType() directly.

    YANG Description: Route level
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspLevelType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__lspLevelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspLevelType(self):
    self.__lspLevelType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lspLevelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_criticalCnt(self):
    """
    Getter method for criticalCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/criticalCnt (uint32)

    YANG Description: Amount of critical level routes
    """
    return self.__criticalCnt
      
  def _set_criticalCnt(self, v, load=False):
    """
    Setter method for criticalCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/criticalCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_criticalCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_criticalCnt() directly.

    YANG Description: Amount of critical level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """criticalCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__criticalCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_criticalCnt(self):
    self.__criticalCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_criticalProtCnt(self):
    """
    Getter method for criticalProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/criticalProtCnt (uint32)

    YANG Description: Amount of protected critical level routes
    """
    return self.__criticalProtCnt
      
  def _set_criticalProtCnt(self, v, load=False):
    """
    Setter method for criticalProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/criticalProtCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_criticalProtCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_criticalProtCnt() directly.

    YANG Description: Amount of protected critical level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """criticalProtCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__criticalProtCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_criticalProtCnt(self):
    self.__criticalProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="criticalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_highCnt(self):
    """
    Getter method for highCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/highCnt (uint32)

    YANG Description: Amount of high level routes
    """
    return self.__highCnt
      
  def _set_highCnt(self, v, load=False):
    """
    Setter method for highCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/highCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_highCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_highCnt() directly.

    YANG Description: Amount of high level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """highCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__highCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_highCnt(self):
    self.__highCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_highProtCnt(self):
    """
    Getter method for highProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/highProtCnt (uint32)

    YANG Description: Amount of protected high level routes
    """
    return self.__highProtCnt
      
  def _set_highProtCnt(self, v, load=False):
    """
    Setter method for highProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/highProtCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_highProtCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_highProtCnt() directly.

    YANG Description: Amount of protected high level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """highProtCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__highProtCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_highProtCnt(self):
    self.__highProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="highProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_mediumCnt(self):
    """
    Getter method for mediumCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/mediumCnt (uint32)

    YANG Description: Amount of medium level routes
    """
    return self.__mediumCnt
      
  def _set_mediumCnt(self, v, load=False):
    """
    Setter method for mediumCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/mediumCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mediumCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mediumCnt() directly.

    YANG Description: Amount of medium level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mediumCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__mediumCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mediumCnt(self):
    self.__mediumCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_mediumProtCnt(self):
    """
    Getter method for mediumProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/mediumProtCnt (uint32)

    YANG Description: Amount of protected medium level routes
    """
    return self.__mediumProtCnt
      
  def _set_mediumProtCnt(self, v, load=False):
    """
    Setter method for mediumProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/mediumProtCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mediumProtCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mediumProtCnt() directly.

    YANG Description: Amount of protected medium level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mediumProtCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__mediumProtCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mediumProtCnt(self):
    self.__mediumProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="mediumProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_lowCnt(self):
    """
    Getter method for lowCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lowCnt (uint32)

    YANG Description: Amount of low level routes
    """
    return self.__lowCnt
      
  def _set_lowCnt(self, v, load=False):
    """
    Setter method for lowCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lowCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowCnt() directly.

    YANG Description: Amount of low level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__lowCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowCnt(self):
    self.__lowCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_lowProtCnt(self):
    """
    Getter method for lowProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lowProtCnt (uint32)

    YANG Description: Amount of protected low level routes
    """
    return self.__lowProtCnt
      
  def _set_lowProtCnt(self, v, load=False):
    """
    Setter method for lowProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lowProtCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowProtCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowProtCnt() directly.

    YANG Description: Amount of protected low level routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowProtCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__lowProtCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowProtCnt(self):
    self.__lowProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="lowProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_totalCnt(self):
    """
    Getter method for totalCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/totalCnt (uint32)

    YANG Description: Amount of routes
    """
    return self.__totalCnt
      
  def _set_totalCnt(self, v, load=False):
    """
    Setter method for totalCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/totalCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_totalCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_totalCnt() directly.

    YANG Description: Amount of routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """totalCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__totalCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_totalCnt(self):
    self.__totalCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_totalProtCnt(self):
    """
    Getter method for totalProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/totalProtCnt (uint32)

    YANG Description: Amount of protected routes
    """
    return self.__totalProtCnt
      
  def _set_totalProtCnt(self, v, load=False):
    """
    Setter method for totalProtCnt, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/totalProtCnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_totalProtCnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_totalProtCnt() directly.

    YANG Description: Amount of protected routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """totalProtCnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__totalProtCnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_totalProtCnt(self):
    self.__totalProtCnt = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="totalProtCnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_criticalCover(self):
    """
    Getter method for criticalCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/criticalCover (string)

    YANG Description: Route protection rate of critical level
    """
    return self.__criticalCover
      
  def _set_criticalCover(self, v, load=False):
    """
    Setter method for criticalCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/criticalCover (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_criticalCover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_criticalCover() directly.

    YANG Description: Route protection rate of critical level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="criticalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """criticalCover must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="criticalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__criticalCover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_criticalCover(self):
    self.__criticalCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="criticalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_highCover(self):
    """
    Getter method for highCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/highCover (string)

    YANG Description: Route protection rate of high level
    """
    return self.__highCover
      
  def _set_highCover(self, v, load=False):
    """
    Setter method for highCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/highCover (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_highCover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_highCover() directly.

    YANG Description: Route protection rate of high level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="highCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """highCover must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="highCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__highCover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_highCover(self):
    self.__highCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="highCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_mediumCover(self):
    """
    Getter method for mediumCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/mediumCover (string)

    YANG Description: Route protection rate of medium level
    """
    return self.__mediumCover
      
  def _set_mediumCover(self, v, load=False):
    """
    Setter method for mediumCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/mediumCover (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mediumCover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mediumCover() directly.

    YANG Description: Route protection rate of medium level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="mediumCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mediumCover must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="mediumCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__mediumCover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mediumCover(self):
    self.__mediumCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="mediumCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_lowCover(self):
    """
    Getter method for lowCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lowCover (string)

    YANG Description: Route protection rate of low level
    """
    return self.__lowCover
      
  def _set_lowCover(self, v, load=False):
    """
    Setter method for lowCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/lowCover (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowCover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowCover() directly.

    YANG Description: Route protection rate of low level
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="lowCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowCover must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="lowCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__lowCover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowCover(self):
    self.__lowCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="lowCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)


  def _get_totalCover(self):
    """
    Getter method for totalCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/totalCover (string)

    YANG Description: Route protection rate
    """
    return self.__totalCover
      
  def _set_totalCover(self, v, load=False):
    """
    Setter method for totalCover, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry/totalCover (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_totalCover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_totalCover() directly.

    YANG Description: Route protection rate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="totalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """totalCover must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="totalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)""",
        })

    self.__totalCover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_totalCover(self):
    self.__totalCover = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..12']}), is_leaf=True, yang_name="totalCover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=False)

  lspLevelType = __builtin__.property(_get_lspLevelType)
  criticalCnt = __builtin__.property(_get_criticalCnt)
  criticalProtCnt = __builtin__.property(_get_criticalProtCnt)
  highCnt = __builtin__.property(_get_highCnt)
  highProtCnt = __builtin__.property(_get_highProtCnt)
  mediumCnt = __builtin__.property(_get_mediumCnt)
  mediumProtCnt = __builtin__.property(_get_mediumProtCnt)
  lowCnt = __builtin__.property(_get_lowCnt)
  lowProtCnt = __builtin__.property(_get_lowProtCnt)
  totalCnt = __builtin__.property(_get_totalCnt)
  totalProtCnt = __builtin__.property(_get_totalProtCnt)
  criticalCover = __builtin__.property(_get_criticalCover)
  highCover = __builtin__.property(_get_highCover)
  mediumCover = __builtin__.property(_get_mediumCover)
  lowCover = __builtin__.property(_get_lowCover)
  totalCover = __builtin__.property(_get_totalCover)


  _pyangbind_elements = OrderedDict([('lspLevelType', lspLevelType), ('criticalCnt', criticalCnt), ('criticalProtCnt', criticalProtCnt), ('highCnt', highCnt), ('highProtCnt', highProtCnt), ('mediumCnt', mediumCnt), ('mediumProtCnt', mediumProtCnt), ('lowCnt', lowCnt), ('lowProtCnt', lowProtCnt), ('totalCnt', totalCnt), ('totalProtCnt', totalProtCnt), ('criticalCover', criticalCover), ('highCover', highCover), ('mediumCover', mediumCover), ('lowCover', lowCover), ('totalCover', totalCover), ])


class yc_isDispFrrSummrys_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite/isDispFrrSummrys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route protection rate list
  """
  __slots__ = ('_path_helper', '_extmethods', '__isDispFrrSummry',)

  _yang_name = 'isDispFrrSummrys'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isDispFrrSummry = YANGDynClass(base=YANGListType("lspLevelType",yc_isDispFrrSummry_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys_isDispFrrSummry, yang_name="isDispFrrSummry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType', extensions=None), is_container='list', yang_name="isDispFrrSummry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite', 'isDispFrrSummrys']

  def _get_isDispFrrSummry(self):
    """
    Getter method for isDispFrrSummry, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry (list)

    YANG Description: All route protection rate
    """
    return self.__isDispFrrSummry
      
  def _set_isDispFrrSummry(self, v, load=False):
    """
    Setter method for isDispFrrSummry, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys/isDispFrrSummry (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispFrrSummry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispFrrSummry() directly.

    YANG Description: All route protection rate
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lspLevelType",yc_isDispFrrSummry_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys_isDispFrrSummry, yang_name="isDispFrrSummry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType', extensions=None), is_container='list', yang_name="isDispFrrSummry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispFrrSummry must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lspLevelType",yc_isDispFrrSummry_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys_isDispFrrSummry, yang_name="isDispFrrSummry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType', extensions=None), is_container='list', yang_name="isDispFrrSummry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)""",
        })

    self.__isDispFrrSummry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispFrrSummry(self):
    self.__isDispFrrSummry = YANGDynClass(base=YANGListType("lspLevelType",yc_isDispFrrSummry_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys_isDispFrrSummry, yang_name="isDispFrrSummry", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lspLevelType', extensions=None), is_container='list', yang_name="isDispFrrSummry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=False)

  isDispFrrSummry = __builtin__.property(_get_isDispFrrSummry) # type: yc_isDispFrrSummry_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys_isDispFrrSummry


  _pyangbind_elements = OrderedDict([('isDispFrrSummry', isDispFrrSummry), ])


class yc_isSite_huawei_isiscomm__isiscomm_isSites_isSite(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites/isSite. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set parameters for the IS-IS instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instanceId','__multiIID','__vpnName','__isLevel','__lspMaxAge','__lspRefreshInterval','__shutDownEnable','__costStyle','__relaxSpfLimit','__linkQuaDeteEn','__spfMaxInterval','__spfInitInterval','__spfIncrInterval','__level1lspLengthOrig','__level2lspLengthOrig','__lspReceiveLength','__level1LspFragExtEnable','__level2LspFragExtEnable','__level1LspFragExtMode','__level2LspFragExtMode','__localSymbolicName','__stdAutoCostEnable','__stdAutoCostEnableCompatible','__stdbandwidth','__stdLevel1Cost','__stdLevel2Cost','__baseTopoType','__ldpAutoCfg','__poiEnable','__poiAlways','__lsdbLimit','__lsdbLimitNum','__lsdbThresUpper','__lsdbThresLower','__directInherit','__description','__peerFlappingSuppress','__isSREnableMPLS','__bwConstraint','__loMultiplier','__unresvBwSubPool','__purgeLspDelayVal','__advOneIntfAddr','__isLspAgeRefresh','__isBgpLs','__isLspGenIntelliTimer','__isFlashFlood','__isOverloadSet','__isLdpSyncdSet','__isExternAbility','__isAvoidMicroLoopSet','__isLocalMtSets','__isAreaIds','__isNetEntitys','__isLspAuthtications','__isNameTables','__isVirtualSystems','__isSrgbs','__isCircuits','__isSiteMTs','__isDispLsdbs','__isDispPeers','__isDispCircs','__isDispLspStatisticss','__isDispBfdSessions','__isDispBfdBitErrSessions','__isDispNameTables','__isLinkGroups','__isDispVirtualAccs','__isSegrCfg','__isDispMapSvrInfos','__isSrv6Cfg','__isIPv6SrAvoidMicroLoopSet','__isDispFrrSummrys',)

  _yang_name = 'isSite'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instanceId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="instanceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__multiIID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="multiIID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    self.__vpnName = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__isLevel = YANGDynClass(base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__lspMaxAge = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="lspMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__lspRefreshInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65534']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="lspRefreshInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__shutDownEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutDownEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__costStyle = YANGDynClass(base=six.text_type, default=six.text_type("narrow"), is_leaf=True, yang_name="costStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__relaxSpfLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="relaxSpfLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__linkQuaDeteEn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="linkQuaDeteEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__spfMaxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="spfMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__spfInitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="spfInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__spfIncrInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="spfIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1lspLengthOrig = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level1lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level2lspLengthOrig = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level2lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__lspReceiveLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="lspReceiveLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__level1LspFragExtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level2LspFragExtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__level1LspFragExtMode = YANGDynClass(base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level1LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__level2LspFragExtMode = YANGDynClass(base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level2LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__localSymbolicName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="localSymbolicName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__stdAutoCostEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__stdAutoCostEnableCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__stdbandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="stdbandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__stdLevel1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__stdLevel2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__baseTopoType = YANGDynClass(base=six.text_type, default=six.text_type("invalid"), is_leaf=True, yang_name="baseTopoType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__ldpAutoCfg = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__poiEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__poiAlways = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiAlways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__lsdbLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lsdbLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__lsdbLimitNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="lsdbLimitNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__lsdbThresUpper = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(80), is_leaf=True, yang_name="lsdbThresUpper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__lsdbThresLower = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(70), is_leaf=True, yang_name="lsdbThresLower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    self.__directInherit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="directInherit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    self.__peerFlappingSuppress = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlappingSuppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isSREnableMPLS = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSREnableMPLS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__bwConstraint = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="bwConstraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__loMultiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="loMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__unresvBwSubPool = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="unresvBwSubPool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__purgeLspDelayVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="purgeLspDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    self.__advOneIntfAddr = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advOneIntfAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__isLspAgeRefresh = YANGDynClass(base=yc_isLspAgeRefresh_huawei_isiscomm__isiscomm_isSites_isSite_isLspAgeRefresh, is_container='container', yang_name="isLspAgeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isBgpLs = YANGDynClass(base=yc_isBgpLs_huawei_isiscomm__isiscomm_isSites_isSite_isBgpLs, is_container='container', yang_name="isBgpLs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLspGenIntelliTimer = YANGDynClass(base=yc_isLspGenIntelliTimer_huawei_isiscomm__isiscomm_isSites_isSite_isLspGenIntelliTimer, is_container='container', yang_name="isLspGenIntelliTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isFlashFlood = YANGDynClass(base=yc_isFlashFlood_huawei_isiscomm__isiscomm_isSites_isSite_isFlashFlood, is_container='container', yang_name="isFlashFlood", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isOverloadSet = YANGDynClass(base=yc_isOverloadSet_huawei_isiscomm__isiscomm_isSites_isSite_isOverloadSet, is_container='container', yang_name="isOverloadSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLdpSyncdSet = YANGDynClass(base=yc_isLdpSyncdSet_huawei_isiscomm__isiscomm_isSites_isSite_isLdpSyncdSet, is_container='container', yang_name="isLdpSyncdSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isExternAbility = YANGDynClass(base=yc_isExternAbility_huawei_isiscomm__isiscomm_isSites_isSite_isExternAbility, is_container='container', yang_name="isExternAbility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isAvoidMicroLoopSet = YANGDynClass(base=yc_isAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isAvoidMicroLoopSet, is_container='container', yang_name="isAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLocalMtSets = YANGDynClass(base=yc_isLocalMtSets_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets, is_container='container', yang_name="isLocalMtSets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isAreaIds = YANGDynClass(base=yc_isAreaIds_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds, is_container='container', yang_name="isAreaIds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isNetEntitys = YANGDynClass(base=yc_isNetEntitys_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys, is_container='container', yang_name="isNetEntitys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLspAuthtications = YANGDynClass(base=yc_isLspAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications, is_container='container', yang_name="isLspAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isNameTables = YANGDynClass(base=yc_isNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables, is_container='container', yang_name="isNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isVirtualSystems = YANGDynClass(base=yc_isVirtualSystems_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems, is_container='container', yang_name="isVirtualSystems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isSrgbs = YANGDynClass(base=yc_isSrgbs_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs, is_container='container', yang_name="isSrgbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isCircuits = YANGDynClass(base=yc_isCircuits_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits, is_container='container', yang_name="isCircuits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isSiteMTs = YANGDynClass(base=yc_isSiteMTs_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs, is_container='container', yang_name="isSiteMTs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispLsdbs = YANGDynClass(base=yc_isDispLsdbs_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs, is_container='container', yang_name="isDispLsdbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispPeers = YANGDynClass(base=yc_isDispPeers_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers, is_container='container', yang_name="isDispPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispCircs = YANGDynClass(base=yc_isDispCircs_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs, is_container='container', yang_name="isDispCircs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispLspStatisticss = YANGDynClass(base=yc_isDispLspStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss, is_container='container', yang_name="isDispLspStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispBfdSessions = YANGDynClass(base=yc_isDispBfdSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions, is_container='container', yang_name="isDispBfdSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispBfdBitErrSessions = YANGDynClass(base=yc_isDispBfdBitErrSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions, is_container='container', yang_name="isDispBfdBitErrSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispNameTables = YANGDynClass(base=yc_isDispNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables, is_container='container', yang_name="isDispNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isLinkGroups = YANGDynClass(base=yc_isLinkGroups_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups, is_container='container', yang_name="isLinkGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispVirtualAccs = YANGDynClass(base=yc_isDispVirtualAccs_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs, is_container='container', yang_name="isDispVirtualAccs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isSegrCfg = YANGDynClass(base=yc_isSegrCfg_huawei_isiscomm__isiscomm_isSites_isSite_isSegrCfg, is_container='container', yang_name="isSegrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispMapSvrInfos = YANGDynClass(base=yc_isDispMapSvrInfos_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos, is_container='container', yang_name="isDispMapSvrInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isSrv6Cfg = YANGDynClass(base=yc_isSrv6Cfg_huawei_isiscomm__isiscomm_isSites_isSite_isSrv6Cfg, is_container='container', yang_name="isSrv6Cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isIPv6SrAvoidMicroLoopSet = YANGDynClass(base=yc_isIPv6SrAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isIPv6SrAvoidMicroLoopSet, is_container='container', yang_name="isIPv6SrAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isDispFrrSummrys = YANGDynClass(base=yc_isDispFrrSummrys_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys, is_container='container', yang_name="isDispFrrSummrys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites', 'isSite']

  def _get_instanceId(self):
    """
    Getter method for instanceId, mapped from YANG variable /isiscomm/isSites/isSite/instanceId (uint32)

    YANG Description: Set the process ID. If the process ID does not exist, you can create a process. Otherwise, the system fails to create a process. 
    """
    return self.__instanceId
      
  def _set_instanceId(self, v, load=False):
    """
    Setter method for instanceId, mapped from YANG variable /isiscomm/isSites/isSite/instanceId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instanceId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instanceId() directly.

    YANG Description: Set the process ID. If the process ID does not exist, you can create a process. Otherwise, the system fails to create a process. 
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="instanceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instanceId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="instanceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__instanceId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instanceId(self):
    self.__instanceId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="instanceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_multiIID(self):
    """
    Getter method for multiIID, mapped from YANG variable /isiscomm/isSites/isSite/multiIID (uint16)

    YANG Description: Set the multi-instance ID.
    """
    return self.__multiIID
      
  def _set_multiIID(self, v, load=False):
    """
    Setter method for multiIID, mapped from YANG variable /isiscomm/isSites/isSite/multiIID (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multiIID is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multiIID() directly.

    YANG Description: Set the multi-instance ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="multiIID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multiIID must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="multiIID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)""",
        })

    self.__multiIID = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multiIID(self):
    self.__multiIID = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="multiIID", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint16', is_config=True)


  def _get_vpnName(self):
    """
    Getter method for vpnName, mapped from YANG variable /isiscomm/isSites/isSite/vpnName (string)

    YANG Description: Set the VPN instance name.
    """
    return self.__vpnName
      
  def _set_vpnName(self, v, load=False):
    """
    Setter method for vpnName, mapped from YANG variable /isiscomm/isSites/isSite/vpnName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpnName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpnName() directly.

    YANG Description: Set the VPN instance name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpnName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__vpnName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpnName(self):
    self.__vpnName = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vpnName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_isLevel(self):
    """
    Getter method for isLevel, mapped from YANG variable /isiscomm/isSites/isSite/isLevel (string)

    YANG Description: Set the level of a router, which can be level-1, level-2, or level-1-2. The default level is level-1-2.
    """
    return self.__isLevel
      
  def _set_isLevel(self, v, load=False):
    """
    Setter method for isLevel, mapped from YANG variable /isiscomm/isSites/isSite/isLevel (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLevel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLevel() directly.

    YANG Description: Set the level of a router, which can be level-1, level-2, or level-1-2. The default level is level-1-2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLevel must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__isLevel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLevel(self):
    self.__isLevel = YANGDynClass(base=six.text_type, default=six.text_type("level_1_2"), is_leaf=True, yang_name="isLevel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_lspMaxAge(self):
    """
    Getter method for lspMaxAge, mapped from YANG variable /isiscomm/isSites/isSite/lspMaxAge (uint32)

    YANG Description: Set the maximum validity period of the LSP generated by the current IS-IS process. The value is expressed in seconds. The default value is 1200.
    """
    return self.__lspMaxAge
      
  def _set_lspMaxAge(self, v, load=False):
    """
    Setter method for lspMaxAge, mapped from YANG variable /isiscomm/isSites/isSite/lspMaxAge (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspMaxAge is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspMaxAge() directly.

    YANG Description: Set the maximum validity period of the LSP generated by the current IS-IS process. The value is expressed in seconds. The default value is 1200.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="lspMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspMaxAge must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="lspMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__lspMaxAge = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspMaxAge(self):
    self.__lspMaxAge = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1200), is_leaf=True, yang_name="lspMaxAge", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_lspRefreshInterval(self):
    """
    Getter method for lspRefreshInterval, mapped from YANG variable /isiscomm/isSites/isSite/lspRefreshInterval (uint32)

    YANG Description: Set the period for refreshing LSPs. The value is expressed in seconds. The default value is 900.
    """
    return self.__lspRefreshInterval
      
  def _set_lspRefreshInterval(self, v, load=False):
    """
    Setter method for lspRefreshInterval, mapped from YANG variable /isiscomm/isSites/isSite/lspRefreshInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspRefreshInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspRefreshInterval() directly.

    YANG Description: Set the period for refreshing LSPs. The value is expressed in seconds. The default value is 900.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65534']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="lspRefreshInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspRefreshInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65534']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="lspRefreshInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__lspRefreshInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspRefreshInterval(self):
    self.__lspRefreshInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65534']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="lspRefreshInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_shutDownEnable(self):
    """
    Getter method for shutDownEnable, mapped from YANG variable /isiscomm/isSites/isSite/shutDownEnable (boolean)

    YANG Description: Disable IS-IS.
    """
    return self.__shutDownEnable
      
  def _set_shutDownEnable(self, v, load=False):
    """
    Setter method for shutDownEnable, mapped from YANG variable /isiscomm/isSites/isSite/shutDownEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutDownEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutDownEnable() directly.

    YANG Description: Disable IS-IS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutDownEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutDownEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutDownEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__shutDownEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutDownEnable(self):
    self.__shutDownEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutDownEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_costStyle(self):
    """
    Getter method for costStyle, mapped from YANG variable /isiscomm/isSites/isSite/costStyle (string)

    YANG Description: Set the cost type for the IS-IS router to receive and send routes. The available options are Narrow, Wide, Wide-compatible, Compatible, and Narrow-compatible.
    """
    return self.__costStyle
      
  def _set_costStyle(self, v, load=False):
    """
    Setter method for costStyle, mapped from YANG variable /isiscomm/isSites/isSite/costStyle (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_costStyle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_costStyle() directly.

    YANG Description: Set the cost type for the IS-IS router to receive and send routes. The available options are Narrow, Wide, Wide-compatible, Compatible, and Narrow-compatible.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("narrow"), is_leaf=True, yang_name="costStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """costStyle must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("narrow"), is_leaf=True, yang_name="costStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__costStyle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_costStyle(self):
    self.__costStyle = YANGDynClass(base=six.text_type, default=six.text_type("narrow"), is_leaf=True, yang_name="costStyle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_relaxSpfLimit(self):
    """
    Getter method for relaxSpfLimit, mapped from YANG variable /isiscomm/isSites/isSite/relaxSpfLimit (boolean)

    YANG Description: Allow the device to receive the routes with a cost greater than 1023.
    """
    return self.__relaxSpfLimit
      
  def _set_relaxSpfLimit(self, v, load=False):
    """
    Setter method for relaxSpfLimit, mapped from YANG variable /isiscomm/isSites/isSite/relaxSpfLimit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relaxSpfLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relaxSpfLimit() directly.

    YANG Description: Allow the device to receive the routes with a cost greater than 1023.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="relaxSpfLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relaxSpfLimit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="relaxSpfLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__relaxSpfLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relaxSpfLimit(self):
    self.__relaxSpfLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="relaxSpfLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_linkQuaDeteEn(self):
    """
    Getter method for linkQuaDeteEn, mapped from YANG variable /isiscomm/isSites/isSite/linkQuaDeteEn (boolean)

    YANG Description: Enable Link Quality Detection
    """
    return self.__linkQuaDeteEn
      
  def _set_linkQuaDeteEn(self, v, load=False):
    """
    Setter method for linkQuaDeteEn, mapped from YANG variable /isiscomm/isSites/isSite/linkQuaDeteEn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linkQuaDeteEn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linkQuaDeteEn() directly.

    YANG Description: Enable Link Quality Detection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="linkQuaDeteEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linkQuaDeteEn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="linkQuaDeteEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__linkQuaDeteEn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linkQuaDeteEn(self):
    self.__linkQuaDeteEn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="linkQuaDeteEn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_spfMaxInterval(self):
    """
    Getter method for spfMaxInterval, mapped from YANG variable /isiscomm/isSites/isSite/spfMaxInterval (uint32)

    YANG Description: Set the maximum delay time for route calculation. The value is an integer, expressed in seconds. The default value is 5.
    """
    return self.__spfMaxInterval
      
  def _set_spfMaxInterval(self, v, load=False):
    """
    Setter method for spfMaxInterval, mapped from YANG variable /isiscomm/isSites/isSite/spfMaxInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spfMaxInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spfMaxInterval() directly.

    YANG Description: Set the maximum delay time for route calculation. The value is an integer, expressed in seconds. The default value is 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="spfMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spfMaxInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="spfMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__spfMaxInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spfMaxInterval(self):
    self.__spfMaxInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="spfMaxInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_spfInitInterval(self):
    """
    Getter method for spfInitInterval, mapped from YANG variable /isiscomm/isSites/isSite/spfInitInterval (uint32)

    YANG Description: Set the delay for the first route calculation. The value is an integer, expressed in milliseconds. The default value is 50.
    """
    return self.__spfInitInterval
      
  def _set_spfInitInterval(self, v, load=False):
    """
    Setter method for spfInitInterval, mapped from YANG variable /isiscomm/isSites/isSite/spfInitInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spfInitInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spfInitInterval() directly.

    YANG Description: Set the delay for the first route calculation. The value is an integer, expressed in milliseconds. The default value is 50.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="spfInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spfInitInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="spfInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__spfInitInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spfInitInterval(self):
    self.__spfInitInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="spfInitInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_spfIncrInterval(self):
    """
    Getter method for spfIncrInterval, mapped from YANG variable /isiscomm/isSites/isSite/spfIncrInterval (uint32)

    YANG Description: Set the incremental delay between two route calculations. The delay doubles the previous one each time. The value is an integer, expressed in milliseconds. The default value is 200.
    """
    return self.__spfIncrInterval
      
  def _set_spfIncrInterval(self, v, load=False):
    """
    Setter method for spfIncrInterval, mapped from YANG variable /isiscomm/isSites/isSite/spfIncrInterval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spfIncrInterval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spfIncrInterval() directly.

    YANG Description: Set the incremental delay between two route calculations. The delay doubles the previous one each time. The value is an integer, expressed in milliseconds. The default value is 200.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="spfIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spfIncrInterval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="spfIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__spfIncrInterval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spfIncrInterval(self):
    self.__spfIncrInterval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="spfIncrInterval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1lspLengthOrig(self):
    """
    Getter method for level1lspLengthOrig, mapped from YANG variable /isiscomm/isSites/isSite/level1lspLengthOrig (uint32)

    YANG Description: Set the maximum size of the level-1 LSPs that are generated locally. The value is expressed in bytes. The default value is 1497.
    """
    return self.__level1lspLengthOrig
      
  def _set_level1lspLengthOrig(self, v, load=False):
    """
    Setter method for level1lspLengthOrig, mapped from YANG variable /isiscomm/isSites/isSite/level1lspLengthOrig (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1lspLengthOrig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1lspLengthOrig() directly.

    YANG Description: Set the maximum size of the level-1 LSPs that are generated locally. The value is expressed in bytes. The default value is 1497.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level1lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1lspLengthOrig must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level1lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level1lspLengthOrig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1lspLengthOrig(self):
    self.__level1lspLengthOrig = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level1lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level2lspLengthOrig(self):
    """
    Getter method for level2lspLengthOrig, mapped from YANG variable /isiscomm/isSites/isSite/level2lspLengthOrig (uint32)

    YANG Description: Set the maximum size of the level-2 LSPs that are generated locally. The value is expressed in bytes. The default value is 1497.
    """
    return self.__level2lspLengthOrig
      
  def _set_level2lspLengthOrig(self, v, load=False):
    """
    Setter method for level2lspLengthOrig, mapped from YANG variable /isiscomm/isSites/isSite/level2lspLengthOrig (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2lspLengthOrig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2lspLengthOrig() directly.

    YANG Description: Set the maximum size of the level-2 LSPs that are generated locally. The value is expressed in bytes. The default value is 1497.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level2lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2lspLengthOrig must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level2lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__level2lspLengthOrig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2lspLengthOrig(self):
    self.__level2lspLengthOrig = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="level2lspLengthOrig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_lspReceiveLength(self):
    """
    Getter method for lspReceiveLength, mapped from YANG variable /isiscomm/isSites/isSite/lspReceiveLength (uint32)

    YANG Description: Set the maximum size of the LSPs that can be received. The value is expressed in bytes. The default value is 1497.
    """
    return self.__lspReceiveLength
      
  def _set_lspReceiveLength(self, v, load=False):
    """
    Setter method for lspReceiveLength, mapped from YANG variable /isiscomm/isSites/isSite/lspReceiveLength (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspReceiveLength is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspReceiveLength() directly.

    YANG Description: Set the maximum size of the LSPs that can be received. The value is expressed in bytes. The default value is 1497.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="lspReceiveLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspReceiveLength must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="lspReceiveLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__lspReceiveLength = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspReceiveLength(self):
    self.__lspReceiveLength = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['512..16384']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1497), is_leaf=True, yang_name="lspReceiveLength", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_level1LspFragExtEnable(self):
    """
    Getter method for level1LspFragExtEnable, mapped from YANG variable /isiscomm/isSites/isSite/level1LspFragExtEnable (boolean)

    YANG Description: Enable the level-1 LSP fragment extension.
    """
    return self.__level1LspFragExtEnable
      
  def _set_level1LspFragExtEnable(self, v, load=False):
    """
    Setter method for level1LspFragExtEnable, mapped from YANG variable /isiscomm/isSites/isSite/level1LspFragExtEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1LspFragExtEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1LspFragExtEnable() directly.

    YANG Description: Enable the level-1 LSP fragment extension.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1LspFragExtEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level1LspFragExtEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1LspFragExtEnable(self):
    self.__level1LspFragExtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level1LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level2LspFragExtEnable(self):
    """
    Getter method for level2LspFragExtEnable, mapped from YANG variable /isiscomm/isSites/isSite/level2LspFragExtEnable (boolean)

    YANG Description: Enable the level-2 LSP fragment extension.
    """
    return self.__level2LspFragExtEnable
      
  def _set_level2LspFragExtEnable(self, v, load=False):
    """
    Setter method for level2LspFragExtEnable, mapped from YANG variable /isiscomm/isSites/isSite/level2LspFragExtEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2LspFragExtEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2LspFragExtEnable() directly.

    YANG Description: Enable the level-2 LSP fragment extension.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2LspFragExtEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__level2LspFragExtEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2LspFragExtEnable(self):
    self.__level2LspFragExtEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="level2LspFragExtEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_level1LspFragExtMode(self):
    """
    Getter method for level1LspFragExtMode, mapped from YANG variable /isiscomm/isSites/isSite/level1LspFragExtMode (string)

    YANG Description: Mode in which the level-1 LSP fragments extension is enabled. The mode can be mode-1 or mode-2. The default mode is mode-1.
    """
    return self.__level1LspFragExtMode
      
  def _set_level1LspFragExtMode(self, v, load=False):
    """
    Setter method for level1LspFragExtMode, mapped from YANG variable /isiscomm/isSites/isSite/level1LspFragExtMode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level1LspFragExtMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level1LspFragExtMode() directly.

    YANG Description: Mode in which the level-1 LSP fragments extension is enabled. The mode can be mode-1 or mode-2. The default mode is mode-1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level1LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level1LspFragExtMode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level1LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__level1LspFragExtMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level1LspFragExtMode(self):
    self.__level1LspFragExtMode = YANGDynClass(base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level1LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_level2LspFragExtMode(self):
    """
    Getter method for level2LspFragExtMode, mapped from YANG variable /isiscomm/isSites/isSite/level2LspFragExtMode (string)

    YANG Description: Mode in which the level-2 LSP fragments extension is enabled. The mode can be mode-1 or mode-2. The default mode is mode-1.
    """
    return self.__level2LspFragExtMode
      
  def _set_level2LspFragExtMode(self, v, load=False):
    """
    Setter method for level2LspFragExtMode, mapped from YANG variable /isiscomm/isSites/isSite/level2LspFragExtMode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level2LspFragExtMode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level2LspFragExtMode() directly.

    YANG Description: Mode in which the level-2 LSP fragments extension is enabled. The mode can be mode-1 or mode-2. The default mode is mode-1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level2LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level2LspFragExtMode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level2LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__level2LspFragExtMode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level2LspFragExtMode(self):
    self.__level2LspFragExtMode = YANGDynClass(base=six.text_type, default=six.text_type("mode_1"), is_leaf=True, yang_name="level2LspFragExtMode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_localSymbolicName(self):
    """
    Getter method for localSymbolicName, mapped from YANG variable /isiscomm/isSites/isSite/localSymbolicName (string)

    YANG Description: Set a dynamic host name for the local system.
    """
    return self.__localSymbolicName
      
  def _set_localSymbolicName(self, v, load=False):
    """
    Setter method for localSymbolicName, mapped from YANG variable /isiscomm/isSites/isSite/localSymbolicName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localSymbolicName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localSymbolicName() directly.

    YANG Description: Set a dynamic host name for the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="localSymbolicName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """localSymbolicName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="localSymbolicName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__localSymbolicName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_localSymbolicName(self):
    self.__localSymbolicName = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="localSymbolicName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_stdAutoCostEnable(self):
    """
    Getter method for stdAutoCostEnable, mapped from YANG variable /isiscomm/isSites/isSite/stdAutoCostEnable (boolean)

    YANG Description: Enable automatic cost calculation for the system. By default, the function is disabled.
    """
    return self.__stdAutoCostEnable
      
  def _set_stdAutoCostEnable(self, v, load=False):
    """
    Setter method for stdAutoCostEnable, mapped from YANG variable /isiscomm/isSites/isSite/stdAutoCostEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdAutoCostEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdAutoCostEnable() directly.

    YANG Description: Enable automatic cost calculation for the system. By default, the function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdAutoCostEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__stdAutoCostEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdAutoCostEnable(self):
    self.__stdAutoCostEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_stdAutoCostEnableCompatible(self):
    """
    Getter method for stdAutoCostEnableCompatible, mapped from YANG variable /isiscomm/isSites/isSite/stdAutoCostEnableCompatible (boolean)

    YANG Description: Enable automatic cost calculation compatibly for the system. By default, the function is disabled.
    """
    return self.__stdAutoCostEnableCompatible
      
  def _set_stdAutoCostEnableCompatible(self, v, load=False):
    """
    Setter method for stdAutoCostEnableCompatible, mapped from YANG variable /isiscomm/isSites/isSite/stdAutoCostEnableCompatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdAutoCostEnableCompatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdAutoCostEnableCompatible() directly.

    YANG Description: Enable automatic cost calculation compatibly for the system. By default, the function is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdAutoCostEnableCompatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__stdAutoCostEnableCompatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdAutoCostEnableCompatible(self):
    self.__stdAutoCostEnableCompatible = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stdAutoCostEnableCompatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_stdbandwidth(self):
    """
    Getter method for stdbandwidth, mapped from YANG variable /isiscomm/isSites/isSite/stdbandwidth (uint32)

    YANG Description: Set a bandwidth reference used for the automatic calculation of the cost for an interface. The value is expressed in Mbit/s. The default value is 100.
    """
    return self.__stdbandwidth
      
  def _set_stdbandwidth(self, v, load=False):
    """
    Setter method for stdbandwidth, mapped from YANG variable /isiscomm/isSites/isSite/stdbandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdbandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdbandwidth() directly.

    YANG Description: Set a bandwidth reference used for the automatic calculation of the cost for an interface. The value is expressed in Mbit/s. The default value is 100.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="stdbandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdbandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="stdbandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdbandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdbandwidth(self):
    self.__stdbandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="stdbandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_stdLevel1Cost(self):
    """
    Getter method for stdLevel1Cost, mapped from YANG variable /isiscomm/isSites/isSite/stdLevel1Cost (uint32)

    YANG Description: Set a level-1 interface cost. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    return self.__stdLevel1Cost
      
  def _set_stdLevel1Cost(self, v, load=False):
    """
    Setter method for stdLevel1Cost, mapped from YANG variable /isiscomm/isSites/isSite/stdLevel1Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdLevel1Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdLevel1Cost() directly.

    YANG Description: Set a level-1 interface cost. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdLevel1Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdLevel1Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdLevel1Cost(self):
    self.__stdLevel1Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel1Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_stdLevel2Cost(self):
    """
    Getter method for stdLevel2Cost, mapped from YANG variable /isiscomm/isSites/isSite/stdLevel2Cost (uint32)

    YANG Description: Set a level-2 interface cost. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    return self.__stdLevel2Cost
      
  def _set_stdLevel2Cost(self, v, load=False):
    """
    Setter method for stdLevel2Cost, mapped from YANG variable /isiscomm/isSites/isSite/stdLevel2Cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stdLevel2Cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stdLevel2Cost() directly.

    YANG Description: Set a level-2 interface cost. If the IS-IS cost type is narrow, narrow-compatible, or compatible, the value ranges from 1 to 63. If the IS-IS cost type is wide or wide-compatible, the value ranges from 1 to 16777215.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stdLevel2Cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__stdLevel2Cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stdLevel2Cost(self):
    self.__stdLevel2Cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), is_leaf=True, yang_name="stdLevel2Cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_baseTopoType(self):
    """
    Getter method for baseTopoType, mapped from YANG variable /isiscomm/isSites/isSite/baseTopoType (string)

    YANG Description: Type of IPv6 enabling, which can be Standard, Compatible, IPv6, or Compatible IPv6 SPF.
    """
    return self.__baseTopoType
      
  def _set_baseTopoType(self, v, load=False):
    """
    Setter method for baseTopoType, mapped from YANG variable /isiscomm/isSites/isSite/baseTopoType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_baseTopoType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_baseTopoType() directly.

    YANG Description: Type of IPv6 enabling, which can be Standard, Compatible, IPv6, or Compatible IPv6 SPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("invalid"), is_leaf=True, yang_name="baseTopoType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """baseTopoType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("invalid"), is_leaf=True, yang_name="baseTopoType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__baseTopoType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_baseTopoType(self):
    self.__baseTopoType = YANGDynClass(base=six.text_type, default=six.text_type("invalid"), is_leaf=True, yang_name="baseTopoType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_ldpAutoCfg(self):
    """
    Getter method for ldpAutoCfg, mapped from YANG variable /isiscomm/isSites/isSite/ldpAutoCfg (boolean)

    YANG Description: Auto MPLS LDP configuration on an interface.
    """
    return self.__ldpAutoCfg
      
  def _set_ldpAutoCfg(self, v, load=False):
    """
    Setter method for ldpAutoCfg, mapped from YANG variable /isiscomm/isSites/isSite/ldpAutoCfg (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldpAutoCfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldpAutoCfg() directly.

    YANG Description: Auto MPLS LDP configuration on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldpAutoCfg must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__ldpAutoCfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldpAutoCfg(self):
    self.__ldpAutoCfg = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldpAutoCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_poiEnable(self):
    """
    Getter method for poiEnable, mapped from YANG variable /isiscomm/isSites/isSite/poiEnable (boolean)

    YANG Description: Enable purge-originator-identification.
    """
    return self.__poiEnable
      
  def _set_poiEnable(self, v, load=False):
    """
    Setter method for poiEnable, mapped from YANG variable /isiscomm/isSites/isSite/poiEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_poiEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_poiEnable() directly.

    YANG Description: Enable purge-originator-identification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """poiEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__poiEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_poiEnable(self):
    self.__poiEnable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_poiAlways(self):
    """
    Getter method for poiAlways, mapped from YANG variable /isiscomm/isSites/isSite/poiAlways (boolean)

    YANG Description: Set purge-originator-identification always with POI TLV.
    """
    return self.__poiAlways
      
  def _set_poiAlways(self, v, load=False):
    """
    Setter method for poiAlways, mapped from YANG variable /isiscomm/isSites/isSite/poiAlways (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_poiAlways is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_poiAlways() directly.

    YANG Description: Set purge-originator-identification always with POI TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiAlways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """poiAlways must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiAlways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__poiAlways = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_poiAlways(self):
    self.__poiAlways = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="poiAlways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_lsdbLimit(self):
    """
    Getter method for lsdbLimit, mapped from YANG variable /isiscomm/isSites/isSite/lsdbLimit (boolean)

    YANG Description: Limit the number of the LSDBs.
    """
    return self.__lsdbLimit
      
  def _set_lsdbLimit(self, v, load=False):
    """
    Setter method for lsdbLimit, mapped from YANG variable /isiscomm/isSites/isSite/lsdbLimit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdbLimit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdbLimit() directly.

    YANG Description: Limit the number of the LSDBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lsdbLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdbLimit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lsdbLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__lsdbLimit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdbLimit(self):
    self.__lsdbLimit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lsdbLimit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_lsdbLimitNum(self):
    """
    Getter method for lsdbLimitNum, mapped from YANG variable /isiscomm/isSites/isSite/lsdbLimitNum (uint32)

    YANG Description: Maximum number of LSDBs.
    """
    return self.__lsdbLimitNum
      
  def _set_lsdbLimitNum(self, v, load=False):
    """
    Setter method for lsdbLimitNum, mapped from YANG variable /isiscomm/isSites/isSite/lsdbLimitNum (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdbLimitNum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdbLimitNum() directly.

    YANG Description: Maximum number of LSDBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="lsdbLimitNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdbLimitNum must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="lsdbLimitNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__lsdbLimitNum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdbLimitNum(self):
    self.__lsdbLimitNum = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="lsdbLimitNum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_lsdbThresUpper(self):
    """
    Getter method for lsdbThresUpper, mapped from YANG variable /isiscomm/isSites/isSite/lsdbThresUpper (uint8)

    YANG Description: Threshold upper percentage of the maximum number of LSDBs, used to trigger an alarm.
    """
    return self.__lsdbThresUpper
      
  def _set_lsdbThresUpper(self, v, load=False):
    """
    Setter method for lsdbThresUpper, mapped from YANG variable /isiscomm/isSites/isSite/lsdbThresUpper (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdbThresUpper is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdbThresUpper() directly.

    YANG Description: Threshold upper percentage of the maximum number of LSDBs, used to trigger an alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(80), is_leaf=True, yang_name="lsdbThresUpper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdbThresUpper must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(80), is_leaf=True, yang_name="lsdbThresUpper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__lsdbThresUpper = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdbThresUpper(self):
    self.__lsdbThresUpper = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(80), is_leaf=True, yang_name="lsdbThresUpper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_lsdbThresLower(self):
    """
    Getter method for lsdbThresLower, mapped from YANG variable /isiscomm/isSites/isSite/lsdbThresLower (uint8)

    YANG Description: Threshold lower percentage of the maximum number of LSDBs, used to trigger a clear alarm.
    """
    return self.__lsdbThresLower
      
  def _set_lsdbThresLower(self, v, load=False):
    """
    Setter method for lsdbThresLower, mapped from YANG variable /isiscomm/isSites/isSite/lsdbThresLower (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdbThresLower is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdbThresLower() directly.

    YANG Description: Threshold lower percentage of the maximum number of LSDBs, used to trigger a clear alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(70), is_leaf=True, yang_name="lsdbThresLower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdbThresLower must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(70), is_leaf=True, yang_name="lsdbThresLower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)""",
        })

    self.__lsdbThresLower = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdbThresLower(self):
    self.__lsdbThresLower = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(70), is_leaf=True, yang_name="lsdbThresLower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint8', is_config=True)


  def _get_directInherit(self):
    """
    Getter method for directInherit, mapped from YANG variable /isiscomm/isSites/isSite/directInherit (boolean)

    YANG Description: Inherit the Direct Route Property.
    """
    return self.__directInherit
      
  def _set_directInherit(self, v, load=False):
    """
    Setter method for directInherit, mapped from YANG variable /isiscomm/isSites/isSite/directInherit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_directInherit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_directInherit() directly.

    YANG Description: Inherit the Direct Route Property.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="directInherit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """directInherit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="directInherit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__directInherit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_directInherit(self):
    self.__directInherit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="directInherit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /isiscomm/isSites/isSite/description (string)

    YANG Description: Set a description information text. The value is a string of case-sensitive characters. 
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /isiscomm/isSites/isSite/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Set a description information text. The value is a string of case-sensitive characters. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='string', is_config=True)


  def _get_peerFlappingSuppress(self):
    """
    Getter method for peerFlappingSuppress, mapped from YANG variable /isiscomm/isSites/isSite/peerFlappingSuppress (boolean)

    YANG Description: Enable the neighbor relationship flapping suppression function. By default, the function is enabled.
    """
    return self.__peerFlappingSuppress
      
  def _set_peerFlappingSuppress(self, v, load=False):
    """
    Setter method for peerFlappingSuppress, mapped from YANG variable /isiscomm/isSites/isSite/peerFlappingSuppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peerFlappingSuppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peerFlappingSuppress() directly.

    YANG Description: Enable the neighbor relationship flapping suppression function. By default, the function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlappingSuppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peerFlappingSuppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlappingSuppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__peerFlappingSuppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peerFlappingSuppress(self):
    self.__peerFlappingSuppress = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peerFlappingSuppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isSREnableMPLS(self):
    """
    Getter method for isSREnableMPLS, mapped from YANG variable /isiscomm/isSites/isSite/isSREnableMPLS (boolean)

    YANG Description: Enable SegmentRouting MPLS.
    """
    return self.__isSREnableMPLS
      
  def _set_isSREnableMPLS(self, v, load=False):
    """
    Setter method for isSREnableMPLS, mapped from YANG variable /isiscomm/isSites/isSite/isSREnableMPLS (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSREnableMPLS is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSREnableMPLS() directly.

    YANG Description: Enable SegmentRouting MPLS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSREnableMPLS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSREnableMPLS must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSREnableMPLS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__isSREnableMPLS = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSREnableMPLS(self):
    self.__isSREnableMPLS = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="isSREnableMPLS", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_bwConstraint(self):
    """
    Getter method for bwConstraint, mapped from YANG variable /isiscomm/isSites/isSite/bwConstraint (uint32)

    YANG Description: Change the value of Bandwidth Constraints sub-tlv.
    """
    return self.__bwConstraint
      
  def _set_bwConstraint(self, v, load=False):
    """
    Setter method for bwConstraint, mapped from YANG variable /isiscomm/isSites/isSite/bwConstraint (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bwConstraint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bwConstraint() directly.

    YANG Description: Change the value of Bandwidth Constraints sub-tlv.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="bwConstraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bwConstraint must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="bwConstraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__bwConstraint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bwConstraint(self):
    self.__bwConstraint = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="bwConstraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_loMultiplier(self):
    """
    Getter method for loMultiplier, mapped from YANG variable /isiscomm/isSites/isSite/loMultiplier (uint32)

    YANG Description: Change the value of Local Overbooking Multipliers sub-tlv.
    """
    return self.__loMultiplier
      
  def _set_loMultiplier(self, v, load=False):
    """
    Setter method for loMultiplier, mapped from YANG variable /isiscomm/isSites/isSite/loMultiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loMultiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loMultiplier() directly.

    YANG Description: Change the value of Local Overbooking Multipliers sub-tlv.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="loMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loMultiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="loMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__loMultiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loMultiplier(self):
    self.__loMultiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="loMultiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_unresvBwSubPool(self):
    """
    Getter method for unresvBwSubPool, mapped from YANG variable /isiscomm/isSites/isSite/unresvBwSubPool (uint32)

    YANG Description: Change the value of Unreserved Sub-Pool Bandwidth sub-tlv.
    """
    return self.__unresvBwSubPool
      
  def _set_unresvBwSubPool(self, v, load=False):
    """
    Setter method for unresvBwSubPool, mapped from YANG variable /isiscomm/isSites/isSite/unresvBwSubPool (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unresvBwSubPool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unresvBwSubPool() directly.

    YANG Description: Change the value of Unreserved Sub-Pool Bandwidth sub-tlv.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="unresvBwSubPool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unresvBwSubPool must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="unresvBwSubPool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__unresvBwSubPool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unresvBwSubPool(self):
    self.__unresvBwSubPool = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['19..254']}), is_leaf=True, yang_name="unresvBwSubPool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_purgeLspDelayVal(self):
    """
    Getter method for purgeLspDelayVal, mapped from YANG variable /isiscomm/isSites/isSite/purgeLspDelayVal (uint32)

    YANG Description: Set the delay time of routing calculation after receiving purge LSP.
    """
    return self.__purgeLspDelayVal
      
  def _set_purgeLspDelayVal(self, v, load=False):
    """
    Setter method for purgeLspDelayVal, mapped from YANG variable /isiscomm/isSites/isSite/purgeLspDelayVal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purgeLspDelayVal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purgeLspDelayVal() directly.

    YANG Description: Set the delay time of routing calculation after receiving purge LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="purgeLspDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purgeLspDelayVal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="purgeLspDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__purgeLspDelayVal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purgeLspDelayVal(self):
    self.__purgeLspDelayVal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="purgeLspDelayVal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)


  def _get_advOneIntfAddr(self):
    """
    Getter method for advOneIntfAddr, mapped from YANG variable /isiscomm/isSites/isSite/advOneIntfAddr (boolean)

    YANG Description: Advertise one interface address
    """
    return self.__advOneIntfAddr
      
  def _set_advOneIntfAddr(self, v, load=False):
    """
    Setter method for advOneIntfAddr, mapped from YANG variable /isiscomm/isSites/isSite/advOneIntfAddr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advOneIntfAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advOneIntfAddr() directly.

    YANG Description: Advertise one interface address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advOneIntfAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advOneIntfAddr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advOneIntfAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__advOneIntfAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advOneIntfAddr(self):
    self.__advOneIntfAddr = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advOneIntfAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_isLspAgeRefresh(self):
    """
    Getter method for isLspAgeRefresh, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh (container)

    YANG Description: Refresh the remaining-lifetime field of a LSP.
    """
    return self.__isLspAgeRefresh
      
  def _set_isLspAgeRefresh(self, v, load=False):
    """
    Setter method for isLspAgeRefresh, mapped from YANG variable /isiscomm/isSites/isSite/isLspAgeRefresh (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLspAgeRefresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLspAgeRefresh() directly.

    YANG Description: Refresh the remaining-lifetime field of a LSP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLspAgeRefresh_huawei_isiscomm__isiscomm_isSites_isSite_isLspAgeRefresh, is_container='container', yang_name="isLspAgeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLspAgeRefresh must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLspAgeRefresh_huawei_isiscomm__isiscomm_isSites_isSite_isLspAgeRefresh, is_container='container', yang_name="isLspAgeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLspAgeRefresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLspAgeRefresh(self):
    self.__isLspAgeRefresh = YANGDynClass(base=yc_isLspAgeRefresh_huawei_isiscomm__isiscomm_isSites_isSite_isLspAgeRefresh, is_container='container', yang_name="isLspAgeRefresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isBgpLs(self):
    """
    Getter method for isBgpLs, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs (container)

    YANG Description: Enable the Bgp-ls.
    """
    return self.__isBgpLs
      
  def _set_isBgpLs(self, v, load=False):
    """
    Setter method for isBgpLs, mapped from YANG variable /isiscomm/isSites/isSite/isBgpLs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isBgpLs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isBgpLs() directly.

    YANG Description: Enable the Bgp-ls.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isBgpLs_huawei_isiscomm__isiscomm_isSites_isSite_isBgpLs, is_container='container', yang_name="isBgpLs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isBgpLs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isBgpLs_huawei_isiscomm__isiscomm_isSites_isSite_isBgpLs, is_container='container', yang_name="isBgpLs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isBgpLs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isBgpLs(self):
    self.__isBgpLs = YANGDynClass(base=yc_isBgpLs_huawei_isiscomm__isiscomm_isSites_isSite_isBgpLs, is_container='container', yang_name="isBgpLs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLspGenIntelliTimer(self):
    """
    Getter method for isLspGenIntelliTimer, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer (container)

    YANG Description: Set an intelligent timer to generate LSPs.
    """
    return self.__isLspGenIntelliTimer
      
  def _set_isLspGenIntelliTimer(self, v, load=False):
    """
    Setter method for isLspGenIntelliTimer, mapped from YANG variable /isiscomm/isSites/isSite/isLspGenIntelliTimer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLspGenIntelliTimer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLspGenIntelliTimer() directly.

    YANG Description: Set an intelligent timer to generate LSPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLspGenIntelliTimer_huawei_isiscomm__isiscomm_isSites_isSite_isLspGenIntelliTimer, is_container='container', yang_name="isLspGenIntelliTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLspGenIntelliTimer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLspGenIntelliTimer_huawei_isiscomm__isiscomm_isSites_isSite_isLspGenIntelliTimer, is_container='container', yang_name="isLspGenIntelliTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLspGenIntelliTimer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLspGenIntelliTimer(self):
    self.__isLspGenIntelliTimer = YANGDynClass(base=yc_isLspGenIntelliTimer_huawei_isiscomm__isiscomm_isSites_isSite_isLspGenIntelliTimer, is_container='container', yang_name="isLspGenIntelliTimer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isFlashFlood(self):
    """
    Getter method for isFlashFlood, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood (container)

    YANG Description: Enable immediate LSP flooding.
    """
    return self.__isFlashFlood
      
  def _set_isFlashFlood(self, v, load=False):
    """
    Setter method for isFlashFlood, mapped from YANG variable /isiscomm/isSites/isSite/isFlashFlood (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isFlashFlood is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isFlashFlood() directly.

    YANG Description: Enable immediate LSP flooding.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isFlashFlood_huawei_isiscomm__isiscomm_isSites_isSite_isFlashFlood, is_container='container', yang_name="isFlashFlood", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isFlashFlood must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isFlashFlood_huawei_isiscomm__isiscomm_isSites_isSite_isFlashFlood, is_container='container', yang_name="isFlashFlood", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isFlashFlood = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isFlashFlood(self):
    self.__isFlashFlood = YANGDynClass(base=yc_isFlashFlood_huawei_isiscomm__isiscomm_isSites_isSite_isFlashFlood, is_container='container', yang_name="isFlashFlood", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isOverloadSet(self):
    """
    Getter method for isOverloadSet, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet (container)

    YANG Description: Set overload.
    """
    return self.__isOverloadSet
      
  def _set_isOverloadSet(self, v, load=False):
    """
    Setter method for isOverloadSet, mapped from YANG variable /isiscomm/isSites/isSite/isOverloadSet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isOverloadSet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isOverloadSet() directly.

    YANG Description: Set overload.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isOverloadSet_huawei_isiscomm__isiscomm_isSites_isSite_isOverloadSet, is_container='container', yang_name="isOverloadSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isOverloadSet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isOverloadSet_huawei_isiscomm__isiscomm_isSites_isSite_isOverloadSet, is_container='container', yang_name="isOverloadSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isOverloadSet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isOverloadSet(self):
    self.__isOverloadSet = YANGDynClass(base=yc_isOverloadSet_huawei_isiscomm__isiscomm_isSites_isSite_isOverloadSet, is_container='container', yang_name="isOverloadSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLdpSyncdSet(self):
    """
    Getter method for isLdpSyncdSet, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet (container)

    YANG Description: Set LDP and IS-IS synchronization.
    """
    return self.__isLdpSyncdSet
      
  def _set_isLdpSyncdSet(self, v, load=False):
    """
    Setter method for isLdpSyncdSet, mapped from YANG variable /isiscomm/isSites/isSite/isLdpSyncdSet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLdpSyncdSet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLdpSyncdSet() directly.

    YANG Description: Set LDP and IS-IS synchronization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLdpSyncdSet_huawei_isiscomm__isiscomm_isSites_isSite_isLdpSyncdSet, is_container='container', yang_name="isLdpSyncdSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLdpSyncdSet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLdpSyncdSet_huawei_isiscomm__isiscomm_isSites_isSite_isLdpSyncdSet, is_container='container', yang_name="isLdpSyncdSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLdpSyncdSet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLdpSyncdSet(self):
    self.__isLdpSyncdSet = YANGDynClass(base=yc_isLdpSyncdSet_huawei_isiscomm__isiscomm_isSites_isSite_isLdpSyncdSet, is_container='container', yang_name="isLdpSyncdSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isExternAbility(self):
    """
    Getter method for isExternAbility, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility (container)

    YANG Description: Expansibility.
    """
    return self.__isExternAbility
      
  def _set_isExternAbility(self, v, load=False):
    """
    Setter method for isExternAbility, mapped from YANG variable /isiscomm/isSites/isSite/isExternAbility (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isExternAbility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isExternAbility() directly.

    YANG Description: Expansibility.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isExternAbility_huawei_isiscomm__isiscomm_isSites_isSite_isExternAbility, is_container='container', yang_name="isExternAbility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isExternAbility must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isExternAbility_huawei_isiscomm__isiscomm_isSites_isSite_isExternAbility, is_container='container', yang_name="isExternAbility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isExternAbility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isExternAbility(self):
    self.__isExternAbility = YANGDynClass(base=yc_isExternAbility_huawei_isiscomm__isiscomm_isSites_isSite_isExternAbility, is_container='container', yang_name="isExternAbility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isAvoidMicroLoopSet(self):
    """
    Getter method for isAvoidMicroLoopSet, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet (container)

    YANG Description: Enable IS-IS avoid-microloop.
    """
    return self.__isAvoidMicroLoopSet
      
  def _set_isAvoidMicroLoopSet(self, v, load=False):
    """
    Setter method for isAvoidMicroLoopSet, mapped from YANG variable /isiscomm/isSites/isSite/isAvoidMicroLoopSet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isAvoidMicroLoopSet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isAvoidMicroLoopSet() directly.

    YANG Description: Enable IS-IS avoid-microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isAvoidMicroLoopSet, is_container='container', yang_name="isAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isAvoidMicroLoopSet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isAvoidMicroLoopSet, is_container='container', yang_name="isAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isAvoidMicroLoopSet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isAvoidMicroLoopSet(self):
    self.__isAvoidMicroLoopSet = YANGDynClass(base=yc_isAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isAvoidMicroLoopSet, is_container='container', yang_name="isAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLocalMtSets(self):
    """
    Getter method for isLocalMtSets, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets (container)

    YANG Description: List of local multicast topologies.
    """
    return self.__isLocalMtSets
      
  def _set_isLocalMtSets(self, v, load=False):
    """
    Setter method for isLocalMtSets, mapped from YANG variable /isiscomm/isSites/isSite/isLocalMtSets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLocalMtSets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLocalMtSets() directly.

    YANG Description: List of local multicast topologies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLocalMtSets_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets, is_container='container', yang_name="isLocalMtSets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLocalMtSets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLocalMtSets_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets, is_container='container', yang_name="isLocalMtSets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLocalMtSets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLocalMtSets(self):
    self.__isLocalMtSets = YANGDynClass(base=yc_isLocalMtSets_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets, is_container='container', yang_name="isLocalMtSets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isAreaIds(self):
    """
    Getter method for isAreaIds, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds (container)

    YANG Description: Auto list of NETs. 
    """
    return self.__isAreaIds
      
  def _set_isAreaIds(self, v, load=False):
    """
    Setter method for isAreaIds, mapped from YANG variable /isiscomm/isSites/isSite/isAreaIds (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isAreaIds is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isAreaIds() directly.

    YANG Description: Auto list of NETs. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isAreaIds_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds, is_container='container', yang_name="isAreaIds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isAreaIds must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isAreaIds_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds, is_container='container', yang_name="isAreaIds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isAreaIds = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isAreaIds(self):
    self.__isAreaIds = YANGDynClass(base=yc_isAreaIds_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds, is_container='container', yang_name="isAreaIds", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isNetEntitys(self):
    """
    Getter method for isNetEntitys, mapped from YANG variable /isiscomm/isSites/isSite/isNetEntitys (container)

    YANG Description: List of NETs. 
    """
    return self.__isNetEntitys
      
  def _set_isNetEntitys(self, v, load=False):
    """
    Setter method for isNetEntitys, mapped from YANG variable /isiscomm/isSites/isSite/isNetEntitys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNetEntitys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNetEntitys() directly.

    YANG Description: List of NETs. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isNetEntitys_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys, is_container='container', yang_name="isNetEntitys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNetEntitys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isNetEntitys_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys, is_container='container', yang_name="isNetEntitys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isNetEntitys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNetEntitys(self):
    self.__isNetEntitys = YANGDynClass(base=yc_isNetEntitys_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys, is_container='container', yang_name="isNetEntitys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLspAuthtications(self):
    """
    Getter method for isLspAuthtications, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications (container)

    YANG Description: Routing packet authentication list.
    """
    return self.__isLspAuthtications
      
  def _set_isLspAuthtications(self, v, load=False):
    """
    Setter method for isLspAuthtications, mapped from YANG variable /isiscomm/isSites/isSite/isLspAuthtications (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLspAuthtications is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLspAuthtications() directly.

    YANG Description: Routing packet authentication list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLspAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications, is_container='container', yang_name="isLspAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLspAuthtications must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLspAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications, is_container='container', yang_name="isLspAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLspAuthtications = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLspAuthtications(self):
    self.__isLspAuthtications = YANGDynClass(base=yc_isLspAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications, is_container='container', yang_name="isLspAuthtications", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isNameTables(self):
    """
    Getter method for isNameTables, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables (container)

    YANG Description: List of name mapping information.
    """
    return self.__isNameTables
      
  def _set_isNameTables(self, v, load=False):
    """
    Setter method for isNameTables, mapped from YANG variable /isiscomm/isSites/isSite/isNameTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isNameTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isNameTables() directly.

    YANG Description: List of name mapping information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables, is_container='container', yang_name="isNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isNameTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables, is_container='container', yang_name="isNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isNameTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isNameTables(self):
    self.__isNameTables = YANGDynClass(base=yc_isNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables, is_container='container', yang_name="isNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isVirtualSystems(self):
    """
    Getter method for isVirtualSystems, mapped from YANG variable /isiscomm/isSites/isSite/isVirtualSystems (container)

    YANG Description: Virtual system list.
    """
    return self.__isVirtualSystems
      
  def _set_isVirtualSystems(self, v, load=False):
    """
    Setter method for isVirtualSystems, mapped from YANG variable /isiscomm/isSites/isSite/isVirtualSystems (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isVirtualSystems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isVirtualSystems() directly.

    YANG Description: Virtual system list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isVirtualSystems_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems, is_container='container', yang_name="isVirtualSystems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isVirtualSystems must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isVirtualSystems_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems, is_container='container', yang_name="isVirtualSystems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isVirtualSystems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isVirtualSystems(self):
    self.__isVirtualSystems = YANGDynClass(base=yc_isVirtualSystems_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems, is_container='container', yang_name="isVirtualSystems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isSrgbs(self):
    """
    Getter method for isSrgbs, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs (container)

    YANG Description: List of Segment Routing Global-block.
    """
    return self.__isSrgbs
      
  def _set_isSrgbs(self, v, load=False):
    """
    Setter method for isSrgbs, mapped from YANG variable /isiscomm/isSites/isSite/isSrgbs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrgbs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrgbs() directly.

    YANG Description: List of Segment Routing Global-block.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSrgbs_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs, is_container='container', yang_name="isSrgbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrgbs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSrgbs_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs, is_container='container', yang_name="isSrgbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSrgbs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrgbs(self):
    self.__isSrgbs = YANGDynClass(base=yc_isSrgbs_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs, is_container='container', yang_name="isSrgbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isCircuits(self):
    """
    Getter method for isCircuits, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits (container)

    YANG Description: List of IS-IS interfaces.
    """
    return self.__isCircuits
      
  def _set_isCircuits(self, v, load=False):
    """
    Setter method for isCircuits, mapped from YANG variable /isiscomm/isSites/isSite/isCircuits (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isCircuits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isCircuits() directly.

    YANG Description: List of IS-IS interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isCircuits_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits, is_container='container', yang_name="isCircuits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isCircuits must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isCircuits_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits, is_container='container', yang_name="isCircuits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isCircuits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isCircuits(self):
    self.__isCircuits = YANGDynClass(base=yc_isCircuits_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits, is_container='container', yang_name="isCircuits", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isSiteMTs(self):
    """
    Getter method for isSiteMTs, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs (container)

    YANG Description: Multi-topology list.
    """
    return self.__isSiteMTs
      
  def _set_isSiteMTs(self, v, load=False):
    """
    Setter method for isSiteMTs, mapped from YANG variable /isiscomm/isSites/isSite/isSiteMTs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSiteMTs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSiteMTs() directly.

    YANG Description: Multi-topology list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSiteMTs_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs, is_container='container', yang_name="isSiteMTs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSiteMTs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSiteMTs_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs, is_container='container', yang_name="isSiteMTs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSiteMTs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSiteMTs(self):
    self.__isSiteMTs = YANGDynClass(base=yc_isSiteMTs_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs, is_container='container', yang_name="isSiteMTs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispLsdbs(self):
    """
    Getter method for isDispLsdbs, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs (container)

    YANG Description: List of LSDB information.
    """
    return self.__isDispLsdbs
      
  def _set_isDispLsdbs(self, v, load=False):
    """
    Setter method for isDispLsdbs, mapped from YANG variable /isiscomm/isSites/isSite/isDispLsdbs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispLsdbs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispLsdbs() directly.

    YANG Description: List of LSDB information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispLsdbs_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs, is_container='container', yang_name="isDispLsdbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispLsdbs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispLsdbs_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs, is_container='container', yang_name="isDispLsdbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispLsdbs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispLsdbs(self):
    self.__isDispLsdbs = YANGDynClass(base=yc_isDispLsdbs_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs, is_container='container', yang_name="isDispLsdbs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispPeers(self):
    """
    Getter method for isDispPeers, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers (container)

    YANG Description: List of neighbor information.
    """
    return self.__isDispPeers
      
  def _set_isDispPeers(self, v, load=False):
    """
    Setter method for isDispPeers, mapped from YANG variable /isiscomm/isSites/isSite/isDispPeers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispPeers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispPeers() directly.

    YANG Description: List of neighbor information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispPeers_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers, is_container='container', yang_name="isDispPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispPeers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispPeers_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers, is_container='container', yang_name="isDispPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispPeers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispPeers(self):
    self.__isDispPeers = YANGDynClass(base=yc_isDispPeers_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers, is_container='container', yang_name="isDispPeers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispCircs(self):
    """
    Getter method for isDispCircs, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs (container)

    YANG Description: List of circuit information.
    """
    return self.__isDispCircs
      
  def _set_isDispCircs(self, v, load=False):
    """
    Setter method for isDispCircs, mapped from YANG variable /isiscomm/isSites/isSite/isDispCircs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispCircs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispCircs() directly.

    YANG Description: List of circuit information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispCircs_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs, is_container='container', yang_name="isDispCircs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispCircs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispCircs_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs, is_container='container', yang_name="isDispCircs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispCircs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispCircs(self):
    self.__isDispCircs = YANGDynClass(base=yc_isDispCircs_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs, is_container='container', yang_name="isDispCircs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispLspStatisticss(self):
    """
    Getter method for isDispLspStatisticss, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss (container)

    YANG Description: List of LSP statistics.
    """
    return self.__isDispLspStatisticss
      
  def _set_isDispLspStatisticss(self, v, load=False):
    """
    Setter method for isDispLspStatisticss, mapped from YANG variable /isiscomm/isSites/isSite/isDispLspStatisticss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispLspStatisticss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispLspStatisticss() directly.

    YANG Description: List of LSP statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispLspStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss, is_container='container', yang_name="isDispLspStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispLspStatisticss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispLspStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss, is_container='container', yang_name="isDispLspStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispLspStatisticss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispLspStatisticss(self):
    self.__isDispLspStatisticss = YANGDynClass(base=yc_isDispLspStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss, is_container='container', yang_name="isDispLspStatisticss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispBfdSessions(self):
    """
    Getter method for isDispBfdSessions, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions (container)

    YANG Description: List of BFD session information.
    """
    return self.__isDispBfdSessions
      
  def _set_isDispBfdSessions(self, v, load=False):
    """
    Setter method for isDispBfdSessions, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdSessions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispBfdSessions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispBfdSessions() directly.

    YANG Description: List of BFD session information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispBfdSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions, is_container='container', yang_name="isDispBfdSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispBfdSessions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispBfdSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions, is_container='container', yang_name="isDispBfdSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispBfdSessions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispBfdSessions(self):
    self.__isDispBfdSessions = YANGDynClass(base=yc_isDispBfdSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions, is_container='container', yang_name="isDispBfdSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispBfdBitErrSessions(self):
    """
    Getter method for isDispBfdBitErrSessions, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions (container)

    YANG Description: List of BFD bit-error session information.
    """
    return self.__isDispBfdBitErrSessions
      
  def _set_isDispBfdBitErrSessions(self, v, load=False):
    """
    Setter method for isDispBfdBitErrSessions, mapped from YANG variable /isiscomm/isSites/isSite/isDispBfdBitErrSessions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispBfdBitErrSessions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispBfdBitErrSessions() directly.

    YANG Description: List of BFD bit-error session information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispBfdBitErrSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions, is_container='container', yang_name="isDispBfdBitErrSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispBfdBitErrSessions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispBfdBitErrSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions, is_container='container', yang_name="isDispBfdBitErrSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispBfdBitErrSessions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispBfdBitErrSessions(self):
    self.__isDispBfdBitErrSessions = YANGDynClass(base=yc_isDispBfdBitErrSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions, is_container='container', yang_name="isDispBfdBitErrSessions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispNameTables(self):
    """
    Getter method for isDispNameTables, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables (container)

    YANG Description: Name mapping table.
    """
    return self.__isDispNameTables
      
  def _set_isDispNameTables(self, v, load=False):
    """
    Setter method for isDispNameTables, mapped from YANG variable /isiscomm/isSites/isSite/isDispNameTables (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispNameTables is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispNameTables() directly.

    YANG Description: Name mapping table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables, is_container='container', yang_name="isDispNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispNameTables must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables, is_container='container', yang_name="isDispNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispNameTables = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispNameTables(self):
    self.__isDispNameTables = YANGDynClass(base=yc_isDispNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables, is_container='container', yang_name="isDispNameTables", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isLinkGroups(self):
    """
    Getter method for isLinkGroups, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups (container)

    YANG Description: List of link group
    """
    return self.__isLinkGroups
      
  def _set_isLinkGroups(self, v, load=False):
    """
    Setter method for isLinkGroups, mapped from YANG variable /isiscomm/isSites/isSite/isLinkGroups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isLinkGroups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isLinkGroups() directly.

    YANG Description: List of link group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isLinkGroups_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups, is_container='container', yang_name="isLinkGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isLinkGroups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isLinkGroups_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups, is_container='container', yang_name="isLinkGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isLinkGroups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isLinkGroups(self):
    self.__isLinkGroups = YANGDynClass(base=yc_isLinkGroups_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups, is_container='container', yang_name="isLinkGroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispVirtualAccs(self):
    """
    Getter method for isDispVirtualAccs, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs (container)

    YANG Description: Display the virtual access information list.
    """
    return self.__isDispVirtualAccs
      
  def _set_isDispVirtualAccs(self, v, load=False):
    """
    Setter method for isDispVirtualAccs, mapped from YANG variable /isiscomm/isSites/isSite/isDispVirtualAccs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispVirtualAccs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispVirtualAccs() directly.

    YANG Description: Display the virtual access information list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispVirtualAccs_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs, is_container='container', yang_name="isDispVirtualAccs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispVirtualAccs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispVirtualAccs_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs, is_container='container', yang_name="isDispVirtualAccs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispVirtualAccs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispVirtualAccs(self):
    self.__isDispVirtualAccs = YANGDynClass(base=yc_isDispVirtualAccs_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs, is_container='container', yang_name="isDispVirtualAccs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isSegrCfg(self):
    """
    Getter method for isSegrCfg, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg (container)

    YANG Description: Configuration about ISIS segment-routing
    """
    return self.__isSegrCfg
      
  def _set_isSegrCfg(self, v, load=False):
    """
    Setter method for isSegrCfg, mapped from YANG variable /isiscomm/isSites/isSite/isSegrCfg (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSegrCfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSegrCfg() directly.

    YANG Description: Configuration about ISIS segment-routing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSegrCfg_huawei_isiscomm__isiscomm_isSites_isSite_isSegrCfg, is_container='container', yang_name="isSegrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSegrCfg must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSegrCfg_huawei_isiscomm__isiscomm_isSites_isSite_isSegrCfg, is_container='container', yang_name="isSegrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSegrCfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSegrCfg(self):
    self.__isSegrCfg = YANGDynClass(base=yc_isSegrCfg_huawei_isiscomm__isiscomm_isSites_isSite_isSegrCfg, is_container='container', yang_name="isSegrCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispMapSvrInfos(self):
    """
    Getter method for isDispMapSvrInfos, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos (container)

    YANG Description: Prefix and SID mapping information.
    """
    return self.__isDispMapSvrInfos
      
  def _set_isDispMapSvrInfos(self, v, load=False):
    """
    Setter method for isDispMapSvrInfos, mapped from YANG variable /isiscomm/isSites/isSite/isDispMapSvrInfos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispMapSvrInfos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispMapSvrInfos() directly.

    YANG Description: Prefix and SID mapping information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispMapSvrInfos_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos, is_container='container', yang_name="isDispMapSvrInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispMapSvrInfos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispMapSvrInfos_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos, is_container='container', yang_name="isDispMapSvrInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispMapSvrInfos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispMapSvrInfos(self):
    self.__isDispMapSvrInfos = YANGDynClass(base=yc_isDispMapSvrInfos_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos, is_container='container', yang_name="isDispMapSvrInfos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isSrv6Cfg(self):
    """
    Getter method for isSrv6Cfg, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg (container)

    YANG Description: Configuration about ISIS segment-routing IPv6.
    """
    return self.__isSrv6Cfg
      
  def _set_isSrv6Cfg(self, v, load=False):
    """
    Setter method for isSrv6Cfg, mapped from YANG variable /isiscomm/isSites/isSite/isSrv6Cfg (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSrv6Cfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSrv6Cfg() directly.

    YANG Description: Configuration about ISIS segment-routing IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSrv6Cfg_huawei_isiscomm__isiscomm_isSites_isSite_isSrv6Cfg, is_container='container', yang_name="isSrv6Cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSrv6Cfg must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSrv6Cfg_huawei_isiscomm__isiscomm_isSites_isSite_isSrv6Cfg, is_container='container', yang_name="isSrv6Cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSrv6Cfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSrv6Cfg(self):
    self.__isSrv6Cfg = YANGDynClass(base=yc_isSrv6Cfg_huawei_isiscomm__isiscomm_isSites_isSite_isSrv6Cfg, is_container='container', yang_name="isSrv6Cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isIPv6SrAvoidMicroLoopSet(self):
    """
    Getter method for isIPv6SrAvoidMicroLoopSet, mapped from YANG variable /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet (container)

    YANG Description: IPv6 segment-routing avoid-microloop.
    """
    return self.__isIPv6SrAvoidMicroLoopSet
      
  def _set_isIPv6SrAvoidMicroLoopSet(self, v, load=False):
    """
    Setter method for isIPv6SrAvoidMicroLoopSet, mapped from YANG variable /isiscomm/isSites/isSite/isIPv6SrAvoidMicroLoopSet (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isIPv6SrAvoidMicroLoopSet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isIPv6SrAvoidMicroLoopSet() directly.

    YANG Description: IPv6 segment-routing avoid-microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isIPv6SrAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isIPv6SrAvoidMicroLoopSet, is_container='container', yang_name="isIPv6SrAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isIPv6SrAvoidMicroLoopSet must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isIPv6SrAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isIPv6SrAvoidMicroLoopSet, is_container='container', yang_name="isIPv6SrAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isIPv6SrAvoidMicroLoopSet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isIPv6SrAvoidMicroLoopSet(self):
    self.__isIPv6SrAvoidMicroLoopSet = YANGDynClass(base=yc_isIPv6SrAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isIPv6SrAvoidMicroLoopSet, is_container='container', yang_name="isIPv6SrAvoidMicroLoopSet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isDispFrrSummrys(self):
    """
    Getter method for isDispFrrSummrys, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys (container)

    YANG Description: Route protection rate list
    """
    return self.__isDispFrrSummrys
      
  def _set_isDispFrrSummrys(self, v, load=False):
    """
    Setter method for isDispFrrSummrys, mapped from YANG variable /isiscomm/isSites/isSite/isDispFrrSummrys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isDispFrrSummrys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isDispFrrSummrys() directly.

    YANG Description: Route protection rate list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isDispFrrSummrys_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys, is_container='container', yang_name="isDispFrrSummrys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isDispFrrSummrys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isDispFrrSummrys_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys, is_container='container', yang_name="isDispFrrSummrys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isDispFrrSummrys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isDispFrrSummrys(self):
    self.__isDispFrrSummrys = YANGDynClass(base=yc_isDispFrrSummrys_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys, is_container='container', yang_name="isDispFrrSummrys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  instanceId = __builtin__.property(_get_instanceId, _set_instanceId)
  multiIID = __builtin__.property(_get_multiIID, _set_multiIID)
  vpnName = __builtin__.property(_get_vpnName, _set_vpnName)
  isLevel = __builtin__.property(_get_isLevel, _set_isLevel)
  lspMaxAge = __builtin__.property(_get_lspMaxAge, _set_lspMaxAge)
  lspRefreshInterval = __builtin__.property(_get_lspRefreshInterval, _set_lspRefreshInterval)
  shutDownEnable = __builtin__.property(_get_shutDownEnable, _set_shutDownEnable)
  costStyle = __builtin__.property(_get_costStyle, _set_costStyle)
  relaxSpfLimit = __builtin__.property(_get_relaxSpfLimit, _set_relaxSpfLimit)
  linkQuaDeteEn = __builtin__.property(_get_linkQuaDeteEn, _set_linkQuaDeteEn)
  spfMaxInterval = __builtin__.property(_get_spfMaxInterval, _set_spfMaxInterval)
  spfInitInterval = __builtin__.property(_get_spfInitInterval, _set_spfInitInterval)
  spfIncrInterval = __builtin__.property(_get_spfIncrInterval, _set_spfIncrInterval)
  level1lspLengthOrig = __builtin__.property(_get_level1lspLengthOrig, _set_level1lspLengthOrig)
  level2lspLengthOrig = __builtin__.property(_get_level2lspLengthOrig, _set_level2lspLengthOrig)
  lspReceiveLength = __builtin__.property(_get_lspReceiveLength, _set_lspReceiveLength)
  level1LspFragExtEnable = __builtin__.property(_get_level1LspFragExtEnable, _set_level1LspFragExtEnable)
  level2LspFragExtEnable = __builtin__.property(_get_level2LspFragExtEnable, _set_level2LspFragExtEnable)
  level1LspFragExtMode = __builtin__.property(_get_level1LspFragExtMode, _set_level1LspFragExtMode)
  level2LspFragExtMode = __builtin__.property(_get_level2LspFragExtMode, _set_level2LspFragExtMode)
  localSymbolicName = __builtin__.property(_get_localSymbolicName, _set_localSymbolicName)
  stdAutoCostEnable = __builtin__.property(_get_stdAutoCostEnable, _set_stdAutoCostEnable)
  stdAutoCostEnableCompatible = __builtin__.property(_get_stdAutoCostEnableCompatible, _set_stdAutoCostEnableCompatible)
  stdbandwidth = __builtin__.property(_get_stdbandwidth, _set_stdbandwidth)
  stdLevel1Cost = __builtin__.property(_get_stdLevel1Cost, _set_stdLevel1Cost)
  stdLevel2Cost = __builtin__.property(_get_stdLevel2Cost, _set_stdLevel2Cost)
  baseTopoType = __builtin__.property(_get_baseTopoType, _set_baseTopoType)
  ldpAutoCfg = __builtin__.property(_get_ldpAutoCfg, _set_ldpAutoCfg)
  poiEnable = __builtin__.property(_get_poiEnable, _set_poiEnable)
  poiAlways = __builtin__.property(_get_poiAlways, _set_poiAlways)
  lsdbLimit = __builtin__.property(_get_lsdbLimit, _set_lsdbLimit)
  lsdbLimitNum = __builtin__.property(_get_lsdbLimitNum, _set_lsdbLimitNum)
  lsdbThresUpper = __builtin__.property(_get_lsdbThresUpper, _set_lsdbThresUpper)
  lsdbThresLower = __builtin__.property(_get_lsdbThresLower, _set_lsdbThresLower)
  directInherit = __builtin__.property(_get_directInherit, _set_directInherit)
  description = __builtin__.property(_get_description, _set_description)
  peerFlappingSuppress = __builtin__.property(_get_peerFlappingSuppress, _set_peerFlappingSuppress)
  isSREnableMPLS = __builtin__.property(_get_isSREnableMPLS, _set_isSREnableMPLS)
  bwConstraint = __builtin__.property(_get_bwConstraint, _set_bwConstraint)
  loMultiplier = __builtin__.property(_get_loMultiplier, _set_loMultiplier)
  unresvBwSubPool = __builtin__.property(_get_unresvBwSubPool, _set_unresvBwSubPool)
  purgeLspDelayVal = __builtin__.property(_get_purgeLspDelayVal, _set_purgeLspDelayVal)
  advOneIntfAddr = __builtin__.property(_get_advOneIntfAddr, _set_advOneIntfAddr)
  isLspAgeRefresh = __builtin__.property(_get_isLspAgeRefresh, _set_isLspAgeRefresh) # type: yc_isLspAgeRefresh_huawei_isiscomm__isiscomm_isSites_isSite_isLspAgeRefresh
  isBgpLs = __builtin__.property(_get_isBgpLs, _set_isBgpLs) # type: yc_isBgpLs_huawei_isiscomm__isiscomm_isSites_isSite_isBgpLs
  isLspGenIntelliTimer = __builtin__.property(_get_isLspGenIntelliTimer, _set_isLspGenIntelliTimer) # type: yc_isLspGenIntelliTimer_huawei_isiscomm__isiscomm_isSites_isSite_isLspGenIntelliTimer
  isFlashFlood = __builtin__.property(_get_isFlashFlood, _set_isFlashFlood) # type: yc_isFlashFlood_huawei_isiscomm__isiscomm_isSites_isSite_isFlashFlood
  isOverloadSet = __builtin__.property(_get_isOverloadSet, _set_isOverloadSet) # type: yc_isOverloadSet_huawei_isiscomm__isiscomm_isSites_isSite_isOverloadSet
  isLdpSyncdSet = __builtin__.property(_get_isLdpSyncdSet, _set_isLdpSyncdSet) # type: yc_isLdpSyncdSet_huawei_isiscomm__isiscomm_isSites_isSite_isLdpSyncdSet
  isExternAbility = __builtin__.property(_get_isExternAbility, _set_isExternAbility) # type: yc_isExternAbility_huawei_isiscomm__isiscomm_isSites_isSite_isExternAbility
  isAvoidMicroLoopSet = __builtin__.property(_get_isAvoidMicroLoopSet, _set_isAvoidMicroLoopSet) # type: yc_isAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isAvoidMicroLoopSet
  isLocalMtSets = __builtin__.property(_get_isLocalMtSets, _set_isLocalMtSets) # type: yc_isLocalMtSets_huawei_isiscomm__isiscomm_isSites_isSite_isLocalMtSets
  isAreaIds = __builtin__.property(_get_isAreaIds, _set_isAreaIds) # type: yc_isAreaIds_huawei_isiscomm__isiscomm_isSites_isSite_isAreaIds
  isNetEntitys = __builtin__.property(_get_isNetEntitys, _set_isNetEntitys) # type: yc_isNetEntitys_huawei_isiscomm__isiscomm_isSites_isSite_isNetEntitys
  isLspAuthtications = __builtin__.property(_get_isLspAuthtications, _set_isLspAuthtications) # type: yc_isLspAuthtications_huawei_isiscomm__isiscomm_isSites_isSite_isLspAuthtications
  isNameTables = __builtin__.property(_get_isNameTables, _set_isNameTables) # type: yc_isNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isNameTables
  isVirtualSystems = __builtin__.property(_get_isVirtualSystems, _set_isVirtualSystems) # type: yc_isVirtualSystems_huawei_isiscomm__isiscomm_isSites_isSite_isVirtualSystems
  isSrgbs = __builtin__.property(_get_isSrgbs, _set_isSrgbs) # type: yc_isSrgbs_huawei_isiscomm__isiscomm_isSites_isSite_isSrgbs
  isCircuits = __builtin__.property(_get_isCircuits, _set_isCircuits) # type: yc_isCircuits_huawei_isiscomm__isiscomm_isSites_isSite_isCircuits
  isSiteMTs = __builtin__.property(_get_isSiteMTs, _set_isSiteMTs) # type: yc_isSiteMTs_huawei_isiscomm__isiscomm_isSites_isSite_isSiteMTs
  isDispLsdbs = __builtin__.property(_get_isDispLsdbs, _set_isDispLsdbs) # type: yc_isDispLsdbs_huawei_isiscomm__isiscomm_isSites_isSite_isDispLsdbs
  isDispPeers = __builtin__.property(_get_isDispPeers, _set_isDispPeers) # type: yc_isDispPeers_huawei_isiscomm__isiscomm_isSites_isSite_isDispPeers
  isDispCircs = __builtin__.property(_get_isDispCircs, _set_isDispCircs) # type: yc_isDispCircs_huawei_isiscomm__isiscomm_isSites_isSite_isDispCircs
  isDispLspStatisticss = __builtin__.property(_get_isDispLspStatisticss, _set_isDispLspStatisticss) # type: yc_isDispLspStatisticss_huawei_isiscomm__isiscomm_isSites_isSite_isDispLspStatisticss
  isDispBfdSessions = __builtin__.property(_get_isDispBfdSessions, _set_isDispBfdSessions) # type: yc_isDispBfdSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdSessions
  isDispBfdBitErrSessions = __builtin__.property(_get_isDispBfdBitErrSessions, _set_isDispBfdBitErrSessions) # type: yc_isDispBfdBitErrSessions_huawei_isiscomm__isiscomm_isSites_isSite_isDispBfdBitErrSessions
  isDispNameTables = __builtin__.property(_get_isDispNameTables, _set_isDispNameTables) # type: yc_isDispNameTables_huawei_isiscomm__isiscomm_isSites_isSite_isDispNameTables
  isLinkGroups = __builtin__.property(_get_isLinkGroups, _set_isLinkGroups) # type: yc_isLinkGroups_huawei_isiscomm__isiscomm_isSites_isSite_isLinkGroups
  isDispVirtualAccs = __builtin__.property(_get_isDispVirtualAccs, _set_isDispVirtualAccs) # type: yc_isDispVirtualAccs_huawei_isiscomm__isiscomm_isSites_isSite_isDispVirtualAccs
  isSegrCfg = __builtin__.property(_get_isSegrCfg, _set_isSegrCfg) # type: yc_isSegrCfg_huawei_isiscomm__isiscomm_isSites_isSite_isSegrCfg
  isDispMapSvrInfos = __builtin__.property(_get_isDispMapSvrInfos, _set_isDispMapSvrInfos) # type: yc_isDispMapSvrInfos_huawei_isiscomm__isiscomm_isSites_isSite_isDispMapSvrInfos
  isSrv6Cfg = __builtin__.property(_get_isSrv6Cfg, _set_isSrv6Cfg) # type: yc_isSrv6Cfg_huawei_isiscomm__isiscomm_isSites_isSite_isSrv6Cfg
  isIPv6SrAvoidMicroLoopSet = __builtin__.property(_get_isIPv6SrAvoidMicroLoopSet, _set_isIPv6SrAvoidMicroLoopSet) # type: yc_isIPv6SrAvoidMicroLoopSet_huawei_isiscomm__isiscomm_isSites_isSite_isIPv6SrAvoidMicroLoopSet
  isDispFrrSummrys = __builtin__.property(_get_isDispFrrSummrys, _set_isDispFrrSummrys) # type: yc_isDispFrrSummrys_huawei_isiscomm__isiscomm_isSites_isSite_isDispFrrSummrys


  _pyangbind_elements = OrderedDict([('instanceId', instanceId), ('multiIID', multiIID), ('vpnName', vpnName), ('isLevel', isLevel), ('lspMaxAge', lspMaxAge), ('lspRefreshInterval', lspRefreshInterval), ('shutDownEnable', shutDownEnable), ('costStyle', costStyle), ('relaxSpfLimit', relaxSpfLimit), ('linkQuaDeteEn', linkQuaDeteEn), ('spfMaxInterval', spfMaxInterval), ('spfInitInterval', spfInitInterval), ('spfIncrInterval', spfIncrInterval), ('level1lspLengthOrig', level1lspLengthOrig), ('level2lspLengthOrig', level2lspLengthOrig), ('lspReceiveLength', lspReceiveLength), ('level1LspFragExtEnable', level1LspFragExtEnable), ('level2LspFragExtEnable', level2LspFragExtEnable), ('level1LspFragExtMode', level1LspFragExtMode), ('level2LspFragExtMode', level2LspFragExtMode), ('localSymbolicName', localSymbolicName), ('stdAutoCostEnable', stdAutoCostEnable), ('stdAutoCostEnableCompatible', stdAutoCostEnableCompatible), ('stdbandwidth', stdbandwidth), ('stdLevel1Cost', stdLevel1Cost), ('stdLevel2Cost', stdLevel2Cost), ('baseTopoType', baseTopoType), ('ldpAutoCfg', ldpAutoCfg), ('poiEnable', poiEnable), ('poiAlways', poiAlways), ('lsdbLimit', lsdbLimit), ('lsdbLimitNum', lsdbLimitNum), ('lsdbThresUpper', lsdbThresUpper), ('lsdbThresLower', lsdbThresLower), ('directInherit', directInherit), ('description', description), ('peerFlappingSuppress', peerFlappingSuppress), ('isSREnableMPLS', isSREnableMPLS), ('bwConstraint', bwConstraint), ('loMultiplier', loMultiplier), ('unresvBwSubPool', unresvBwSubPool), ('purgeLspDelayVal', purgeLspDelayVal), ('advOneIntfAddr', advOneIntfAddr), ('isLspAgeRefresh', isLspAgeRefresh), ('isBgpLs', isBgpLs), ('isLspGenIntelliTimer', isLspGenIntelliTimer), ('isFlashFlood', isFlashFlood), ('isOverloadSet', isOverloadSet), ('isLdpSyncdSet', isLdpSyncdSet), ('isExternAbility', isExternAbility), ('isAvoidMicroLoopSet', isAvoidMicroLoopSet), ('isLocalMtSets', isLocalMtSets), ('isAreaIds', isAreaIds), ('isNetEntitys', isNetEntitys), ('isLspAuthtications', isLspAuthtications), ('isNameTables', isNameTables), ('isVirtualSystems', isVirtualSystems), ('isSrgbs', isSrgbs), ('isCircuits', isCircuits), ('isSiteMTs', isSiteMTs), ('isDispLsdbs', isDispLsdbs), ('isDispPeers', isDispPeers), ('isDispCircs', isDispCircs), ('isDispLspStatisticss', isDispLspStatisticss), ('isDispBfdSessions', isDispBfdSessions), ('isDispBfdBitErrSessions', isDispBfdBitErrSessions), ('isDispNameTables', isDispNameTables), ('isLinkGroups', isLinkGroups), ('isDispVirtualAccs', isDispVirtualAccs), ('isSegrCfg', isSegrCfg), ('isDispMapSvrInfos', isDispMapSvrInfos), ('isSrv6Cfg', isSrv6Cfg), ('isIPv6SrAvoidMicroLoopSet', isIPv6SrAvoidMicroLoopSet), ('isDispFrrSummrys', isDispFrrSummrys), ])


class yc_isSites_huawei_isiscomm__isiscomm_isSites(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isSites. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IS-IS instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isSite',)

  _yang_name = 'isSites'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isSite = YANGDynClass(base=YANGListType("instanceId",yc_isSite_huawei_isiscomm__isiscomm_isSites_isSite, yang_name="isSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instanceId', extensions=None), is_container='list', yang_name="isSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isSites']

  def _get_isSite(self):
    """
    Getter method for isSite, mapped from YANG variable /isiscomm/isSites/isSite (list)

    YANG Description: Set parameters for the IS-IS instance.
    """
    return self.__isSite
      
  def _set_isSite(self, v, load=False):
    """
    Setter method for isSite, mapped from YANG variable /isiscomm/isSites/isSite (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSite() directly.

    YANG Description: Set parameters for the IS-IS instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("instanceId",yc_isSite_huawei_isiscomm__isiscomm_isSites_isSite, yang_name="isSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instanceId', extensions=None), is_container='list', yang_name="isSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSite must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("instanceId",yc_isSite_huawei_isiscomm__isiscomm_isSites_isSite, yang_name="isSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instanceId', extensions=None), is_container='list', yang_name="isSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)""",
        })

    self.__isSite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSite(self):
    self.__isSite = YANGDynClass(base=YANGListType("instanceId",yc_isSite_huawei_isiscomm__isiscomm_isSites_isSite, yang_name="isSite", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='instanceId', extensions=None), is_container='list', yang_name="isSite", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='list', is_config=True)

  isSite = __builtin__.property(_get_isSite, _set_isSite) # type: yc_isSite_huawei_isiscomm__isiscomm_isSites_isSite


  _pyangbind_elements = OrderedDict([('isSite', isSite), ])


class yc_isisGlobalCfg_huawei_isiscomm__isiscomm_isisGlobalCfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isisGlobalCfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: ISIS Global Config
  """
  __slots__ = ('_path_helper', '_extmethods', '__lspSeqOverAutoRvFlag','__sysIdConflictAutoRvFlag','__purgeLspProtectEnable','__purgeSourceTraceEnable','__purgeSourceTracePort',)

  _yang_name = 'isisGlobalCfg'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lspSeqOverAutoRvFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspSeqOverAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__sysIdConflictAutoRvFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sysIdConflictAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__purgeLspProtectEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeLspProtectEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__purgeSourceTraceEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeSourceTraceEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    self.__purgeSourceTracePort = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50121), is_leaf=True, yang_name="purgeSourceTracePort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isisGlobalCfg']

  def _get_lspSeqOverAutoRvFlag(self):
    """
    Getter method for lspSeqOverAutoRvFlag, mapped from YANG variable /isiscomm/isisGlobalCfg/lspSeqOverAutoRvFlag (boolean)

    YANG Description: If enable, to recover ISIS system-id automatically when the sequence number of the local lsp overflowed
    """
    return self.__lspSeqOverAutoRvFlag
      
  def _set_lspSeqOverAutoRvFlag(self, v, load=False):
    """
    Setter method for lspSeqOverAutoRvFlag, mapped from YANG variable /isiscomm/isisGlobalCfg/lspSeqOverAutoRvFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lspSeqOverAutoRvFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lspSeqOverAutoRvFlag() directly.

    YANG Description: If enable, to recover ISIS system-id automatically when the sequence number of the local lsp overflowed
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspSeqOverAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lspSeqOverAutoRvFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspSeqOverAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__lspSeqOverAutoRvFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lspSeqOverAutoRvFlag(self):
    self.__lspSeqOverAutoRvFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lspSeqOverAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_sysIdConflictAutoRvFlag(self):
    """
    Getter method for sysIdConflictAutoRvFlag, mapped from YANG variable /isiscomm/isisGlobalCfg/sysIdConflictAutoRvFlag (boolean)

    YANG Description: If enable, to recover ISIS system-id automatically when the system-id conflicted
    """
    return self.__sysIdConflictAutoRvFlag
      
  def _set_sysIdConflictAutoRvFlag(self, v, load=False):
    """
    Setter method for sysIdConflictAutoRvFlag, mapped from YANG variable /isiscomm/isisGlobalCfg/sysIdConflictAutoRvFlag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sysIdConflictAutoRvFlag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sysIdConflictAutoRvFlag() directly.

    YANG Description: If enable, to recover ISIS system-id automatically when the system-id conflicted
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sysIdConflictAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sysIdConflictAutoRvFlag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sysIdConflictAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__sysIdConflictAutoRvFlag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sysIdConflictAutoRvFlag(self):
    self.__sysIdConflictAutoRvFlag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sysIdConflictAutoRvFlag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_purgeLspProtectEnable(self):
    """
    Getter method for purgeLspProtectEnable, mapped from YANG variable /isiscomm/isisGlobalCfg/purgeLspProtectEnable (boolean)

    YANG Description: Enable automatic IS-IS purge LSP protection.
    """
    return self.__purgeLspProtectEnable
      
  def _set_purgeLspProtectEnable(self, v, load=False):
    """
    Setter method for purgeLspProtectEnable, mapped from YANG variable /isiscomm/isisGlobalCfg/purgeLspProtectEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purgeLspProtectEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purgeLspProtectEnable() directly.

    YANG Description: Enable automatic IS-IS purge LSP protection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeLspProtectEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purgeLspProtectEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeLspProtectEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__purgeLspProtectEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purgeLspProtectEnable(self):
    self.__purgeLspProtectEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeLspProtectEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_purgeSourceTraceEnable(self):
    """
    Getter method for purgeSourceTraceEnable, mapped from YANG variable /isiscomm/isisGlobalCfg/purgeSourceTraceEnable (boolean)

    YANG Description: Enable purge LSP source tracing.
    """
    return self.__purgeSourceTraceEnable
      
  def _set_purgeSourceTraceEnable(self, v, load=False):
    """
    Setter method for purgeSourceTraceEnable, mapped from YANG variable /isiscomm/isisGlobalCfg/purgeSourceTraceEnable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purgeSourceTraceEnable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purgeSourceTraceEnable() directly.

    YANG Description: Enable purge LSP source tracing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeSourceTraceEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purgeSourceTraceEnable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeSourceTraceEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)""",
        })

    self.__purgeSourceTraceEnable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purgeSourceTraceEnable(self):
    self.__purgeSourceTraceEnable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="purgeSourceTraceEnable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='boolean', is_config=True)


  def _get_purgeSourceTracePort(self):
    """
    Getter method for purgeSourceTracePort, mapped from YANG variable /isiscomm/isisGlobalCfg/purgeSourceTracePort (uint32)

    YANG Description: Configure the port of purge LSP source tracing.
    """
    return self.__purgeSourceTracePort
      
  def _set_purgeSourceTracePort(self, v, load=False):
    """
    Setter method for purgeSourceTracePort, mapped from YANG variable /isiscomm/isisGlobalCfg/purgeSourceTracePort (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purgeSourceTracePort is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purgeSourceTracePort() directly.

    YANG Description: Configure the port of purge LSP source tracing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50121), is_leaf=True, yang_name="purgeSourceTracePort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purgeSourceTracePort must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50121), is_leaf=True, yang_name="purgeSourceTracePort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)""",
        })

    self.__purgeSourceTracePort = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purgeSourceTracePort(self):
    self.__purgeSourceTracePort = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50121), is_leaf=True, yang_name="purgeSourceTracePort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=True)

  lspSeqOverAutoRvFlag = __builtin__.property(_get_lspSeqOverAutoRvFlag, _set_lspSeqOverAutoRvFlag)
  sysIdConflictAutoRvFlag = __builtin__.property(_get_sysIdConflictAutoRvFlag, _set_sysIdConflictAutoRvFlag)
  purgeLspProtectEnable = __builtin__.property(_get_purgeLspProtectEnable, _set_purgeLspProtectEnable)
  purgeSourceTraceEnable = __builtin__.property(_get_purgeSourceTraceEnable, _set_purgeSourceTraceEnable)
  purgeSourceTracePort = __builtin__.property(_get_purgeSourceTracePort, _set_purgeSourceTracePort)


  _pyangbind_elements = OrderedDict([('lspSeqOverAutoRvFlag', lspSeqOverAutoRvFlag), ('sysIdConflictAutoRvFlag', sysIdConflictAutoRvFlag), ('purgeLspProtectEnable', purgeLspProtectEnable), ('purgeSourceTraceEnable', purgeSourceTraceEnable), ('purgeSourceTracePort', purgeSourceTracePort), ])


class yc_isisGlobalStat_huawei_isiscomm__isiscomm_isisGlobalStat(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm/isisGlobalStat. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Display ISIS Global State
  """
  __slots__ = ('_path_helper', '_extmethods', '__globalPubNodeNumber','__globalPubPeerNumber',)

  _yang_name = 'isisGlobalStat'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__globalPubNodeNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubNodeNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    self.__globalPubPeerNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubPeerNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm', 'isisGlobalStat']

  def _get_globalPubNodeNumber(self):
    """
    Getter method for globalPubNodeNumber, mapped from YANG variable /isiscomm/isisGlobalStat/globalPubNodeNumber (uint32)

    YANG Description: Support to Get ISIS Area Public Nodes
    """
    return self.__globalPubNodeNumber
      
  def _set_globalPubNodeNumber(self, v, load=False):
    """
    Setter method for globalPubNodeNumber, mapped from YANG variable /isiscomm/isisGlobalStat/globalPubNodeNumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_globalPubNodeNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_globalPubNodeNumber() directly.

    YANG Description: Support to Get ISIS Area Public Nodes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubNodeNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """globalPubNodeNumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubNodeNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__globalPubNodeNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_globalPubNodeNumber(self):
    self.__globalPubNodeNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubNodeNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)


  def _get_globalPubPeerNumber(self):
    """
    Getter method for globalPubPeerNumber, mapped from YANG variable /isiscomm/isisGlobalStat/globalPubPeerNumber (uint32)

    YANG Description: Support to Get ISIS Area Public Peers
    """
    return self.__globalPubPeerNumber
      
  def _set_globalPubPeerNumber(self, v, load=False):
    """
    Setter method for globalPubPeerNumber, mapped from YANG variable /isiscomm/isisGlobalStat/globalPubPeerNumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_globalPubPeerNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_globalPubPeerNumber() directly.

    YANG Description: Support to Get ISIS Area Public Peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubPeerNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """globalPubPeerNumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubPeerNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)""",
        })

    self.__globalPubPeerNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_globalPubPeerNumber(self):
    self.__globalPubPeerNumber = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="globalPubPeerNumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='uint32', is_config=False)

  globalPubNodeNumber = __builtin__.property(_get_globalPubNodeNumber)
  globalPubPeerNumber = __builtin__.property(_get_globalPubPeerNumber)


  _pyangbind_elements = OrderedDict([('globalPubNodeNumber', globalPubNodeNumber), ('globalPubPeerNumber', globalPubPeerNumber), ])


class yc_isiscomm_huawei_isiscomm__isiscomm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /isiscomm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IS-IS management.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isSites','__isisGlobalCfg','__isisGlobalStat',)

  _yang_name = 'isiscomm'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isSites = YANGDynClass(base=yc_isSites_huawei_isiscomm__isiscomm_isSites, is_container='container', yang_name="isSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isisGlobalCfg = YANGDynClass(base=yc_isisGlobalCfg_huawei_isiscomm__isiscomm_isisGlobalCfg, is_container='container', yang_name="isisGlobalCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    self.__isisGlobalStat = YANGDynClass(base=yc_isisGlobalStat_huawei_isiscomm__isiscomm_isisGlobalStat, is_container='container', yang_name="isisGlobalStat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['isiscomm']

  def _get_isSites(self):
    """
    Getter method for isSites, mapped from YANG variable /isiscomm/isSites (container)

    YANG Description: List of IS-IS instances.
    """
    return self.__isSites
      
  def _set_isSites(self, v, load=False):
    """
    Setter method for isSites, mapped from YANG variable /isiscomm/isSites (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isSites is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isSites() directly.

    YANG Description: List of IS-IS instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isSites_huawei_isiscomm__isiscomm_isSites, is_container='container', yang_name="isSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isSites must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isSites_huawei_isiscomm__isiscomm_isSites, is_container='container', yang_name="isSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isSites = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isSites(self):
    self.__isSites = YANGDynClass(base=yc_isSites_huawei_isiscomm__isiscomm_isSites, is_container='container', yang_name="isSites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isisGlobalCfg(self):
    """
    Getter method for isisGlobalCfg, mapped from YANG variable /isiscomm/isisGlobalCfg (container)

    YANG Description: ISIS Global Config
    """
    return self.__isisGlobalCfg
      
  def _set_isisGlobalCfg(self, v, load=False):
    """
    Setter method for isisGlobalCfg, mapped from YANG variable /isiscomm/isisGlobalCfg (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isisGlobalCfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isisGlobalCfg() directly.

    YANG Description: ISIS Global Config
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isisGlobalCfg_huawei_isiscomm__isiscomm_isisGlobalCfg, is_container='container', yang_name="isisGlobalCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isisGlobalCfg must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isisGlobalCfg_huawei_isiscomm__isiscomm_isisGlobalCfg, is_container='container', yang_name="isisGlobalCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isisGlobalCfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isisGlobalCfg(self):
    self.__isisGlobalCfg = YANGDynClass(base=yc_isisGlobalCfg_huawei_isiscomm__isiscomm_isisGlobalCfg, is_container='container', yang_name="isisGlobalCfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)


  def _get_isisGlobalStat(self):
    """
    Getter method for isisGlobalStat, mapped from YANG variable /isiscomm/isisGlobalStat (container)

    YANG Description: Display ISIS Global State
    """
    return self.__isisGlobalStat
      
  def _set_isisGlobalStat(self, v, load=False):
    """
    Setter method for isisGlobalStat, mapped from YANG variable /isiscomm/isisGlobalStat (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isisGlobalStat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isisGlobalStat() directly.

    YANG Description: Display ISIS Global State
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isisGlobalStat_huawei_isiscomm__isiscomm_isisGlobalStat, is_container='container', yang_name="isisGlobalStat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isisGlobalStat must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isisGlobalStat_huawei_isiscomm__isiscomm_isisGlobalStat, is_container='container', yang_name="isisGlobalStat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isisGlobalStat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isisGlobalStat(self):
    self.__isisGlobalStat = YANGDynClass(base=yc_isisGlobalStat_huawei_isiscomm__isiscomm_isisGlobalStat, is_container='container', yang_name="isisGlobalStat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isSites = __builtin__.property(_get_isSites, _set_isSites) # type: yc_isSites_huawei_isiscomm__isiscomm_isSites
  isisGlobalCfg = __builtin__.property(_get_isisGlobalCfg, _set_isisGlobalCfg) # type: yc_isisGlobalCfg_huawei_isiscomm__isiscomm_isisGlobalCfg
  isisGlobalStat = __builtin__.property(_get_isisGlobalStat, _set_isisGlobalStat) # type: yc_isisGlobalStat_huawei_isiscomm__isiscomm_isisGlobalStat


  _pyangbind_elements = OrderedDict([('isSites', isSites), ('isisGlobalCfg', isisGlobalCfg), ('isisGlobalStat', isisGlobalStat), ])


class huawei_isiscomm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-isiscomm - based on the path /huawei-isiscomm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IS-IS management.
  """
  __slots__ = ('_path_helper', '_extmethods', '__isiscomm',)

  _yang_name = 'huawei-isiscomm'
  _yang_namespace = 'http://www.huawei.com/netconf/vrp/huawei-isiscomm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__isiscomm = YANGDynClass(base=yc_isiscomm_huawei_isiscomm__isiscomm, is_container='container', yang_name="isiscomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_isiscomm(self):
    """
    Getter method for isiscomm, mapped from YANG variable /isiscomm (container)

    YANG Description: IS-IS management.
    """
    return self.__isiscomm
      
  def _set_isiscomm(self, v, load=False):
    """
    Setter method for isiscomm, mapped from YANG variable /isiscomm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isiscomm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isiscomm() directly.

    YANG Description: IS-IS management.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isiscomm_huawei_isiscomm__isiscomm, is_container='container', yang_name="isiscomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isiscomm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isiscomm_huawei_isiscomm__isiscomm, is_container='container', yang_name="isiscomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)""",
        })

    self.__isiscomm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isiscomm(self):
    self.__isiscomm = YANGDynClass(base=yc_isiscomm_huawei_isiscomm__isiscomm, is_container='container', yang_name="isiscomm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://www.huawei.com/netconf/vrp/huawei-isiscomm', defining_module='huawei-isiscomm', yang_type='container', is_config=True)

  isiscomm = __builtin__.property(_get_isiscomm, _set_isiscomm) # type: yc_isiscomm_huawei_isiscomm__isiscomm


  _pyangbind_elements = OrderedDict([('isiscomm', isiscomm), ])


