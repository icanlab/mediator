# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__mask','__type',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/ip (inet:ipv4-address-no-zone)

    YANG Description: IPv4 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv4 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_mask(self):
    """
    Getter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/mask (ipv4-netmask)

    YANG Description: IPv4 address mask.
    """
    return self.__mask
      
  def _set_mask(self, v, load=False):
    """
    Setter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/mask (ipv4-netmask)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask() directly.

    YANG Description: IPv4 address mask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask must be of a type compatible with ipv4-netmask""",
          'defined-type': "huawei-ip:ipv4-netmask",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)""",
        })

    self.__mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask(self):
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/type (ipv4-address-config-type)

    YANG Description: IPv4 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/type (ipv4-address-config-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv4 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-config-type""",
          'defined-type': "huawei-ip:ipv4-address-config-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  mask = __builtin__.property(_get_mask, _set_mask)
  type = __builtin__.property(_get_type, _set_type)

  __choices__ = {'address': {'common-address': ['ip', 'mask', 'type']}}
  _pyangbind_elements = OrderedDict([('ip', ip), ('mask', mask), ('type', type), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of common addresses. The IPv4 address of the DCN interface cannot be created, modified, or deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address (list)

    YANG Description: Configure IPv4 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Configure IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address

  __choices__ = {'address': {'common-address': ['address']}}
  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/unnumbered-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure unnumbered interface. The address borrowing relationship of the DCN interface cannot be created, modified, or deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unnumbered_if_name',)

  _yang_name = 'unnumbered-address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unnumbered_if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'unnumbered-address']

  def _get_unnumbered_if_name(self):
    """
    Getter method for unnumbered_if_name, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address/unnumbered_if_name (leafref)

    YANG Description: Name of an unnumbered interface.
    """
    return self.__unnumbered_if_name
      
  def _set_unnumbered_if_name(self, v, load=False):
    """
    Setter method for unnumbered_if_name, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address/unnumbered_if_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered_if_name() directly.

    YANG Description: Name of an unnumbered interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered_if_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)""",
        })

    self.__unnumbered_if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered_if_name(self):
    self.__unnumbered_if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)

  unnumbered_if_name = __builtin__.property(_get_unnumbered_if_name, _set_unnumbered_if_name)

  __choices__ = {'address': {'unnumbered-address': ['unnumbered_if_name']}}
  _pyangbind_elements = OrderedDict([('unnumbered_if_name', unnumbered_if_name), ])


class yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/negotiation-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure negotiate address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__negotiation_type',)

  _yang_name = 'negotiation-address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__negotiation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'negotiation-address']

  def _get_negotiation_type(self):
    """
    Getter method for negotiation_type, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address/negotiation_type (negotiation-type)

    YANG Description: Enable negotiation address on interface.
    """
    return self.__negotiation_type
      
  def _set_negotiation_type(self, v, load=False):
    """
    Setter method for negotiation_type, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address/negotiation_type (negotiation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiation_type() directly.

    YANG Description: Enable negotiation address on interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiation_type must be of a type compatible with negotiation-type""",
          'defined-type': "huawei-ip:negotiation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)""",
        })

    self.__negotiation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiation_type(self):
    self.__negotiation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)

  negotiation_type = __builtin__.property(_get_negotiation_type, _set_negotiation_type)

  __choices__ = {'address': {'negotiate-address': ['negotiation_type']}}
  _pyangbind_elements = OrderedDict([('negotiation_type', negotiation_type), ])


class yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__mask','__type','__is_block',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/ip (inet:ipv4-address-no-zone)

    YANG Description: IPv4 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv4 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_mask(self):
    """
    Getter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/mask (ipv4-netmask)

    YANG Description: IPv4 address mask.
    """
    return self.__mask
      
  def _set_mask(self, v, load=False):
    """
    Setter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/mask (ipv4-netmask)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask() directly.

    YANG Description: IPv4 address mask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask must be of a type compatible with ipv4-netmask""",
          'defined-type': "huawei-ip:ipv4-netmask",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)""",
        })

    self.__mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask(self):
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/type (ipv4-address-state-type)

    YANG Description: IPv4 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/type (ipv4-address-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv4 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-state-type""",
          'defined-type': "huawei-ip:ipv4-address-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)


  def _get_is_block(self):
    """
    Getter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/is_block (boolean)

    YANG Description: IPv4 address is blocked or not.
    """
    return self.__is_block
      
  def _set_is_block(self, v, load=False):
    """
    Setter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/is_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_block() directly.

    YANG Description: IPv4 address is blocked or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)""",
        })

    self.__is_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_block(self):
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)

  ip = __builtin__.property(_get_ip)
  mask = __builtin__.property(_get_mask)
  type = __builtin__.property(_get_type)
  is_block = __builtin__.property(_get_is_block)


  _pyangbind_elements = OrderedDict([('ip', ip), ('mask', mask), ('type', type), ('is_block', is_block), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address (list)

    YANG Description: Operational state of IPv4 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Operational state of IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

  address = __builtin__.property(_get_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/gateways/gateway. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of gateway addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__gateway',)

  _yang_name = 'gateway'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__gateway = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'gateways', 'gateway']

  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway/gateway (inet:ipv4-address)

    YANG Description: Gateway of interface.
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway/gateway (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.

    YANG Description: Gateway of interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)

  gateway = __builtin__.property(_get_gateway)


  _pyangbind_elements = OrderedDict([('gateway', gateway), ])


class yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/gateways. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of gateway addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__gateway',)

  _yang_name = 'gateways'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__gateway = YANGDynClass(base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'gateways']

  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway (list)

    YANG Description: Operational state of gateway addresses.
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.

    YANG Description: Operational state of gateway addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

  gateway = __builtin__.property(_get_gateway) # type: yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway


  _pyangbind_elements = OrderedDict([('gateway', gateway), ])


class yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv4 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__gateways',)

  _yang_name = 'state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    self.__gateways = YANGDynClass(base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses (container)

    YANG Description: List of addresses.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)


  def _get_gateways(self):
    """
    Getter method for gateways, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways (container)

    YANG Description: List of gateway addresses.
    """
    return self.__gateways
      
  def _set_gateways(self, v, load=False):
    """
    Setter method for gateways, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateways is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateways() directly.

    YANG Description: List of gateway addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateways must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)""",
        })

    self.__gateways = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateways(self):
    self.__gateways = YANGDynClass(base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

  addresses = __builtin__.property(_get_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses
  gateways = __builtin__.property(_get_gateways) # type: yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('gateways', gateways), ])


class yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure IPv4 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__unnumbered_address','__negotiation_address','__state',)

  _yang_name = 'ipv4'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__unnumbered_address = YANGDynClass(base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__negotiation_address = YANGDynClass(base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses (container)

    YANG Description: List of common addresses. The IPv4 address of the DCN interface cannot be created, modified, or deleted.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of common addresses. The IPv4 address of the DCN interface cannot be created, modified, or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_unnumbered_address(self):
    """
    Getter method for unnumbered_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address (container)

    YANG Description: Configure unnumbered interface. The address borrowing relationship of the DCN interface cannot be created, modified, or deleted.
    """
    return self.__unnumbered_address
      
  def _set_unnumbered_address(self, v, load=False):
    """
    Setter method for unnumbered_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered_address() directly.

    YANG Description: Configure unnumbered interface. The address borrowing relationship of the DCN interface cannot be created, modified, or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__unnumbered_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered_address(self):
    self.__unnumbered_address = YANGDynClass(base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_negotiation_address(self):
    """
    Getter method for negotiation_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address (container)

    YANG Description: Configure negotiate address.
    """
    return self.__negotiation_address
      
  def _set_negotiation_address(self, v, load=False):
    """
    Setter method for negotiation_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiation_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiation_address() directly.

    YANG Description: Configure negotiate address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiation_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__negotiation_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiation_address(self):
    self.__negotiation_address = YANGDynClass(base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv4/state (container)

    YANG Description: Operational state of IPv4 addresses.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv4/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state of IPv4 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses
  unnumbered_address = __builtin__.property(_get_unnumbered_address, _set_unnumbered_address) # type: yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address
  negotiation_address = __builtin__.property(_get_negotiation_address, _set_negotiation_address) # type: yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address
  state = __builtin__.property(_get_state, _set_state) # type: yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state

  __choices__ = {'address': {'common-address': ['addresses'], 'unnumbered-address': ['unnumbered_address'], 'negotiate-address': ['negotiation_address']}}
  _pyangbind_elements = OrderedDict([('addresses', addresses), ('unnumbered_address', unnumbered_address), ('negotiation_address', negotiation_address), ('state', state), ])


class yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure IPv6 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__algorithm_type',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/ip (inet:ipv6-address-no-zone)

    YANG Description: IPv6 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/prefix_length (uint32)

    YANG Description: Length of the IPv6 address prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/prefix_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Length of the IPv6 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/type (ipv6-address-config-type)

    YANG Description: IPv6 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/type (ipv6-address-config-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv6 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv6-address-config-type""",
          'defined-type': "huawei-ip:ipv6-address-config-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)


  def _get_algorithm_type(self):
    """
    Getter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/algorithm_type (ipv6-address-algorithm-type)

    YANG Description: Address algorithm type.
    """
    return self.__algorithm_type
      
  def _set_algorithm_type(self, v, load=False):
    """
    Setter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/algorithm_type (ipv6-address-algorithm-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm_type() directly.

    YANG Description: Address algorithm type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm_type must be of a type compatible with ipv6-address-algorithm-type""",
          'defined-type': "huawei-ip:ipv6-address-algorithm-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)""",
        })

    self.__algorithm_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm_type(self):
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)
  algorithm_type = __builtin__.property(_get_algorithm_type, _set_algorithm_type)

  __choices__ = {'address': {'common-address': ['ip', 'prefix_length', 'type', 'algorithm_type']}}
  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('algorithm_type', algorithm_type), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address (list)

    YANG Description: Configure IPv6 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Configure IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address

  __choices__ = {'address': {'common-address': ['address']}}
  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/nd-prefixs/nd-prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure nd prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__prefix_len','__valid_lifetime','__preferred_lifetime','__auto_flag','__on_link_flag',)

  _yang_name = 'nd-prefix'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__prefix_len = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__auto_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    self.__on_link_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'nd-prefixs', 'nd-prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix (inet:ipv6-address-no-zone)

    YANG Description: IPv6 address of the prefix.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 address of the prefix.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_prefix_len(self):
    """
    Getter method for prefix_len, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix_len (int32)

    YANG Description: Length of the prefix address.
    """
    return self.__prefix_len
      
  def _set_prefix_len(self, v, load=False):
    """
    Setter method for prefix_len, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix_len (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_len() directly.

    YANG Description: Length of the prefix address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_len must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)""",
        })

    self.__prefix_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_len(self):
    self.__prefix_len = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/valid_lifetime (uint32)

    YANG Description: Valid life time.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: Valid life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/preferred_lifetime (uint32)

    YANG Description: Preferred life time.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: Preferred life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_auto_flag(self):
    """
    Getter method for auto_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/auto_flag (boolean)

    YANG Description: Enable/disable the autonomous address-configuration.
    """
    return self.__auto_flag
      
  def _set_auto_flag(self, v, load=False):
    """
    Setter method for auto_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/auto_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_flag() directly.

    YANG Description: Enable/disable the autonomous address-configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__auto_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_flag(self):
    self.__auto_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)


  def _get_on_link_flag(self):
    """
    Getter method for on_link_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/on_link_flag (boolean)

    YANG Description: Enable/disable the on-link flag.
    """
    return self.__on_link_flag
      
  def _set_on_link_flag(self, v, load=False):
    """
    Setter method for on_link_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/on_link_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_on_link_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_on_link_flag() directly.

    YANG Description: Enable/disable the on-link flag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """on_link_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__on_link_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_on_link_flag(self):
    self.__on_link_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  prefix_len = __builtin__.property(_get_prefix_len, _set_prefix_len)
  valid_lifetime = __builtin__.property(_get_valid_lifetime, _set_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime, _set_preferred_lifetime)
  auto_flag = __builtin__.property(_get_auto_flag, _set_auto_flag)
  on_link_flag = __builtin__.property(_get_on_link_flag, _set_on_link_flag)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('prefix_len', prefix_len), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('auto_flag', auto_flag), ('on_link_flag', on_link_flag), ])


class yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/nd-prefixs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of nd prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nd_prefix',)

  _yang_name = 'nd-prefixs'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nd_prefix = YANGDynClass(base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'nd-prefixs']

  def _get_nd_prefix(self):
    """
    Getter method for nd_prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix (list)

    YANG Description: Configure nd prefix.
    """
    return self.__nd_prefix
      
  def _set_nd_prefix(self, v, load=False):
    """
    Setter method for nd_prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nd_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nd_prefix() directly.

    YANG Description: Configure nd prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nd_prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)""",
        })

    self.__nd_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nd_prefix(self):
    self.__nd_prefix = YANGDynClass(base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

  nd_prefix = __builtin__.property(_get_nd_prefix, _set_nd_prefix) # type: yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix


  _pyangbind_elements = OrderedDict([('nd_prefix', nd_prefix), ])


class yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/state/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__algorithm_type','__collision_count','__is_block','__status',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)
    self.__collision_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'state', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/ip (inet:ipv6-address-no-zone)

    YANG Description: IPv6 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/prefix_length (uint32)

    YANG Description: Length of the IPv6 address prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/prefix_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Length of the IPv6 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/type (ipv6-address-state-type)

    YANG Description: IPv6 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/type (ipv6-address-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv6 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv6-address-state-type""",
          'defined-type': "huawei-ip:ipv6-address-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)


  def _get_algorithm_type(self):
    """
    Getter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/algorithm_type (ipv6-address-algorithm-type)

    YANG Description: Address algorithm type.
    """
    return self.__algorithm_type
      
  def _set_algorithm_type(self, v, load=False):
    """
    Setter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/algorithm_type (ipv6-address-algorithm-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm_type() directly.

    YANG Description: Address algorithm type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm_type must be of a type compatible with ipv6-address-algorithm-type""",
          'defined-type': "huawei-ip:ipv6-address-algorithm-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)""",
        })

    self.__algorithm_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm_type(self):
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)


  def _get_collision_count(self):
    """
    Getter method for collision_count, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/collision_count (uint8)

    YANG Description: Number of IPv6 address collisions.
    """
    return self.__collision_count
      
  def _set_collision_count(self, v, load=False):
    """
    Setter method for collision_count, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/collision_count (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collision_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collision_count() directly.

    YANG Description: Number of IPv6 address collisions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """collision_count must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)""",
        })

    self.__collision_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_collision_count(self):
    self.__collision_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)


  def _get_is_block(self):
    """
    Getter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/is_block (boolean)

    YANG Description: IPv6 address is blocked or not.
    """
    return self.__is_block
      
  def _set_is_block(self, v, load=False):
    """
    Setter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/is_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_block() directly.

    YANG Description: IPv6 address is blocked or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)""",
        })

    self.__is_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_block(self):
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/status (ipv6-status-type)

    YANG Description: IPv6 address status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/status (ipv6-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: IPv6 address status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with ipv6-status-type""",
          'defined-type': "huawei-ip:ipv6-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  algorithm_type = __builtin__.property(_get_algorithm_type)
  collision_count = __builtin__.property(_get_collision_count)
  is_block = __builtin__.property(_get_is_block)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('algorithm_type', algorithm_type), ('collision_count', collision_count), ('is_block', is_block), ('status', status), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/state/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'state', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address (list)

    YANG Description: Operational state of IPv6 addresses.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Operational state of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

  address = __builtin__.property(_get_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mtu6','__addresses',)

  _yang_name = 'state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'state']

  def _get_mtu6(self):
    """
    Getter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/mtu6 (uint32)

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    return self.__mtu6
      
  def _set_mtu6(self, v, load=False):
    """
    Setter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/mtu6 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu6() directly.

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu6 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)""",
        })

    self.__mtu6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu6(self):
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses (container)

    YANG Description: List of IPv6 addresses.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

  mtu6 = __builtin__.property(_get_mtu6)
  addresses = __builtin__.property(_get_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses


  _pyangbind_elements = OrderedDict([('mtu6', mtu6), ('addresses', addresses), ])


class yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable the IPv6 capability on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mtu6','__spread_mtu_flag','__auto_link_local','__addresses','__nd_prefixs','__state',)

  _yang_name = 'ipv6'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    self.__auto_link_local = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__nd_prefixs = YANGDynClass(base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6']

  def _get_mtu6(self):
    """
    Getter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/mtu6 (uint32)

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    return self.__mtu6
      
  def _set_mtu6(self, v, load=False):
    """
    Setter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/mtu6 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu6() directly.

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu6 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__mtu6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu6(self):
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_spread_mtu_flag(self):
    """
    Getter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/spread_mtu_flag (boolean)

    YANG Description: Enable/disable the function of spreading the IPv6 MTU of main interface to subinterface.
    """
    return self.__spread_mtu_flag
      
  def _set_spread_mtu_flag(self, v, load=False):
    """
    Setter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/spread_mtu_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spread_mtu_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spread_mtu_flag() directly.

    YANG Description: Enable/disable the function of spreading the IPv6 MTU of main interface to subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spread_mtu_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__spread_mtu_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spread_mtu_flag(self):
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)


  def _get_auto_link_local(self):
    """
    Getter method for auto_link_local, mapped from YANG variable /ifm/interfaces/interface/ipv6/auto_link_local (boolean)

    YANG Description: Enable/disable an interface with the auto linklocal address function.
    """
    return self.__auto_link_local
      
  def _set_auto_link_local(self, v, load=False):
    """
    Setter method for auto_link_local, mapped from YANG variable /ifm/interfaces/interface/ipv6/auto_link_local (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_link_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_link_local() directly.

    YANG Description: Enable/disable an interface with the auto linklocal address function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_link_local must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__auto_link_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_link_local(self):
    self.__auto_link_local = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses (container)

    YANG Description: List of IPv6 addresses.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_nd_prefixs(self):
    """
    Getter method for nd_prefixs, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs (container)

    YANG Description: List of nd prefix.
    """
    return self.__nd_prefixs
      
  def _set_nd_prefixs(self, v, load=False):
    """
    Setter method for nd_prefixs, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nd_prefixs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nd_prefixs() directly.

    YANG Description: List of nd prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nd_prefixs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__nd_prefixs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nd_prefixs(self):
    self.__nd_prefixs = YANGDynClass(base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv6/state (container)

    YANG Description: Operational state of IPv6 addresses.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv6/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

  mtu6 = __builtin__.property(_get_mtu6, _set_mtu6)
  spread_mtu_flag = __builtin__.property(_get_spread_mtu_flag, _set_spread_mtu_flag)
  auto_link_local = __builtin__.property(_get_auto_link_local, _set_auto_link_local)
  addresses = __builtin__.property(_get_addresses, _set_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses
  nd_prefixs = __builtin__.property(_get_nd_prefixs, _set_nd_prefixs) # type: yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs
  state = __builtin__.property(_get_state, _set_state) # type: yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state

  __choices__ = {'address': {'common-address': ['addresses']}}
  _pyangbind_elements = OrderedDict([('mtu6', mtu6), ('spread_mtu_flag', spread_mtu_flag), ('auto_link_local', auto_link_local), ('addresses', addresses), ('nd_prefixs', nd_prefixs), ('state', state), ])


class yc_interface_huawei_ifm__ifm_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__vrf_name','__ipv4','__ipv6',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='if-name', is_config=True)
    self.__vrf_name = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ifm/interfaces/interface/name (if-name)

    YANG Description: The textual name of the interface.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ifm/interfaces/interface/name (if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The textual name of the interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='if-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with if-name""",
          'defined-type': "huawei-ifm:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='if-name', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='if-name', is_config=True)


  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /ifm/interfaces/interface/vrf_name (string)

    YANG Description: Name of a VPN instance. It uniquely identifies a VPN instance.
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /ifm/interfaces/interface/vrf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: Name of a VPN instance. It uniquely identifies a VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /ifm/interfaces/interface/ipv4 (container)

    YANG Description: Configure IPv4 addresses.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /ifm/interfaces/interface/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Configure IPv4 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /ifm/interfaces/interface/ipv6 (container)

    YANG Description: Enable/disable the IPv6 capability on an interface.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /ifm/interfaces/interface/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Enable/disable the IPv6 capability on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  vrf_name = __builtin__.property(_get_vrf_name, _set_vrf_name)
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4) # type: yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6) # type: yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6


  _pyangbind_elements = OrderedDict([('name', name), ('vrf_name', vrf_name), ('ipv4', ipv4), ('ipv6', ipv6), ])


class yc_interfaces_huawei_ifm__ifm_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /ifm/interfaces/interface (list)

    YANG Description: Information about an interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /ifm/interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Information about an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface) # type: yc_interface_huawei_ifm__ifm_interfaces_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_ifm_huawei_ifm__ifm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Common interface management, which includes the public configuration of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces',)

  _yang_name = 'ifm'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm']

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /ifm/interfaces (container)

    YANG Description: List of interfaces.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /ifm/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: List of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_huawei_ifm__ifm_interfaces


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ])


class huawei_ifm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /huawei-ifm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Common interface management, which includes the public configuration of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifm',)

  _yang_name = 'huawei-ifm'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifm = YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ifm(self):
    """
    Getter method for ifm, mapped from YANG variable /ifm (container)

    YANG Description: Common interface management, which includes the public configuration of interfaces.
    """
    return self.__ifm
      
  def _set_ifm(self, v, load=False):
    """
    Setter method for ifm, mapped from YANG variable /ifm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifm() directly.

    YANG Description: Common interface management, which includes the public configuration of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ifm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifm(self):
    self.__ifm = YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  ifm = __builtin__.property(_get_ifm, _set_ifm) # type: yc_ifm_huawei_ifm__ifm


  _pyangbind_elements = OrderedDict([('ifm', ifm), ])


class huawei_ip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ip - based on the path /huawei-ip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions for
configuring IP implementations.
Copyright (C) 2019 Huawei Technologies Co., Ltd. All rights reserved.
  """
  _pyangbind_elements = {}

  

