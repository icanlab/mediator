# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_global__huawei_network_instance__network_instance_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the global layer 3 virtual private network (L3VPN).
  """
  __slots__ = ('_path_helper', '_extmethods', '__cfg_router_id','__as_notation_plain','__route_distinguisher_auto_ip',)

  _yang_name = 'global'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cfg_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__as_notation_plain = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)
    self.__route_distinguisher_auto_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'global']

  def _get_cfg_router_id(self):
    """
    Getter method for cfg_router_id, mapped from YANG variable /network_instance/global/cfg_router_id (inet:ipv4-address-no-zone)

    YANG Description: The router id of router manager.
    """
    return self.__cfg_router_id
      
  def _set_cfg_router_id(self, v, load=False):
    """
    Setter method for cfg_router_id, mapped from YANG variable /network_instance/global/cfg_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cfg_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cfg_router_id() directly.

    YANG Description: The router id of router manager.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cfg_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__cfg_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cfg_router_id(self):
    self.__cfg_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_as_notation_plain(self):
    """
    Getter method for as_notation_plain, mapped from YANG variable /network_instance/global/as_notation_plain (boolean)

    YANG Description: Enable/disable setting the display format of the BGP 4 byte as to be unformatted integer type.
    """
    return self.__as_notation_plain
      
  def _set_as_notation_plain(self, v, load=False):
    """
    Setter method for as_notation_plain, mapped from YANG variable /network_instance/global/as_notation_plain (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_notation_plain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_notation_plain() directly.

    YANG Description: Enable/disable setting the display format of the BGP 4 byte as to be unformatted integer type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_notation_plain must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__as_notation_plain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_notation_plain(self):
    self.__as_notation_plain = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)


  def _get_route_distinguisher_auto_ip(self):
    """
    Getter method for route_distinguisher_auto_ip, mapped from YANG variable /network_instance/global/route_distinguisher_auto_ip (inet:ipv4-address-no-zone)

    YANG Description: Configure IP address to automatic route-distinguisher.
    """
    return self.__route_distinguisher_auto_ip
      
  def _set_route_distinguisher_auto_ip(self, v, load=False):
    """
    Setter method for route_distinguisher_auto_ip, mapped from YANG variable /network_instance/global/route_distinguisher_auto_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher_auto_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher_auto_ip() directly.

    YANG Description: Configure IP address to automatic route-distinguisher.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher_auto_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__route_distinguisher_auto_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher_auto_ip(self):
    self.__route_distinguisher_auto_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)

  cfg_router_id = __builtin__.property(_get_cfg_router_id, _set_cfg_router_id)
  as_notation_plain = __builtin__.property(_get_as_notation_plain, _set_as_notation_plain)
  route_distinguisher_auto_ip = __builtin__.property(_get_route_distinguisher_auto_ip, _set_route_distinguisher_auto_ip)


  _pyangbind_elements = OrderedDict([('cfg_router_id', cfg_router_id), ('as_notation_plain', as_notation_plain), ('route_distinguisher_auto_ip', route_distinguisher_auto_ip), ])


class yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure L3VPN instances information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__identifier',)

  _yang_name = 'parameter'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'parameter']

  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /network_instance/instances/instance/parameter/identifier (string)

    YANG Description: Configures a globally unique identifier for a VPN instance. The format of a VPN identifier are follows:HEX<0-ffffffff>:HEX<0-ffffffff>, but not support 0:0.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /network_instance/instances/instance/parameter/identifier (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: Configures a globally unique identifier for a VPN instance. The format of a VPN identifier are follows:HEX<0-ffffffff>:HEX<0-ffffffff>, but not support 0:0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)

  identifier = __builtin__.property(_get_identifier, _set_identifier)


  _pyangbind_elements = OrderedDict([('identifier', identifier), ])


class yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/vpn-targets/vpn-target. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure RT (VPN Target) s to control route advertisement
between network nodes. Before sending a VPN route to a PE,
the local PE adds an Export RT to the route. After receiving
a route from another PE, the local PE determines whether the
route will be added to the VPN instance based on the local
Import RT and the Export RT that is added to the VPN route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__type',)

  _yang_name = 'vpn-target'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'vpn-targets', 'vpn-target']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/value (string)

    YANG Description: The formats of a VPN target value are as follows:
(1) 16-bit AS number : 32-bit user-defined number,
    for example, 1:3. An AS number ranges from 0
    to 65535, and a user-defined number ranges from
    0 to 4294967295. The AS number and user-defined
    number cannot be both 0s. This means that the
    VPN Target value cannot be 0:0.
(2) 32-bit IP address: 16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address
    ranges from 0.0.0.0 to 255.255.255.255, and
    the user-defined number ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from
    0.0 to 65535.65535 or 0 to 4294967295, and a
    user-defined number ranges from 0 to 65535.
    The AS number and user-defined number cannot
    be both 0s. This means that the VPN Target
    value cannot be 0.0:0.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The formats of a VPN target value are as follows:
(1) 16-bit AS number : 32-bit user-defined number,
    for example, 1:3. An AS number ranges from 0
    to 65535, and a user-defined number ranges from
    0 to 4294967295. The AS number and user-defined
    number cannot be both 0s. This means that the
    VPN Target value cannot be 0:0.
(2) 32-bit IP address: 16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address
    ranges from 0.0.0.0 to 255.255.255.255, and
    the user-defined number ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from
    0.0 to 65535.65535 or 0 to 4294967295, and a
    user-defined number ranges from 0 to 65535.
    The AS number and user-defined number cannot
    be both 0s. This means that the VPN Target
    value cannot be 0.0:0.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/type (vpn-target-type)

    YANG Description: RT types are as follows:
export-extcommunity: Specifies the value of the
  extended community attribute of the route from
  an outbound interface to the destination VPN.
import-extcommunity: Receives routes that carry
  the specified extended community attribute value.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/type (vpn-target-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: RT types are as follows:
export-extcommunity: Specifies the value of the
  extended community attribute of the route from
  an outbound interface to the destination VPN.
import-extcommunity: Receives routes that carry
  the specified extended community attribute value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with vpn-target-type""",
          'defined-type': "huawei-l3vpn:vpn-target-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('value', value), ('type', type), ])


class yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/vpn-targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of RTs. The number of RTs in the group ranges from 1 to 8.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_target',)

  _yang_name = 'vpn-targets'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_target = YANGDynClass(base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'vpn-targets']

  def _get_vpn_target(self):
    """
    Getter method for vpn_target, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target (list)

    YANG Description: Configure RT (VPN Target) s to control route advertisement
between network nodes. Before sending a VPN route to a PE,
the local PE adds an Export RT to the route. After receiving
a route from another PE, the local PE determines whether the
route will be added to the VPN instance based on the local
Import RT and the Export RT that is added to the VPN route.
    """
    return self.__vpn_target
      
  def _set_vpn_target(self, v, load=False):
    """
    Setter method for vpn_target, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_target() directly.

    YANG Description: Configure RT (VPN Target) s to control route advertisement
between network nodes. Before sending a VPN route to a PE,
the local PE adds an Export RT to the route. After receiving
a route from another PE, the local PE determines whether the
route will be added to the VPN instance based on the local
Import RT and the Export RT that is added to the VPN route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_target must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)""",
        })

    self.__vpn_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_target(self):
    self.__vpn_target = YANGDynClass(base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

  vpn_target = __builtin__.property(_get_vpn_target, _set_vpn_target) # type: yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target


  _pyangbind_elements = OrderedDict([('vpn_target', vpn_target), ])


class yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of address families of the VPN instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__create_time','__up_time','__label','__status',)

  _yang_name = 'state'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__create_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'state']

  def _get_create_time(self):
    """
    Getter method for create_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/create_time (yang:date-and-time)

    YANG Description: The createtime of address families of the VPN instance.
    """
    return self.__create_time
      
  def _set_create_time(self, v, load=False):
    """
    Setter method for create_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/create_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_time() directly.

    YANG Description: The createtime of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__create_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_time(self):
    self.__create_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)


  def _get_up_time(self):
    """
    Getter method for up_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/up_time (pub-type:time-tick)

    YANG Description: The uptime of address families of the VPN instance.
    """
    return self.__up_time
      
  def _set_up_time(self, v, load=False):
    """
    Setter method for up_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/up_time (pub-type:time-tick)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_time() directly.

    YANG Description: The uptime of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_time must be of a type compatible with pub-type:time-tick""",
          'defined-type': "pub-type:time-tick",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)""",
        })

    self.__up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_time(self):
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /network_instance/instances/instance/afs/af/state/label (uint32)

    YANG Description: The label of address families of the VPN instance.
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /network_instance/instances/instance/afs/af/state/label (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: The label of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /network_instance/instances/instance/afs/af/state/status (vpn-status-type)

    YANG Description: VPN instance status. A VPN instance is up when there
is at least one interface associated with the VRF
whose ifOperStatus is up. A VRF is down when:
a. There does not exist at least one interface whose
   ifOperStatus is up.
b. There are no interfaces associated with the VRF.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /network_instance/instances/instance/afs/af/state/status (vpn-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: VPN instance status. A VPN instance is up when there
is at least one interface associated with the VRF
whose ifOperStatus is up. A VRF is down when:
a. There does not exist at least one interface whose
   ifOperStatus is up.
b. There are no interfaces associated with the VRF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with vpn-status-type""",
          'defined-type': "huawei-l3vpn:vpn-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)

  create_time = __builtin__.property(_get_create_time)
  up_time = __builtin__.property(_get_up_time)
  label = __builtin__.property(_get_label)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('create_time', create_time), ('up_time', up_time), ('label', label), ('status', status), ])


class yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/tunnel-infos/tunnel-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of tunnel informations.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__peer_ip','__id','__color','__name',)

  _yang_name = 'tunnel-info'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)
    self.__peer_ip = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    self.__color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'tunnel-infos', 'tunnel-info']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/type (tnlm:tunnel-type)

    YANG Description: Tunnel's type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/type (tnlm:tunnel-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Tunnel's type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with tnlm:tunnel-type""",
          'defined-type': "tnlm:tunnel-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)


  def _get_peer_ip(self):
    """
    Getter method for peer_ip, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/peer_ip (inet:ip-address-no-zone)

    YANG Description: Next Hop address through which the packet has to be sent.
    """
    return self.__peer_ip
      
  def _set_peer_ip(self, v, load=False):
    """
    Setter method for peer_ip, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/peer_ip (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_ip() directly.

    YANG Description: Next Hop address through which the packet has to be sent.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_ip must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)""",
        })

    self.__peer_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_ip(self):
    self.__peer_ip = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/id (uint32)

    YANG Description: Tunnel's ID.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Tunnel's ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)


  def _get_color(self):
    """
    Getter method for color, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/color (uint32)

    YANG Description: Color information for tunnel.
    """
    return self.__color
      
  def _set_color(self, v, load=False):
    """
    Setter method for color, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/color (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_color is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_color() directly.

    YANG Description: Color information for tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """color must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)""",
        })

    self.__color = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_color(self):
    self.__color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/name (string)

    YANG Description: Tunnel's name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Tunnel's name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  peer_ip = __builtin__.property(_get_peer_ip)
  id = __builtin__.property(_get_id)
  color = __builtin__.property(_get_color)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('peer_ip', peer_ip), ('id', id), ('color', color), ('name', name), ])


class yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/tunnel-infos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of tunnel informations.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tunnel_info',)

  _yang_name = 'tunnel-infos'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tunnel_info = YANGDynClass(base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'tunnel-infos']

  def _get_tunnel_info(self):
    """
    Getter method for tunnel_info, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info (list)

    YANG Description: Statistics of tunnel informations.
    """
    return self.__tunnel_info
      
  def _set_tunnel_info(self, v, load=False):
    """
    Setter method for tunnel_info, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_info() directly.

    YANG Description: Statistics of tunnel informations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_info must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)""",
        })

    self.__tunnel_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_info(self):
    self.__tunnel_info = YANGDynClass(base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)

  tunnel_info = __builtin__.property(_get_tunnel_info) # type: yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info


  _pyangbind_elements = OrderedDict([('tunnel_info', tunnel_info), ])


class yc_ospf_import_rt_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts_ospf_import_rt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/ospf-import-rts/ospf-import-rt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure import route information from another routing protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__src_vrf','__process_id','__valid_route','__route_policy','__route_filter',)

  _yang_name = 'ospf-import-rt'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__src_vrf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="src-vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__valid_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'ospf-import-rts', 'ospf-import-rt']

  def _get_src_vrf(self):
    """
    Getter method for src_vrf, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/src_vrf (leafref)

    YANG Description: VPN instance route information.
    """
    return self.__src_vrf
      
  def _set_src_vrf(self, v, load=False):
    """
    Setter method for src_vrf, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/src_vrf (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_vrf() directly.

    YANG Description: VPN instance route information.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="src-vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_vrf must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="src-vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__src_vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_vrf(self):
    self.__src_vrf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="src-vrf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_process_id(self):
    """
    Getter method for process_id, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/process_id (uint32)

    YANG Description: Process ID.
    """
    return self.__process_id
      
  def _set_process_id(self, v, load=False):
    """
    Setter method for process_id, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/process_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process_id() directly.

    YANG Description: Process ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__process_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process_id(self):
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/valid_route (boolean)

    YANG Description: Enable/disable the valid routes.
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Enable/disable the valid routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_route_policy(self):
    """
    Getter method for route_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/route_policy (leafref)

    YANG Description: Set a route policy name.
    """
    return self.__route_policy
      
  def _set_route_policy(self, v, load=False):
    """
    Setter method for route_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/route_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy() directly.

    YANG Description: Set a route policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy(self):
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter(self):
    """
    Getter method for route_filter, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/route_filter (leafref)

    YANG Description: Set a route filter name.
    """
    return self.__route_filter
      
  def _set_route_filter(self, v, load=False):
    """
    Setter method for route_filter, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt/route_filter (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter() directly.

    YANG Description: Set a route filter name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter(self):
    self.__route_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  src_vrf = __builtin__.property(_get_src_vrf, _set_src_vrf)
  process_id = __builtin__.property(_get_process_id, _set_process_id)
  valid_route = __builtin__.property(_get_valid_route, _set_valid_route)
  route_policy = __builtin__.property(_get_route_policy, _set_route_policy)
  route_filter = __builtin__.property(_get_route_filter, _set_route_filter)

  __choices__ = {'policy-type': {'route-policy': ['route_policy'], 'route-filter': ['route_filter']}}
  _pyangbind_elements = OrderedDict([('src_vrf', src_vrf), ('process_id', process_id), ('valid_route', valid_route), ('route_policy', route_policy), ('route_filter', route_filter), ])


class yc_ospf_import_rts_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/ospf-import-rts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of import route information from another routing protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ospf_import_rt',)

  _yang_name = 'ospf-import-rts'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ospf_import_rt = YANGDynClass(base=YANGListType("src_vrf process_id",yc_ospf_import_rt_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts_ospf_import_rt, yang_name="ospf-import-rt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-vrf process-id', extensions=None), is_container='list', yang_name="ospf-import-rt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'ospf-import-rts']

  def _get_ospf_import_rt(self):
    """
    Getter method for ospf_import_rt, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt (list)

    YANG Description: Configure import route information from another routing protocol.
    """
    return self.__ospf_import_rt
      
  def _set_ospf_import_rt(self, v, load=False):
    """
    Setter method for ospf_import_rt, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts/ospf_import_rt (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospf_import_rt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospf_import_rt() directly.

    YANG Description: Configure import route information from another routing protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("src_vrf process_id",yc_ospf_import_rt_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts_ospf_import_rt, yang_name="ospf-import-rt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-vrf process-id', extensions=None), is_container='list', yang_name="ospf-import-rt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospf_import_rt must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("src_vrf process_id",yc_ospf_import_rt_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts_ospf_import_rt, yang_name="ospf-import-rt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-vrf process-id', extensions=None), is_container='list', yang_name="ospf-import-rt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__ospf_import_rt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospf_import_rt(self):
    self.__ospf_import_rt = YANGDynClass(base=YANGListType("src_vrf process_id",yc_ospf_import_rt_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts_ospf_import_rt, yang_name="ospf-import-rt", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-vrf process-id', extensions=None), is_container='list', yang_name="ospf-import-rt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  ospf_import_rt = __builtin__.property(_get_ospf_import_rt, _set_ospf_import_rt) # type: yc_ospf_import_rt_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts_ospf_import_rt


  _pyangbind_elements = OrderedDict([('ospf_import_rt', ospf_import_rt), ])


class yc_af_huawei_network_instance__network_instance_instances_instance_afs_af(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure address families of the VPN instance. A VPN instance
supports the configurations and functions of an
address family only after the address family is
configured on the instance. Neither of the address
families in the _public_ VPN instance can be deleted.
If either of a VPN instance's IPv4 and IPv6 address
families is referenced by BGP, the referenced address
family cannot be deleted. If one of the address
families is referenced by BGP, the non-referenced
address family in the VPN instance can be deleted.
If the VPN instance is referenced by BGP but its
address families are not referenced by BGP, neither
address family can be deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__route_distinguisher','__effect_route_distinguisher','__import_policy','__export_policy','__export_policy_add_ert_first','__label_mode','__vpn_frr','__tunnel_policy','__transit_vpn','__lsp_operation','__default_color','__vpn_targets','__state','__tunnel_infos','__ospf_import_rts',)

  _yang_name = 'af'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)
    self.__route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    self.__effect_route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    self.__export_policy_add_ert_first = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__label_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)
    self.__vpn_frr = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__tunnel_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    self.__transit_vpn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__lsp_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)
    self.__default_color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__tunnel_infos = YANGDynClass(base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__ospf_import_rts = YANGDynClass(base=yc_ospf_import_rts_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts, is_container='container', yang_name="ospf-import-rts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/type (af-type)

    YANG Description: Types of the VPN address families.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/type (af-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Types of the VPN address families.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with af-type""",
          'defined-type': "huawei-l3vpn:af-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)


  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/route_distinguisher (string)

    YANG Description: A VPN address family takes effect only after it is
configured with a RD.The object allows configuration
and deletion, it cannot be modified. The format of
an RD are as follows:
(1) 16-bit AS number :32-bit user-defined number,
    for example, 101:3. An AS number ranges from 0 to 65535,
    and a user-defined number ranges from 0 to 4294967295.
    The AS number and user-defined number cannot be both 0s.
    This means that the RD value cannot be 0:0.
(2) 32-bit IP address:16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address ranges from
    0.0.0.0 to 255.255.255.255, and the user-defined number
    ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from 0.0 to
    65535.65535 or 0 to 4294967295, and a user-defined number
    ranges from 0 to 65535. The AS number and user-defined
    number cannot be both 0s. This means that the RD value
    cannot be 0.0:0. If a VPN instance's IPv4 or IPv6 address
    family to which the node belongs is referenced by BGP,
    the node cannot be deleted. If the IPv4 or IPv6 address
    family to which the node belongs is not referenced by
    BGP and the other address family is referenced by BGP,
    the node can be deleted. If the VPN instance is referenced
    by BGP but its address families are not referenced by BGP,
    the nodes in the address families cannot be deleted.
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/route_distinguisher (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: A VPN address family takes effect only after it is
configured with a RD.The object allows configuration
and deletion, it cannot be modified. The format of
an RD are as follows:
(1) 16-bit AS number :32-bit user-defined number,
    for example, 101:3. An AS number ranges from 0 to 65535,
    and a user-defined number ranges from 0 to 4294967295.
    The AS number and user-defined number cannot be both 0s.
    This means that the RD value cannot be 0:0.
(2) 32-bit IP address:16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address ranges from
    0.0.0.0 to 255.255.255.255, and the user-defined number
    ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from 0.0 to
    65535.65535 or 0 to 4294967295, and a user-defined number
    ranges from 0 to 65535. The AS number and user-defined
    number cannot be both 0s. This means that the RD value
    cannot be 0.0:0. If a VPN instance's IPv4 or IPv6 address
    family to which the node belongs is referenced by BGP,
    the node cannot be deleted. If the IPv4 or IPv6 address
    family to which the node belongs is not referenced by
    BGP and the other address family is referenced by BGP,
    the node can be deleted. If the VPN instance is referenced
    by BGP but its address families are not referenced by BGP,
    the nodes in the address families cannot be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)


  def _get_effect_route_distinguisher(self):
    """
    Getter method for effect_route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/effect_route_distinguisher (string)

    YANG Description: Effective RD.
    """
    return self.__effect_route_distinguisher
      
  def _set_effect_route_distinguisher(self, v, load=False):
    """
    Setter method for effect_route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/effect_route_distinguisher (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effect_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effect_route_distinguisher() directly.

    YANG Description: Effective RD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effect_route_distinguisher must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)""",
        })

    self.__effect_route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effect_route_distinguisher(self):
    self.__effect_route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)


  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/import_policy (leafref)

    YANG Description: Name of a route import policy. The policy is associating
the VPN instance with an inbound routing policy. If a
mode that is more accurate than the extended community
attribute mode is required for filtering import VPN
instance routes, the inbound routing policy can be
adopted. The inbound routing policy can filter imported
routes and set routing attributes for the qualified routes.
If the inbound routing policy is not configured, all routes
matching the VPN-target attribute are added to the VPN instance.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: Name of a route import policy. The policy is associating
the VPN instance with an inbound routing policy. If a
mode that is more accurate than the extended community
attribute mode is required for filtering import VPN
instance routes, the inbound routing policy can be
adopted. The inbound routing policy can filter imported
routes and set routing attributes for the qualified routes.
If the inbound routing policy is not configured, all routes
matching the VPN-target attribute are added to the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy (leafref)

    YANG Description: Name of a route export policy. The policy is associating
the VPN instance with an outbound routing policy.
If a mode that is more accurate than the extended
community attribute mode is required to control
the advertisement ofVPN instance routes, the outbound
routing policy can be adopted. The outbound routing
policy can filter the routes to be advertised and set
routing attributes for the qualified routes. If the
outbound routing policy is not configured, all routes
can be advertised.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: Name of a route export policy. The policy is associating
the VPN instance with an outbound routing policy.
If a mode that is more accurate than the extended
community attribute mode is required to control
the advertisement ofVPN instance routes, the outbound
routing policy can be adopted. The outbound routing
policy can filter the routes to be advertised and set
routing attributes for the qualified routes. If the
outbound routing policy is not configured, all routes
can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)


  def _get_export_policy_add_ert_first(self):
    """
    Getter method for export_policy_add_ert_first, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy_add_ert_first (boolean)

    YANG Description: Enable/disable advertise routes to VPNv4 add ERT first.
    """
    return self.__export_policy_add_ert_first
      
  def _set_export_policy_add_ert_first(self, v, load=False):
    """
    Setter method for export_policy_add_ert_first, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy_add_ert_first (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy_add_ert_first is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy_add_ert_first() directly.

    YANG Description: Enable/disable advertise routes to VPNv4 add ERT first.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy_add_ert_first must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__export_policy_add_ert_first = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy_add_ert_first(self):
    self.__export_policy_add_ert_first = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_label_mode(self):
    """
    Getter method for label_mode, mapped from YANG variable /network_instance/instances/instance/afs/af/label_mode (label-mode-type)

    YANG Description: Method of distributing labels to VPN instance routes.
The way which assigns the label depends on the paf value.
If there are a large number of routes in a VPN instance,
assign a label for each instance. This allows all routes
in the instance to use one label.
    """
    return self.__label_mode
      
  def _set_label_mode(self, v, load=False):
    """
    Setter method for label_mode, mapped from YANG variable /network_instance/instances/instance/afs/af/label_mode (label-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label_mode() directly.

    YANG Description: Method of distributing labels to VPN instance routes.
The way which assigns the label depends on the paf value.
If there are a large number of routes in a VPN instance,
assign a label for each instance. This allows all routes
in the instance to use one label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label_mode must be of a type compatible with label-mode-type""",
          'defined-type': "huawei-l3vpn:label-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)""",
        })

    self.__label_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label_mode(self):
    self.__label_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)


  def _get_vpn_frr(self):
    """
    Getter method for vpn_frr, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_frr (boolean)

    YANG Description: Enable/disable the VPN FRR function.
    """
    return self.__vpn_frr
      
  def _set_vpn_frr(self, v, load=False):
    """
    Setter method for vpn_frr, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_frr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_frr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_frr() directly.

    YANG Description: Enable/disable the VPN FRR function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_frr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__vpn_frr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_frr(self):
    self.__vpn_frr = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_tunnel_policy(self):
    """
    Getter method for tunnel_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_policy (leafref)

    YANG Description: Name of a tunnel policy. It is used to associate the VPN
instance with the specified tunnel policy. If no tunnel
policy is configured, the default tunnel policy is used.
Only LDP LSPs or static LSPs match the default tunnel policy,
and load balancing is not performed for LSPs.
    """
    return self.__tunnel_policy
      
  def _set_tunnel_policy(self, v, load=False):
    """
    Setter method for tunnel_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_policy() directly.

    YANG Description: Name of a tunnel policy. It is used to associate the VPN
instance with the specified tunnel policy. If no tunnel
policy is configured, the default tunnel policy is used.
Only LDP LSPs or static LSPs match the default tunnel policy,
and load balancing is not performed for LSPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)""",
        })

    self.__tunnel_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_policy(self):
    self.__tunnel_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)


  def _get_transit_vpn(self):
    """
    Getter method for transit_vpn, mapped from YANG variable /network_instance/instances/instance/afs/af/transit_vpn (boolean)

    YANG Description: Enable/disable keeping the VPN instance status up.
    """
    return self.__transit_vpn
      
  def _set_transit_vpn(self, v, load=False):
    """
    Setter method for transit_vpn, mapped from YANG variable /network_instance/instances/instance/afs/af/transit_vpn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_vpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_vpn() directly.

    YANG Description: Enable/disable keeping the VPN instance status up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_vpn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__transit_vpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_vpn(self):
    self.__transit_vpn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_lsp_operation(self):
    """
    Getter method for lsp_operation, mapped from YANG variable /network_instance/instances/instance/afs/af/lsp_operation (lsp-operation-type)

    YANG Description: Label Operation Mode.
    """
    return self.__lsp_operation
      
  def _set_lsp_operation(self, v, load=False):
    """
    Setter method for lsp_operation, mapped from YANG variable /network_instance/instances/instance/afs/af/lsp_operation (lsp-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_operation() directly.

    YANG Description: Label Operation Mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_operation must be of a type compatible with lsp-operation-type""",
          'defined-type': "huawei-l3vpn:lsp-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)""",
        })

    self.__lsp_operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_operation(self):
    self.__lsp_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)


  def _get_default_color(self):
    """
    Getter method for default_color, mapped from YANG variable /network_instance/instances/instance/afs/af/default_color (uint32)

    YANG Description: Set default color for nexthop iteration.
    """
    return self.__default_color
      
  def _set_default_color(self, v, load=False):
    """
    Setter method for default_color, mapped from YANG variable /network_instance/instances/instance/afs/af/default_color (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_color is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_color() directly.

    YANG Description: Set default color for nexthop iteration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_color must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)""",
        })

    self.__default_color = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_color(self):
    self.__default_color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)


  def _get_vpn_targets(self):
    """
    Getter method for vpn_targets, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets (container)

    YANG Description: List of RTs. The number of RTs in the group ranges from 1 to 8.
    """
    return self.__vpn_targets
      
  def _set_vpn_targets(self, v, load=False):
    """
    Setter method for vpn_targets, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_targets() directly.

    YANG Description: List of RTs. The number of RTs in the group ranges from 1 to 8.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_targets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__vpn_targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_targets(self):
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instance/instances/instance/afs/af/state (container)

    YANG Description: Statistics of address families of the VPN instance.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instance/instances/instance/afs/af/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Statistics of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_tunnel_infos(self):
    """
    Getter method for tunnel_infos, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos (container)

    YANG Description: List of tunnel informations.
    """
    return self.__tunnel_infos
      
  def _set_tunnel_infos(self, v, load=False):
    """
    Setter method for tunnel_infos, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_infos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_infos() directly.

    YANG Description: List of tunnel informations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_infos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__tunnel_infos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_infos(self):
    self.__tunnel_infos = YANGDynClass(base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_ospf_import_rts(self):
    """
    Getter method for ospf_import_rts, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts (container)

    YANG Description: List of import route information from another routing protocol.
    """
    return self.__ospf_import_rts
      
  def _set_ospf_import_rts(self, v, load=False):
    """
    Setter method for ospf_import_rts, mapped from YANG variable /network_instance/instances/instance/afs/af/ospf_import_rts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospf_import_rts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospf_import_rts() directly.

    YANG Description: List of import route information from another routing protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ospf_import_rts_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts, is_container='container', yang_name="ospf-import-rts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospf_import_rts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ospf_import_rts_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts, is_container='container', yang_name="ospf-import-rts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ospf_import_rts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospf_import_rts(self):
    self.__ospf_import_rts = YANGDynClass(base=yc_ospf_import_rts_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts, is_container='container', yang_name="ospf-import-rts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  route_distinguisher = __builtin__.property(_get_route_distinguisher, _set_route_distinguisher)
  effect_route_distinguisher = __builtin__.property(_get_effect_route_distinguisher)
  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  export_policy_add_ert_first = __builtin__.property(_get_export_policy_add_ert_first, _set_export_policy_add_ert_first)
  label_mode = __builtin__.property(_get_label_mode, _set_label_mode)
  vpn_frr = __builtin__.property(_get_vpn_frr, _set_vpn_frr)
  tunnel_policy = __builtin__.property(_get_tunnel_policy, _set_tunnel_policy)
  transit_vpn = __builtin__.property(_get_transit_vpn, _set_transit_vpn)
  lsp_operation = __builtin__.property(_get_lsp_operation, _set_lsp_operation)
  default_color = __builtin__.property(_get_default_color, _set_default_color)
  vpn_targets = __builtin__.property(_get_vpn_targets, _set_vpn_targets) # type: yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets
  state = __builtin__.property(_get_state, _set_state) # type: yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state
  tunnel_infos = __builtin__.property(_get_tunnel_infos, _set_tunnel_infos) # type: yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos
  ospf_import_rts = __builtin__.property(_get_ospf_import_rts, _set_ospf_import_rts) # type: yc_ospf_import_rts_huawei_network_instance__network_instance_instances_instance_afs_af_ospf_import_rts

  __choices__ = {'import-policy-type': {'rtp-ref': ['import_policy']}, 'export-policy-type': {'rtp-ref': ['export_policy']}}
  _pyangbind_elements = OrderedDict([('type', type), ('route_distinguisher', route_distinguisher), ('effect_route_distinguisher', effect_route_distinguisher), ('import_policy', import_policy), ('export_policy', export_policy), ('export_policy_add_ert_first', export_policy_add_ert_first), ('label_mode', label_mode), ('vpn_frr', vpn_frr), ('tunnel_policy', tunnel_policy), ('transit_vpn', transit_vpn), ('lsp_operation', lsp_operation), ('default_color', default_color), ('vpn_targets', vpn_targets), ('state', state), ('tunnel_infos', tunnel_infos), ('ospf_import_rts', ospf_import_rts), ])


class yc_afs_huawei_network_instance__network_instance_instances_instance_afs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VPN address families. A VPN instance supports the
configurations and functions of an address family only
after the address family is configured on the instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__af',)

  _yang_name = 'afs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs']

  def _get_af(self):
    """
    Getter method for af, mapped from YANG variable /network_instance/instances/instance/afs/af (list)

    YANG Description: Configure address families of the VPN instance. A VPN instance
supports the configurations and functions of an
address family only after the address family is
configured on the instance. Neither of the address
families in the _public_ VPN instance can be deleted.
If either of a VPN instance's IPv4 and IPv6 address
families is referenced by BGP, the referenced address
family cannot be deleted. If one of the address
families is referenced by BGP, the non-referenced
address family in the VPN instance can be deleted.
If the VPN instance is referenced by BGP but its
address families are not referenced by BGP, neither
address family can be deleted.
    """
    return self.__af
      
  def _set_af(self, v, load=False):
    """
    Setter method for af, mapped from YANG variable /network_instance/instances/instance/afs/af (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_af is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_af() directly.

    YANG Description: Configure address families of the VPN instance. A VPN instance
supports the configurations and functions of an
address family only after the address family is
configured on the instance. Neither of the address
families in the _public_ VPN instance can be deleted.
If either of a VPN instance's IPv4 and IPv6 address
families is referenced by BGP, the referenced address
family cannot be deleted. If one of the address
families is referenced by BGP, the non-referenced
address family in the VPN instance can be deleted.
If the VPN instance is referenced by BGP but its
address families are not referenced by BGP, neither
address family can be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """af must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)""",
        })

    self.__af = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_af(self):
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

  af = __builtin__.property(_get_af, _set_af) # type: yc_af_huawei_network_instance__network_instance_instances_instance_afs_af


  _pyangbind_elements = OrderedDict([('af', af), ])


class yc_gtsm_huawei_network_instance__network_instance_instances_instance_ospfv2_gtsm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/gtsm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the OSPF GTSM.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hops','__nonstandard_multicast',)

  _yang_name = 'gtsm'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    self.__nonstandard_multicast = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nonstandard-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'gtsm']

  def _get_hops(self):
    """
    Getter method for hops, mapped from YANG variable /network_instance/instances/instance/ospfv2/gtsm/hops (uint8)

    YANG Description: Specifies the number of TTL hops to be detected.
    """
    return self.__hops
      
  def _set_hops(self, v, load=False):
    """
    Setter method for hops, mapped from YANG variable /network_instance/instances/instance/ospfv2/gtsm/hops (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hops() directly.

    YANG Description: Specifies the number of TTL hops to be detected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hops must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)""",
        })

    self.__hops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hops(self):
    self.__hops = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="hops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)


  def _get_nonstandard_multicast(self):
    """
    Getter method for nonstandard_multicast, mapped from YANG variable /network_instance/instances/instance/ospfv2/gtsm/nonstandard_multicast (boolean)

    YANG Description: Enable/disable sending Multicast packet with TTL as 255 and receive multicast packet TTL should be 1 or 255 to ((255 - configured hop) + 1).
    """
    return self.__nonstandard_multicast
      
  def _set_nonstandard_multicast(self, v, load=False):
    """
    Setter method for nonstandard_multicast, mapped from YANG variable /network_instance/instances/instance/ospfv2/gtsm/nonstandard_multicast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nonstandard_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nonstandard_multicast() directly.

    YANG Description: Enable/disable sending Multicast packet with TTL as 255 and receive multicast packet TTL should be 1 or 255 to ((255 - configured hop) + 1).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nonstandard-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nonstandard_multicast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nonstandard-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__nonstandard_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nonstandard_multicast(self):
    self.__nonstandard_multicast = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="nonstandard-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  hops = __builtin__.property(_get_hops, _set_hops)
  nonstandard_multicast = __builtin__.property(_get_nonstandard_multicast, _set_nonstandard_multicast)


  _pyangbind_elements = OrderedDict([('hops', hops), ('nonstandard_multicast', nonstandard_multicast), ])


class yc_domain_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/private-net/domain-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure ID of an OSPF domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__domain_id','__type','__value',)

  _yang_name = 'domain-id'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__domain_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), default=six.text_type("0x0005"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), default=six.text_type("0x0"), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'private-net', 'domain-id']

  def _get_domain_id(self):
    """
    Getter method for domain_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id/domain_id (inet:ipv4-address-no-zone)

    YANG Description: ID of an OSPF domain.
    """
    return self.__domain_id
      
  def _set_domain_id(self, v, load=False):
    """
    Setter method for domain_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id/domain_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_id() directly.

    YANG Description: ID of an OSPF domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__domain_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_id(self):
    self.__domain_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id/type (domain-id-type)

    YANG Description: Type of an OSPF domain ID.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id/type (domain-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of an OSPF domain ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), default=six.text_type("0x0005"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with domain-id-type""",
          'defined-type': "huawei-ospfv2:domain-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), default=six.text_type("0x0005"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), default=six.text_type("0x0005"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id/value (pub-type:hex-binary)

    YANG Description: Value of an OSPF domain ID type.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id/value (pub-type:hex-binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of an OSPF domain ID type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), default=six.text_type("0x0"), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with pub-type:hex-binary""",
          'defined-type': "pub-type:hex-binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), default=six.text_type("0x0"), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), default=six.text_type("0x0"), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)

  domain_id = __builtin__.property(_get_domain_id, _set_domain_id)
  type = __builtin__.property(_get_type, _set_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('domain_id', domain_id), ('type', type), ('value', value), ])


class yc_domain_id_secondary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys_domain_id_secondary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/private-net/domain-id-secondarys/domain-id-secondary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure ID of a secondary domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__domain_id','__type','__value',)

  _yang_name = 'domain-id-secondary'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__domain_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'private-net', 'domain-id-secondarys', 'domain-id-secondary']

  def _get_domain_id(self):
    """
    Getter method for domain_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary/domain_id (inet:ipv4-address-no-zone)

    YANG Description: ID of an OSPF domain.
    """
    return self.__domain_id
      
  def _set_domain_id(self, v, load=False):
    """
    Setter method for domain_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary/domain_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_id() directly.

    YANG Description: ID of an OSPF domain.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__domain_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_id(self):
    self.__domain_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary/type (domain-id-type)

    YANG Description: Type of an OSPF domain ID.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary/type (domain-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of an OSPF domain ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with domain-id-type""",
          'defined-type': "huawei-ospfv2:domain-id-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'0x0005': {'value': 1}, '0x0105': {'value': 2}, '0x0205': {'value': 3}, '0x8005': {'value': 4}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='domain-id-type', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary/value (pub-type:hex-binary)

    YANG Description: Value of an OSPF domain ID type.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary/value (pub-type:hex-binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of an OSPF domain ID type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with pub-type:hex-binary""",
          'defined-type': "pub-type:hex-binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0x|0X)?[0-9a-fA-F]+', 'length': ['1..10']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:hex-binary', is_config=True)

  domain_id = __builtin__.property(_get_domain_id, _set_domain_id)
  type = __builtin__.property(_get_type, _set_type)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('domain_id', domain_id), ('type', type), ('value', value), ])


class yc_domain_id_secondarys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/private-net/domain-id-secondarys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of ID of a secondary domain.
  """
  __slots__ = ('_path_helper', '_extmethods', '__domain_id_secondary',)

  _yang_name = 'domain-id-secondarys'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__domain_id_secondary = YANGDynClass(base=YANGListType("domain_id type value",yc_domain_id_secondary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys_domain_id_secondary, yang_name="domain-id-secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='domain-id type value', extensions=None), is_container='list', yang_name="domain-id-secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'private-net', 'domain-id-secondarys']

  def _get_domain_id_secondary(self):
    """
    Getter method for domain_id_secondary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary (list)

    YANG Description: Configure ID of a secondary domain.
    """
    return self.__domain_id_secondary
      
  def _set_domain_id_secondary(self, v, load=False):
    """
    Setter method for domain_id_secondary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys/domain_id_secondary (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_id_secondary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_id_secondary() directly.

    YANG Description: Configure ID of a secondary domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("domain_id type value",yc_domain_id_secondary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys_domain_id_secondary, yang_name="domain-id-secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='domain-id type value', extensions=None), is_container='list', yang_name="domain-id-secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_id_secondary must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("domain_id type value",yc_domain_id_secondary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys_domain_id_secondary, yang_name="domain-id-secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='domain-id type value', extensions=None), is_container='list', yang_name="domain-id-secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__domain_id_secondary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_id_secondary(self):
    self.__domain_id_secondary = YANGDynClass(base=YANGListType("domain_id type value",yc_domain_id_secondary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys_domain_id_secondary, yang_name="domain-id-secondary", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='domain-id type value', extensions=None), is_container='list', yang_name="domain-id-secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  domain_id_secondary = __builtin__.property(_get_domain_id_secondary, _set_domain_id_secondary) # type: yc_domain_id_secondary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys_domain_id_secondary


  _pyangbind_elements = OrderedDict([('domain_id_secondary', domain_id_secondary), ])


class yc_private_net_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/private-net. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure private network configuration of OSPF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__eca_route','__disable','__value','__vpn_capability','__domain_id','__domain_id_secondarys',)

  _yang_name = 'private-net'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__eca_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eca-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__disable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable", parent=self, choice=('route-tag', 'disable'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="value", parent=self, choice=('route-tag', 'value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__vpn_capability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__domain_id = YANGDynClass(base=yc_domain_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id, is_container='container', yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__domain_id_secondarys = YANGDynClass(base=yc_domain_id_secondarys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys, is_container='container', yang_name="domain-id-secondarys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'private-net']

  def _get_eca_route(self):
    """
    Getter method for eca_route, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/eca_route (boolean)

    YANG Description: Enable/disable route type of the extended community attribute for VPN.
    """
    return self.__eca_route
      
  def _set_eca_route(self, v, load=False):
    """
    Setter method for eca_route, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/eca_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eca_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eca_route() directly.

    YANG Description: Enable/disable route type of the extended community attribute for VPN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eca-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eca_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eca-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__eca_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eca_route(self):
    self.__eca_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="eca-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_disable(self):
    """
    Getter method for disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/disable (empty)

    YANG Description: To disable the using of the tag for loop detection.
    """
    return self.__disable
      
  def _set_disable(self, v, load=False):
    """
    Setter method for disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/disable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable() directly.

    YANG Description: To disable the using of the tag for loop detection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="disable", parent=self, choice=('route-tag', 'disable'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable", parent=self, choice=('route-tag', 'disable'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable(self):
    self.__disable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="disable", parent=self, choice=('route-tag', 'disable'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/value (uint32)

    YANG Description: Tag of an imported VPN route. By default, the first two bytes of the tag value are fixed to be 0xD000, and the last two bytes are the local AS number of the local BGP. For example, if the AS number of BGP is 100, the default tag value in decimal notation is 3489661028.If not configed, the default is 0.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Tag of an imported VPN route. By default, the first two bytes of the tag value are fixed to be 0xD000, and the last two bytes are the local AS number of the local BGP. For example, if the AS number of BGP is 100, the default tag value in decimal notation is 3489661028.If not configed, the default is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="value", parent=self, choice=('route-tag', 'value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="value", parent=self, choice=('route-tag', 'value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="value", parent=self, choice=('route-tag', 'value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_vpn_capability(self):
    """
    Getter method for vpn_capability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/vpn_capability (boolean)

    YANG Description: Enable/disable route loop detection and directly calculate routes. When VPN multi instance is supported on the multi VPN instance CE (MCE) router, loop detection must be cancelled. It is applicable to only OSPF VPN instances.
    """
    return self.__vpn_capability
      
  def _set_vpn_capability(self, v, load=False):
    """
    Setter method for vpn_capability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/vpn_capability (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_capability() directly.

    YANG Description: Enable/disable route loop detection and directly calculate routes. When VPN multi instance is supported on the multi VPN instance CE (MCE) router, loop detection must be cancelled. It is applicable to only OSPF VPN instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_capability must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__vpn_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_capability(self):
    self.__vpn_capability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_domain_id(self):
    """
    Getter method for domain_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id (container)

    YANG Description: Configure ID of an OSPF domain.
    """
    return self.__domain_id
      
  def _set_domain_id(self, v, load=False):
    """
    Setter method for domain_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_id() directly.

    YANG Description: Configure ID of an OSPF domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_domain_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id, is_container='container', yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_domain_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id, is_container='container', yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__domain_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_id(self):
    self.__domain_id = YANGDynClass(base=yc_domain_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id, is_container='container', yang_name="domain-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_domain_id_secondarys(self):
    """
    Getter method for domain_id_secondarys, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys (container)

    YANG Description: List of ID of a secondary domain.
    """
    return self.__domain_id_secondarys
      
  def _set_domain_id_secondarys(self, v, load=False):
    """
    Setter method for domain_id_secondarys, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net/domain_id_secondarys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_id_secondarys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_id_secondarys() directly.

    YANG Description: List of ID of a secondary domain.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_domain_id_secondarys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys, is_container='container', yang_name="domain-id-secondarys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_id_secondarys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_domain_id_secondarys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys, is_container='container', yang_name="domain-id-secondarys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__domain_id_secondarys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_id_secondarys(self):
    self.__domain_id_secondarys = YANGDynClass(base=yc_domain_id_secondarys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys, is_container='container', yang_name="domain-id-secondarys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  eca_route = __builtin__.property(_get_eca_route, _set_eca_route)
  disable = __builtin__.property(_get_disable, _set_disable)
  value = __builtin__.property(_get_value, _set_value)
  vpn_capability = __builtin__.property(_get_vpn_capability, _set_vpn_capability)
  domain_id = __builtin__.property(_get_domain_id, _set_domain_id) # type: yc_domain_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id
  domain_id_secondarys = __builtin__.property(_get_domain_id_secondarys, _set_domain_id_secondarys) # type: yc_domain_id_secondarys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net_domain_id_secondarys

  __choices__ = {'route-tag': {'disable': ['disable'], 'value': ['value']}}
  _pyangbind_elements = OrderedDict([('eca_route', eca_route), ('disable', disable), ('value', value), ('vpn_capability', vpn_capability), ('domain_id', domain_id), ('domain_id_secondarys', domain_id_secondarys), ])


class yc_host_name_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_host_name(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/host-name. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF host name.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__value',)

  _yang_name = 'host-name'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'host-name']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/host_name/enable (boolean)

    YANG Description: Enable/disable host name.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/host_name/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/host_name/value (string)

    YANG Description: Set host name.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/host_name/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Set host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('enable', enable), ('value', value), ])


class yc_bandwidth_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bandwidth(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/bandwidth. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure bandwidth.
  """
  __slots__ = ('_path_helper', '_extmethods', '__config_bw_enable','__reference_value',)

  _yang_name = 'bandwidth'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config_bw_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="config-bw-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__reference_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="reference-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'bandwidth']

  def _get_config_bw_enable(self):
    """
    Getter method for config_bw_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bandwidth/config_bw_enable (boolean)

    YANG Description: Enable/disable bandwidth config.
    """
    return self.__config_bw_enable
      
  def _set_config_bw_enable(self, v, load=False):
    """
    Setter method for config_bw_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bandwidth/config_bw_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_bw_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_bw_enable() directly.

    YANG Description: Enable/disable bandwidth config.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="config-bw-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_bw_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="config-bw-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__config_bw_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_bw_enable(self):
    self.__config_bw_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="config-bw-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_reference_value(self):
    """
    Getter method for reference_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bandwidth/reference_value (uint32)

    YANG Description: Reference to the calculation of link costs.
    """
    return self.__reference_value
      
  def _set_reference_value(self, v, load=False):
    """
    Setter method for reference_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bandwidth/reference_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reference_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reference_value() directly.

    YANG Description: Reference to the calculation of link costs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="reference-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reference_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="reference-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__reference_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reference_value(self):
    self.__reference_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..2147483648']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="reference-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  config_bw_enable = __builtin__.property(_get_config_bw_enable, _set_config_bw_enable)
  reference_value = __builtin__.property(_get_reference_value, _set_reference_value)


  _pyangbind_elements = OrderedDict([('config_bw_enable', config_bw_enable), ('reference_value', reference_value), ])


class yc_lsa_arrival_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arrival(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/timer/lsa-arrival. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure interval for receiving LSAs either through an intelligent timer or timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__max_interval','__start_interval','__hold_interval',)

  _yang_name = 'lsa-arrival'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), is_leaf=True, yang_name="interval", parent=self, choice=('timer-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__max_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__start_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'timer', 'lsa-arrival']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/interval (uint32)

    YANG Description: Interval for receiving LSAs.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: Interval for receiving LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), is_leaf=True, yang_name="interval", parent=self, choice=('timer-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), is_leaf=True, yang_name="interval", parent=self, choice=('timer-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), is_leaf=True, yang_name="interval", parent=self, choice=('timer-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_max_interval(self):
    """
    Getter method for max_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/max_interval (uint32)

    YANG Description: Maximum interval for receiving OSPF LSAs.
    """
    return self.__max_interval
      
  def _set_max_interval(self, v, load=False):
    """
    Setter method for max_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/max_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_interval() directly.

    YANG Description: Maximum interval for receiving OSPF LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__max_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_interval(self):
    self.__max_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_start_interval(self):
    """
    Getter method for start_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/start_interval (uint32)

    YANG Description: Initial interval for receiving OSPF LSAs.
    """
    return self.__start_interval
      
  def _set_start_interval(self, v, load=False):
    """
    Setter method for start_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/start_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_interval() directly.

    YANG Description: Initial interval for receiving OSPF LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__start_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_interval(self):
    self.__start_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_interval(self):
    """
    Getter method for hold_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/hold_interval (uint32)

    YANG Description: Hold interval for receiving OSPF LSAs.
    """
    return self.__hold_interval
      
  def _set_hold_interval(self, v, load=False):
    """
    Setter method for hold_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival/hold_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_interval() directly.

    YANG Description: Hold interval for receiving OSPF LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hold_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_interval(self):
    self.__hold_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  max_interval = __builtin__.property(_get_max_interval, _set_max_interval)
  start_interval = __builtin__.property(_get_start_interval, _set_start_interval)
  hold_interval = __builtin__.property(_get_hold_interval, _set_hold_interval)

  __choices__ = {'timer-type': {'timer': ['interval'], 'intelligent-timer': ['max_interval', 'start_interval', 'hold_interval']}}
  _pyangbind_elements = OrderedDict([('interval', interval), ('max_interval', max_interval), ('start_interval', start_interval), ('hold_interval', hold_interval), ])


class yc_lsa_arr_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arr_supp_flap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/timer/lsa-arr-supp-flap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the delay timer for LSA acceptance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__threshold_count',)

  _yang_name = 'lsa-arr-supp-flap'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__threshold_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'timer', 'lsa-arr-supp-flap']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arr_supp_flap/interval (uint32)

    YANG Description: Specifies an interval for suppressing LSA advertising in case of route flapping. The value 0 indicates that LSA advertising is not suppressed.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arr_supp_flap/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: Specifies an interval for suppressing LSA advertising in case of route flapping. The value 0 indicates that LSA advertising is not suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_threshold_count(self):
    """
    Getter method for threshold_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arr_supp_flap/threshold_count (uint32)

    YANG Description: Value of the threshold of LSAs to be suppressed.
    """
    return self.__threshold_count
      
  def _set_threshold_count(self, v, load=False):
    """
    Setter method for threshold_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arr_supp_flap/threshold_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_count() directly.

    YANG Description: Value of the threshold of LSAs to be suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__threshold_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_count(self):
    self.__threshold_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  threshold_count = __builtin__.property(_get_threshold_count, _set_threshold_count)


  _pyangbind_elements = OrderedDict([('interval', interval), ('threshold_count', threshold_count), ])


class yc_lsa_originate_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_originate(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/timer/lsa-originate. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure interval for receiving LSAs either through an intelligent timer or timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__other_type_interval','__max_interval','__start_interval','__hold_interval',)

  _yang_name = 'lsa-originate'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__other_type_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="other-type-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__max_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__start_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'timer', 'lsa-originate']

  def _get_other_type_interval(self):
    """
    Getter method for other_type_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/other_type_interval (uint32)

    YANG Description: Specify an updating/originating interval for type3, type4 and type10 LSAs. Interval for updating the LSAs except OSPF router LSAs and network LSAs.
    """
    return self.__other_type_interval
      
  def _set_other_type_interval(self, v, load=False):
    """
    Setter method for other_type_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/other_type_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_type_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_type_interval() directly.

    YANG Description: Specify an updating/originating interval for type3, type4 and type10 LSAs. Interval for updating the LSAs except OSPF router LSAs and network LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="other-type-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_type_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="other-type-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__other_type_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_type_interval(self):
    self.__other_type_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="other-type-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_max_interval(self):
    """
    Getter method for max_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/max_interval (uint32)

    YANG Description: Maximum interval for updating OSPF LSAs.
    """
    return self.__max_interval
      
  def _set_max_interval(self, v, load=False):
    """
    Setter method for max_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/max_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_interval() directly.

    YANG Description: Maximum interval for updating OSPF LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__max_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_interval(self):
    self.__max_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_start_interval(self):
    """
    Getter method for start_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/start_interval (uint32)

    YANG Description: Initial interval for updating OSPF LSAs.
    """
    return self.__start_interval
      
  def _set_start_interval(self, v, load=False):
    """
    Setter method for start_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/start_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_interval() directly.

    YANG Description: Initial interval for updating OSPF LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__start_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_interval(self):
    self.__start_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="start-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_interval(self):
    """
    Getter method for hold_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/hold_interval (uint32)

    YANG Description: Hold interval for updating OSPF LSAs.
    """
    return self.__hold_interval
      
  def _set_hold_interval(self, v, load=False):
    """
    Setter method for hold_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate/hold_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_interval() directly.

    YANG Description: Hold interval for updating OSPF LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hold_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_interval(self):
    self.__hold_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="hold-interval", parent=self, choice=('timer-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  other_type_interval = __builtin__.property(_get_other_type_interval, _set_other_type_interval)
  max_interval = __builtin__.property(_get_max_interval, _set_max_interval)
  start_interval = __builtin__.property(_get_start_interval, _set_start_interval)
  hold_interval = __builtin__.property(_get_hold_interval, _set_hold_interval)

  __choices__ = {'timer-type': {'intelligent-timer': ['max_interval', 'start_interval', 'hold_interval']}}
  _pyangbind_elements = OrderedDict([('other_type_interval', other_type_interval), ('max_interval', max_interval), ('start_interval', start_interval), ('hold_interval', hold_interval), ])


class yc_lsa_org_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_org_supp_flap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/timer/lsa-org-supp-flap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the delay timer for LSA generation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__threshold_count',)

  _yang_name = 'lsa-org-supp-flap'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__threshold_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'timer', 'lsa-org-supp-flap']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_org_supp_flap/interval (uint32)

    YANG Description: Specifies an interval for suppressing LSA advertising in case of route flapping. The value 0 indicates that LSA advertising is not suppressed.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_org_supp_flap/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: Specifies an interval for suppressing LSA advertising in case of route flapping. The value 0 indicates that LSA advertising is not suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_threshold_count(self):
    """
    Getter method for threshold_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_org_supp_flap/threshold_count (uint32)

    YANG Description: Value of the threshold of LSAs to be suppressed.
    """
    return self.__threshold_count
      
  def _set_threshold_count(self, v, load=False):
    """
    Setter method for threshold_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_org_supp_flap/threshold_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_count() directly.

    YANG Description: Value of the threshold of LSAs to be suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__threshold_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_count(self):
    self.__threshold_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="threshold-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  threshold_count = __builtin__.property(_get_threshold_count, _set_threshold_count)


  _pyangbind_elements = OrderedDict([('interval', interval), ('threshold_count', threshold_count), ])


class yc_spf_schedule_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_spf_schedule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/timer/spf-schedule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the interval for SPF calculation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interval','__max_interval','__start_interval','__hold_interval','__conserv_flag','__millisecond',)

  _yang_name = 'spf-schedule'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="interval", parent=self, choice=('schedule-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__max_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__start_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="start-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="hold-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__conserv_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conserv-flag", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__millisecond = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), is_leaf=True, yang_name="millisecond", parent=self, choice=('schedule-type', 'millisecond'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'timer', 'spf-schedule']

  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/interval (uint32)

    YANG Description: Interval for OSPF SPF calculation. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidth and router resources caused by frequent network changes.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: Interval for OSPF SPF calculation. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidth and router resources caused by frequent network changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="interval", parent=self, choice=('schedule-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="interval", parent=self, choice=('schedule-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10']}), is_leaf=True, yang_name="interval", parent=self, choice=('schedule-type', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_max_interval(self):
    """
    Getter method for max_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/max_interval (uint32)

    YANG Description: Maximum interval for OSPF SPF calculation set through an intelligent timer. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidths and device resources caused by frequent network changes.
    """
    return self.__max_interval
      
  def _set_max_interval(self, v, load=False):
    """
    Setter method for max_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/max_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_interval() directly.

    YANG Description: Maximum interval for OSPF SPF calculation set through an intelligent timer. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidths and device resources caused by frequent network changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__max_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_interval(self):
    self.__max_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_start_interval(self):
    """
    Getter method for start_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/start_interval (uint32)

    YANG Description: Initial interval for OSPF SPF calculation set through an intelligent timer. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidth and router resources caused by frequent network changes.
    """
    return self.__start_interval
      
  def _set_start_interval(self, v, load=False):
    """
    Setter method for start_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/start_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_interval() directly.

    YANG Description: Initial interval for OSPF SPF calculation set through an intelligent timer. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidth and router resources caused by frequent network changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="start-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="start-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__start_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start_interval(self):
    self.__start_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="start-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_interval(self):
    """
    Getter method for hold_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/hold_interval (uint32)

    YANG Description: Hold interval for OSPF SPF calculation set through an intelligent timer. By adjusting the interval for calculating SPF, you can prevent the occupation of too many bandwidth and router resources caused by frequent network changes.
    """
    return self.__hold_interval
      
  def _set_hold_interval(self, v, load=False):
    """
    Setter method for hold_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/hold_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_interval() directly.

    YANG Description: Hold interval for OSPF SPF calculation set through an intelligent timer. By adjusting the interval for calculating SPF, you can prevent the occupation of too many bandwidth and router resources caused by frequent network changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="hold-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="hold-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hold_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_interval(self):
    self.__hold_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..60000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(200), is_leaf=True, yang_name="hold-interval", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_conserv_flag(self):
    """
    Getter method for conserv_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/conserv_flag (boolean)

    YANG Description: Enable/disable conservative mode.
    """
    return self.__conserv_flag
      
  def _set_conserv_flag(self, v, load=False):
    """
    Setter method for conserv_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/conserv_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conserv_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conserv_flag() directly.

    YANG Description: Enable/disable conservative mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conserv-flag", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conserv_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conserv-flag", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__conserv_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conserv_flag(self):
    self.__conserv_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="conserv-flag", parent=self, choice=('schedule-type', 'intelligent-timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_millisecond(self):
    """
    Getter method for millisecond, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/millisecond (uint32)

    YANG Description: Interval for OSPF SPF calculation. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidths and device resources caused by frequent network changes.
    """
    return self.__millisecond
      
  def _set_millisecond(self, v, load=False):
    """
    Setter method for millisecond, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule/millisecond (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_millisecond is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_millisecond() directly.

    YANG Description: Interval for OSPF SPF calculation. By adjusting the interval for SPF calculation, you can prevent the occupation of too many bandwidths and device resources caused by frequent network changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), is_leaf=True, yang_name="millisecond", parent=self, choice=('schedule-type', 'millisecond'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """millisecond must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), is_leaf=True, yang_name="millisecond", parent=self, choice=('schedule-type', 'millisecond'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__millisecond = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_millisecond(self):
    self.__millisecond = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..10000']}), is_leaf=True, yang_name="millisecond", parent=self, choice=('schedule-type', 'millisecond'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  interval = __builtin__.property(_get_interval, _set_interval)
  max_interval = __builtin__.property(_get_max_interval, _set_max_interval)
  start_interval = __builtin__.property(_get_start_interval, _set_start_interval)
  hold_interval = __builtin__.property(_get_hold_interval, _set_hold_interval)
  conserv_flag = __builtin__.property(_get_conserv_flag, _set_conserv_flag)
  millisecond = __builtin__.property(_get_millisecond, _set_millisecond)

  __choices__ = {'schedule-type': {'timer': ['interval'], 'intelligent-timer': ['max_interval', 'start_interval', 'hold_interval', 'conserv_flag'], 'millisecond': ['millisecond']}}
  _pyangbind_elements = OrderedDict([('interval', interval), ('max_interval', max_interval), ('start_interval', start_interval), ('hold_interval', hold_interval), ('conserv_flag', conserv_flag), ('millisecond', millisecond), ])


class yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/timer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lsa_arrival','__lsa_arr_supp_flap','__lsa_originate','__lsa_org_supp_flap','__spf_schedule',)

  _yang_name = 'timer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lsa_arrival = YANGDynClass(base=yc_lsa_arrival_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arrival, is_container='container', yang_name="lsa-arrival", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__lsa_arr_supp_flap = YANGDynClass(base=yc_lsa_arr_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arr_supp_flap, is_container='container', yang_name="lsa-arr-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__lsa_originate = YANGDynClass(base=yc_lsa_originate_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_originate, is_container='container', yang_name="lsa-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__lsa_org_supp_flap = YANGDynClass(base=yc_lsa_org_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_org_supp_flap, is_container='container', yang_name="lsa-org-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__spf_schedule = YANGDynClass(base=yc_spf_schedule_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_spf_schedule, is_container='container', yang_name="spf-schedule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'timer']

  def _get_lsa_arrival(self):
    """
    Getter method for lsa_arrival, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival (container)

    YANG Description: Configure interval for receiving LSAs either through an intelligent timer or timer.
    """
    return self.__lsa_arrival
      
  def _set_lsa_arrival(self, v, load=False):
    """
    Setter method for lsa_arrival, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arrival (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_arrival is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_arrival() directly.

    YANG Description: Configure interval for receiving LSAs either through an intelligent timer or timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsa_arrival_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arrival, is_container='container', yang_name="lsa-arrival", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_arrival must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsa_arrival_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arrival, is_container='container', yang_name="lsa-arrival", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__lsa_arrival = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_arrival(self):
    self.__lsa_arrival = YANGDynClass(base=yc_lsa_arrival_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arrival, is_container='container', yang_name="lsa-arrival", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_lsa_arr_supp_flap(self):
    """
    Getter method for lsa_arr_supp_flap, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arr_supp_flap (container)

    YANG Description: Configure the delay timer for LSA acceptance.
    """
    return self.__lsa_arr_supp_flap
      
  def _set_lsa_arr_supp_flap(self, v, load=False):
    """
    Setter method for lsa_arr_supp_flap, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_arr_supp_flap (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_arr_supp_flap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_arr_supp_flap() directly.

    YANG Description: Configure the delay timer for LSA acceptance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsa_arr_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arr_supp_flap, is_container='container', yang_name="lsa-arr-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_arr_supp_flap must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsa_arr_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arr_supp_flap, is_container='container', yang_name="lsa-arr-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__lsa_arr_supp_flap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_arr_supp_flap(self):
    self.__lsa_arr_supp_flap = YANGDynClass(base=yc_lsa_arr_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arr_supp_flap, is_container='container', yang_name="lsa-arr-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_lsa_originate(self):
    """
    Getter method for lsa_originate, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate (container)

    YANG Description: Configure interval for receiving LSAs either through an intelligent timer or timer.
    """
    return self.__lsa_originate
      
  def _set_lsa_originate(self, v, load=False):
    """
    Setter method for lsa_originate, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_originate (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_originate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_originate() directly.

    YANG Description: Configure interval for receiving LSAs either through an intelligent timer or timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsa_originate_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_originate, is_container='container', yang_name="lsa-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_originate must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsa_originate_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_originate, is_container='container', yang_name="lsa-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__lsa_originate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_originate(self):
    self.__lsa_originate = YANGDynClass(base=yc_lsa_originate_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_originate, is_container='container', yang_name="lsa-originate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_lsa_org_supp_flap(self):
    """
    Getter method for lsa_org_supp_flap, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_org_supp_flap (container)

    YANG Description: Configure the delay timer for LSA generation.
    """
    return self.__lsa_org_supp_flap
      
  def _set_lsa_org_supp_flap(self, v, load=False):
    """
    Setter method for lsa_org_supp_flap, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/lsa_org_supp_flap (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_org_supp_flap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_org_supp_flap() directly.

    YANG Description: Configure the delay timer for LSA generation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsa_org_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_org_supp_flap, is_container='container', yang_name="lsa-org-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_org_supp_flap must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsa_org_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_org_supp_flap, is_container='container', yang_name="lsa-org-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__lsa_org_supp_flap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_org_supp_flap(self):
    self.__lsa_org_supp_flap = YANGDynClass(base=yc_lsa_org_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_org_supp_flap, is_container='container', yang_name="lsa-org-supp-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_spf_schedule(self):
    """
    Getter method for spf_schedule, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule (container)

    YANG Description: Configure the interval for SPF calculation.
    """
    return self.__spf_schedule
      
  def _set_spf_schedule(self, v, load=False):
    """
    Setter method for spf_schedule, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer/spf_schedule (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_schedule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_schedule() directly.

    YANG Description: Configure the interval for SPF calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_spf_schedule_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_spf_schedule, is_container='container', yang_name="spf-schedule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_schedule must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_spf_schedule_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_spf_schedule, is_container='container', yang_name="spf-schedule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__spf_schedule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_schedule(self):
    self.__spf_schedule = YANGDynClass(base=yc_spf_schedule_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_spf_schedule, is_container='container', yang_name="spf-schedule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  lsa_arrival = __builtin__.property(_get_lsa_arrival, _set_lsa_arrival) # type: yc_lsa_arrival_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arrival
  lsa_arr_supp_flap = __builtin__.property(_get_lsa_arr_supp_flap, _set_lsa_arr_supp_flap) # type: yc_lsa_arr_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_arr_supp_flap
  lsa_originate = __builtin__.property(_get_lsa_originate, _set_lsa_originate) # type: yc_lsa_originate_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_originate
  lsa_org_supp_flap = __builtin__.property(_get_lsa_org_supp_flap, _set_lsa_org_supp_flap) # type: yc_lsa_org_supp_flap_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_lsa_org_supp_flap
  spf_schedule = __builtin__.property(_get_spf_schedule, _set_spf_schedule) # type: yc_spf_schedule_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer_spf_schedule


  _pyangbind_elements = OrderedDict([('lsa_arrival', lsa_arrival), ('lsa_arr_supp_flap', lsa_arr_supp_flap), ('lsa_originate', lsa_originate), ('lsa_org_supp_flap', lsa_org_supp_flap), ('spf_schedule', spf_schedule), ])


class yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD in a OSPF process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__min_rx','__min_tx','__detect_multiplier','__incr_cost','__frr_binding',)

  _yang_name = 'bfd'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__min_rx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__min_tx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__detect_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__incr_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__frr_binding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'bfd']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/enable (boolean)

    YANG Description: Enable/disable BFD in an OSPF process.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable BFD in an OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_min_rx(self):
    """
    Getter method for min_rx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/min_rx (uint32)

    YANG Description: Minimum interval for receiving BFD packets from the peer end. The range and default are based on PAF.
    """
    return self.__min_rx
      
  def _set_min_rx(self, v, load=False):
    """
    Setter method for min_rx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/min_rx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_rx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_rx() directly.

    YANG Description: Minimum interval for receiving BFD packets from the peer end. The range and default are based on PAF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_rx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__min_rx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_rx(self):
    self.__min_rx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_min_tx(self):
    """
    Getter method for min_tx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/min_tx (uint32)

    YANG Description: Minimum interval for sending BFD packets to the peer end. The range and default are based on PAF.
    """
    return self.__min_tx
      
  def _set_min_tx(self, v, load=False):
    """
    Setter method for min_tx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/min_tx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_tx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_tx() directly.

    YANG Description: Minimum interval for sending BFD packets to the peer end. The range and default are based on PAF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_tx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__min_tx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_tx(self):
    self.__min_tx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_detect_multiplier(self):
    """
    Getter method for detect_multiplier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/detect_multiplier (uint32)

    YANG Description: Local detection multiplier.
    """
    return self.__detect_multiplier
      
  def _set_detect_multiplier(self, v, load=False):
    """
    Setter method for detect_multiplier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/detect_multiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detect_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detect_multiplier() directly.

    YANG Description: Local detection multiplier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detect_multiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__detect_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detect_multiplier(self):
    self.__detect_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_incr_cost(self):
    """
    Getter method for incr_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/incr_cost (uint32)

    YANG Description: BFD sync cost.
    """
    return self.__incr_cost
      
  def _set_incr_cost(self, v, load=False):
    """
    Setter method for incr_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/incr_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_incr_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_incr_cost() directly.

    YANG Description: BFD sync cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """incr_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__incr_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_incr_cost(self):
    self.__incr_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_frr_binding(self):
    """
    Getter method for frr_binding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/frr_binding (boolean)

    YANG Description: Enable/disable bind FRR with BFD.
    """
    return self.__frr_binding
      
  def _set_frr_binding(self, v, load=False):
    """
    Setter method for frr_binding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd/frr_binding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_binding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_binding() directly.

    YANG Description: Enable/disable bind FRR with BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_binding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__frr_binding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_binding(self):
    self.__frr_binding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  min_rx = __builtin__.property(_get_min_rx, _set_min_rx)
  min_tx = __builtin__.property(_get_min_tx, _set_min_tx)
  detect_multiplier = __builtin__.property(_get_detect_multiplier, _set_detect_multiplier)
  incr_cost = __builtin__.property(_get_incr_cost, _set_incr_cost)
  frr_binding = __builtin__.property(_get_frr_binding, _set_frr_binding)


  _pyangbind_elements = OrderedDict([('enable', enable), ('min_rx', min_rx), ('min_tx', min_tx), ('detect_multiplier', detect_multiplier), ('incr_cost', incr_cost), ('frr_binding', frr_binding), ])


class yc_metric_delay_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_metric_delay(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/metric-delay. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure metric delay in a OSPF process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adv_enable','__suppress_timer','__suppress_percent','__suppress_absolute',)

  _yang_name = 'metric-delay'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adv_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adv-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__suppress_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="suppress-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__suppress_percent = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="suppress-percent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    self.__suppress_absolute = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="suppress-absolute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'metric-delay']

  def _get_adv_enable(self):
    """
    Getter method for adv_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/adv_enable (boolean)

    YANG Description: Enable/disable metric delay advertisement.
    """
    return self.__adv_enable
      
  def _set_adv_enable(self, v, load=False):
    """
    Setter method for adv_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/adv_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adv_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adv_enable() directly.

    YANG Description: Enable/disable metric delay advertisement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adv-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adv_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adv-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__adv_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adv_enable(self):
    self.__adv_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="adv-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_suppress_timer(self):
    """
    Getter method for suppress_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/suppress_timer (uint32)

    YANG Description: Metric delay suppress timer.
    """
    return self.__suppress_timer
      
  def _set_suppress_timer(self, v, load=False):
    """
    Setter method for suppress_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/suppress_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_timer() directly.

    YANG Description: Metric delay suppress timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="suppress-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="suppress-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__suppress_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_timer(self):
    self.__suppress_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="suppress-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_suppress_percent(self):
    """
    Getter method for suppress_percent, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/suppress_percent (uint8)

    YANG Description: Metric delay suppress percent threshold.
    """
    return self.__suppress_percent
      
  def _set_suppress_percent(self, v, load=False):
    """
    Setter method for suppress_percent, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/suppress_percent (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_percent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_percent() directly.

    YANG Description: Metric delay suppress percent threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="suppress-percent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_percent must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="suppress-percent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)""",
        })

    self.__suppress_percent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_percent(self):
    self.__suppress_percent = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="suppress-percent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)


  def _get_suppress_absolute(self):
    """
    Getter method for suppress_absolute, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/suppress_absolute (uint32)

    YANG Description: Metric delay suppress absolute threshold.
    """
    return self.__suppress_absolute
      
  def _set_suppress_absolute(self, v, load=False):
    """
    Setter method for suppress_absolute, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay/suppress_absolute (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_absolute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_absolute() directly.

    YANG Description: Metric delay suppress absolute threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="suppress-absolute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_absolute must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="suppress-absolute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__suppress_absolute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_absolute(self):
    self.__suppress_absolute = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="suppress-absolute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  adv_enable = __builtin__.property(_get_adv_enable, _set_adv_enable)
  suppress_timer = __builtin__.property(_get_suppress_timer, _set_suppress_timer)
  suppress_percent = __builtin__.property(_get_suppress_percent, _set_suppress_percent)
  suppress_absolute = __builtin__.property(_get_suppress_absolute, _set_suppress_absolute)


  _pyangbind_elements = OrderedDict([('adv_enable', adv_enable), ('suppress_timer', suppress_timer), ('suppress_percent', suppress_percent), ('suppress_absolute', suppress_absolute), ])


class yc_bier_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/bier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the bier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable',)

  _yang_name = 'bier'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'bier']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bier/enable (boolean)

    YANG Description: Enable/disable the bier.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bier/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable the bier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)


  _pyangbind_elements = OrderedDict([('enable', enable), ])


class yc_stub_router_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_stub_router(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/stub-router. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure stub router is used to configure the router as stub router.
  """
  __slots__ = ('_path_helper', '_extmethods', '__flag','__interval','__include_stub','__external_lsa','__external_cost','__summary_lsa','__summary_cost',)

  _yang_name = 'stub-router'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'no-config': {'value': 0}, 'stub-on-hand': {'value': 1}, 'stub-on-boot': {'value': 2}},), default=six.text_type("no-config"), is_leaf=True, yang_name="flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='stub-router-flag', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__include_stub = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__external_lsa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="external-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__external_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="external-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__summary_lsa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summary-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__summary_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="summary-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'stub-router']

  def _get_flag(self):
    """
    Getter method for flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/flag (stub-router-flag)

    YANG Description: Stub router. The router configured with the stub router command notifies other OSPF routers of not using the stub router to forward data by increasing the metric greater than 65535 of the links in the LSA that is generated by the router.
    """
    return self.__flag
      
  def _set_flag(self, v, load=False):
    """
    Setter method for flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/flag (stub-router-flag)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flag() directly.

    YANG Description: Stub router. The router configured with the stub router command notifies other OSPF routers of not using the stub router to forward data by increasing the metric greater than 65535 of the links in the LSA that is generated by the router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'no-config': {'value': 0}, 'stub-on-hand': {'value': 1}, 'stub-on-boot': {'value': 2}},), default=six.text_type("no-config"), is_leaf=True, yang_name="flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='stub-router-flag', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flag must be of a type compatible with stub-router-flag""",
          'defined-type': "huawei-ospfv2:stub-router-flag",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'no-config': {'value': 0}, 'stub-on-hand': {'value': 1}, 'stub-on-boot': {'value': 2}},), default=six.text_type("no-config"), is_leaf=True, yang_name="flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='stub-router-flag', is_config=True)""",
        })

    self.__flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flag(self):
    self.__flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'no-config': {'value': 0}, 'stub-on-hand': {'value': 1}, 'stub-on-boot': {'value': 2}},), default=six.text_type("no-config"), is_leaf=True, yang_name="flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='stub-router-flag', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/interval (uint32)

    YANG Description: Interval for remaining as the stub router during the active/standby switchover of a router.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: Interval for remaining as the stub router during the active/standby switchover of a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['5..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(500), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_include_stub(self):
    """
    Getter method for include_stub, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/include_stub (boolean)

    YANG Description: Enable/disable set maximum cost for router lsa stub link.
    """
    return self.__include_stub
      
  def _set_include_stub(self, v, load=False):
    """
    Setter method for include_stub, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/include_stub (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_stub is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_stub() directly.

    YANG Description: Enable/disable set maximum cost for router lsa stub link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_stub must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__include_stub = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_stub(self):
    self.__include_stub = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_external_lsa(self):
    """
    Getter method for external_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/external_lsa (boolean)

    YANG Description: Enable/disable set maximum cost for external lsa.
    """
    return self.__external_lsa
      
  def _set_external_lsa(self, v, load=False):
    """
    Setter method for external_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/external_lsa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_lsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_lsa() directly.

    YANG Description: Enable/disable set maximum cost for external lsa.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="external-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_lsa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="external-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__external_lsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_lsa(self):
    self.__external_lsa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="external-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_external_cost(self):
    """
    Getter method for external_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/external_cost (uint32)

    YANG Description: Advertise external LSAs with configured/default overriding metric.
    """
    return self.__external_cost
      
  def _set_external_cost(self, v, load=False):
    """
    Setter method for external_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/external_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_cost() directly.

    YANG Description: Advertise external LSAs with configured/default overriding metric.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="external-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="external-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__external_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_cost(self):
    self.__external_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="external-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_summary_lsa(self):
    """
    Getter method for summary_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/summary_lsa (boolean)

    YANG Description: Enable/disable set maximum cost for summary lsa.
    """
    return self.__summary_lsa
      
  def _set_summary_lsa(self, v, load=False):
    """
    Setter method for summary_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/summary_lsa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary_lsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary_lsa() directly.

    YANG Description: Enable/disable set maximum cost for summary lsa.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summary-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary_lsa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summary-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__summary_lsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary_lsa(self):
    self.__summary_lsa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="summary-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_summary_cost(self):
    """
    Getter method for summary_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/summary_cost (uint32)

    YANG Description: Advertise summary LSAs with configured/default overriding metric.
    """
    return self.__summary_cost
      
  def _set_summary_cost(self, v, load=False):
    """
    Setter method for summary_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router/summary_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary_cost() directly.

    YANG Description: Advertise summary LSAs with configured/default overriding metric.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="summary-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="summary-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__summary_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary_cost(self):
    self.__summary_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..16777215']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16711680), is_leaf=True, yang_name="summary-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  flag = __builtin__.property(_get_flag, _set_flag)
  interval = __builtin__.property(_get_interval, _set_interval)
  include_stub = __builtin__.property(_get_include_stub, _set_include_stub)
  external_lsa = __builtin__.property(_get_external_lsa, _set_external_lsa)
  external_cost = __builtin__.property(_get_external_cost, _set_external_cost)
  summary_lsa = __builtin__.property(_get_summary_lsa, _set_summary_lsa)
  summary_cost = __builtin__.property(_get_summary_cost, _set_summary_cost)


  _pyangbind_elements = OrderedDict([('flag', flag), ('interval', interval), ('include_stub', include_stub), ('external_lsa', external_lsa), ('external_cost', external_cost), ('summary_lsa', summary_lsa), ('summary_cost', summary_cost), ])


class yc_bgp_ls_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bgp_ls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/bgp-ls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BGP LS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__identifier',)

  _yang_name = 'bgp-ls'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'bgp-ls']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bgp_ls/enable (boolean)

    YANG Description: Enable/disable BGP LS.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bgp_ls/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable BGP LS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bgp_ls/identifier (uint32)

    YANG Description: Topo identifier.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bgp_ls/identifier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: Topo identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..65535']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  identifier = __builtin__.property(_get_identifier, _set_identifier)


  _pyangbind_elements = OrderedDict([('enable', enable), ('identifier', identifier), ])


class yc_import_limit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/import-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure limits the maximum number of routes to be imported.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_number','__threshold_upper','__threshold_lower',)

  _yang_name = 'import-limit'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="max-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__threshold_upper = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(80), is_leaf=True, yang_name="threshold-upper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__threshold_lower = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(70), is_leaf=True, yang_name="threshold-lower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'import-limit']

  def _get_max_number(self):
    """
    Getter method for max_number, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit/max_number (uint32)

    YANG Description: Maximum number of external routes that can be imported.
    """
    return self.__max_number
      
  def _set_max_number(self, v, load=False):
    """
    Setter method for max_number, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit/max_number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_number() directly.

    YANG Description: Maximum number of external routes that can be imported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="max-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_number must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="max-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__max_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_number(self):
    self.__max_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="max-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_threshold_upper(self):
    """
    Getter method for threshold_upper, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit/threshold_upper (uint32)

    YANG Description: Upper threshold of the maximum number of routes that can be imported.
    """
    return self.__threshold_upper
      
  def _set_threshold_upper(self, v, load=False):
    """
    Setter method for threshold_upper, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit/threshold_upper (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_upper is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_upper() directly.

    YANG Description: Upper threshold of the maximum number of routes that can be imported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(80), is_leaf=True, yang_name="threshold-upper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_upper must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(80), is_leaf=True, yang_name="threshold-upper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__threshold_upper = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_upper(self):
    self.__threshold_upper = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(80), is_leaf=True, yang_name="threshold-upper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_threshold_lower(self):
    """
    Getter method for threshold_lower, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit/threshold_lower (uint32)

    YANG Description: Lower threshold of the maximum number of routes that can be imported.
    """
    return self.__threshold_lower
      
  def _set_threshold_lower(self, v, load=False):
    """
    Setter method for threshold_lower, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit/threshold_lower (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_lower is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_lower() directly.

    YANG Description: Lower threshold of the maximum number of routes that can be imported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(70), is_leaf=True, yang_name="threshold-lower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold_lower must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(70), is_leaf=True, yang_name="threshold-lower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__threshold_lower = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold_lower(self):
    self.__threshold_lower = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(70), is_leaf=True, yang_name="threshold-lower", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  max_number = __builtin__.property(_get_max_number, _set_max_number)
  threshold_upper = __builtin__.property(_get_threshold_upper, _set_threshold_upper)
  threshold_lower = __builtin__.property(_get_threshold_lower, _set_threshold_lower)


  _pyangbind_elements = OrderedDict([('max_number', max_number), ('threshold_upper', threshold_upper), ('threshold_lower', threshold_lower), ])


class yc_spf_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_spf_control(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/spf-control. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure SPF calculation control.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_load_balancing',)

  _yang_name = 'spf-control'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_load_balancing = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(128), is_leaf=True, yang_name="max-load-balancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'spf-control']

  def _get_max_load_balancing(self):
    """
    Getter method for max_load_balancing, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/spf_control/max_load_balancing (uint32)

    YANG Description: Maximum number of the equal cost routes of the destination address in the routing table. The range and default are based on PAF.
    """
    return self.__max_load_balancing
      
  def _set_max_load_balancing(self, v, load=False):
    """
    Setter method for max_load_balancing, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/spf_control/max_load_balancing (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_load_balancing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_load_balancing() directly.

    YANG Description: Maximum number of the equal cost routes of the destination address in the routing table. The range and default are based on PAF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(128), is_leaf=True, yang_name="max-load-balancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_load_balancing must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(128), is_leaf=True, yang_name="max-load-balancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__max_load_balancing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_load_balancing(self):
    self.__max_load_balancing = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(128), is_leaf=True, yang_name="max-load-balancing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  max_load_balancing = __builtin__.property(_get_max_load_balancing, _set_max_load_balancing)


  _pyangbind_elements = OrderedDict([('max_load_balancing', max_load_balancing), ])


class yc_default_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_default_para(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/default-para. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure default parameter.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cost_value','__cost_inherit_metric','__tag','__type',)

  _yang_name = 'default-para'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cost_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__cost_inherit_metric = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cost-inherit-metric", parent=self, choice=('cost', 'cost-inherit-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), default=six.text_type("type2"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'default-para']

  def _get_cost_value(self):
    """
    Getter method for cost_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/cost_value (uint32)

    YANG Description: Default metric of the external routes imported by OSPF.
    """
    return self.__cost_value
      
  def _set_cost_value(self, v, load=False):
    """
    Setter method for cost_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/cost_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost_value() directly.

    YANG Description: Default metric of the external routes imported by OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost_value(self):
    self.__cost_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_cost_inherit_metric(self):
    """
    Getter method for cost_inherit_metric, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/cost_inherit_metric (empty)

    YANG Description: Cost of the imported route is the cost carried in the route. If the cost is not specified, the default cost can be set through the default command.
    """
    return self.__cost_inherit_metric
      
  def _set_cost_inherit_metric(self, v, load=False):
    """
    Setter method for cost_inherit_metric, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/cost_inherit_metric (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost_inherit_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost_inherit_metric() directly.

    YANG Description: Cost of the imported route is the cost carried in the route. If the cost is not specified, the default cost can be set through the default command.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cost-inherit-metric", parent=self, choice=('cost', 'cost-inherit-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost_inherit_metric must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cost-inherit-metric", parent=self, choice=('cost', 'cost-inherit-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__cost_inherit_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost_inherit_metric(self):
    self.__cost_inherit_metric = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cost-inherit-metric", parent=self, choice=('cost', 'cost-inherit-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/tag (uint32)

    YANG Description: Tag of an external route.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Tag of an external route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/type (external-route-type)

    YANG Description: Type of an external route.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para/type (external-route-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of an external route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), default=six.text_type("type2"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with external-route-type""",
          'defined-type': "huawei-ospfv2:external-route-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), default=six.text_type("type2"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), default=six.text_type("type2"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)

  cost_value = __builtin__.property(_get_cost_value, _set_cost_value)
  cost_inherit_metric = __builtin__.property(_get_cost_inherit_metric, _set_cost_inherit_metric)
  tag = __builtin__.property(_get_tag, _set_tag)
  type = __builtin__.property(_get_type, _set_type)

  __choices__ = {'cost': {'cost-value': ['cost_value'], 'cost-inherit-metric': ['cost_inherit_metric']}}
  _pyangbind_elements = OrderedDict([('cost_value', cost_value), ('cost_inherit_metric', cost_inherit_metric), ('tag', tag), ('type', type), ])


class yc_avoid_micro_loop_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_avoid_micro_loop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/avoid-micro-loop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF avoid microloop.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frr_enable','__frr_rib_update_delay','__te_tunnel_enable','__te_tunnel_rib_update_delay',)

  _yang_name = 'avoid-micro-loop'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frr_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__frr_rib_update_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="frr-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__te_tunnel_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__te_tunnel_rib_update_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="te-tunnel-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'avoid-micro-loop']

  def _get_frr_enable(self):
    """
    Getter method for frr_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/frr_enable (boolean)

    YANG Description: Enable/disable avoid microloop.
    """
    return self.__frr_enable
      
  def _set_frr_enable(self, v, load=False):
    """
    Setter method for frr_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/frr_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_enable() directly.

    YANG Description: Enable/disable avoid microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__frr_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_enable(self):
    self.__frr_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_frr_rib_update_delay(self):
    """
    Getter method for frr_rib_update_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/frr_rib_update_delay (uint32)

    YANG Description: Set the maximum interval of delay timer.
    """
    return self.__frr_rib_update_delay
      
  def _set_frr_rib_update_delay(self, v, load=False):
    """
    Setter method for frr_rib_update_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/frr_rib_update_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_rib_update_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_rib_update_delay() directly.

    YANG Description: Set the maximum interval of delay timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="frr-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_rib_update_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="frr-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__frr_rib_update_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_rib_update_delay(self):
    self.__frr_rib_update_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..5000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="frr-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_te_tunnel_enable(self):
    """
    Getter method for te_tunnel_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/te_tunnel_enable (boolean)

    YANG Description: Enable/disable TE shortcut tunnel avoid microloop.
    """
    return self.__te_tunnel_enable
      
  def _set_te_tunnel_enable(self, v, load=False):
    """
    Setter method for te_tunnel_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/te_tunnel_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_te_tunnel_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_te_tunnel_enable() directly.

    YANG Description: Enable/disable TE shortcut tunnel avoid microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """te_tunnel_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__te_tunnel_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_te_tunnel_enable(self):
    self.__te_tunnel_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_te_tunnel_rib_update_delay(self):
    """
    Getter method for te_tunnel_rib_update_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/te_tunnel_rib_update_delay (uint32)

    YANG Description: Set the route delivery delay for TE shortcut tunnel.
    """
    return self.__te_tunnel_rib_update_delay
      
  def _set_te_tunnel_rib_update_delay(self, v, load=False):
    """
    Setter method for te_tunnel_rib_update_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop/te_tunnel_rib_update_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_te_tunnel_rib_update_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_te_tunnel_rib_update_delay() directly.

    YANG Description: Set the route delivery delay for TE shortcut tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="te-tunnel-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """te_tunnel_rib_update_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="te-tunnel-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__te_tunnel_rib_update_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_te_tunnel_rib_update_delay(self):
    self.__te_tunnel_rib_update_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..30000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000), is_leaf=True, yang_name="te-tunnel-rib-update-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  frr_enable = __builtin__.property(_get_frr_enable, _set_frr_enable)
  frr_rib_update_delay = __builtin__.property(_get_frr_rib_update_delay, _set_frr_rib_update_delay)
  te_tunnel_enable = __builtin__.property(_get_te_tunnel_enable, _set_te_tunnel_enable)
  te_tunnel_rib_update_delay = __builtin__.property(_get_te_tunnel_rib_update_delay, _set_te_tunnel_rib_update_delay)


  _pyangbind_elements = OrderedDict([('frr_enable', frr_enable), ('frr_rib_update_delay', frr_rib_update_delay), ('te_tunnel_enable', te_tunnel_enable), ('te_tunnel_rib_update_delay', te_tunnel_rib_update_delay), ])


class yc_asbr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs_asbr_summary_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/asbr-summary-prefixs/asbr-summary-prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure aggregate addresses for OSPF (only for ASBR).
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__network_mask','__cost','__distribute_delay','__tag','__advertise','__generate_null_zero',)

  _yang_name = 'asbr-summary-prefix'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__network_mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__distribute_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__advertise = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__generate_null_zero = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'asbr-summary-prefixs', 'asbr-summary-prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/prefix (inet:ipv4-address-no-zone)

    YANG Description: IP address. Prefix is the address after mask.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/prefix (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IP address. Prefix is the address after mask.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_network_mask(self):
    """
    Getter method for network_mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/network_mask (inet:ipv4-address-no-zone)

    YANG Description: IP address mask.
    """
    return self.__network_mask
      
  def _set_network_mask(self, v, load=False):
    """
    Setter method for network_mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/network_mask (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_mask() directly.

    YANG Description: IP address mask.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_mask must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__network_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_mask(self):
    self.__network_mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/cost (uint32)

    YANG Description: Specifies the cost of the aggregated route.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Specifies the cost of the aggregated route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_distribute_delay(self):
    """
    Getter method for distribute_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/distribute_delay (uint32)

    YANG Description: Distribute delay interval.
    """
    return self.__distribute_delay
      
  def _set_distribute_delay(self, v, load=False):
    """
    Setter method for distribute_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/distribute_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distribute_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distribute_delay() directly.

    YANG Description: Distribute delay interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distribute_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__distribute_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distribute_delay(self):
    self.__distribute_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/tag (uint32)

    YANG Description: Specifies that the tag is mainly used to control advertisement of routes through the routing policy.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Specifies that the tag is mainly used to control advertisement of routes through the routing policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_advertise(self):
    """
    Getter method for advertise, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/advertise (boolean)

    YANG Description: Enable/disable the aggregated route is advertised.
    """
    return self.__advertise
      
  def _set_advertise(self, v, load=False):
    """
    Setter method for advertise, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/advertise (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise() directly.

    YANG Description: Enable/disable the aggregated route is advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__advertise = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise(self):
    self.__advertise = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_generate_null_zero(self):
    """
    Getter method for generate_null_zero, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/generate_null_zero (boolean)

    YANG Description: Enable/disable generate black hole route.
    """
    return self.__generate_null_zero
      
  def _set_generate_null_zero(self, v, load=False):
    """
    Setter method for generate_null_zero, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix/generate_null_zero (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_generate_null_zero is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_generate_null_zero() directly.

    YANG Description: Enable/disable generate black hole route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """generate_null_zero must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__generate_null_zero = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_generate_null_zero(self):
    self.__generate_null_zero = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  network_mask = __builtin__.property(_get_network_mask, _set_network_mask)
  cost = __builtin__.property(_get_cost, _set_cost)
  distribute_delay = __builtin__.property(_get_distribute_delay, _set_distribute_delay)
  tag = __builtin__.property(_get_tag, _set_tag)
  advertise = __builtin__.property(_get_advertise, _set_advertise)
  generate_null_zero = __builtin__.property(_get_generate_null_zero, _set_generate_null_zero)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('network_mask', network_mask), ('cost', cost), ('distribute_delay', distribute_delay), ('tag', tag), ('advertise', advertise), ('generate_null_zero', generate_null_zero), ])


class yc_asbr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/asbr-summary-prefixs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of aggregate addresses for OSPF (only for ASBR).
  """
  __slots__ = ('_path_helper', '_extmethods', '__asbr_summary_prefix',)

  _yang_name = 'asbr-summary-prefixs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__asbr_summary_prefix = YANGDynClass(base=YANGListType("prefix network_mask",yc_asbr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs_asbr_summary_prefix, yang_name="asbr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="asbr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'asbr-summary-prefixs']

  def _get_asbr_summary_prefix(self):
    """
    Getter method for asbr_summary_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix (list)

    YANG Description: Configure aggregate addresses for OSPF (only for ASBR).
    """
    return self.__asbr_summary_prefix
      
  def _set_asbr_summary_prefix(self, v, load=False):
    """
    Setter method for asbr_summary_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs/asbr_summary_prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asbr_summary_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asbr_summary_prefix() directly.

    YANG Description: Configure aggregate addresses for OSPF (only for ASBR).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix network_mask",yc_asbr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs_asbr_summary_prefix, yang_name="asbr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="asbr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asbr_summary_prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix network_mask",yc_asbr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs_asbr_summary_prefix, yang_name="asbr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="asbr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__asbr_summary_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asbr_summary_prefix(self):
    self.__asbr_summary_prefix = YANGDynClass(base=YANGListType("prefix network_mask",yc_asbr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs_asbr_summary_prefix, yang_name="asbr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="asbr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  asbr_summary_prefix = __builtin__.property(_get_asbr_summary_prefix, _set_asbr_summary_prefix) # type: yc_asbr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs_asbr_summary_prefix


  _pyangbind_elements = OrderedDict([('asbr_summary_prefix', asbr_summary_prefix), ])


class yc_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure advertises the type3 summary LSAs of the specified default route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cost',)

  _yang_name = 'summary'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'summary']

  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/summary/cost (uint32)

    YANG Description: Metric of an ASE LSA.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/summary/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Metric of an ASE LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  cost = __builtin__.property(_get_cost, _set_cost)

  __choices__ = {'default-route': {'summary': ['cost']}}
  _pyangbind_elements = OrderedDict([('cost', cost), ])


class yc_no_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_no_summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/no-summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure default routes to the OSPF routing area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__cost','__tag','__type','__distribute_delay','__permit_calculate_other','__permit_ibgp','__always','__route_policy_name','__route_filter_name',)

  _yang_name = 'no-summary'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)
    self.__distribute_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__permit_calculate_other = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="permit-calculate-other", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__permit_ibgp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="permit-ibgp", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__always = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="always", parent=self, choice=('mode', 'always'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'no-summary']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/enable (empty)

    YANG Description: Default Route Enable. The node enable is deprecated. You are advised to use the node no-summary.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/enable (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Default Route Enable. The node enable is deprecated. You are advised to use the node no-summary.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/cost (uint32)

    YANG Description: Metric of an ASE LSA.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Metric of an ASE LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/tag (uint32)

    YANG Description: Route tag for default imported routes.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Route tag for default imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/type (external-route-type)

    YANG Description: Metric type of an ASE LSA for the default routes.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/type (external-route-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Metric type of an ASE LSA for the default routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with external-route-type""",
          'defined-type': "huawei-ospfv2:external-route-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)


  def _get_distribute_delay(self):
    """
    Getter method for distribute_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/distribute_delay (uint32)

    YANG Description: Distribute delay timer used for the local router to calculate the default routes advertised by other routers.
    """
    return self.__distribute_delay
      
  def _set_distribute_delay(self, v, load=False):
    """
    Setter method for distribute_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/distribute_delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distribute_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distribute_delay() directly.

    YANG Description: Distribute delay timer used for the local router to calculate the default routes advertised by other routers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distribute_delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__distribute_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distribute_delay(self):
    self.__distribute_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="distribute-delay", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_permit_calculate_other(self):
    """
    Getter method for permit_calculate_other, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/permit_calculate_other (empty)

    YANG Description: To generate and advertise an ASE LSA that describes the default route only when there are valid default routes of other protocols in the routing table of the host. The router configured with permit calculate other still calculates the default routes of other routers.
    """
    return self.__permit_calculate_other
      
  def _set_permit_calculate_other(self, v, load=False):
    """
    Setter method for permit_calculate_other, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/permit_calculate_other (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_permit_calculate_other is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_permit_calculate_other() directly.

    YANG Description: To generate and advertise an ASE LSA that describes the default route only when there are valid default routes of other protocols in the routing table of the host. The router configured with permit calculate other still calculates the default routes of other routers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="permit-calculate-other", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """permit_calculate_other must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="permit-calculate-other", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__permit_calculate_other = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_permit_calculate_other(self):
    self.__permit_calculate_other = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="permit-calculate-other", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_permit_ibgp(self):
    """
    Getter method for permit_ibgp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/permit_ibgp (empty)

    YANG Description: Match IBGP default route.
    """
    return self.__permit_ibgp
      
  def _set_permit_ibgp(self, v, load=False):
    """
    Setter method for permit_ibgp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/permit_ibgp (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_permit_ibgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_permit_ibgp() directly.

    YANG Description: Match IBGP default route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="permit-ibgp", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """permit_ibgp must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="permit-ibgp", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__permit_ibgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_permit_ibgp(self):
    self.__permit_ibgp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="permit-ibgp", parent=self, choice=('mode', 'permit-calculate-other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_always(self):
    """
    Getter method for always, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/always (empty)

    YANG Description: The router configured with the always parameter does not calculate the default routes of other routers.
    """
    return self.__always
      
  def _set_always(self, v, load=False):
    """
    Setter method for always, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/always (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_always is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_always() directly.

    YANG Description: The router configured with the always parameter does not calculate the default routes of other routers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="always", parent=self, choice=('mode', 'always'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """always must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="always", parent=self, choice=('mode', 'always'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__always = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_always(self):
    self.__always = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="always", parent=self, choice=('mode', 'always'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_route_policy_name(self):
    """
    Getter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/route_policy_name (leafref)

    YANG Description: Name of a routing policy. Through the routing policy, the device matches the default routing entry generated by the device that does not run OSPF in the routing table, and advertises the default route according to the parameters set through the routing policy.
    """
    return self.__route_policy_name
      
  def _set_route_policy_name(self, v, load=False):
    """
    Setter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/route_policy_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy_name() directly.

    YANG Description: Name of a routing policy. Through the routing policy, the device matches the default routing entry generated by the device that does not run OSPF in the routing table, and advertises the default route according to the parameters set through the routing policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy_name(self):
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter_name(self):
    """
    Getter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/route_filter_name (leafref)

    YANG Description: Name of a routing Filter.
    """
    return self.__route_filter_name
      
  def _set_route_filter_name(self, v, load=False):
    """
    Setter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary/route_filter_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter_name() directly.

    YANG Description: Name of a routing Filter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter_name(self):
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  cost = __builtin__.property(_get_cost, _set_cost)
  tag = __builtin__.property(_get_tag, _set_tag)
  type = __builtin__.property(_get_type, _set_type)
  distribute_delay = __builtin__.property(_get_distribute_delay, _set_distribute_delay)
  permit_calculate_other = __builtin__.property(_get_permit_calculate_other, _set_permit_calculate_other)
  permit_ibgp = __builtin__.property(_get_permit_ibgp, _set_permit_ibgp)
  always = __builtin__.property(_get_always, _set_always)
  route_policy_name = __builtin__.property(_get_route_policy_name, _set_route_policy_name)
  route_filter_name = __builtin__.property(_get_route_filter_name, _set_route_filter_name)

  __choices__ = {'default-route': {'no-summary': ['enable', 'cost', 'tag', 'type', 'distribute_delay']}, 'mode': {'permit-calculate-other': ['permit_calculate_other', 'permit_ibgp'], 'always': ['always']}, 'policy-type': {'route-policy-name': ['route_policy_name'], 'route-filter-name': ['route_filter_name']}}
  _pyangbind_elements = OrderedDict([('enable', enable), ('cost', cost), ('tag', tag), ('type', type), ('distribute_delay', distribute_delay), ('permit_calculate_other', permit_calculate_other), ('permit_ibgp', permit_ibgp), ('always', always), ('route_policy_name', route_policy_name), ('route_filter_name', route_filter_name), ])


class yc_route_preference_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences_route_preference(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/route-preferences/route-preference. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure preference of an OSPF route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_type','__preference','__route_policy_name','__route_filter_name',)

  _yang_name = 'route-preference'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 1}, 'inter': {'value': 4}, 'intra': {'value': 3}, 'ase': {'value': 2}},), is_leaf=True, yang_name="route-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ospf-route-type', is_config=True)
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'route-preferences', 'route-preference']

  def _get_route_type(self):
    """
    Getter method for route_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/route_type (ospf-route-type)

    YANG Description: Router type.
    """
    return self.__route_type
      
  def _set_route_type(self, v, load=False):
    """
    Setter method for route_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/route_type (ospf-route-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_type() directly.

    YANG Description: Router type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 1}, 'inter': {'value': 4}, 'intra': {'value': 3}, 'ase': {'value': 2}},), is_leaf=True, yang_name="route-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ospf-route-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_type must be of a type compatible with ospf-route-type""",
          'defined-type': "huawei-ospfv2:ospf-route-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 1}, 'inter': {'value': 4}, 'intra': {'value': 3}, 'ase': {'value': 2}},), is_leaf=True, yang_name="route-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ospf-route-type', is_config=True)""",
        })

    self.__route_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_type(self):
    self.__route_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 1}, 'inter': {'value': 4}, 'intra': {'value': 3}, 'ase': {'value': 2}},), is_leaf=True, yang_name="route-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ospf-route-type', is_config=True)


  def _get_preference(self):
    """
    Getter method for preference, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/preference (uint32)

    YANG Description: Preference of an OSPF route. The default of intra and inter area is 10.And The default of external is 150.
    """
    return self.__preference
      
  def _set_preference(self, v, load=False):
    """
    Setter method for preference, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/preference (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preference() directly.

    YANG Description: Preference of an OSPF route. The default of intra and inter area is 10.And The default of external is 150.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preference must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preference(self):
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_route_policy_name(self):
    """
    Getter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/route_policy_name (leafref)

    YANG Description: Name of a routing policy.
    """
    return self.__route_policy_name
      
  def _set_route_policy_name(self, v, load=False):
    """
    Setter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/route_policy_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy_name() directly.

    YANG Description: Name of a routing policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy_name(self):
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter_name(self):
    """
    Getter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/route_filter_name (leafref)

    YANG Description: Name of a routing Filter.
    """
    return self.__route_filter_name
      
  def _set_route_filter_name(self, v, load=False):
    """
    Setter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference/route_filter_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter_name() directly.

    YANG Description: Name of a routing Filter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter_name(self):
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  route_type = __builtin__.property(_get_route_type, _set_route_type)
  preference = __builtin__.property(_get_preference, _set_preference)
  route_policy_name = __builtin__.property(_get_route_policy_name, _set_route_policy_name)
  route_filter_name = __builtin__.property(_get_route_filter_name, _set_route_filter_name)

  __choices__ = {'policy-type': {'route-policy-name': ['route_policy_name'], 'route-filter-name': ['route_filter_name']}}
  _pyangbind_elements = OrderedDict([('route_type', route_type), ('preference', preference), ('route_policy_name', route_policy_name), ('route_filter_name', route_filter_name), ])


class yc_route_preferences_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/route-preferences. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of preference of an OSPF route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference',)

  _yang_name = 'route-preferences'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_preference = YANGDynClass(base=YANGListType("route_type",yc_route_preference_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences_route_preference, yang_name="route-preference", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-type', extensions=None), is_container='list', yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'route-preferences']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference (list)

    YANG Description: Configure preference of an OSPF route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences/route_preference (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: Configure preference of an OSPF route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("route_type",yc_route_preference_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences_route_preference, yang_name="route-preference", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-type', extensions=None), is_container='list', yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("route_type",yc_route_preference_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences_route_preference, yang_name="route-preference", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-type', extensions=None), is_container='list', yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=YANGListType("route_type",yc_route_preference_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences_route_preference, yang_name="route-preference", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-type', extensions=None), is_container='list', yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  route_preference = __builtin__.property(_get_route_preference, _set_route_preference) # type: yc_route_preference_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences_route_preference


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ])


class yc_nexthop_weight_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights_nexthop_weight(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/nexthop-weights/nexthop-weight. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure preference of an equal cost route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_address','__weight',)

  _yang_name = 'nexthop-weight'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'nexthop-weights', 'nexthop-weight']

  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights/nexthop_weight/ip_address (inet:ipv4-address-no-zone)

    YANG Description: IP address of the next hop.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights/nexthop_weight/ip_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the next hop.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights/nexthop_weight/weight (uint32)

    YANG Description: Weight of the next hop. After OSPF calculates the equal cost routes, the next hop is chosen from these equal cost routes based on the value of weight. The smaller the value is, the higher the preference is. By default, the weight is 255. This indicates that load balancing is carried out among equal cost routes and packets are forwarded at the same time without the preference being set.
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights/nexthop_weight/weight (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: Weight of the next hop. After OSPF calculates the equal cost routes, the next hop is chosen from these equal cost routes based on the value of weight. The smaller the value is, the higher the preference is. By default, the weight is 255. This indicates that load balancing is carried out among equal cost routes and packets are forwarded at the same time without the preference being set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..254']}), is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  weight = __builtin__.property(_get_weight, _set_weight)


  _pyangbind_elements = OrderedDict([('ip_address', ip_address), ('weight', weight), ])


class yc_nexthop_weights_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/nexthop-weights. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of preference of an equal cost route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nexthop_weight',)

  _yang_name = 'nexthop-weights'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nexthop_weight = YANGDynClass(base=YANGListType("ip_address",yc_nexthop_weight_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights_nexthop_weight, yang_name="nexthop-weight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="nexthop-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'nexthop-weights']

  def _get_nexthop_weight(self):
    """
    Getter method for nexthop_weight, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights/nexthop_weight (list)

    YANG Description: Configure preference of an equal cost route.
    """
    return self.__nexthop_weight
      
  def _set_nexthop_weight(self, v, load=False):
    """
    Setter method for nexthop_weight, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights/nexthop_weight (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_weight() directly.

    YANG Description: Configure preference of an equal cost route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip_address",yc_nexthop_weight_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights_nexthop_weight, yang_name="nexthop-weight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="nexthop-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_weight must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address",yc_nexthop_weight_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights_nexthop_weight, yang_name="nexthop-weight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="nexthop-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__nexthop_weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_weight(self):
    self.__nexthop_weight = YANGDynClass(base=YANGListType("ip_address",yc_nexthop_weight_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights_nexthop_weight, yang_name="nexthop-weight", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="nexthop-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  nexthop_weight = __builtin__.property(_get_nexthop_weight, _set_nexthop_weight) # type: yc_nexthop_weight_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights_nexthop_weight


  _pyangbind_elements = OrderedDict([('nexthop_weight', nexthop_weight), ])


class yc_prefix_priority_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys_prefix_priority(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/prefix-prioritys/prefix-priority. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure priority of OSPF route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__priority','__ip_prefix',)

  _yang_name = 'prefix-priority'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 1}, 'high': {'value': 2}, 'medium': {'value': 3}, 'very-low': {'value': 5}},), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='prefix-priority', is_config=True)
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'prefix-prioritys', 'prefix-priority']

  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys/prefix_priority/priority (prefix-priority)

    YANG Description: Convergence priority of OSPF routes.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys/prefix_priority/priority (prefix-priority)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Convergence priority of OSPF routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 1}, 'high': {'value': 2}, 'medium': {'value': 3}, 'very-low': {'value': 5}},), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='prefix-priority', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with prefix-priority""",
          'defined-type': "huawei-ospfv2:prefix-priority",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 1}, 'high': {'value': 2}, 'medium': {'value': 3}, 'very-low': {'value': 5}},), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='prefix-priority', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 1}, 'high': {'value': 2}, 'medium': {'value': 3}, 'very-low': {'value': 5}},), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='prefix-priority', is_config=True)


  def _get_ip_prefix(self):
    """
    Getter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys/prefix_priority/ip_prefix (leafref)

    YANG Description: Name of the IP prefix list. The value is a string of 1 to 169 characters without spaces. The prefix priority command sets the convergence priority of OSPF routes according to the specified IP prefix list name, and takes effect on the public network only.
By default, the convergence priority of public OSPF host routes is medium, the convergence priority of directly connected routes is high, the convergence priority of static routes is medium, and the convergence priority of the routes of other protocols (such as BGP and RIP) is low. On the private network, OSPF 32 bit host routes are globally identified as medium.
    """
    return self.__ip_prefix
      
  def _set_ip_prefix(self, v, load=False):
    """
    Setter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys/prefix_priority/ip_prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefix() directly.

    YANG Description: Name of the IP prefix list. The value is a string of 1 to 169 characters without spaces. The prefix priority command sets the convergence priority of OSPF routes according to the specified IP prefix list name, and takes effect on the public network only.
By default, the convergence priority of public OSPF host routes is medium, the convergence priority of directly connected routes is high, the convergence priority of static routes is medium, and the convergence priority of the routes of other protocols (such as BGP and RIP) is low. On the private network, OSPF 32 bit host routes are globally identified as medium.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefix(self):
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  priority = __builtin__.property(_get_priority, _set_priority)
  ip_prefix = __builtin__.property(_get_ip_prefix, _set_ip_prefix)


  _pyangbind_elements = OrderedDict([('priority', priority), ('ip_prefix', ip_prefix), ])


class yc_prefix_prioritys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/prefix-prioritys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of priority of OSPF route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_priority',)

  _yang_name = 'prefix-prioritys'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_priority = YANGDynClass(base=YANGListType("priority",yc_prefix_priority_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys_prefix_priority, yang_name="prefix-priority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='priority', extensions=None), is_container='list', yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'prefix-prioritys']

  def _get_prefix_priority(self):
    """
    Getter method for prefix_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys/prefix_priority (list)

    YANG Description: Configure priority of OSPF route.
    """
    return self.__prefix_priority
      
  def _set_prefix_priority(self, v, load=False):
    """
    Setter method for prefix_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys/prefix_priority (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_priority() directly.

    YANG Description: Configure priority of OSPF route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("priority",yc_prefix_priority_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys_prefix_priority, yang_name="prefix-priority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='priority', extensions=None), is_container='list', yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_priority must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("priority",yc_prefix_priority_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys_prefix_priority, yang_name="prefix-priority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='priority', extensions=None), is_container='list', yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__prefix_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_priority(self):
    self.__prefix_priority = YANGDynClass(base=YANGListType("priority",yc_prefix_priority_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys_prefix_priority, yang_name="prefix-priority", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='priority', extensions=None), is_container='list', yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  prefix_priority = __builtin__.property(_get_prefix_priority, _set_prefix_priority) # type: yc_prefix_priority_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys_prefix_priority


  _pyangbind_elements = OrderedDict([('prefix_priority', prefix_priority), ])


class yc_ecmp_prefer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_ecmp_prefer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/ecmp-prefer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure equal cost multipath preference of OSPF routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__te_tunnel','__intact',)

  _yang_name = 'ecmp-prefer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__te_tunnel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__intact = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="intact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'ecmp-prefer']

  def _get_te_tunnel(self):
    """
    Getter method for te_tunnel, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/ecmp_prefer/te_tunnel (boolean)

    YANG Description: Enable/disable TE tunnel interface nexthops.
    """
    return self.__te_tunnel
      
  def _set_te_tunnel(self, v, load=False):
    """
    Setter method for te_tunnel, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/ecmp_prefer/te_tunnel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_te_tunnel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_te_tunnel() directly.

    YANG Description: Enable/disable TE tunnel interface nexthops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """te_tunnel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__te_tunnel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_te_tunnel(self):
    self.__te_tunnel = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="te-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_intact(self):
    """
    Getter method for intact, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/ecmp_prefer/intact (boolean)

    YANG Description: Enable/disable IGP native nexthop.
    """
    return self.__intact
      
  def _set_intact(self, v, load=False):
    """
    Setter method for intact, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/ecmp_prefer/intact (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intact is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intact() directly.

    YANG Description: Enable/disable IGP native nexthop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="intact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intact must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="intact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__intact = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intact(self):
    self.__intact = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="intact", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  te_tunnel = __builtin__.property(_get_te_tunnel, _set_te_tunnel)
  intact = __builtin__.property(_get_intact, _set_intact)


  _pyangbind_elements = OrderedDict([('te_tunnel', te_tunnel), ('intact', intact), ])


class yc_tiebreaker_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_tiebreaker(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/frr/tiebreaker. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure tiebreaker for multiple backups.
  """
  __slots__ = ('_path_helper', '_extmethods', '__node_protect','__lowest_cost','__ldp_sync',)

  _yang_name = 'tiebreaker'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_protect = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="node-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    self.__lowest_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="lowest-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    self.__ldp_sync = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'frr', 'tiebreaker']

  def _get_node_protect(self):
    """
    Getter method for node_protect, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker/node_protect (uint8)

    YANG Description: Set the value of node protect preference. The preference value 5 is reserved for SRLG disjoint type, cannot be configured.
    """
    return self.__node_protect
      
  def _set_node_protect(self, v, load=False):
    """
    Setter method for node_protect, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker/node_protect (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_protect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_protect() directly.

    YANG Description: Set the value of node protect preference. The preference value 5 is reserved for SRLG disjoint type, cannot be configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="node-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_protect must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="node-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)""",
        })

    self.__node_protect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_protect(self):
    self.__node_protect = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(40), is_leaf=True, yang_name="node-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)


  def _get_lowest_cost(self):
    """
    Getter method for lowest_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker/lowest_cost (uint8)

    YANG Description: Set the value of lowcost preference.
    """
    return self.__lowest_cost
      
  def _set_lowest_cost(self, v, load=False):
    """
    Setter method for lowest_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker/lowest_cost (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowest_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowest_cost() directly.

    YANG Description: Set the value of lowcost preference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="lowest-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowest_cost must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="lowest-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)""",
        })

    self.__lowest_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowest_cost(self):
    self.__lowest_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(20), is_leaf=True, yang_name="lowest-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)


  def _get_ldp_sync(self):
    """
    Getter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker/ldp_sync (uint8)

    YANG Description: Prefer backup nexthop with ldp sync.
    """
    return self.__ldp_sync
      
  def _set_ldp_sync(self, v, load=False):
    """
    Setter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker/ldp_sync (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync() directly.

    YANG Description: Prefer backup nexthop with ldp sync.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)""",
        })

    self.__ldp_sync = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync(self):
    self.__ldp_sync = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(10), is_leaf=True, yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)

  node_protect = __builtin__.property(_get_node_protect, _set_node_protect)
  lowest_cost = __builtin__.property(_get_lowest_cost, _set_lowest_cost)
  ldp_sync = __builtin__.property(_get_ldp_sync, _set_ldp_sync)


  _pyangbind_elements = OrderedDict([('node_protect', node_protect), ('lowest_cost', lowest_cost), ('ldp_sync', ldp_sync), ])


class yc_route_policy_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_route_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/frr/route-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure FRR route policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_policy_name','__route_filter_name',)

  _yang_name = 'route-policy'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'frr', 'route-policy']

  def _get_route_policy_name(self):
    """
    Getter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/route_policy/route_policy_name (leafref)

    YANG Description: Name of a routing policy.
    """
    return self.__route_policy_name
      
  def _set_route_policy_name(self, v, load=False):
    """
    Setter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/route_policy/route_policy_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy_name() directly.

    YANG Description: Name of a routing policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy_name(self):
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter_name(self):
    """
    Getter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/route_policy/route_filter_name (leafref)

    YANG Description: Name of a routing filter.
    """
    return self.__route_filter_name
      
  def _set_route_filter_name(self, v, load=False):
    """
    Setter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/route_policy/route_filter_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter_name() directly.

    YANG Description: Name of a routing filter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter_name(self):
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('policy-type', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  route_policy_name = __builtin__.property(_get_route_policy_name, _set_route_policy_name)
  route_filter_name = __builtin__.property(_get_route_filter_name, _set_route_filter_name)

  __choices__ = {'policy-type': {'route-policy-name': ['route_policy_name'], 'route-filter-name': ['route_filter_name']}}
  _pyangbind_elements = OrderedDict([('route_policy_name', route_policy_name), ('route_filter_name', route_filter_name), ])


class yc_rlfa_tunnel_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_rlfa_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/frr/rlfa-tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure remote LFA ip prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_prefix_name',)

  _yang_name = 'rlfa-tunnel'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_prefix_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix-name", parent=self, choice=('policy-type', 'ip-prefix-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'frr', 'rlfa-tunnel']

  def _get_ip_prefix_name(self):
    """
    Getter method for ip_prefix_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_tunnel/ip_prefix_name (leafref)

    YANG Description: To filter PQ node. Those nodes which don't pass filter can't be PQ node.
    """
    return self.__ip_prefix_name
      
  def _set_ip_prefix_name(self, v, load=False):
    """
    Setter method for ip_prefix_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_tunnel/ip_prefix_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefix_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefix_name() directly.

    YANG Description: To filter PQ node. Those nodes which don't pass filter can't be PQ node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-prefix-name", parent=self, choice=('policy-type', 'ip-prefix-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefix_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix-name", parent=self, choice=('policy-type', 'ip-prefix-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__ip_prefix_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefix_name(self):
    self.__ip_prefix_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix-name", parent=self, choice=('policy-type', 'ip-prefix-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  ip_prefix_name = __builtin__.property(_get_ip_prefix_name, _set_ip_prefix_name)

  __choices__ = {'policy-type': {'ip-prefix-name': ['ip_prefix_name']}}
  _pyangbind_elements = OrderedDict([('ip_prefix_name', ip_prefix_name), ])


class yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/frr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF fast rerouting.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__lfa_enable','__rlfa_enable','__rlfa_max_cost','__tilfa_enable','__tiebreaker','__route_policy','__rlfa_tunnel',)

  _yang_name = 'frr'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__lfa_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__rlfa_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__rlfa_max_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4294967295), is_leaf=True, yang_name="rlfa-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__tilfa_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__tiebreaker = YANGDynClass(base=yc_tiebreaker_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_tiebreaker, is_container='container', yang_name="tiebreaker", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__route_policy = YANGDynClass(base=yc_route_policy_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_route_policy, is_container='container', yang_name="route-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__rlfa_tunnel = YANGDynClass(base=yc_rlfa_tunnel_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_rlfa_tunnel, is_container='container', yang_name="rlfa-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'frr']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/enable (boolean)

    YANG Description: Enable/disable FRR for this particular process.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable FRR for this particular process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_lfa_enable(self):
    """
    Getter method for lfa_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/lfa_enable (boolean)

    YANG Description: Enable/disable loop free alternate.
    """
    return self.__lfa_enable
      
  def _set_lfa_enable(self, v, load=False):
    """
    Setter method for lfa_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/lfa_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lfa_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lfa_enable() directly.

    YANG Description: Enable/disable loop free alternate.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lfa_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__lfa_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lfa_enable(self):
    self.__lfa_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="lfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_rlfa_enable(self):
    """
    Getter method for rlfa_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_enable (boolean)

    YANG Description: Enable/disable remote lfa.
    """
    return self.__rlfa_enable
      
  def _set_rlfa_enable(self, v, load=False):
    """
    Setter method for rlfa_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfa_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfa_enable() directly.

    YANG Description: Enable/disable remote lfa.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfa_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__rlfa_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfa_enable(self):
    self.__rlfa_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_rlfa_max_cost(self):
    """
    Getter method for rlfa_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_max_cost (uint32)

    YANG Description: Remote lfa tunnel ldp maximum-reachable-cost.
    """
    return self.__rlfa_max_cost
      
  def _set_rlfa_max_cost(self, v, load=False):
    """
    Setter method for rlfa_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_max_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfa_max_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfa_max_cost() directly.

    YANG Description: Remote lfa tunnel ldp maximum-reachable-cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4294967295), is_leaf=True, yang_name="rlfa-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfa_max_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4294967295), is_leaf=True, yang_name="rlfa-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__rlfa_max_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfa_max_cost(self):
    self.__rlfa_max_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(4294967295), is_leaf=True, yang_name="rlfa-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_tilfa_enable(self):
    """
    Getter method for tilfa_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tilfa_enable (boolean)

    YANG Description: Enable/disable TILFA.
    """
    return self.__tilfa_enable
      
  def _set_tilfa_enable(self, v, load=False):
    """
    Setter method for tilfa_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tilfa_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tilfa_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tilfa_enable() directly.

    YANG Description: Enable/disable TILFA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tilfa_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__tilfa_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tilfa_enable(self):
    self.__tilfa_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tilfa-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_tiebreaker(self):
    """
    Getter method for tiebreaker, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker (container)

    YANG Description: Configure tiebreaker for multiple backups.
    """
    return self.__tiebreaker
      
  def _set_tiebreaker(self, v, load=False):
    """
    Setter method for tiebreaker, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/tiebreaker (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tiebreaker is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tiebreaker() directly.

    YANG Description: Configure tiebreaker for multiple backups.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tiebreaker_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_tiebreaker, is_container='container', yang_name="tiebreaker", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tiebreaker must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tiebreaker_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_tiebreaker, is_container='container', yang_name="tiebreaker", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__tiebreaker = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tiebreaker(self):
    self.__tiebreaker = YANGDynClass(base=yc_tiebreaker_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_tiebreaker, is_container='container', yang_name="tiebreaker", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_route_policy(self):
    """
    Getter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/route_policy (container)

    YANG Description: Configure FRR route policy.
    """
    return self.__route_policy
      
  def _set_route_policy(self, v, load=False):
    """
    Setter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/route_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy() directly.

    YANG Description: Configure FRR route policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_policy_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_route_policy, is_container='container', yang_name="route-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_policy_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_route_policy, is_container='container', yang_name="route-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__route_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy(self):
    self.__route_policy = YANGDynClass(base=yc_route_policy_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_route_policy, is_container='container', yang_name="route-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_rlfa_tunnel(self):
    """
    Getter method for rlfa_tunnel, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_tunnel (container)

    YANG Description: Configure remote LFA ip prefix.
    """
    return self.__rlfa_tunnel
      
  def _set_rlfa_tunnel(self, v, load=False):
    """
    Setter method for rlfa_tunnel, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr/rlfa_tunnel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfa_tunnel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfa_tunnel() directly.

    YANG Description: Configure remote LFA ip prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rlfa_tunnel_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_rlfa_tunnel, is_container='container', yang_name="rlfa-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfa_tunnel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rlfa_tunnel_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_rlfa_tunnel, is_container='container', yang_name="rlfa-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__rlfa_tunnel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfa_tunnel(self):
    self.__rlfa_tunnel = YANGDynClass(base=yc_rlfa_tunnel_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_rlfa_tunnel, is_container='container', yang_name="rlfa-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  lfa_enable = __builtin__.property(_get_lfa_enable, _set_lfa_enable)
  rlfa_enable = __builtin__.property(_get_rlfa_enable, _set_rlfa_enable)
  rlfa_max_cost = __builtin__.property(_get_rlfa_max_cost, _set_rlfa_max_cost)
  tilfa_enable = __builtin__.property(_get_tilfa_enable, _set_tilfa_enable)
  tiebreaker = __builtin__.property(_get_tiebreaker, _set_tiebreaker) # type: yc_tiebreaker_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_tiebreaker
  route_policy = __builtin__.property(_get_route_policy, _set_route_policy) # type: yc_route_policy_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_route_policy
  rlfa_tunnel = __builtin__.property(_get_rlfa_tunnel, _set_rlfa_tunnel) # type: yc_rlfa_tunnel_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr_rlfa_tunnel


  _pyangbind_elements = OrderedDict([('enable', enable), ('lfa_enable', lfa_enable), ('rlfa_enable', rlfa_enable), ('rlfa_max_cost', rlfa_max_cost), ('tilfa_enable', tilfa_enable), ('tiebreaker', tiebreaker), ('route_policy', route_policy), ('rlfa_tunnel', rlfa_tunnel), ])


class yc_local_mt_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_local_mt_filter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/local-mt-filter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF local multicast topology filtering in routing updates.
  """
  __slots__ = ('_path_helper', '_extmethods', '__acl_name_or_num','__ip_prefix','__route_policy_name','__route_filter_name',)

  _yang_name = 'local-mt-filter'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__acl_name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl-name-or-num", parent=self, choice=('filter-policy', 'acl-name-or-num'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('filter-policy', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('filter-policy', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('filter-policy', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'local-mt-filter']

  def _get_acl_name_or_num(self):
    """
    Getter method for acl_name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/acl_name_or_num (leafref)

    YANG Description: ACL name or ACL number. ACL name: specify the ACL name. ACL num: apply basic ACL.
    """
    return self.__acl_name_or_num
      
  def _set_acl_name_or_num(self, v, load=False):
    """
    Setter method for acl_name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/acl_name_or_num (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_name_or_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_name_or_num() directly.

    YANG Description: ACL name or ACL number. ACL name: specify the ACL name. ACL num: apply basic ACL.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="acl-name-or-num", parent=self, choice=('filter-policy', 'acl-name-or-num'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_name_or_num must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl-name-or-num", parent=self, choice=('filter-policy', 'acl-name-or-num'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__acl_name_or_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_name_or_num(self):
    self.__acl_name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acl-name-or-num", parent=self, choice=('filter-policy', 'acl-name-or-num'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_ip_prefix(self):
    """
    Getter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/ip_prefix (leafref)

    YANG Description: Ip prefix name.
    """
    return self.__ip_prefix
      
  def _set_ip_prefix(self, v, load=False):
    """
    Setter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/ip_prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefix() directly.

    YANG Description: Ip prefix name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('filter-policy', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('filter-policy', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefix(self):
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('filter-policy', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_policy_name(self):
    """
    Getter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/route_policy_name (leafref)

    YANG Description: Name of a routing policy.
    """
    return self.__route_policy_name
      
  def _set_route_policy_name(self, v, load=False):
    """
    Setter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/route_policy_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy_name() directly.

    YANG Description: Name of a routing policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('filter-policy', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('filter-policy', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy_name(self):
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('filter-policy', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter_name(self):
    """
    Getter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/route_filter_name (leafref)

    YANG Description: Name of a routing filter.
    """
    return self.__route_filter_name
      
  def _set_route_filter_name(self, v, load=False):
    """
    Setter method for route_filter_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter/route_filter_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter_name() directly.

    YANG Description: Name of a routing filter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('filter-policy', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('filter-policy', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter_name(self):
    self.__route_filter_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter-name", parent=self, choice=('filter-policy', 'route-filter-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  acl_name_or_num = __builtin__.property(_get_acl_name_or_num, _set_acl_name_or_num)
  ip_prefix = __builtin__.property(_get_ip_prefix, _set_ip_prefix)
  route_policy_name = __builtin__.property(_get_route_policy_name, _set_route_policy_name)
  route_filter_name = __builtin__.property(_get_route_filter_name, _set_route_filter_name)

  __choices__ = {'filter-policy': {'acl-name-or-num': ['acl_name_or_num'], 'ip-prefix': ['ip_prefix'], 'route-policy-name': ['route_policy_name'], 'route-filter-name': ['route_filter_name']}}
  _pyangbind_elements = OrderedDict([('acl_name_or_num', acl_name_or_num), ('ip_prefix', ip_prefix), ('route_policy_name', route_policy_name), ('route_filter_name', route_filter_name), ])


class yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers_peer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/peers/peer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the IP address and DR priority of the neighbor router on the NBMA network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_address','__priority',)

  _yang_name = 'peer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(1), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'peers', 'peer']

  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers/peer/ip_address (inet:ipv4-address-no-zone)

    YANG Description: IP address of the neighbor router.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers/peer/ip_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the neighbor router.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers/peer/priority (uint8)

    YANG Description: To set the IP address and DR priority of the neighbor router on the NBMA network.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers/peer/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: To set the IP address and DR priority of the neighbor router on the NBMA network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(1), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(1), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(1), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=True)

  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  priority = __builtin__.property(_get_priority, _set_priority)


  _pyangbind_elements = OrderedDict([('ip_address', ip_address), ('priority', priority), ])


class yc_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/peers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the IP address and DR priority of the neighbor router on the NBMA network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer',)

  _yang_name = 'peers'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer = YANGDynClass(base=YANGListType("ip_address",yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'peers']

  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers/peer (list)

    YANG Description: Configure the IP address and DR priority of the neighbor router on the NBMA network.
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers/peer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.

    YANG Description: Configure the IP address and DR priority of the neighbor router on the NBMA network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip_address",yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address",yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=YANGListType("ip_address",yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  peer = __builtin__.property(_get_peer, _set_peer) # type: yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers_peer


  _pyangbind_elements = OrderedDict([('peer', peer), ])


class yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs_filter_lsa_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/filter-lsa-outs/filter-lsa-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure LSA filter policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer_ip_addr',)

  _yang_name = 'filter-lsa-out'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer_ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peer-ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'filter-lsa-outs', 'filter-lsa-out']

  def _get_peer_ip_addr(self):
    """
    Getter method for peer_ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_lsa_outs/filter_lsa_out/peer_ip_addr (inet:ipv4-address-no-zone)

    YANG Description: IP address of the P2MP neighbor.
    """
    return self.__peer_ip_addr
      
  def _set_peer_ip_addr(self, v, load=False):
    """
    Setter method for peer_ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_lsa_outs/filter_lsa_out/peer_ip_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_ip_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_ip_addr() directly.

    YANG Description: IP address of the P2MP neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peer-ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_ip_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peer-ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__peer_ip_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_ip_addr(self):
    self.__peer_ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="peer-ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)

  peer_ip_addr = __builtin__.property(_get_peer_ip_addr, _set_peer_ip_addr)


  _pyangbind_elements = OrderedDict([('peer_ip_addr', peer_ip_addr), ])


class yc_filter_lsa_outs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/filter-lsa-outs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LSA filter policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__filter_lsa_out',)

  _yang_name = 'filter-lsa-outs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__filter_lsa_out = YANGDynClass(base=YANGListType("peer_ip_addr",yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs_filter_lsa_out, yang_name="filter-lsa-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions=None), is_container='list', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'filter-lsa-outs']

  def _get_filter_lsa_out(self):
    """
    Getter method for filter_lsa_out, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_lsa_outs/filter_lsa_out (list)

    YANG Description: Configure LSA filter policy.
    """
    return self.__filter_lsa_out
      
  def _set_filter_lsa_out(self, v, load=False):
    """
    Setter method for filter_lsa_out, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_lsa_outs/filter_lsa_out (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_lsa_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_lsa_out() directly.

    YANG Description: Configure LSA filter policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ip_addr",yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs_filter_lsa_out, yang_name="filter-lsa-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions=None), is_container='list', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_lsa_out must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ip_addr",yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs_filter_lsa_out, yang_name="filter-lsa-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions=None), is_container='list', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__filter_lsa_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_lsa_out(self):
    self.__filter_lsa_out = YANGDynClass(base=YANGListType("peer_ip_addr",yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs_filter_lsa_out, yang_name="filter-lsa-out", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip-addr', extensions=None), is_container='list', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  filter_lsa_out = __builtin__.property(_get_filter_lsa_out, _set_filter_lsa_out) # type: yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs_filter_lsa_out


  _pyangbind_elements = OrderedDict([('filter_lsa_out', filter_lsa_out), ])


class yc_gr_ietf_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_gr_ietf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/gr-ietf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF IETF GR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__never','__planned_only','__ignore_external_lsa',)

  _yang_name = 'gr-ietf'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__never = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="never", parent=self, choice=('helper-role-mode', 'never'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__planned_only = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="planned-only", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__ignore_external_lsa = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-external-lsa", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'gr-ietf']

  def _get_never(self):
    """
    Getter method for never, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf/never (empty)

    YANG Description: Forbid to support enable mode.
    """
    return self.__never
      
  def _set_never(self, v, load=False):
    """
    Setter method for never, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf/never (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_never is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_never() directly.

    YANG Description: Forbid to support enable mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="never", parent=self, choice=('helper-role-mode', 'never'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """never must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="never", parent=self, choice=('helper-role-mode', 'never'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__never = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_never(self):
    self.__never = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="never", parent=self, choice=('helper-role-mode', 'never'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_planned_only(self):
    """
    Getter method for planned_only, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf/planned_only (empty)

    YANG Description: To support only planned GR on routers.
    """
    return self.__planned_only
      
  def _set_planned_only(self, v, load=False):
    """
    Setter method for planned_only, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf/planned_only (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_planned_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_planned_only() directly.

    YANG Description: To support only planned GR on routers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="planned-only", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """planned_only must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="planned-only", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__planned_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_planned_only(self):
    self.__planned_only = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="planned-only", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_ignore_external_lsa(self):
    """
    Getter method for ignore_external_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf/ignore_external_lsa (empty)

    YANG Description: Ignore external lsa check (type5 and type7 LSAs).
    """
    return self.__ignore_external_lsa
      
  def _set_ignore_external_lsa(self, v, load=False):
    """
    Setter method for ignore_external_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf/ignore_external_lsa (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_external_lsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_external_lsa() directly.

    YANG Description: Ignore external lsa check (type5 and type7 LSAs).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ignore-external-lsa", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_external_lsa must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-external-lsa", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__ignore_external_lsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_external_lsa(self):
    self.__ignore_external_lsa = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-external-lsa", parent=self, choice=('helper-role-mode', 'work-mode'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

  never = __builtin__.property(_get_never, _set_never)
  planned_only = __builtin__.property(_get_planned_only, _set_planned_only)
  ignore_external_lsa = __builtin__.property(_get_ignore_external_lsa, _set_ignore_external_lsa)

  __choices__ = {'helper-role-mode': {'never': ['never'], 'work-mode': ['planned_only', 'ignore_external_lsa']}}
  _pyangbind_elements = OrderedDict([('never', never), ('planned_only', planned_only), ('ignore_external_lsa', ignore_external_lsa), ])


class yc_flood_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_flood_control(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/flood-control. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF flooding control.
  """
  __slots__ = ('_path_helper', '_extmethods', '__number','__interval',)

  _yang_name = 'flood-control'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'flood-control']

  def _get_number(self):
    """
    Getter method for number, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/flood_control/number (uint32)

    YANG Description: Specify the update packet number to send.
    """
    return self.__number
      
  def _set_number(self, v, load=False):
    """
    Setter method for number, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/flood_control/number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number() directly.

    YANG Description: Specify the update packet number to send.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number(self):
    self.__number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(50), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/flood_control/interval (uint32)

    YANG Description: Specify the update packet timer interval to send.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/flood_control/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: Specify the update packet timer interval to send.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..100000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  number = __builtin__.property(_get_number, _set_number)
  interval = __builtin__.property(_get_interval, _set_interval)


  _pyangbind_elements = OrderedDict([('number', number), ('interval', interval), ])


class yc_summary_router_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids_summary_router_id(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/dn-bit/summary-router-ids/summary-router-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id',)

  _yang_name = 'summary-router-id'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'dn-bit', 'summary-router-ids', 'summary-router-id']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/summary_router_ids/summary_router_id/router_id (inet:ipv4-address-no-zone)

    YANG Description: Router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/summary_router_ids/summary_router_id/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ])


class yc_summary_router_ids_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/dn-bit/summary-router-ids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__summary_router_id',)

  _yang_name = 'summary-router-ids'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__summary_router_id = YANGDynClass(base=YANGListType("router_id",yc_summary_router_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids_summary_router_id, yang_name="summary-router-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="summary-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'dn-bit', 'summary-router-ids']

  def _get_summary_router_id(self):
    """
    Getter method for summary_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/summary_router_ids/summary_router_id (list)

    YANG Description: Configure router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
    """
    return self.__summary_router_id
      
  def _set_summary_router_id(self, v, load=False):
    """
    Setter method for summary_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/summary_router_ids/summary_router_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary_router_id() directly.

    YANG Description: Configure router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("router_id",yc_summary_router_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids_summary_router_id, yang_name="summary-router-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="summary-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary_router_id must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("router_id",yc_summary_router_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids_summary_router_id, yang_name="summary-router-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="summary-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__summary_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary_router_id(self):
    self.__summary_router_id = YANGDynClass(base=YANGListType("router_id",yc_summary_router_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids_summary_router_id, yang_name="summary-router-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="summary-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  summary_router_id = __builtin__.property(_get_summary_router_id, _set_summary_router_id) # type: yc_summary_router_id_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids_summary_router_id


  _pyangbind_elements = OrderedDict([('summary_router_id', summary_router_id), ])


class yc_dn_bit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/dn-bit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure VPN optionA feature will help PEs in inter AS exchange routes through OSPF. VPN optionA provide two ways to suppress DN bit so that so that inter AS can exchange routes through OSPF. First way dose not set DN bit while import routes from BGP, second way dose not check DN bit while learning the routes from neighbor router. In both the scenario PE will be able to learn route and propagate the route in the new VPN cloud.
  """
  __slots__ = ('_path_helper', '_extmethods', '__set_ase','__set_nssa','__set_summary','__check_ase','__check_nssa','__check_summary','__summary_router_ids',)

  _yang_name = 'dn-bit'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__set_ase = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__set_nssa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__set_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__check_ase = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__check_nssa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__check_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__summary_router_ids = YANGDynClass(base=yc_summary_router_ids_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids, is_container='container', yang_name="summary-router-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'dn-bit']

  def _get_set_ase(self):
    """
    Getter method for set_ase, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/set_ase (boolean)

    YANG Description: Enable/disable setting of DN bit in all ASE LSA, applicable in private network.
    """
    return self.__set_ase
      
  def _set_set_ase(self, v, load=False):
    """
    Setter method for set_ase, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/set_ase (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_set_ase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_set_ase() directly.

    YANG Description: Enable/disable setting of DN bit in all ASE LSA, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """set_ase must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__set_ase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_set_ase(self):
    self.__set_ase = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_set_nssa(self):
    """
    Getter method for set_nssa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/set_nssa (boolean)

    YANG Description: Enable/disable setting of DN bit in all NSSA LSA, applicable in private network.
    """
    return self.__set_nssa
      
  def _set_set_nssa(self, v, load=False):
    """
    Setter method for set_nssa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/set_nssa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_set_nssa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_set_nssa() directly.

    YANG Description: Enable/disable setting of DN bit in all NSSA LSA, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """set_nssa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__set_nssa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_set_nssa(self):
    self.__set_nssa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_set_summary(self):
    """
    Getter method for set_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/set_summary (boolean)

    YANG Description: Enable/disable setting of DN bit in all summary LSA, applicable in private network.
    """
    return self.__set_summary
      
  def _set_set_summary(self, v, load=False):
    """
    Setter method for set_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/set_summary (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_set_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_set_summary() directly.

    YANG Description: Enable/disable setting of DN bit in all summary LSA, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """set_summary must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__set_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_set_summary(self):
    self.__set_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_check_ase(self):
    """
    Getter method for check_ase, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/check_ase (boolean)

    YANG Description: Enable/disable checking of DN bit in all ASE LSA, applicable in private network.
    """
    return self.__check_ase
      
  def _set_check_ase(self, v, load=False):
    """
    Setter method for check_ase, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/check_ase (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_check_ase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_check_ase() directly.

    YANG Description: Enable/disable checking of DN bit in all ASE LSA, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """check_ase must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__check_ase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_check_ase(self):
    self.__check_ase = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_check_nssa(self):
    """
    Getter method for check_nssa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/check_nssa (boolean)

    YANG Description: Enable/disable checking of DN bit in all NSSA LSA, applicable in private network.
    """
    return self.__check_nssa
      
  def _set_check_nssa(self, v, load=False):
    """
    Setter method for check_nssa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/check_nssa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_check_nssa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_check_nssa() directly.

    YANG Description: Enable/disable checking of DN bit in all NSSA LSA, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """check_nssa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__check_nssa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_check_nssa(self):
    self.__check_nssa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_check_summary(self):
    """
    Getter method for check_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/check_summary (boolean)

    YANG Description: Enable/disable checking of DN bit in all summary LSA, applicable in private network.
    """
    return self.__check_summary
      
  def _set_check_summary(self, v, load=False):
    """
    Setter method for check_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/check_summary (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_check_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_check_summary() directly.

    YANG Description: Enable/disable checking of DN bit in all summary LSA, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """check_summary must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__check_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_check_summary(self):
    self.__check_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="check-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_summary_router_ids(self):
    """
    Getter method for summary_router_ids, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/summary_router_ids (container)

    YANG Description: List of router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
    """
    return self.__summary_router_ids
      
  def _set_summary_router_ids(self, v, load=False):
    """
    Setter method for summary_router_ids, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit/summary_router_ids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary_router_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary_router_ids() directly.

    YANG Description: List of router ID for which checking for DN bit summary LSA is disabled, applicable in private network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_summary_router_ids_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids, is_container='container', yang_name="summary-router-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary_router_ids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_summary_router_ids_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids, is_container='container', yang_name="summary-router-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__summary_router_ids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary_router_ids(self):
    self.__summary_router_ids = YANGDynClass(base=yc_summary_router_ids_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids, is_container='container', yang_name="summary-router-ids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  set_ase = __builtin__.property(_get_set_ase, _set_set_ase)
  set_nssa = __builtin__.property(_get_set_nssa, _set_set_nssa)
  set_summary = __builtin__.property(_get_set_summary, _set_set_summary)
  check_ase = __builtin__.property(_get_check_ase, _set_check_ase)
  check_nssa = __builtin__.property(_get_check_nssa, _set_check_nssa)
  check_summary = __builtin__.property(_get_check_summary, _set_check_summary)
  summary_router_ids = __builtin__.property(_get_summary_router_ids, _set_summary_router_ids) # type: yc_summary_router_ids_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit_summary_router_ids


  _pyangbind_elements = OrderedDict([('set_ase', set_ase), ('set_nssa', set_nssa), ('set_summary', set_summary), ('check_ase', check_ase), ('check_nssa', check_nssa), ('check_summary', check_summary), ('summary_router_ids', summary_router_ids), ])


class yc_filter_import_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_import(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/filter-import. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the filter policy import command. You can set the rules for filtering intra area, inter area, and AS external routes of an OSPF process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name_or_num','__ip_prefix','__route_policy','__route_filter','__secondary',)

  _yang_name = 'filter-import'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__secondary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'filter-import']

  def _get_name_or_num(self):
    """
    Getter method for name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/name_or_num (leafref)

    YANG Description: Apply basic ACL name or ACL number.
    """
    return self.__name_or_num
      
  def _set_name_or_num(self, v, load=False):
    """
    Setter method for name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/name_or_num (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name_or_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name_or_num() directly.

    YANG Description: Apply basic ACL name or ACL number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name_or_num must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__name_or_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name_or_num(self):
    self.__name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_ip_prefix(self):
    """
    Getter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/ip_prefix (leafref)

    YANG Description: Set the name of an IP prefix list.
    """
    return self.__ip_prefix
      
  def _set_ip_prefix(self, v, load=False):
    """
    Setter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/ip_prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefix() directly.

    YANG Description: Set the name of an IP prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefix(self):
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_policy(self):
    """
    Getter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/route_policy (leafref)

    YANG Description: Set a route policy name.
    """
    return self.__route_policy
      
  def _set_route_policy(self, v, load=False):
    """
    Setter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/route_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy() directly.

    YANG Description: Set a route policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy(self):
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter(self):
    """
    Getter method for route_filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/route_filter (leafref)

    YANG Description: Set a route filter name.
    """
    return self.__route_filter
      
  def _set_route_filter(self, v, load=False):
    """
    Setter method for route_filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/route_filter (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter() directly.

    YANG Description: Set a route filter name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter(self):
    self.__route_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_secondary(self):
    """
    Getter method for secondary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/secondary (boolean)

    YANG Description: Enable/disable secondary flag.
    """
    return self.__secondary
      
  def _set_secondary(self, v, load=False):
    """
    Setter method for secondary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import/secondary (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary() directly.

    YANG Description: Enable/disable secondary flag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__secondary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary(self):
    self.__secondary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secondary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  name_or_num = __builtin__.property(_get_name_or_num, _set_name_or_num)
  ip_prefix = __builtin__.property(_get_ip_prefix, _set_ip_prefix)
  route_policy = __builtin__.property(_get_route_policy, _set_route_policy)
  route_filter = __builtin__.property(_get_route_filter, _set_route_filter)
  secondary = __builtin__.property(_get_secondary, _set_secondary)

  __choices__ = {'policy-type': {'basic-acl': ['name_or_num'], 'ip-prefix': ['ip_prefix'], 'route-policy': ['route_policy'], 'route-filter': ['route_filter']}}
  _pyangbind_elements = OrderedDict([('name_or_num', name_or_num), ('ip_prefix', ip_prefix), ('route_policy', route_policy), ('route_filter', route_filter), ('secondary', secondary), ])


class yc_filter_export_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports_filter_export(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/filter-exports/filter-export. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the filter policy export command. You can set the rules for filtering the routes imported through the import route (OSPF) command when the routes are advertised in type5 LSAs to the OSPF AS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__protocol_id','__name_or_num','__ip_prefix','__route_policy',)

  _yang_name = 'filter-export'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 9}, 'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='filter-rt-protocol', is_config=True)
    self.__protocol_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="protocol-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'filter-exports', 'filter-export']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/protocol (filter-rt-protocol)

    YANG Description: Protocol that advertises routes.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/protocol (filter-rt-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Protocol that advertises routes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 9}, 'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='filter-rt-protocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with filter-rt-protocol""",
          'defined-type': "huawei-ospfv2:filter-rt-protocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 9}, 'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='filter-rt-protocol', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'default': {'value': 9}, 'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='filter-rt-protocol', is_config=True)


  def _get_protocol_id(self):
    """
    Getter method for protocol_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/protocol_id (uint32)

    YANG Description: Process ID when the advertised protocol is RIP, ISIS, or OSPF.
    """
    return self.__protocol_id
      
  def _set_protocol_id(self, v, load=False):
    """
    Setter method for protocol_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/protocol_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_id() directly.

    YANG Description: Process ID when the advertised protocol is RIP, ISIS, or OSPF.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="protocol-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="protocol-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__protocol_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_id(self):
    self.__protocol_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="protocol-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_name_or_num(self):
    """
    Getter method for name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/name_or_num (leafref)

    YANG Description: Apply basic ACL name or ACL number.
    """
    return self.__name_or_num
      
  def _set_name_or_num(self, v, load=False):
    """
    Setter method for name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/name_or_num (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name_or_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name_or_num() directly.

    YANG Description: Apply basic ACL name or ACL number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name_or_num must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__name_or_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name_or_num(self):
    self.__name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_ip_prefix(self):
    """
    Getter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/ip_prefix (leafref)

    YANG Description: Set the name of an IP prefix list.
    """
    return self.__ip_prefix
      
  def _set_ip_prefix(self, v, load=False):
    """
    Setter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/ip_prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefix() directly.

    YANG Description: Set the name of an IP prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefix(self):
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_policy(self):
    """
    Getter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/route_policy (leafref)

    YANG Description: Set a route policy name.
    """
    return self.__route_policy
      
  def _set_route_policy(self, v, load=False):
    """
    Setter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export/route_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy() directly.

    YANG Description: Set a route policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy(self):
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  protocol_id = __builtin__.property(_get_protocol_id, _set_protocol_id)
  name_or_num = __builtin__.property(_get_name_or_num, _set_name_or_num)
  ip_prefix = __builtin__.property(_get_ip_prefix, _set_ip_prefix)
  route_policy = __builtin__.property(_get_route_policy, _set_route_policy)

  __choices__ = {'policy-type': {'basic-acl': ['name_or_num'], 'ip-prefix': ['ip_prefix'], 'route-policy': ['route_policy']}}
  _pyangbind_elements = OrderedDict([('protocol', protocol), ('protocol_id', protocol_id), ('name_or_num', name_or_num), ('ip_prefix', ip_prefix), ('route_policy', route_policy), ])


class yc_filter_exports_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/filter-exports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the filter policy export command. You can set the rules for filtering the routes imported through the import route (OSPF) command when the routes are advertised in type5 LSAs to the OSPF AS.
  """
  __slots__ = ('_path_helper', '_extmethods', '__filter_export',)

  _yang_name = 'filter-exports'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__filter_export = YANGDynClass(base=YANGListType("protocol protocol_id",yc_filter_export_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports_filter_export, yang_name="filter-export", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol protocol-id', extensions=None), is_container='list', yang_name="filter-export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'filter-exports']

  def _get_filter_export(self):
    """
    Getter method for filter_export, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export (list)

    YANG Description: Configure the filter policy export command. You can set the rules for filtering the routes imported through the import route (OSPF) command when the routes are advertised in type5 LSAs to the OSPF AS.
    """
    return self.__filter_export
      
  def _set_filter_export(self, v, load=False):
    """
    Setter method for filter_export, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports/filter_export (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_export is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_export() directly.

    YANG Description: Configure the filter policy export command. You can set the rules for filtering the routes imported through the import route (OSPF) command when the routes are advertised in type5 LSAs to the OSPF AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("protocol protocol_id",yc_filter_export_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports_filter_export, yang_name="filter-export", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol protocol-id', extensions=None), is_container='list', yang_name="filter-export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_export must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("protocol protocol_id",yc_filter_export_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports_filter_export, yang_name="filter-export", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol protocol-id', extensions=None), is_container='list', yang_name="filter-export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__filter_export = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_export(self):
    self.__filter_export = YANGDynClass(base=YANGListType("protocol protocol_id",yc_filter_export_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports_filter_export, yang_name="filter-export", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol protocol-id', extensions=None), is_container='list', yang_name="filter-export", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  filter_export = __builtin__.property(_get_filter_export, _set_filter_export) # type: yc_filter_export_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports_filter_export


  _pyangbind_elements = OrderedDict([('filter_export', filter_export), ])


class yc_import_route_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes_import_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/import-routes/import-route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure import the routes learned from other routing protocols.
  """
  __slots__ = ('_path_helper', '_extmethods', '__protocol','__process_id','__cost','__tag','__type','__permit_ibgp','__route_policy_name',)

  _yang_name = 'import-route'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-rt-protocol', is_config=True)
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)
    self.__permit_ibgp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permit-ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'import-routes', 'import-route']

  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/protocol (import-rt-protocol)

    YANG Description: Routing protocol whose routes are imported.
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/protocol (import-rt-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Routing protocol whose routes are imported.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-rt-protocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with import-rt-protocol""",
          'defined-type': "huawei-ospfv2:import-rt-protocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-rt-protocol', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'direct': {'value': 1}, 'ospf': {'value': 2}, 'isis': {'value': 3}, 'static': {'value': 4}, 'rip': {'value': 5}, 'bgp': {'value': 6}, 'unr': {'value': 11}},), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-rt-protocol', is_config=True)


  def _get_process_id(self):
    """
    Getter method for process_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/process_id (uint32)

    YANG Description: Process ID of the routing protocol whose routes are imported. It needs to be set only when the protocol is RIP, OSPF, or ISIS.
    """
    return self.__process_id
      
  def _set_process_id(self, v, load=False):
    """
    Setter method for process_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/process_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process_id() directly.

    YANG Description: Process ID of the routing protocol whose routes are imported. It needs to be set only when the protocol is RIP, OSPF, or ISIS.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__process_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process_id(self):
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/cost (uint32)

    YANG Description: Route cost.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Route cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/tag (uint32)

    YANG Description: Route tag of an external LSA.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Route tag of an external LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/type (external-route-type)

    YANG Description: Metric type of an external LSA.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/type (external-route-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Metric type of an external LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with external-route-type""",
          'defined-type': "huawei-ospfv2:external-route-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'type1': {'value': 1}, 'type2': {'value': 2}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='external-route-type', is_config=True)


  def _get_permit_ibgp(self):
    """
    Getter method for permit_ibgp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/permit_ibgp (boolean)

    YANG Description: Enable/disable to import IBGP routes.
    """
    return self.__permit_ibgp
      
  def _set_permit_ibgp(self, v, load=False):
    """
    Setter method for permit_ibgp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/permit_ibgp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_permit_ibgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_permit_ibgp() directly.

    YANG Description: Enable/disable to import IBGP routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permit-ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """permit_ibgp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permit-ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__permit_ibgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_permit_ibgp(self):
    self.__permit_ibgp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="permit-ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_route_policy_name(self):
    """
    Getter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/route_policy_name (leafref)

    YANG Description: Name of a routing policy.
    """
    return self.__route_policy_name
      
  def _set_route_policy_name(self, v, load=False):
    """
    Setter method for route_policy_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route/route_policy_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy_name() directly.

    YANG Description: Name of a routing policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy_name(self):
    self.__route_policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy-name", parent=self, choice=('policy-type', 'route-policy-name'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  protocol = __builtin__.property(_get_protocol, _set_protocol)
  process_id = __builtin__.property(_get_process_id, _set_process_id)
  cost = __builtin__.property(_get_cost, _set_cost)
  tag = __builtin__.property(_get_tag, _set_tag)
  type = __builtin__.property(_get_type, _set_type)
  permit_ibgp = __builtin__.property(_get_permit_ibgp, _set_permit_ibgp)
  route_policy_name = __builtin__.property(_get_route_policy_name, _set_route_policy_name)

  __choices__ = {'policy-type': {'route-policy-name': ['route_policy_name']}}
  _pyangbind_elements = OrderedDict([('protocol', protocol), ('process_id', process_id), ('cost', cost), ('tag', tag), ('type', type), ('permit_ibgp', permit_ibgp), ('route_policy_name', route_policy_name), ])


class yc_import_routes_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/import-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of import the routes learned from other routing protocols.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_route',)

  _yang_name = 'import-routes'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_route = YANGDynClass(base=YANGListType("protocol process_id",yc_import_route_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes_import_route, yang_name="import-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol process-id', extensions=None), is_container='list', yang_name="import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'import-routes']

  def _get_import_route(self):
    """
    Getter method for import_route, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route (list)

    YANG Description: Configure import the routes learned from other routing protocols.
    """
    return self.__import_route
      
  def _set_import_route(self, v, load=False):
    """
    Setter method for import_route, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes/import_route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_route() directly.

    YANG Description: Configure import the routes learned from other routing protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("protocol process_id",yc_import_route_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes_import_route, yang_name="import-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol process-id', extensions=None), is_container='list', yang_name="import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("protocol process_id",yc_import_route_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes_import_route, yang_name="import-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol process-id', extensions=None), is_container='list', yang_name="import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__import_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_route(self):
    self.__import_route = YANGDynClass(base=YANGListType("protocol process_id",yc_import_route_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes_import_route, yang_name="import-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol process-id', extensions=None), is_container='list', yang_name="import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  import_route = __builtin__.property(_get_import_route, _set_import_route) # type: yc_import_route_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes_import_route


  _pyangbind_elements = OrderedDict([('import_route', import_route), ])


class yc_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces_silent_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/silent-interfaces/silent-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure interface. To prevent the OSPF routing information from being received by routers in a network segment and forbid the local router to receive the routing update information that is advertised by other routers in the network segment, you can use the silent interface command to suppress the interface to receive or send the OSPF packets.
  """
  __slots__ = ('_path_helper', '_extmethods', '__if_name',)

  _yang_name = 'silent-interface'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'silent-interfaces', 'silent-interface']

  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_interfaces/silent_interface/if_name (leafref)

    YANG Description: Interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_interfaces/silent_interface/if_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  if_name = __builtin__.property(_get_if_name, _set_if_name)


  _pyangbind_elements = OrderedDict([('if_name', if_name), ])


class yc_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/silent-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of interface. To prevent the OSPF routing information from being received by routers in a network segment and forbid the local router to receive the routing update information that is advertised by other routers in the network segment, you can use the silent interface command to suppress the interface to receive or send the OSPF packets.
  """
  __slots__ = ('_path_helper', '_extmethods', '__silent_interface',)

  _yang_name = 'silent-interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__silent_interface = YANGDynClass(base=YANGListType("if_name",yc_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces_silent_interface, yang_name="silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'silent-interfaces']

  def _get_silent_interface(self):
    """
    Getter method for silent_interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_interfaces/silent_interface (list)

    YANG Description: Configure interface. To prevent the OSPF routing information from being received by routers in a network segment and forbid the local router to receive the routing update information that is advertised by other routers in the network segment, you can use the silent interface command to suppress the interface to receive or send the OSPF packets.
    """
    return self.__silent_interface
      
  def _set_silent_interface(self, v, load=False):
    """
    Setter method for silent_interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_interfaces/silent_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_silent_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_silent_interface() directly.

    YANG Description: Configure interface. To prevent the OSPF routing information from being received by routers in a network segment and forbid the local router to receive the routing update information that is advertised by other routers in the network segment, you can use the silent interface command to suppress the interface to receive or send the OSPF packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("if_name",yc_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces_silent_interface, yang_name="silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """silent_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("if_name",yc_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces_silent_interface, yang_name="silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__silent_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_silent_interface(self):
    self.__silent_interface = YANGDynClass(base=YANGListType("if_name",yc_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces_silent_interface, yang_name="silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  silent_interface = __builtin__.property(_get_silent_interface, _set_silent_interface) # type: yc_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces_silent_interface


  _pyangbind_elements = OrderedDict([('silent_interface', silent_interface), ])


class yc_undo_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces_undo_silent_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/undo-silent-interfaces/undo-silent-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure interface. Enables sending and receiving packet on this interface when true. This information is useful when sending and receiving packet is suppressed on all interface on process level and user want it to be enabled on certain interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__if_name',)

  _yang_name = 'undo-silent-interface'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'undo-silent-interfaces', 'undo-silent-interface']

  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/undo_silent_interfaces/undo_silent_interface/if_name (leafref)

    YANG Description: Interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/undo_silent_interfaces/undo_silent_interface/if_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  if_name = __builtin__.property(_get_if_name, _set_if_name)


  _pyangbind_elements = OrderedDict([('if_name', if_name), ])


class yc_undo_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/undo-silent-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of interface. Enables sending and receiving packet on this interface when true. This information is useful when sending and receiving packet is suppressed on all interface on process level and user want it to be enabled on certain interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__undo_silent_interface',)

  _yang_name = 'undo-silent-interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__undo_silent_interface = YANGDynClass(base=YANGListType("if_name",yc_undo_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces_undo_silent_interface, yang_name="undo-silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="undo-silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'undo-silent-interfaces']

  def _get_undo_silent_interface(self):
    """
    Getter method for undo_silent_interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/undo_silent_interfaces/undo_silent_interface (list)

    YANG Description: Configure interface. Enables sending and receiving packet on this interface when true. This information is useful when sending and receiving packet is suppressed on all interface on process level and user want it to be enabled on certain interface.
    """
    return self.__undo_silent_interface
      
  def _set_undo_silent_interface(self, v, load=False):
    """
    Setter method for undo_silent_interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/undo_silent_interfaces/undo_silent_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_undo_silent_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_undo_silent_interface() directly.

    YANG Description: Configure interface. Enables sending and receiving packet on this interface when true. This information is useful when sending and receiving packet is suppressed on all interface on process level and user want it to be enabled on certain interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("if_name",yc_undo_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces_undo_silent_interface, yang_name="undo-silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="undo-silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """undo_silent_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("if_name",yc_undo_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces_undo_silent_interface, yang_name="undo-silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="undo-silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__undo_silent_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_undo_silent_interface(self):
    self.__undo_silent_interface = YANGDynClass(base=YANGListType("if_name",yc_undo_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces_undo_silent_interface, yang_name="undo-silent-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-name', extensions=None), is_container='list', yang_name="undo-silent-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  undo_silent_interface = __builtin__.property(_get_undo_silent_interface, _set_undo_silent_interface) # type: yc_undo_silent_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces_undo_silent_interface


  _pyangbind_elements = OrderedDict([('undo_silent_interface', undo_silent_interface), ])


class yc_cost_binding_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings_cost_binding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/cost-bindings/cost-binding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure cost-binding. Indicate cost of routing from indicated router source ID binding interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__if_name',)

  _yang_name = 'cost-binding'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'cost-bindings', 'cost-binding']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings/cost_binding/router_id (inet:ipv4-address-no-zone)

    YANG Description: Source router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings/cost_binding/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Source router ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings/cost_binding/if_name (leafref)

    YANG Description: Interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings/cost_binding/if_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  if_name = __builtin__.property(_get_if_name, _set_if_name)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('if_name', if_name), ])


class yc_cost_bindings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/cost-bindings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of cost-binding. Indicate cost of routing from indicated router source ID binding interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cost_binding',)

  _yang_name = 'cost-bindings'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cost_binding = YANGDynClass(base=YANGListType("router_id if_name",yc_cost_binding_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings_cost_binding, yang_name="cost-binding", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id if-name', extensions=None), is_container='list', yang_name="cost-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'cost-bindings']

  def _get_cost_binding(self):
    """
    Getter method for cost_binding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings/cost_binding (list)

    YANG Description: Configure cost-binding. Indicate cost of routing from indicated router source ID binding interface.
    """
    return self.__cost_binding
      
  def _set_cost_binding(self, v, load=False):
    """
    Setter method for cost_binding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings/cost_binding (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost_binding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost_binding() directly.

    YANG Description: Configure cost-binding. Indicate cost of routing from indicated router source ID binding interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("router_id if_name",yc_cost_binding_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings_cost_binding, yang_name="cost-binding", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id if-name', extensions=None), is_container='list', yang_name="cost-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost_binding must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("router_id if_name",yc_cost_binding_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings_cost_binding, yang_name="cost-binding", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id if-name', extensions=None), is_container='list', yang_name="cost-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__cost_binding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost_binding(self):
    self.__cost_binding = YANGDynClass(base=YANGListType("router_id if_name",yc_cost_binding_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings_cost_binding, yang_name="cost-binding", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id if-name', extensions=None), is_container='list', yang_name="cost-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  cost_binding = __builtin__.property(_get_cost_binding, _set_cost_binding) # type: yc_cost_binding_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings_cost_binding


  _pyangbind_elements = OrderedDict([('cost_binding', cost_binding), ])


class yc_network_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/networks/network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the interface that runs OSPF and the area to which the interface belongs to.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_address','__mask','__description',)

  _yang_name = 'network'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'networks', 'network']

  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network/ip_address (inet:ipv4-address-no-zone)

    YANG Description: Specifies the address of the network segment where the interface resides.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network/ip_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: Specifies the address of the network segment where the interface resides.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_mask(self):
    """
    Getter method for mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network/mask (inet:ipv4-address-no-zone)

    YANG Description: Specifies the wildcard mask of IP address.
    """
    return self.__mask
      
  def _set_mask(self, v, load=False):
    """
    Setter method for mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network/mask (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask() directly.

    YANG Description: Specifies the wildcard mask of IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask(self):
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network/description (string)

    YANG Description: Specifies the description of the specified OSPF network segment.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Specifies the description of the specified OSPF network segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  mask = __builtin__.property(_get_mask, _set_mask)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('ip_address', ip_address), ('mask', mask), ('description', description), ])


class yc_networks_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/networks. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the interface that runs OSPF and the area to which the interface belongs to.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network',)

  _yang_name = 'networks'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network = YANGDynClass(base=YANGListType("ip_address mask",yc_network_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address mask', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'networks']

  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network (list)

    YANG Description: Configure the interface that runs OSPF and the area to which the interface belongs to.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks/network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: Configure the interface that runs OSPF and the area to which the interface belongs to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip_address mask",yc_network_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address mask', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address mask",yc_network_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address mask', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=YANGListType("ip_address mask",yc_network_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address mask', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  network = __builtin__.property(_get_network, _set_network) # type: yc_network_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks_network


  _pyangbind_elements = OrderedDict([('network', network), ])


class yc_stub_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_stub(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/stub. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure stub area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__backbone_peer_ignore','__no_summary','__default_cost',)

  _yang_name = 'stub'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__backbone_peer_ignore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__no_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__default_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'stub']

  def _get_backbone_peer_ignore(self):
    """
    Getter method for backbone_peer_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub/backbone_peer_ignore (boolean)

    YANG Description: Enable/disable ignore backbone peer for Stub area.
    """
    return self.__backbone_peer_ignore
      
  def _set_backbone_peer_ignore(self, v, load=False):
    """
    Setter method for backbone_peer_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub/backbone_peer_ignore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backbone_peer_ignore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backbone_peer_ignore() directly.

    YANG Description: Enable/disable ignore backbone peer for Stub area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backbone_peer_ignore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__backbone_peer_ignore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backbone_peer_ignore(self):
    self.__backbone_peer_ignore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_no_summary(self):
    """
    Getter method for no_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub/no_summary (boolean)

    YANG Description: Enable/disable forbid an ABR to Send Summary LSAs to the Stub Area.
    """
    return self.__no_summary
      
  def _set_no_summary(self, v, load=False):
    """
    Setter method for no_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub/no_summary (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_summary() directly.

    YANG Description: Enable/disable forbid an ABR to Send Summary LSAs to the Stub Area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_summary must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__no_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_summary(self):
    self.__no_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_default_cost(self):
    """
    Getter method for default_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub/default_cost (int32)

    YANG Description: Cost of the default Type3 routes that are sent by an OSPF process to a stub area or an NSSA area. The value is an integer ranging from 1 to 16777214. This parameter takes effect only when it is configured on the ABR connected to a stub area or an NSSA area. The default is 1.
    """
    return self.__default_cost
      
  def _set_default_cost(self, v, load=False):
    """
    Setter method for default_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub/default_cost (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_cost() directly.

    YANG Description: Cost of the default Type3 routes that are sent by an OSPF process to a stub area or an NSSA area. The value is an integer ranging from 1 to 16777214. This parameter takes effect only when it is configured on the ABR connected to a stub area or an NSSA area. The default is 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_cost must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__default_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_cost(self):
    self.__default_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

  backbone_peer_ignore = __builtin__.property(_get_backbone_peer_ignore, _set_backbone_peer_ignore)
  no_summary = __builtin__.property(_get_no_summary, _set_no_summary)
  default_cost = __builtin__.property(_get_default_cost, _set_default_cost)


  _pyangbind_elements = OrderedDict([('backbone_peer_ignore', backbone_peer_ignore), ('no_summary', no_summary), ('default_cost', default_cost), ])


class yc_nssa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_nssa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/nssa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure nssa area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__no_summary','__translator_always','__default_route_advertise','__backbone_peer_ignore','__no_import_route','__set_n_bit','__suppress_fa','__zero_address_forwarding','__translator_interval','__default_cost',)

  _yang_name = 'nssa'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__no_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__translator_always = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="translator-always", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__default_route_advertise = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route-advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__backbone_peer_ignore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__no_import_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__set_n_bit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-n-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__suppress_fa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-fa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__zero_address_forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="zero-address-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__translator_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="translator-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__default_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'nssa']

  def _get_no_summary(self):
    """
    Getter method for no_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/no_summary (boolean)

    YANG Description: Enable/disable forbid an ABR to Send Summary LSAs to the NSSA Area.
    """
    return self.__no_summary
      
  def _set_no_summary(self, v, load=False):
    """
    Setter method for no_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/no_summary (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_summary() directly.

    YANG Description: Enable/disable forbid an ABR to Send Summary LSAs to the NSSA Area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_summary must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__no_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_summary(self):
    self.__no_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_translator_always(self):
    """
    Getter method for translator_always, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/translator_always (boolean)

    YANG Description: Enable/disable the router to act as translator always for NSSA Area.
    """
    return self.__translator_always
      
  def _set_translator_always(self, v, load=False):
    """
    Setter method for translator_always, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/translator_always (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_translator_always is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_translator_always() directly.

    YANG Description: Enable/disable the router to act as translator always for NSSA Area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="translator-always", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """translator_always must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="translator-always", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__translator_always = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_translator_always(self):
    self.__translator_always = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="translator-always", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_default_route_advertise(self):
    """
    Getter method for default_route_advertise, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/default_route_advertise (boolean)

    YANG Description: Enable/disable originate Type 7 default into NSSA area.
    """
    return self.__default_route_advertise
      
  def _set_default_route_advertise(self, v, load=False):
    """
    Setter method for default_route_advertise, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/default_route_advertise (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_route_advertise is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_route_advertise() directly.

    YANG Description: Enable/disable originate Type 7 default into NSSA area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route-advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_route_advertise must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route-advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__default_route_advertise = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_route_advertise(self):
    self.__default_route_advertise = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route-advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_backbone_peer_ignore(self):
    """
    Getter method for backbone_peer_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/backbone_peer_ignore (boolean)

    YANG Description: Enable/disable ignore backbone peer for Nssa area.
    """
    return self.__backbone_peer_ignore
      
  def _set_backbone_peer_ignore(self, v, load=False):
    """
    Setter method for backbone_peer_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/backbone_peer_ignore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backbone_peer_ignore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backbone_peer_ignore() directly.

    YANG Description: Enable/disable ignore backbone peer for Nssa area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backbone_peer_ignore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__backbone_peer_ignore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backbone_peer_ignore(self):
    self.__backbone_peer_ignore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="backbone-peer-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_no_import_route(self):
    """
    Getter method for no_import_route, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/no_import_route (boolean)

    YANG Description: Enable/disable redistribute type 7 LSA into this area.
    """
    return self.__no_import_route
      
  def _set_no_import_route(self, v, load=False):
    """
    Setter method for no_import_route, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/no_import_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_import_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_import_route() directly.

    YANG Description: Enable/disable redistribute type 7 LSA into this area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_import_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__no_import_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_import_route(self):
    self.__no_import_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-import-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_set_n_bit(self):
    """
    Getter method for set_n_bit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/set_n_bit (boolean)

    YANG Description: Enable/disable setting of 'N' bit in the DD packet.
    """
    return self.__set_n_bit
      
  def _set_set_n_bit(self, v, load=False):
    """
    Setter method for set_n_bit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/set_n_bit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_set_n_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_set_n_bit() directly.

    YANG Description: Enable/disable setting of 'N' bit in the DD packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-n-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """set_n_bit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-n-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__set_n_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_set_n_bit(self):
    self.__set_n_bit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="set-n-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_suppress_fa(self):
    """
    Getter method for suppress_fa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/suppress_fa (boolean)

    YANG Description: Enable/disable the forwarding address as 0 for all translated type 5 LSAs.
    """
    return self.__suppress_fa
      
  def _set_suppress_fa(self, v, load=False):
    """
    Setter method for suppress_fa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/suppress_fa (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_fa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_fa() directly.

    YANG Description: Enable/disable the forwarding address as 0 for all translated type 5 LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-fa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_fa must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-fa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__suppress_fa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_fa(self):
    self.__suppress_fa = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-fa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_zero_address_forwarding(self):
    """
    Getter method for zero_address_forwarding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/zero_address_forwarding (boolean)

    YANG Description: Enable/disable allow zero forwarding address for redistributed type 7 LSA.
    """
    return self.__zero_address_forwarding
      
  def _set_zero_address_forwarding(self, v, load=False):
    """
    Setter method for zero_address_forwarding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/zero_address_forwarding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_zero_address_forwarding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_zero_address_forwarding() directly.

    YANG Description: Enable/disable allow zero forwarding address for redistributed type 7 LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="zero-address-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """zero_address_forwarding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="zero-address-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__zero_address_forwarding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_zero_address_forwarding(self):
    self.__zero_address_forwarding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="zero-address-forwarding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_translator_interval(self):
    """
    Getter method for translator_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/translator_interval (uint32)

    YANG Description: Translator interval.
    """
    return self.__translator_interval
      
  def _set_translator_interval(self, v, load=False):
    """
    Setter method for translator_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/translator_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_translator_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_translator_interval() directly.

    YANG Description: Translator interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="translator-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """translator_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="translator-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__translator_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_translator_interval(self):
    self.__translator_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..120']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="translator-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_default_cost(self):
    """
    Getter method for default_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/default_cost (int32)

    YANG Description: Cost of the default Type3 routes that are sent by an OSPF process to a stub area or an NSSA area. This parameter takes effect only when it is configured on the ABR connected to a stub area or an NSSA area.
    """
    return self.__default_cost
      
  def _set_default_cost(self, v, load=False):
    """
    Setter method for default_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa/default_cost (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_cost() directly.

    YANG Description: Cost of the default Type3 routes that are sent by an OSPF process to a stub area or an NSSA area. This parameter takes effect only when it is configured on the ABR connected to a stub area or an NSSA area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_cost must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__default_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_cost(self):
    self.__default_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..16777214']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="default-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

  no_summary = __builtin__.property(_get_no_summary, _set_no_summary)
  translator_always = __builtin__.property(_get_translator_always, _set_translator_always)
  default_route_advertise = __builtin__.property(_get_default_route_advertise, _set_default_route_advertise)
  backbone_peer_ignore = __builtin__.property(_get_backbone_peer_ignore, _set_backbone_peer_ignore)
  no_import_route = __builtin__.property(_get_no_import_route, _set_no_import_route)
  set_n_bit = __builtin__.property(_get_set_n_bit, _set_set_n_bit)
  suppress_fa = __builtin__.property(_get_suppress_fa, _set_suppress_fa)
  zero_address_forwarding = __builtin__.property(_get_zero_address_forwarding, _set_zero_address_forwarding)
  translator_interval = __builtin__.property(_get_translator_interval, _set_translator_interval)
  default_cost = __builtin__.property(_get_default_cost, _set_default_cost)


  _pyangbind_elements = OrderedDict([('no_summary', no_summary), ('translator_always', translator_always), ('default_route_advertise', default_route_advertise), ('backbone_peer_ignore', backbone_peer_ignore), ('no_import_route', no_import_route), ('set_n_bit', set_n_bit), ('suppress_fa', suppress_fa), ('zero_address_forwarding', zero_address_forwarding), ('translator_interval', translator_interval), ('default_cost', default_cost), ])


class yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_ldp_sync(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/ldp-sync. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer ldp sync.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__timer','__infinite',)

  _yang_name = 'ldp-sync'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__infinite = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'ldp-sync']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync/enable (boolean)

    YANG Description: Enable/disable LDP and OSPF synchronization on area.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable LDP and OSPF synchronization on area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync/timer (uint32)

    YANG Description: The interval for sending OSPF LSAs to advertise the maximum metric on the local device.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync/timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: The interval for sending OSPF LSAs to advertise the maximum metric on the local device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_infinite(self):
    """
    Getter method for infinite, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync/infinite (boolean)

    YANG Description: Enable/disable always advertise the maximum cost.
    """
    return self.__infinite
      
  def _set_infinite(self, v, load=False):
    """
    Setter method for infinite, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync/infinite (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_infinite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_infinite() directly.

    YANG Description: Enable/disable always advertise the maximum cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """infinite must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__infinite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_infinite(self):
    self.__infinite = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  timer = __builtin__.property(_get_timer, _set_timer)
  infinite = __builtin__.property(_get_infinite, _set_infinite)

  __choices__ = {'hold-cost-max': {'timer': ['timer'], 'infinite': ['infinite']}}
  _pyangbind_elements = OrderedDict([('enable', enable), ('timer', timer), ('infinite', infinite), ])


class yc_mpls_te_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_mpls_te(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/mpls-te. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF processes enabled with the TE capability.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__standard_complying',)

  _yang_name = 'mpls-te'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__standard_complying = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standard-complying", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'mpls-te']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/mpls_te/enable (boolean)

    YANG Description: Enable/disable TE capability of the OSPF process in the specified area.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/mpls_te/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable TE capability of the OSPF process in the specified area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_standard_complying(self):
    """
    Getter method for standard_complying, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/mpls_te/standard_complying (boolean)

    YANG Description: Enable/disable accept the LSAs in standard format only.
    """
    return self.__standard_complying
      
  def _set_standard_complying(self, v, load=False):
    """
    Setter method for standard_complying, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/mpls_te/standard_complying (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_standard_complying is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_standard_complying() directly.

    YANG Description: Enable/disable accept the LSAs in standard format only.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standard-complying", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """standard_complying must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standard-complying", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__standard_complying = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_standard_complying(self):
    self.__standard_complying = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="standard-complying", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  standard_complying = __builtin__.property(_get_standard_complying, _set_standard_complying)


  _pyangbind_elements = OrderedDict([('enable', enable), ('standard_complying', standard_complying), ])


class yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_authentication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/authentication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure authentication.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode','__auth_text_simple','__key_id','__auth_text_md5','__key_chain_name',)

  _yang_name = 'authentication'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'md5': {'value': 64}, 'hmac-sha256': {'value': 2}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-authen-mode', is_config=True)
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'authentication']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/mode (area-authen-mode)

    YANG Description: Set authentication type.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/mode (area-authen-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Set authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'md5': {'value': 64}, 'hmac-sha256': {'value': 2}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-authen-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with area-authen-mode""",
          'defined-type': "huawei-ospfv2:area-authen-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'md5': {'value': 64}, 'hmac-sha256': {'value': 2}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-authen-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'md5': {'value': 64}, 'hmac-sha256': {'value': 2}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-authen-mode', is_config=True)


  def _get_auth_text_simple(self):
    """
    Getter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/auth_text_simple (pub-type:password)

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    return self.__auth_text_simple
      
  def _set_auth_text_simple(self, v, load=False):
    """
    Setter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/auth_text_simple (pub-type:password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_simple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_simple() directly.

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_simple must be of a type compatible with pub-type:password""",
          'defined-type': "pub-type:password",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)""",
        })

    self.__auth_text_simple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_simple(self):
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)


  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/key_id (uint32)

    YANG Description: Authentication identifier.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/key_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Authentication identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_auth_text_md5(self):
    """
    Getter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/auth_text_md5 (pub-type:password-extend)

    YANG Description: Encrypted authentication password.
    """
    return self.__auth_text_md5
      
  def _set_auth_text_md5(self, v, load=False):
    """
    Setter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/auth_text_md5 (pub-type:password-extend)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_md5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_md5() directly.

    YANG Description: Encrypted authentication password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_md5 must be of a type compatible with pub-type:password-extend""",
          'defined-type': "pub-type:password-extend",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)""",
        })

    self.__auth_text_md5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_md5(self):
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)


  def _get_key_chain_name(self):
    """
    Getter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/key_chain_name (string)

    YANG Description: Keychain name.
    """
    return self.__key_chain_name
      
  def _set_key_chain_name(self, v, load=False):
    """
    Setter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication/key_chain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain_name() directly.

    YANG Description: Keychain name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__key_chain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain_name(self):
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)
  auth_text_simple = __builtin__.property(_get_auth_text_simple, _set_auth_text_simple)
  key_id = __builtin__.property(_get_key_id, _set_key_id)
  auth_text_md5 = __builtin__.property(_get_auth_text_md5, _set_auth_text_md5)
  key_chain_name = __builtin__.property(_get_key_chain_name, _set_key_chain_name)


  _pyangbind_elements = OrderedDict([('mode', mode), ('auth_text_simple', auth_text_simple), ('key_id', key_id), ('auth_text_md5', auth_text_md5), ('key_chain_name', key_chain_name), ])


class yc_abr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs_abr_summary_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/abr-summary-prefixs/abr-summary-prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure ABR route aggregation method.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__network_mask','__cost_value','__cost_inherit_min','__hold_max_cost','__advertise','__generate_null_zero',)

  _yang_name = 'abr-summary-prefix'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__network_mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__cost_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__cost_inherit_min = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cost-inherit-min", parent=self, choice=('cost', 'cost-inherit-min'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__hold_max_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['10..1800']}), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__advertise = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__generate_null_zero = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'abr-summary-prefixs', 'abr-summary-prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/prefix (inet:ipv4-address-no-zone)

    YANG Description: Specifies the IP address in dotted decimal notation.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/prefix (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Specifies the IP address in dotted decimal notation.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_network_mask(self):
    """
    Getter method for network_mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/network_mask (inet:ipv4-address-no-zone)

    YANG Description: Specifies the mask of the IP address. The mask address is in dotted decimal notation.
    """
    return self.__network_mask
      
  def _set_network_mask(self, v, load=False):
    """
    Setter method for network_mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/network_mask (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_mask() directly.

    YANG Description: Specifies the mask of the IP address. The mask address is in dotted decimal notation.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_mask must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__network_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_mask(self):
    self.__network_mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_cost_value(self):
    """
    Getter method for cost_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/cost_value (uint32)

    YANG Description: Specifies the cost of the aggregated route. By default, the maximal cost in that of all the routes which are aggregated serves as the cost of the aggregated route.
    """
    return self.__cost_value
      
  def _set_cost_value(self, v, load=False):
    """
    Setter method for cost_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/cost_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost_value() directly.

    YANG Description: Specifies the cost of the aggregated route. By default, the maximal cost in that of all the routes which are aggregated serves as the cost of the aggregated route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost_value(self):
    self.__cost_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..16777214']}), is_leaf=True, yang_name="cost-value", parent=self, choice=('cost', 'cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_cost_inherit_min(self):
    """
    Getter method for cost_inherit_min, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/cost_inherit_min (empty)

    YANG Description: Indicates if minimum cost should be inherited. By default, maximum cost is inherited.
    """
    return self.__cost_inherit_min
      
  def _set_cost_inherit_min(self, v, load=False):
    """
    Setter method for cost_inherit_min, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/cost_inherit_min (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost_inherit_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost_inherit_min() directly.

    YANG Description: Indicates if minimum cost should be inherited. By default, maximum cost is inherited.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="cost-inherit-min", parent=self, choice=('cost', 'cost-inherit-min'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost_inherit_min must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cost-inherit-min", parent=self, choice=('cost', 'cost-inherit-min'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__cost_inherit_min = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost_inherit_min(self):
    self.__cost_inherit_min = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="cost-inherit-min", parent=self, choice=('cost', 'cost-inherit-min'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_hold_max_cost(self):
    """
    Getter method for hold_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/hold_max_cost (uint16)

    YANG Description: Hold max cost duration.
    """
    return self.__hold_max_cost
      
  def _set_hold_max_cost(self, v, load=False):
    """
    Setter method for hold_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/hold_max_cost (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_max_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_max_cost() directly.

    YANG Description: Hold max cost duration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['10..1800']}), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_max_cost must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['10..1800']}), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__hold_max_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_max_cost(self):
    self.__hold_max_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['10..1800']}), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_advertise(self):
    """
    Getter method for advertise, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/advertise (boolean)

    YANG Description: Enable/disable the aggregated route is advertised.
    """
    return self.__advertise
      
  def _set_advertise(self, v, load=False):
    """
    Setter method for advertise, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/advertise (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise() directly.

    YANG Description: Enable/disable the aggregated route is advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__advertise = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise(self):
    self.__advertise = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="advertise", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_generate_null_zero(self):
    """
    Getter method for generate_null_zero, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/generate_null_zero (boolean)

    YANG Description: Enable/disable generate black hole route.
    """
    return self.__generate_null_zero
      
  def _set_generate_null_zero(self, v, load=False):
    """
    Setter method for generate_null_zero, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix/generate_null_zero (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_generate_null_zero is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_generate_null_zero() directly.

    YANG Description: Enable/disable generate black hole route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """generate_null_zero must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__generate_null_zero = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_generate_null_zero(self):
    self.__generate_null_zero = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="generate-null-zero", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  network_mask = __builtin__.property(_get_network_mask, _set_network_mask)
  cost_value = __builtin__.property(_get_cost_value, _set_cost_value)
  cost_inherit_min = __builtin__.property(_get_cost_inherit_min, _set_cost_inherit_min)
  hold_max_cost = __builtin__.property(_get_hold_max_cost, _set_hold_max_cost)
  advertise = __builtin__.property(_get_advertise, _set_advertise)
  generate_null_zero = __builtin__.property(_get_generate_null_zero, _set_generate_null_zero)

  __choices__ = {'cost': {'cost-value': ['cost_value'], 'cost-inherit-min': ['cost_inherit_min']}}
  _pyangbind_elements = OrderedDict([('prefix', prefix), ('network_mask', network_mask), ('cost_value', cost_value), ('cost_inherit_min', cost_inherit_min), ('hold_max_cost', hold_max_cost), ('advertise', advertise), ('generate_null_zero', generate_null_zero), ])


class yc_abr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/abr-summary-prefixs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of ABR route aggregation method.
  """
  __slots__ = ('_path_helper', '_extmethods', '__abr_summary_prefix',)

  _yang_name = 'abr-summary-prefixs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__abr_summary_prefix = YANGDynClass(base=YANGListType("prefix network_mask",yc_abr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs_abr_summary_prefix, yang_name="abr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="abr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'abr-summary-prefixs']

  def _get_abr_summary_prefix(self):
    """
    Getter method for abr_summary_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix (list)

    YANG Description: Configure ABR route aggregation method.
    """
    return self.__abr_summary_prefix
      
  def _set_abr_summary_prefix(self, v, load=False):
    """
    Setter method for abr_summary_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs/abr_summary_prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_summary_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_summary_prefix() directly.

    YANG Description: Configure ABR route aggregation method.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix network_mask",yc_abr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs_abr_summary_prefix, yang_name="abr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="abr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_summary_prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix network_mask",yc_abr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs_abr_summary_prefix, yang_name="abr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="abr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__abr_summary_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_summary_prefix(self):
    self.__abr_summary_prefix = YANGDynClass(base=YANGListType("prefix network_mask",yc_abr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs_abr_summary_prefix, yang_name="abr-summary-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix network-mask', extensions=None), is_container='list', yang_name="abr-summary-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  abr_summary_prefix = __builtin__.property(_get_abr_summary_prefix, _set_abr_summary_prefix) # type: yc_abr_summary_prefix_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs_abr_summary_prefix


  _pyangbind_elements = OrderedDict([('abr_summary_prefix', abr_summary_prefix), ])


class yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_timer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/vlink-peers/vlink-peer/timer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hello_interval','__dead_interval','__trans_delay_interval',)

  _yang_name = 'timer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__trans_delay_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'vlink-peers', 'vlink-peer', 'timer']

  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer/hello_interval (uint32)

    YANG Description: Time between Hello packets.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer/hello_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Time between Hello packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_dead_interval(self):
    """
    Getter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer/dead_interval (uint32)

    YANG Description: Interval after which a neighbor is declared dead.
    """
    return self.__dead_interval
      
  def _set_dead_interval(self, v, load=False):
    """
    Setter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer/dead_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_interval() directly.

    YANG Description: Interval after which a neighbor is declared dead.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__dead_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_interval(self):
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_trans_delay_interval(self):
    """
    Getter method for trans_delay_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer/trans_delay_interval (uint32)

    YANG Description: Delay for transmitting LSAs.
    """
    return self.__trans_delay_interval
      
  def _set_trans_delay_interval(self, v, load=False):
    """
    Setter method for trans_delay_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer/trans_delay_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trans_delay_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trans_delay_interval() directly.

    YANG Description: Delay for transmitting LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trans_delay_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__trans_delay_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trans_delay_interval(self):
    self.__trans_delay_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  hello_interval = __builtin__.property(_get_hello_interval, _set_hello_interval)
  dead_interval = __builtin__.property(_get_dead_interval, _set_dead_interval)
  trans_delay_interval = __builtin__.property(_get_trans_delay_interval, _set_trans_delay_interval)


  _pyangbind_elements = OrderedDict([('hello_interval', hello_interval), ('dead_interval', dead_interval), ('trans_delay_interval', trans_delay_interval), ])


class yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_authentication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/vlink-peers/vlink-peer/authentication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure authentication.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode','__auth_text_simple','__key_id','__auth_text_md5','__key_chain_name',)

  _yang_name = 'authentication'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'vlink-peers', 'vlink-peer', 'authentication']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/mode (intf-authen-mode)

    YANG Description: Set authentication type: Simple authentication type, Md5/HMAC MD5/HMAC SHA256 authentication type.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/mode (intf-authen-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Set authentication type: Simple authentication type, Md5/HMAC MD5/HMAC SHA256 authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with intf-authen-mode""",
          'defined-type': "huawei-ospfv2:intf-authen-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)


  def _get_auth_text_simple(self):
    """
    Getter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/auth_text_simple (pub-type:password)

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    return self.__auth_text_simple
      
  def _set_auth_text_simple(self, v, load=False):
    """
    Setter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/auth_text_simple (pub-type:password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_simple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_simple() directly.

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_simple must be of a type compatible with pub-type:password""",
          'defined-type': "pub-type:password",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)""",
        })

    self.__auth_text_simple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_simple(self):
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)


  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/key_id (uint32)

    YANG Description: Authentication identifier.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/key_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Authentication identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_auth_text_md5(self):
    """
    Getter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/auth_text_md5 (pub-type:password-extend)

    YANG Description: MD5/HMAC MD5/HMAC SHA256 authentication password.
    """
    return self.__auth_text_md5
      
  def _set_auth_text_md5(self, v, load=False):
    """
    Setter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/auth_text_md5 (pub-type:password-extend)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_md5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_md5() directly.

    YANG Description: MD5/HMAC MD5/HMAC SHA256 authentication password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_md5 must be of a type compatible with pub-type:password-extend""",
          'defined-type': "pub-type:password-extend",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)""",
        })

    self.__auth_text_md5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_md5(self):
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)


  def _get_key_chain_name(self):
    """
    Getter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/key_chain_name (string)

    YANG Description: Keychain name.
    """
    return self.__key_chain_name
      
  def _set_key_chain_name(self, v, load=False):
    """
    Setter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication/key_chain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain_name() directly.

    YANG Description: Keychain name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__key_chain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain_name(self):
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)
  auth_text_simple = __builtin__.property(_get_auth_text_simple, _set_auth_text_simple)
  key_id = __builtin__.property(_get_key_id, _set_key_id)
  auth_text_md5 = __builtin__.property(_get_auth_text_md5, _set_auth_text_md5)
  key_chain_name = __builtin__.property(_get_key_chain_name, _set_key_chain_name)


  _pyangbind_elements = OrderedDict([('mode', mode), ('auth_text_simple', auth_text_simple), ('key_id', key_id), ('auth_text_md5', auth_text_md5), ('key_chain_name', key_chain_name), ])


class yc_vlink_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/vlink-peers/vlink-peer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure virtual link and its parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__retransmit_interval','__smart_discover','__timer','__authentication',)

  _yang_name = 'vlink-peer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'vlink-peers', 'vlink-peer']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/router_id (inet:ipv4-address-no-zone)

    YANG Description: Neighbor Router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Neighbor Router ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_retransmit_interval(self):
    """
    Getter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/retransmit_interval (uint32)

    YANG Description: Interval for retransmitting LSAs.
    """
    return self.__retransmit_interval
      
  def _set_retransmit_interval(self, v, load=False):
    """
    Setter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/retransmit_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_interval() directly.

    YANG Description: Interval for retransmitting LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__retransmit_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_interval(self):
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_smart_discover(self):
    """
    Getter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/smart_discover (boolean)

    YANG Description: Enable/disable smart discover feature.
    """
    return self.__smart_discover
      
  def _set_smart_discover(self, v, load=False):
    """
    Setter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/smart_discover (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smart_discover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smart_discover() directly.

    YANG Description: Enable/disable smart discover feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smart_discover must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__smart_discover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smart_discover(self):
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer (container)

    YANG Description: Configure timer.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/timer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Configure timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_authentication(self):
    """
    Getter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication (container)

    YANG Description: Configure authentication.
    """
    return self.__authentication
      
  def _set_authentication(self, v, load=False):
    """
    Setter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer/authentication (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication() directly.

    YANG Description: Configure authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__authentication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication(self):
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  retransmit_interval = __builtin__.property(_get_retransmit_interval, _set_retransmit_interval)
  smart_discover = __builtin__.property(_get_smart_discover, _set_smart_discover)
  timer = __builtin__.property(_get_timer, _set_timer) # type: yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_timer
  authentication = __builtin__.property(_get_authentication, _set_authentication) # type: yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer_authentication


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('retransmit_interval', retransmit_interval), ('smart_discover', smart_discover), ('timer', timer), ('authentication', authentication), ])


class yc_vlink_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/vlink-peers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of virtual link and its parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vlink_peer',)

  _yang_name = 'vlink-peers'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlink_peer = YANGDynClass(base=YANGListType("router_id",yc_vlink_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer, yang_name="vlink-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="vlink-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'vlink-peers']

  def _get_vlink_peer(self):
    """
    Getter method for vlink_peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer (list)

    YANG Description: Configure virtual link and its parameters.
    """
    return self.__vlink_peer
      
  def _set_vlink_peer(self, v, load=False):
    """
    Setter method for vlink_peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers/vlink_peer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlink_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlink_peer() directly.

    YANG Description: Configure virtual link and its parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("router_id",yc_vlink_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer, yang_name="vlink-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="vlink-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlink_peer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("router_id",yc_vlink_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer, yang_name="vlink-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="vlink-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__vlink_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlink_peer(self):
    self.__vlink_peer = YANGDynClass(base=YANGListType("router_id",yc_vlink_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer, yang_name="vlink-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id', extensions=None), is_container='list', yang_name="vlink-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  vlink_peer = __builtin__.property(_get_vlink_peer, _set_vlink_peer) # type: yc_vlink_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers_vlink_peer


  _pyangbind_elements = OrderedDict([('vlink_peer', vlink_peer), ])


class yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_timer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/sham-links/sham-link/timer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hello_interval','__dead_interval','__trans_delay_interval',)

  _yang_name = 'timer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__trans_delay_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'sham-links', 'sham-link', 'timer']

  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer/hello_interval (uint32)

    YANG Description: Time between Hello packets.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer/hello_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Time between Hello packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_dead_interval(self):
    """
    Getter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer/dead_interval (uint32)

    YANG Description: Interval after which a neighbor is declared dead.
    """
    return self.__dead_interval
      
  def _set_dead_interval(self, v, load=False):
    """
    Setter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer/dead_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_interval() directly.

    YANG Description: Interval after which a neighbor is declared dead.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__dead_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_interval(self):
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(40), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_trans_delay_interval(self):
    """
    Getter method for trans_delay_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer/trans_delay_interval (uint32)

    YANG Description: Delay for transmitting LSAs.
    """
    return self.__trans_delay_interval
      
  def _set_trans_delay_interval(self, v, load=False):
    """
    Setter method for trans_delay_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer/trans_delay_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trans_delay_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trans_delay_interval() directly.

    YANG Description: Delay for transmitting LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trans_delay_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__trans_delay_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trans_delay_interval(self):
    self.__trans_delay_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="trans-delay-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  hello_interval = __builtin__.property(_get_hello_interval, _set_hello_interval)
  dead_interval = __builtin__.property(_get_dead_interval, _set_dead_interval)
  trans_delay_interval = __builtin__.property(_get_trans_delay_interval, _set_trans_delay_interval)


  _pyangbind_elements = OrderedDict([('hello_interval', hello_interval), ('dead_interval', dead_interval), ('trans_delay_interval', trans_delay_interval), ])


class yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_authentication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/sham-links/sham-link/authentication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure authentication.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode','__auth_text_simple','__key_id','__auth_text_md5','__key_chain_name',)

  _yang_name = 'authentication'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'sham-links', 'sham-link', 'authentication']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/mode (intf-authen-mode)

    YANG Description: Set authentication type: Simple authentication type, Md5/HMAC MD5/HMAC SHA256 authentication type.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/mode (intf-authen-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Set authentication type: Simple authentication type, Md5/HMAC MD5/HMAC SHA256 authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with intf-authen-mode""",
          'defined-type': "huawei-ospfv2:intf-authen-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)


  def _get_auth_text_simple(self):
    """
    Getter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/auth_text_simple (pub-type:password)

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    return self.__auth_text_simple
      
  def _set_auth_text_simple(self, v, load=False):
    """
    Setter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/auth_text_simple (pub-type:password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_simple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_simple() directly.

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_simple must be of a type compatible with pub-type:password""",
          'defined-type': "pub-type:password",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)""",
        })

    self.__auth_text_simple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_simple(self):
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)


  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/key_id (uint32)

    YANG Description: Authentication identifier.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/key_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Authentication identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_auth_text_md5(self):
    """
    Getter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/auth_text_md5 (pub-type:password-extend)

    YANG Description: MD5/HMAC MD5/HMAC SHA256 authentication password.
    """
    return self.__auth_text_md5
      
  def _set_auth_text_md5(self, v, load=False):
    """
    Setter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/auth_text_md5 (pub-type:password-extend)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_md5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_md5() directly.

    YANG Description: MD5/HMAC MD5/HMAC SHA256 authentication password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_md5 must be of a type compatible with pub-type:password-extend""",
          'defined-type': "pub-type:password-extend",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)""",
        })

    self.__auth_text_md5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_md5(self):
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)


  def _get_key_chain_name(self):
    """
    Getter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/key_chain_name (string)

    YANG Description: Keychain name.
    """
    return self.__key_chain_name
      
  def _set_key_chain_name(self, v, load=False):
    """
    Setter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication/key_chain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain_name() directly.

    YANG Description: Keychain name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__key_chain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain_name(self):
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)
  auth_text_simple = __builtin__.property(_get_auth_text_simple, _set_auth_text_simple)
  key_id = __builtin__.property(_get_key_id, _set_key_id)
  auth_text_md5 = __builtin__.property(_get_auth_text_md5, _set_auth_text_md5)
  key_chain_name = __builtin__.property(_get_key_chain_name, _set_key_chain_name)


  _pyangbind_elements = OrderedDict([('mode', mode), ('auth_text_simple', auth_text_simple), ('key_id', key_id), ('auth_text_md5', auth_text_md5), ('key_chain_name', key_chain_name), ])


class yc_sham_link_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/sham-links/sham-link. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure sham link and its parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__src_addr','__dest_addr','__cost','__retransmit_interval','__smart_discover','__timer','__authentication',)

  _yang_name = 'sham-link'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__src_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__dest_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'sham-links', 'sham-link']

  def _get_src_addr(self):
    """
    Getter method for src_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/src_addr (inet:ipv4-address-no-zone)

    YANG Description: Source address.
    """
    return self.__src_addr
      
  def _set_src_addr(self, v, load=False):
    """
    Setter method for src_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/src_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_addr() directly.

    YANG Description: Source address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__src_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_addr(self):
    self.__src_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_dest_addr(self):
    """
    Getter method for dest_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/dest_addr (inet:ipv4-address-no-zone)

    YANG Description: Destination address.
    """
    return self.__dest_addr
      
  def _set_dest_addr(self, v, load=False):
    """
    Setter method for dest_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/dest_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_addr() directly.

    YANG Description: Destination address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__dest_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_addr(self):
    self.__dest_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/cost (uint32)

    YANG Description: Cost.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_retransmit_interval(self):
    """
    Getter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/retransmit_interval (uint32)

    YANG Description: Interval for retransmitting LSAs.
    """
    return self.__retransmit_interval
      
  def _set_retransmit_interval(self, v, load=False):
    """
    Setter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/retransmit_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_interval() directly.

    YANG Description: Interval for retransmitting LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__retransmit_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_interval(self):
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_smart_discover(self):
    """
    Getter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/smart_discover (boolean)

    YANG Description: Enable/disable smart discover feature.
    """
    return self.__smart_discover
      
  def _set_smart_discover(self, v, load=False):
    """
    Setter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/smart_discover (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smart_discover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smart_discover() directly.

    YANG Description: Enable/disable smart discover feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smart_discover must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__smart_discover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smart_discover(self):
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer (container)

    YANG Description: Configure timer.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/timer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Configure timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_authentication(self):
    """
    Getter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication (container)

    YANG Description: Configure authentication.
    """
    return self.__authentication
      
  def _set_authentication(self, v, load=False):
    """
    Setter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link/authentication (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication() directly.

    YANG Description: Configure authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__authentication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication(self):
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  src_addr = __builtin__.property(_get_src_addr, _set_src_addr)
  dest_addr = __builtin__.property(_get_dest_addr, _set_dest_addr)
  cost = __builtin__.property(_get_cost, _set_cost)
  retransmit_interval = __builtin__.property(_get_retransmit_interval, _set_retransmit_interval)
  smart_discover = __builtin__.property(_get_smart_discover, _set_smart_discover)
  timer = __builtin__.property(_get_timer, _set_timer) # type: yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_timer
  authentication = __builtin__.property(_get_authentication, _set_authentication) # type: yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link_authentication


  _pyangbind_elements = OrderedDict([('src_addr', src_addr), ('dest_addr', dest_addr), ('cost', cost), ('retransmit_interval', retransmit_interval), ('smart_discover', smart_discover), ('timer', timer), ('authentication', authentication), ])


class yc_sham_links_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/sham-links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of sham link and its parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__sham_link',)

  _yang_name = 'sham-links'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sham_link = YANGDynClass(base=YANGListType("src_addr dest_addr",yc_sham_link_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-addr dest-addr', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'sham-links']

  def _get_sham_link(self):
    """
    Getter method for sham_link, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link (list)

    YANG Description: Configure sham link and its parameters.
    """
    return self.__sham_link
      
  def _set_sham_link(self, v, load=False):
    """
    Setter method for sham_link, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links/sham_link (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sham_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sham_link() directly.

    YANG Description: Configure sham link and its parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("src_addr dest_addr",yc_sham_link_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-addr dest-addr', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sham_link must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("src_addr dest_addr",yc_sham_link_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-addr dest-addr', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__sham_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sham_link(self):
    self.__sham_link = YANGDynClass(base=YANGListType("src_addr dest_addr",yc_sham_link_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='src-addr dest-addr', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  sham_link = __builtin__.property(_get_sham_link, _set_sham_link) # type: yc_sham_link_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links_sham_link


  _pyangbind_elements = OrderedDict([('sham_link', sham_link), ])


class yc_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters_filter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure ABR to filter outgoing or incoming summary LSAs of the local area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode','__name_or_num','__ip_prefix','__route_policy','__route_filter','__include_abr_summary',)

  _yang_name = 'filter'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'filter-import': {'value': 0}, 'filter-export': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-filter-mode', is_config=True)
    self.__name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__route_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__include_abr_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-abr-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'filters', 'filter']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/mode (area-filter-mode)

    YANG Description: Using the filter export command, you can configure an ABR to filter outgoing summary LSAs of the local area. Using the filter import command, you can configure an ABR to filter incoming summary LSAs of the local area.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/mode (area-filter-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Using the filter export command, you can configure an ABR to filter outgoing summary LSAs of the local area. Using the filter import command, you can configure an ABR to filter incoming summary LSAs of the local area.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'filter-import': {'value': 0}, 'filter-export': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-filter-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with area-filter-mode""",
          'defined-type': "huawei-ospfv2:area-filter-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'filter-import': {'value': 0}, 'filter-export': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-filter-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'filter-import': {'value': 0}, 'filter-export': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-filter-mode', is_config=True)


  def _get_name_or_num(self):
    """
    Getter method for name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/name_or_num (leafref)

    YANG Description: Apply basic ACL Name or ACL Number.
    """
    return self.__name_or_num
      
  def _set_name_or_num(self, v, load=False):
    """
    Setter method for name_or_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/name_or_num (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name_or_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name_or_num() directly.

    YANG Description: Apply basic ACL Name or ACL Number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name_or_num must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__name_or_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name_or_num(self):
    self.__name_or_num = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name-or-num", parent=self, choice=('policy-type', 'basic-acl'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_ip_prefix(self):
    """
    Getter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/ip_prefix (leafref)

    YANG Description: Set the name of an IP prefix list.
    """
    return self.__ip_prefix
      
  def _set_ip_prefix(self, v, load=False):
    """
    Setter method for ip_prefix, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/ip_prefix (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefix() directly.

    YANG Description: Set the name of an IP prefix list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefix must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefix(self):
    self.__ip_prefix = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-prefix", parent=self, choice=('policy-type', 'ip-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_policy(self):
    """
    Getter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/route_policy (leafref)

    YANG Description: Set a route policy name.
    """
    return self.__route_policy
      
  def _set_route_policy(self, v, load=False):
    """
    Setter method for route_policy, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/route_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policy() directly.

    YANG Description: Set a route policy name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policy(self):
    self.__route_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-policy", parent=self, choice=('policy-type', 'route-policy'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_route_filter(self):
    """
    Getter method for route_filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/route_filter (leafref)

    YANG Description: Set a route filter name.
    """
    return self.__route_filter
      
  def _set_route_filter(self, v, load=False):
    """
    Setter method for route_filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/route_filter (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_filter() directly.

    YANG Description: Set a route filter name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_filter must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__route_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_filter(self):
    self.__route_filter = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="route-filter", parent=self, choice=('policy-type', 'route-filter'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_include_abr_summary(self):
    """
    Getter method for include_abr_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/include_abr_summary (boolean)

    YANG Description: Enable/disable include abr summary flag.
    """
    return self.__include_abr_summary
      
  def _set_include_abr_summary(self, v, load=False):
    """
    Setter method for include_abr_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter/include_abr_summary (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_abr_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_abr_summary() directly.

    YANG Description: Enable/disable include abr summary flag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-abr-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_abr_summary must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-abr-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__include_abr_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_abr_summary(self):
    self.__include_abr_summary = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="include-abr-summary", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)
  name_or_num = __builtin__.property(_get_name_or_num, _set_name_or_num)
  ip_prefix = __builtin__.property(_get_ip_prefix, _set_ip_prefix)
  route_policy = __builtin__.property(_get_route_policy, _set_route_policy)
  route_filter = __builtin__.property(_get_route_filter, _set_route_filter)
  include_abr_summary = __builtin__.property(_get_include_abr_summary, _set_include_abr_summary)

  __choices__ = {'policy-type': {'basic-acl': ['name_or_num'], 'ip-prefix': ['ip_prefix'], 'route-policy': ['route_policy'], 'route-filter': ['route_filter']}}
  _pyangbind_elements = OrderedDict([('mode', mode), ('name_or_num', name_or_num), ('ip_prefix', ip_prefix), ('route_policy', route_policy), ('route_filter', route_filter), ('include_abr_summary', include_abr_summary), ])


class yc_filters_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/filters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of ABR to filter outgoing or incoming summary LSAs of the local area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__filter',)

  _yang_name = 'filters'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__filter = YANGDynClass(base=YANGListType("mode",yc_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters_filter, yang_name="filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode', extensions=None), is_container='list', yang_name="filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'filters']

  def _get_filter(self):
    """
    Getter method for filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter (list)

    YANG Description: Configure ABR to filter outgoing or incoming summary LSAs of the local area.
    """
    return self.__filter
      
  def _set_filter(self, v, load=False):
    """
    Setter method for filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters/filter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter() directly.

    YANG Description: Configure ABR to filter outgoing or incoming summary LSAs of the local area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mode",yc_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters_filter, yang_name="filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode', extensions=None), is_container='list', yang_name="filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mode",yc_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters_filter, yang_name="filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode', extensions=None), is_container='list', yang_name="filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter(self):
    self.__filter = YANGDynClass(base=YANGListType("mode",yc_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters_filter, yang_name="filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mode', extensions=None), is_container='list', yang_name="filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  filter = __builtin__.property(_get_filter, _set_filter) # type: yc_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters_filter


  _pyangbind_elements = OrderedDict([('filter', filter), ])


class yc_ti_lfa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr_ti_lfa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/ti-lfa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure topology independent loop free alternate (TILFA) computation using segment routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__disable',)

  _yang_name = 'ti-lfa'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'frr', 'ti-lfa']

  def _get_disable(self):
    """
    Getter method for disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/ti_lfa/disable (boolean)

    YANG Description: Enable/disable topology independent LFA on the interface except Loopback.
    """
    return self.__disable
      
  def _set_disable(self, v, load=False):
    """
    Setter method for disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/ti_lfa/disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable() directly.

    YANG Description: Enable/disable topology independent LFA on the interface except Loopback.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable(self):
    self.__disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  disable = __builtin__.property(_get_disable, _set_disable)


  _pyangbind_elements = OrderedDict([('disable', disable), ])


class yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure FRR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frr_disable','__rlfa_disable','__ti_lfa',)

  _yang_name = 'frr'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frr_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__rlfa_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__ti_lfa = YANGDynClass(base=yc_ti_lfa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr_ti_lfa, is_container='container', yang_name="ti-lfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'frr']

  def _get_frr_disable(self):
    """
    Getter method for frr_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/frr_disable (boolean)

    YANG Description: Enable/disable not use this interface for FRR calculation.
    """
    return self.__frr_disable
      
  def _set_frr_disable(self, v, load=False):
    """
    Setter method for frr_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/frr_disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_disable() directly.

    YANG Description: Enable/disable not use this interface for FRR calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__frr_disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_disable(self):
    self.__frr_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_rlfa_disable(self):
    """
    Getter method for rlfa_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/rlfa_disable (boolean)

    YANG Description: Enable/disable remote LFA of the Interface.
    """
    return self.__rlfa_disable
      
  def _set_rlfa_disable(self, v, load=False):
    """
    Setter method for rlfa_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/rlfa_disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfa_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfa_disable() directly.

    YANG Description: Enable/disable remote LFA of the Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfa_disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__rlfa_disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfa_disable(self):
    self.__rlfa_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_ti_lfa(self):
    """
    Getter method for ti_lfa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/ti_lfa (container)

    YANG Description: Configure topology independent loop free alternate (TILFA) computation using segment routing.
    """
    return self.__ti_lfa
      
  def _set_ti_lfa(self, v, load=False):
    """
    Setter method for ti_lfa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr/ti_lfa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ti_lfa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ti_lfa() directly.

    YANG Description: Configure topology independent loop free alternate (TILFA) computation using segment routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ti_lfa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr_ti_lfa, is_container='container', yang_name="ti-lfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ti_lfa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ti_lfa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr_ti_lfa, is_container='container', yang_name="ti-lfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ti_lfa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ti_lfa(self):
    self.__ti_lfa = YANGDynClass(base=yc_ti_lfa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr_ti_lfa, is_container='container', yang_name="ti-lfa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  frr_disable = __builtin__.property(_get_frr_disable, _set_frr_disable)
  rlfa_disable = __builtin__.property(_get_rlfa_disable, _set_rlfa_disable)
  ti_lfa = __builtin__.property(_get_ti_lfa, _set_ti_lfa) # type: yc_ti_lfa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr_ti_lfa


  _pyangbind_elements = OrderedDict([('frr_disable', frr_disable), ('rlfa_disable', rlfa_disable), ('ti_lfa', ti_lfa), ])


class yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_timer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hello_interval','__hello_conser','__dead_interval','__wait_interval','__poll_interval','__retransmit_interval',)

  _yang_name = 'timer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__hello_conser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hello-conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__wait_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__poll_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(120), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'timer']

  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/hello_interval (int32)

    YANG Description: Interval for sending hello packets on an interface.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/hello_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval for sending hello packets on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_hello_conser(self):
    """
    Getter method for hello_conser, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/hello_conser (boolean)

    YANG Description: Enable/disable the compensation mechanism of controling the deadtimer to enable.
    """
    return self.__hello_conser
      
  def _set_hello_conser(self, v, load=False):
    """
    Setter method for hello_conser, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/hello_conser (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_conser is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_conser() directly.

    YANG Description: Enable/disable the compensation mechanism of controling the deadtimer to enable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hello-conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_conser must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hello-conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__hello_conser = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_conser(self):
    self.__hello_conser = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hello-conser", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_dead_interval(self):
    """
    Getter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/dead_interval (int32)

    YANG Description: Dead interval of an OSPF neighbor.
    """
    return self.__dead_interval
      
  def _set_dead_interval(self, v, load=False):
    """
    Setter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/dead_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_interval() directly.

    YANG Description: Dead interval of an OSPF neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__dead_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_interval(self):
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_wait_interval(self):
    """
    Getter method for wait_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/wait_interval (uint32)

    YANG Description: Wait time.
    """
    return self.__wait_interval
      
  def _set_wait_interval(self, v, load=False):
    """
    Setter method for wait_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/wait_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait_interval() directly.

    YANG Description: Wait time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__wait_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait_interval(self):
    self.__wait_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="wait-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_poll_interval(self):
    """
    Getter method for poll_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/poll_interval (int32)

    YANG Description: Poll interval for sending hello packets. On the NBMA network, after the neighbor is invalid, the router sends hello packets periodically according to the interval set through the ospf timer poll command. The poll interval should be at least four times of the interval for sending hello packets.
    """
    return self.__poll_interval
      
  def _set_poll_interval(self, v, load=False):
    """
    Setter method for poll_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/poll_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_poll_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_poll_interval() directly.

    YANG Description: Poll interval for sending hello packets. On the NBMA network, after the neighbor is invalid, the router sends hello packets periodically according to the interval set through the ospf timer poll command. The poll interval should be at least four times of the interval for sending hello packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(120), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """poll_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(120), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__poll_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_poll_interval(self):
    self.__poll_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(120), is_leaf=True, yang_name="poll-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_retransmit_interval(self):
    """
    Getter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/retransmit_interval (int32)

    YANG Description: Interval for retransmitting LSAs on an interface.
    """
    return self.__retransmit_interval
      
  def _set_retransmit_interval(self, v, load=False):
    """
    Setter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer/retransmit_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_interval() directly.

    YANG Description: Interval for retransmitting LSAs on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__retransmit_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_interval(self):
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

  hello_interval = __builtin__.property(_get_hello_interval, _set_hello_interval)
  hello_conser = __builtin__.property(_get_hello_conser, _set_hello_conser)
  dead_interval = __builtin__.property(_get_dead_interval, _set_dead_interval)
  wait_interval = __builtin__.property(_get_wait_interval, _set_wait_interval)
  poll_interval = __builtin__.property(_get_poll_interval, _set_poll_interval)
  retransmit_interval = __builtin__.property(_get_retransmit_interval, _set_retransmit_interval)


  _pyangbind_elements = OrderedDict([('hello_interval', hello_interval), ('hello_conser', hello_conser), ('dead_interval', dead_interval), ('wait_interval', wait_interval), ('poll_interval', poll_interval), ('retransmit_interval', retransmit_interval), ])


class yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_ldp_sync(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp-sync. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer ldp sync.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hold_down_timer','__timer','__infinite',)

  _yang_name = 'ldp-sync'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hold_down_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__infinite = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'ldp-sync']

  def _get_hold_down_timer(self):
    """
    Getter method for hold_down_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync/hold_down_timer (uint16)

    YANG Description: Hold down interval.
    """
    return self.__hold_down_timer
      
  def _set_hold_down_timer(self, v, load=False):
    """
    Setter method for hold_down_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync/hold_down_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_down_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_down_timer() directly.

    YANG Description: Hold down interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_down_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__hold_down_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_down_timer(self):
    self.__hold_down_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync/timer (uint16)

    YANG Description: Max cost interval range.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync/timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Max cost interval range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_infinite(self):
    """
    Getter method for infinite, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync/infinite (empty)

    YANG Description: Always advertise the maximum cost.
    """
    return self.__infinite
      
  def _set_infinite(self, v, load=False):
    """
    Setter method for infinite, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync/infinite (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_infinite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_infinite() directly.

    YANG Description: Always advertise the maximum cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """infinite must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__infinite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_infinite(self):
    self.__infinite = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

  hold_down_timer = __builtin__.property(_get_hold_down_timer, _set_hold_down_timer)
  timer = __builtin__.property(_get_timer, _set_timer)
  infinite = __builtin__.property(_get_infinite, _set_infinite)

  __choices__ = {'hold-cost-max': {'timer': ['timer'], 'infinite': ['infinite']}}
  _pyangbind_elements = OrderedDict([('hold_down_timer', hold_down_timer), ('timer', timer), ('infinite', infinite), ])


class yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__block','__detect_multiplier','__min_tx','__min_rx','__frr_binding','__incr_cost_block','__incr_cost_value','__per_link_flag','__one_arm_echo_flag',)

  _yang_name = 'bfd'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__detect_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__min_tx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__min_rx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__frr_binding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__incr_cost_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="incr-cost-block", parent=self, choice=('incr-cost', 'incr-cost-block'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__incr_cost_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost-value", parent=self, choice=('incr-cost', 'incr-cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__per_link_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="per-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__one_arm_echo_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="one-arm-echo-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'bfd']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/enable (boolean)

    YANG Description: Enable/disable BFD.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_block(self):
    """
    Getter method for block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/block (boolean)

    YANG Description: Enable/disable to prevent the dynamic establishment of a BFD session on an interface.
    """
    return self.__block
      
  def _set_block(self, v, load=False):
    """
    Setter method for block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_block() directly.

    YANG Description: Enable/disable to prevent the dynamic establishment of a BFD session on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_block(self):
    self.__block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_detect_multiplier(self):
    """
    Getter method for detect_multiplier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/detect_multiplier (uint32)

    YANG Description: Local detection multiplier.
    """
    return self.__detect_multiplier
      
  def _set_detect_multiplier(self, v, load=False):
    """
    Setter method for detect_multiplier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/detect_multiplier (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detect_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detect_multiplier() directly.

    YANG Description: Local detection multiplier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detect_multiplier must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__detect_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detect_multiplier(self):
    self.__detect_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..50']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(3), is_leaf=True, yang_name="detect-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_min_tx(self):
    """
    Getter method for min_tx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/min_tx (uint32)

    YANG Description: Minimum interval for sending BFD packets to the peer end. The ranges and the default value is determined by the PAF.
    """
    return self.__min_tx
      
  def _set_min_tx(self, v, load=False):
    """
    Setter method for min_tx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/min_tx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_tx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_tx() directly.

    YANG Description: Minimum interval for sending BFD packets to the peer end. The ranges and the default value is determined by the PAF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_tx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__min_tx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_tx(self):
    self.__min_tx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-tx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_min_rx(self):
    """
    Getter method for min_rx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/min_rx (uint32)

    YANG Description: Minimum interval for receiving BFD packets from the peer end. The ranges and the default value is determined by the PAF.
    """
    return self.__min_rx
      
  def _set_min_rx(self, v, load=False):
    """
    Setter method for min_rx, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/min_rx (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_rx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_rx() directly.

    YANG Description: Minimum interval for receiving BFD packets from the peer end. The ranges and the default value is determined by the PAF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_rx must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__min_rx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_rx(self):
    self.__min_rx = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['3..20000']}), is_leaf=True, yang_name="min-rx", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_frr_binding(self):
    """
    Getter method for frr_binding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/frr_binding (boolean)

    YANG Description: Enable/disable bind FRR with BFD.
    """
    return self.__frr_binding
      
  def _set_frr_binding(self, v, load=False):
    """
    Setter method for frr_binding, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/frr_binding (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_binding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_binding() directly.

    YANG Description: Enable/disable bind FRR with BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_binding must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__frr_binding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_binding(self):
    self.__frr_binding = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_incr_cost_block(self):
    """
    Getter method for incr_cost_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/incr_cost_block (empty)

    YANG Description: Interface BFD sync cost block.
    """
    return self.__incr_cost_block
      
  def _set_incr_cost_block(self, v, load=False):
    """
    Setter method for incr_cost_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/incr_cost_block (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_incr_cost_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_incr_cost_block() directly.

    YANG Description: Interface BFD sync cost block.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="incr-cost-block", parent=self, choice=('incr-cost', 'incr-cost-block'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """incr_cost_block must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="incr-cost-block", parent=self, choice=('incr-cost', 'incr-cost-block'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__incr_cost_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_incr_cost_block(self):
    self.__incr_cost_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="incr-cost-block", parent=self, choice=('incr-cost', 'incr-cost-block'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_incr_cost_value(self):
    """
    Getter method for incr_cost_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/incr_cost_value (uint32)

    YANG Description: Interface BFD sync cost.
    """
    return self.__incr_cost_value
      
  def _set_incr_cost_value(self, v, load=False):
    """
    Setter method for incr_cost_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/incr_cost_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_incr_cost_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_incr_cost_value() directly.

    YANG Description: Interface BFD sync cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost-value", parent=self, choice=('incr-cost', 'incr-cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """incr_cost_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost-value", parent=self, choice=('incr-cost', 'incr-cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__incr_cost_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_incr_cost_value(self):
    self.__incr_cost_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="incr-cost-value", parent=self, choice=('incr-cost', 'incr-cost-value'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_per_link_flag(self):
    """
    Getter method for per_link_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/per_link_flag (boolean)

    YANG Description: Enable/disable BFD session per link, support only VLANif interface.
    """
    return self.__per_link_flag
      
  def _set_per_link_flag(self, v, load=False):
    """
    Setter method for per_link_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/per_link_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_per_link_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_per_link_flag() directly.

    YANG Description: Enable/disable BFD session per link, support only VLANif interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="per-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """per_link_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="per-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__per_link_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_per_link_flag(self):
    self.__per_link_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="per-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_one_arm_echo_flag(self):
    """
    Getter method for one_arm_echo_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/one_arm_echo_flag (boolean)

    YANG Description: Enable/disable echo detection mode, support only VLANif interface.
    """
    return self.__one_arm_echo_flag
      
  def _set_one_arm_echo_flag(self, v, load=False):
    """
    Setter method for one_arm_echo_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd/one_arm_echo_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_one_arm_echo_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_one_arm_echo_flag() directly.

    YANG Description: Enable/disable echo detection mode, support only VLANif interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="one-arm-echo-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """one_arm_echo_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="one-arm-echo-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__one_arm_echo_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_one_arm_echo_flag(self):
    self.__one_arm_echo_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="one-arm-echo-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  block = __builtin__.property(_get_block, _set_block)
  detect_multiplier = __builtin__.property(_get_detect_multiplier, _set_detect_multiplier)
  min_tx = __builtin__.property(_get_min_tx, _set_min_tx)
  min_rx = __builtin__.property(_get_min_rx, _set_min_rx)
  frr_binding = __builtin__.property(_get_frr_binding, _set_frr_binding)
  incr_cost_block = __builtin__.property(_get_incr_cost_block, _set_incr_cost_block)
  incr_cost_value = __builtin__.property(_get_incr_cost_value, _set_incr_cost_value)
  per_link_flag = __builtin__.property(_get_per_link_flag, _set_per_link_flag)
  one_arm_echo_flag = __builtin__.property(_get_one_arm_echo_flag, _set_one_arm_echo_flag)

  __choices__ = {'incr-cost': {'incr-cost-block': ['incr_cost_block'], 'incr-cost-value': ['incr_cost_value']}}
  _pyangbind_elements = OrderedDict([('enable', enable), ('block', block), ('detect_multiplier', detect_multiplier), ('min_tx', min_tx), ('min_rx', min_rx), ('frr_binding', frr_binding), ('incr_cost_block', incr_cost_block), ('incr_cost_value', incr_cost_value), ('per_link_flag', per_link_flag), ('one_arm_echo_flag', one_arm_echo_flag), ])


class yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_authentication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure authentication.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode','__auth_text_simple','__key_id','__auth_text_md5','__key_chain_name',)

  _yang_name = 'authentication'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'authentication']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/mode (intf-authen-mode)

    YANG Description: Set Authentication type.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/mode (intf-authen-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Set Authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with intf-authen-mode""",
          'defined-type': "huawei-ospfv2:intf-authen-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)


  def _get_auth_text_simple(self):
    """
    Getter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/auth_text_simple (pub-type:password)

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    return self.__auth_text_simple
      
  def _set_auth_text_simple(self, v, load=False):
    """
    Setter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/auth_text_simple (pub-type:password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_simple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_simple() directly.

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_simple must be of a type compatible with pub-type:password""",
          'defined-type': "pub-type:password",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)""",
        })

    self.__auth_text_simple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_simple(self):
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)


  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/key_id (uint32)

    YANG Description: Authentication identifier.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/key_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Authentication identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_auth_text_md5(self):
    """
    Getter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/auth_text_md5 (pub-type:password-extend)

    YANG Description: Encrypted authentication password.
    """
    return self.__auth_text_md5
      
  def _set_auth_text_md5(self, v, load=False):
    """
    Setter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/auth_text_md5 (pub-type:password-extend)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_md5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_md5() directly.

    YANG Description: Encrypted authentication password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_md5 must be of a type compatible with pub-type:password-extend""",
          'defined-type': "pub-type:password-extend",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)""",
        })

    self.__auth_text_md5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_md5(self):
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)


  def _get_key_chain_name(self):
    """
    Getter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/key_chain_name (string)

    YANG Description: Keychain name.
    """
    return self.__key_chain_name
      
  def _set_key_chain_name(self, v, load=False):
    """
    Setter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication/key_chain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain_name() directly.

    YANG Description: Keychain name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__key_chain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain_name(self):
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)
  auth_text_simple = __builtin__.property(_get_auth_text_simple, _set_auth_text_simple)
  key_id = __builtin__.property(_get_key_id, _set_key_id)
  auth_text_md5 = __builtin__.property(_get_auth_text_md5, _set_auth_text_md5)
  key_chain_name = __builtin__.property(_get_key_chain_name, _set_key_chain_name)


  _pyangbind_elements = OrderedDict([('mode', mode), ('auth_text_simple', auth_text_simple), ('key_id', key_id), ('auth_text_md5', auth_text_md5), ('key_chain_name', key_chain_name), ])


class yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_filter_lsa_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter-lsa-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure filter lsa out.
  """
  __slots__ = ('_path_helper', '_extmethods', '__all_flag','__sum_flag','__ase_flag','__nssa_flag',)

  _yang_name = 'filter-lsa-out'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__all_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__sum_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__ase_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__nssa_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'filter-lsa-out']

  def _get_all_flag(self):
    """
    Getter method for all_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/all_flag (empty)

    YANG Description: Filter all types of LSAs.
    """
    return self.__all_flag
      
  def _set_all_flag(self, v, load=False):
    """
    Setter method for all_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/all_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_all_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_all_flag() directly.

    YANG Description: Filter all types of LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """all_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__all_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_all_flag(self):
    self.__all_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_sum_flag(self):
    """
    Getter method for sum_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/sum_flag (empty)

    YANG Description: Filter type3 summary LSAs.
    """
    return self.__sum_flag
      
  def _set_sum_flag(self, v, load=False):
    """
    Setter method for sum_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/sum_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sum_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sum_flag() directly.

    YANG Description: Filter type3 summary LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sum_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__sum_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sum_flag(self):
    self.__sum_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_ase_flag(self):
    """
    Getter method for ase_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/ase_flag (empty)

    YANG Description: Filter type5 ASE LSAs.
    """
    return self.__ase_flag
      
  def _set_ase_flag(self, v, load=False):
    """
    Setter method for ase_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/ase_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_flag() directly.

    YANG Description: Filter type5 ASE LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__ase_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_flag(self):
    self.__ase_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_nssa_flag(self):
    """
    Getter method for nssa_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/nssa_flag (empty)

    YANG Description: Filter type7 NSSA LSAs.
    """
    return self.__nssa_flag
      
  def _set_nssa_flag(self, v, load=False):
    """
    Setter method for nssa_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out/nssa_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa_flag() directly.

    YANG Description: Filter type7 NSSA LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__nssa_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa_flag(self):
    self.__nssa_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

  all_flag = __builtin__.property(_get_all_flag, _set_all_flag)
  sum_flag = __builtin__.property(_get_sum_flag, _set_sum_flag)
  ase_flag = __builtin__.property(_get_ase_flag, _set_ase_flag)
  nssa_flag = __builtin__.property(_get_nssa_flag, _set_nssa_flag)

  __choices__ = {'type': {'total': ['all_flag'], 'other': ['sum_flag', 'ase_flag', 'nssa_flag']}}
  _pyangbind_elements = OrderedDict([('all_flag', all_flag), ('sum_flag', sum_flag), ('ase_flag', ase_flag), ('nssa_flag', nssa_flag), ])


class yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping_peer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress-flapping/peer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure flapping suppression peer. Not support Loopback.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__detect_interval','__threshold','__resume_interval','__hold_down_interval','__hold_max_cost',)

  _yang_name = 'peer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__detect_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__resume_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_down_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_max_cost = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'suppress-flapping', 'peer']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/enable (boolean)

    YANG Description: Enable/disable interface peer flapping suppress.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable interface peer flapping suppress.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_detect_interval(self):
    """
    Getter method for detect_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/detect_interval (uint32)

    YANG Description: Detecting interval.
    """
    return self.__detect_interval
      
  def _set_detect_interval(self, v, load=False):
    """
    Setter method for detect_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/detect_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detect_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detect_interval() directly.

    YANG Description: Detecting interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detect_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__detect_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detect_interval(self):
    self.__detect_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/threshold (uint32)

    YANG Description: Threshold.
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: Threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_resume_interval(self):
    """
    Getter method for resume_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/resume_interval (uint32)

    YANG Description: Resume interval.
    """
    return self.__resume_interval
      
  def _set_resume_interval(self, v, load=False):
    """
    Setter method for resume_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/resume_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resume_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resume_interval() directly.

    YANG Description: Resume interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resume_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__resume_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resume_interval(self):
    self.__resume_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_down_interval(self):
    """
    Getter method for hold_down_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/hold_down_interval (uint32)

    YANG Description: Hold down interval.
    """
    return self.__hold_down_interval
      
  def _set_hold_down_interval(self, v, load=False):
    """
    Setter method for hold_down_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/hold_down_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_down_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_down_interval() directly.

    YANG Description: Hold down interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_down_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hold_down_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_down_interval(self):
    self.__hold_down_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_max_cost(self):
    """
    Getter method for hold_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/hold_max_cost (boolean)

    YANG Description: Enable/disable hold max cost.
    """
    return self.__hold_max_cost
      
  def _set_hold_max_cost(self, v, load=False):
    """
    Setter method for hold_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer/hold_max_cost (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_max_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_max_cost() directly.

    YANG Description: Enable/disable hold max cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_max_cost must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__hold_max_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_max_cost(self):
    self.__hold_max_cost = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  detect_interval = __builtin__.property(_get_detect_interval, _set_detect_interval)
  threshold = __builtin__.property(_get_threshold, _set_threshold)
  resume_interval = __builtin__.property(_get_resume_interval, _set_resume_interval)
  hold_down_interval = __builtin__.property(_get_hold_down_interval, _set_hold_down_interval)
  hold_max_cost = __builtin__.property(_get_hold_max_cost, _set_hold_max_cost)


  _pyangbind_elements = OrderedDict([('enable', enable), ('detect_interval', detect_interval), ('threshold', threshold), ('resume_interval', resume_interval), ('hold_down_interval', hold_down_interval), ('hold_max_cost', hold_max_cost), ])


class yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress-flapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure flapping suppression.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer',)

  _yang_name = 'suppress-flapping'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer = YANGDynClass(base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'suppress-flapping']

  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer (container)

    YANG Description: Configure flapping suppression peer. Not support Loopback.
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping/peer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.

    YANG Description: Configure flapping suppression peer. Not support Loopback.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  peer = __builtin__.property(_get_peer, _set_peer) # type: yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping_peer


  _pyangbind_elements = OrderedDict([('peer', peer), ])


class yc_flush_source_trace_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_flush_source_trace(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/flush-source-trace. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF flush source trace function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__block',)

  _yang_name = 'flush-source-trace'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'flush-source-trace']

  def _get_block(self):
    """
    Getter method for block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/flush_source_trace/block (boolean)

    YANG Description: Enable/disable OSPF flush source trace.
    """
    return self.__block
      
  def _set_block(self, v, load=False):
    """
    Setter method for block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/flush_source_trace/block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_block() directly.

    YANG Description: Enable/disable OSPF flush source trace.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_block(self):
    self.__block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  block = __builtin__.property(_get_block, _set_block)


  _pyangbind_elements = OrderedDict([('block', block), ])


class yc_proc_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs_proc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls-te-peers/mpls-te-peer/procs/proc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF passive peers area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__pid','__aid','__cost',)

  _yang_name = 'proc'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__pid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__aid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'mpls-te-peers', 'mpls-te-peer', 'procs', 'proc']

  def _get_pid(self):
    """
    Getter method for pid, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc/pid (uint32)

    YANG Description: Process ID.
    """
    return self.__pid
      
  def _set_pid(self, v, load=False):
    """
    Setter method for pid, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc/pid (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pid() directly.

    YANG Description: Process ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pid must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__pid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pid(self):
    self.__pid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="pid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_aid(self):
    """
    Getter method for aid, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc/aid (inet:ipv4-address-no-zone)

    YANG Description: Area ID.
    """
    return self.__aid
      
  def _set_aid(self, v, load=False):
    """
    Setter method for aid, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc/aid (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aid() directly.

    YANG Description: Area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aid must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__aid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aid(self):
    self.__aid = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc/cost (uint32)

    YANG Description: Configuration cost value.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Configuration cost value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  pid = __builtin__.property(_get_pid, _set_pid)
  aid = __builtin__.property(_get_aid, _set_aid)
  cost = __builtin__.property(_get_cost, _set_cost)


  _pyangbind_elements = OrderedDict([('pid', pid), ('aid', aid), ('cost', cost), ])


class yc_procs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls-te-peers/mpls-te-peer/procs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OSPF passive peers area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__proc',)

  _yang_name = 'procs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__proc = YANGDynClass(base=YANGListType("pid aid",yc_proc_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs_proc, yang_name="proc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid aid', extensions=None), is_container='list', yang_name="proc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'mpls-te-peers', 'mpls-te-peer', 'procs']

  def _get_proc(self):
    """
    Getter method for proc, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc (list)

    YANG Description: Configure OSPF passive peers area.
    """
    return self.__proc
      
  def _set_proc(self, v, load=False):
    """
    Setter method for proc, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs/proc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proc() directly.

    YANG Description: Configure OSPF passive peers area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("pid aid",yc_proc_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs_proc, yang_name="proc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid aid', extensions=None), is_container='list', yang_name="proc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """proc must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("pid aid",yc_proc_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs_proc, yang_name="proc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid aid', extensions=None), is_container='list', yang_name="proc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__proc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_proc(self):
    self.__proc = YANGDynClass(base=YANGListType("pid aid",yc_proc_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs_proc, yang_name="proc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='pid aid', extensions=None), is_container='list', yang_name="proc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  proc = __builtin__.property(_get_proc, _set_proc) # type: yc_proc_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs_proc


  _pyangbind_elements = OrderedDict([('proc', proc), ])


class yc_mpls_te_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls-te-peers/mpls-te-peer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF passive peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__router_id','__intf_ip','__procs',)

  _yang_name = 'mpls-te-peer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__intf_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__procs = YANGDynClass(base=yc_procs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs, is_container='container', yang_name="procs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'mpls-te-peers', 'mpls-te-peer']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/id (uint32)

    YANG Description: Neighbor ID.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Neighbor ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/router_id (inet:ipv4-address-no-zone)

    YANG Description: Configure OSPF passive peer router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Configure OSPF passive peer router ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_intf_ip(self):
    """
    Getter method for intf_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/intf_ip (inet:ipv4-address-no-zone)

    YANG Description: Configure interface address of passive peer.
    """
    return self.__intf_ip
      
  def _set_intf_ip(self, v, load=False):
    """
    Setter method for intf_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/intf_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intf_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intf_ip() directly.

    YANG Description: Configure interface address of passive peer.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intf_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__intf_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intf_ip(self):
    self.__intf_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_procs(self):
    """
    Getter method for procs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs (container)

    YANG Description: List of OSPF passive peers area.
    """
    return self.__procs
      
  def _set_procs(self, v, load=False):
    """
    Setter method for procs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer/procs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_procs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_procs() directly.

    YANG Description: List of OSPF passive peers area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_procs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs, is_container='container', yang_name="procs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """procs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_procs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs, is_container='container', yang_name="procs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__procs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_procs(self):
    self.__procs = YANGDynClass(base=yc_procs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs, is_container='container', yang_name="procs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  router_id = __builtin__.property(_get_router_id, _set_router_id)
  intf_ip = __builtin__.property(_get_intf_ip, _set_intf_ip)
  procs = __builtin__.property(_get_procs, _set_procs) # type: yc_procs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer_procs


  _pyangbind_elements = OrderedDict([('id', id), ('router_id', router_id), ('intf_ip', intf_ip), ('procs', procs), ])


class yc_mpls_te_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls-te-peers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OSPF passive peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mpls_te_peer',)

  _yang_name = 'mpls-te-peers'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mpls_te_peer = YANGDynClass(base=YANGListType("id router_id intf_ip",yc_mpls_te_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer, yang_name="mpls-te-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id router-id intf-ip', extensions=None), is_container='list', yang_name="mpls-te-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'mpls-te-peers']

  def _get_mpls_te_peer(self):
    """
    Getter method for mpls_te_peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer (list)

    YANG Description: Configure OSPF passive peer.
    """
    return self.__mpls_te_peer
      
  def _set_mpls_te_peer(self, v, load=False):
    """
    Setter method for mpls_te_peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers/mpls_te_peer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_te_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_te_peer() directly.

    YANG Description: Configure OSPF passive peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id router_id intf_ip",yc_mpls_te_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer, yang_name="mpls-te-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id router-id intf-ip', extensions=None), is_container='list', yang_name="mpls-te-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_te_peer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id router_id intf_ip",yc_mpls_te_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer, yang_name="mpls-te-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id router-id intf-ip', extensions=None), is_container='list', yang_name="mpls-te-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__mpls_te_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_te_peer(self):
    self.__mpls_te_peer = YANGDynClass(base=YANGListType("id router_id intf_ip",yc_mpls_te_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer, yang_name="mpls-te-peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id router-id intf-ip', extensions=None), is_container='list', yang_name="mpls-te-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  mpls_te_peer = __builtin__.property(_get_mpls_te_peer, _set_mpls_te_peer) # type: yc_mpls_te_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers_mpls_te_peer


  _pyangbind_elements = OrderedDict([('mpls_te_peer', mpls_te_peer), ])


class yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_frr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/frr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure frr.
  """
  __slots__ = ('_path_helper', '_extmethods', '__frr_disable','__rlfa_disable','__ti_lfa_disable',)

  _yang_name = 'frr'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frr_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__rlfa_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__ti_lfa_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ti-lfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'frr']

  def _get_frr_disable(self):
    """
    Getter method for frr_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr/frr_disable (boolean)

    YANG Description: Enable/disable use this interface for FRR calculation.
    """
    return self.__frr_disable
      
  def _set_frr_disable(self, v, load=False):
    """
    Setter method for frr_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr/frr_disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr_disable() directly.

    YANG Description: Enable/disable use this interface for FRR calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr_disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__frr_disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr_disable(self):
    self.__frr_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="frr-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_rlfa_disable(self):
    """
    Getter method for rlfa_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr/rlfa_disable (boolean)

    YANG Description: Enable/disable remote LFA of the Interface.
    """
    return self.__rlfa_disable
      
  def _set_rlfa_disable(self, v, load=False):
    """
    Setter method for rlfa_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr/rlfa_disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rlfa_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rlfa_disable() directly.

    YANG Description: Enable/disable remote LFA of the Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rlfa_disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__rlfa_disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rlfa_disable(self):
    self.__rlfa_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rlfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_ti_lfa_disable(self):
    """
    Getter method for ti_lfa_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr/ti_lfa_disable (boolean)

    YANG Description: Enable/disable Topology Independent LFA on the interface except Loopback.
    """
    return self.__ti_lfa_disable
      
  def _set_ti_lfa_disable(self, v, load=False):
    """
    Setter method for ti_lfa_disable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr/ti_lfa_disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ti_lfa_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ti_lfa_disable() directly.

    YANG Description: Enable/disable Topology Independent LFA on the interface except Loopback.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ti-lfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ti_lfa_disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ti-lfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__ti_lfa_disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ti_lfa_disable(self):
    self.__ti_lfa_disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ti-lfa-disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  frr_disable = __builtin__.property(_get_frr_disable, _set_frr_disable)
  rlfa_disable = __builtin__.property(_get_rlfa_disable, _set_rlfa_disable)
  ti_lfa_disable = __builtin__.property(_get_ti_lfa_disable, _set_ti_lfa_disable)


  _pyangbind_elements = OrderedDict([('frr_disable', frr_disable), ('rlfa_disable', rlfa_disable), ('ti_lfa_disable', ti_lfa_disable), ])


class yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_timer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/timer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hello_interval','__dead_interval','__retransmit_interval',)

  _yang_name = 'timer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'timer']

  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer/hello_interval (int32)

    YANG Description: Interval for sending Hello packets on an interface. The default value of p2p and broadcast is 10.The default of p2mp and NBMA is 30.
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer/hello_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval for sending Hello packets on an interface. The default value of p2p and broadcast is 10.The default of p2mp and NBMA is 30.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_dead_interval(self):
    """
    Getter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer/dead_interval (int32)

    YANG Description: Dead interval of an OSPF neighbor. The default value of p2p and broadcast is 40.The default of p2mp and NBMA is 120.
    """
    return self.__dead_interval
      
  def _set_dead_interval(self, v, load=False):
    """
    Setter method for dead_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer/dead_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_interval() directly.

    YANG Description: Dead interval of an OSPF neighbor. The default value of p2p and broadcast is 40.The default of p2mp and NBMA is 120.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__dead_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_interval(self):
    self.__dead_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..235926000']}), is_leaf=True, yang_name="dead-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_retransmit_interval(self):
    """
    Getter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer/retransmit_interval (int32)

    YANG Description: Interval for Retransmitting LSAs on an Interface.
    """
    return self.__retransmit_interval
      
  def _set_retransmit_interval(self, v, load=False):
    """
    Setter method for retransmit_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer/retransmit_interval (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmit_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmit_interval() directly.

    YANG Description: Interval for Retransmitting LSAs on an Interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmit_interval must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__retransmit_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmit_interval(self):
    self.__retransmit_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..3600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(5), is_leaf=True, yang_name="retransmit-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)

  hello_interval = __builtin__.property(_get_hello_interval, _set_hello_interval)
  dead_interval = __builtin__.property(_get_dead_interval, _set_dead_interval)
  retransmit_interval = __builtin__.property(_get_retransmit_interval, _set_retransmit_interval)


  _pyangbind_elements = OrderedDict([('hello_interval', hello_interval), ('dead_interval', dead_interval), ('retransmit_interval', retransmit_interval), ])


class yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_ldp_sync(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/ldp-sync. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure timer ldp sync.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hold_down_timer','__timer','__infinite',)

  _yang_name = 'ldp-sync'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hold_down_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__infinite = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'ldp-sync']

  def _get_hold_down_timer(self):
    """
    Getter method for hold_down_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync/hold_down_timer (uint16)

    YANG Description: Hold down interval range.
    """
    return self.__hold_down_timer
      
  def _set_hold_down_timer(self, v, load=False):
    """
    Setter method for hold_down_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync/hold_down_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_down_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_down_timer() directly.

    YANG Description: Hold down interval range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_down_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__hold_down_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_down_timer(self):
    self.__hold_down_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(10), is_leaf=True, yang_name="hold-down-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync/timer (uint16)

    YANG Description: Max cost interval range.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync/timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Max cost interval range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="timer", parent=self, choice=('hold-cost-max', 'timer'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_infinite(self):
    """
    Getter method for infinite, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync/infinite (empty)

    YANG Description: Always advertise the maximum cost.
    """
    return self.__infinite
      
  def _set_infinite(self, v, load=False):
    """
    Setter method for infinite, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync/infinite (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_infinite is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_infinite() directly.

    YANG Description: Always advertise the maximum cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """infinite must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__infinite = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_infinite(self):
    self.__infinite = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="infinite", parent=self, choice=('hold-cost-max', 'infinite'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

  hold_down_timer = __builtin__.property(_get_hold_down_timer, _set_hold_down_timer)
  timer = __builtin__.property(_get_timer, _set_timer)
  infinite = __builtin__.property(_get_infinite, _set_infinite)

  __choices__ = {'hold-cost-max': {'timer': ['timer'], 'infinite': ['infinite']}}
  _pyangbind_elements = OrderedDict([('hold_down_timer', hold_down_timer), ('timer', timer), ('infinite', infinite), ])


class yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__block',)

  _yang_name = 'bfd'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'bfd']

  def _get_block(self):
    """
    Getter method for block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/bfd/block (boolean)

    YANG Description: Enable/disable prevent the dynamic establishment of a BFD session on an interface.
    """
    return self.__block
      
  def _set_block(self, v, load=False):
    """
    Setter method for block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/bfd/block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_block() directly.

    YANG Description: Enable/disable prevent the dynamic establishment of a BFD session on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_block(self):
    self.__block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  block = __builtin__.property(_get_block, _set_block)


  _pyangbind_elements = OrderedDict([('block', block), ])


class yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_authentication(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/authentication. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure authentication.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode','__auth_text_simple','__key_id','__auth_text_md5','__key_chain_name',)

  _yang_name = 'authentication'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'authentication']

  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/mode (intf-authen-mode)

    YANG Description: Set Authentication type.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/mode (intf-authen-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Set Authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with intf-authen-mode""",
          'defined-type': "huawei-ospfv2:intf-authen-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'null': {'value': 16}, 'hmac-sha256': {'value': 2}, 'md5': {'value': 64}, 'hmac-md5': {'value': 128}, 'simple': {'value': 32}, 'keychain': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-authen-mode', is_config=True)


  def _get_auth_text_simple(self):
    """
    Getter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/auth_text_simple (pub-type:password)

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    return self.__auth_text_simple
      
  def _set_auth_text_simple(self, v, load=False):
    """
    Setter method for auth_text_simple, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/auth_text_simple (pub-type:password)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_simple is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_simple() directly.

    YANG Description: Simple authentication key. The password is a string ranging from 1 to 8 characters for a unencrypted password and 24 to 128 characters for a encrypted password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_simple must be of a type compatible with pub-type:password""",
          'defined-type': "pub-type:password",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)""",
        })

    self.__auth_text_simple = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_simple(self):
    self.__auth_text_simple = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..128']}), is_leaf=True, yang_name="auth-text-simple", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password', is_config=True)


  def _get_key_id(self):
    """
    Getter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/key_id (uint32)

    YANG Description: Authentication identifier.
    """
    return self.__key_id
      
  def _set_key_id(self, v, load=False):
    """
    Setter method for key_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/key_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_id() directly.

    YANG Description: Authentication identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__key_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_id(self):
    self.__key_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="key-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_auth_text_md5(self):
    """
    Getter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/auth_text_md5 (pub-type:password-extend)

    YANG Description: MD5/HMAC-MD5/HMAC-SHA256 Authentication Password.
    """
    return self.__auth_text_md5
      
  def _set_auth_text_md5(self, v, load=False):
    """
    Setter method for auth_text_md5, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/auth_text_md5 (pub-type:password-extend)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_text_md5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_text_md5() directly.

    YANG Description: MD5/HMAC-MD5/HMAC-SHA256 Authentication Password.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_text_md5 must be of a type compatible with pub-type:password-extend""",
          'defined-type': "pub-type:password-extend",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)""",
        })

    self.__auth_text_md5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_text_md5(self):
    self.__auth_text_md5 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..432']}), is_leaf=True, yang_name="auth-text-md5", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pub-type:password-extend', is_config=True)


  def _get_key_chain_name(self):
    """
    Getter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/key_chain_name (string)

    YANG Description: Keychain Name.
    """
    return self.__key_chain_name
      
  def _set_key_chain_name(self, v, load=False):
    """
    Setter method for key_chain_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication/key_chain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain_name() directly.

    YANG Description: Keychain Name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__key_chain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain_name(self):
    self.__key_chain_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[^A-Z]+', 'length': ['1..47']}), is_leaf=True, yang_name="key-chain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)

  mode = __builtin__.property(_get_mode, _set_mode)
  auth_text_simple = __builtin__.property(_get_auth_text_simple, _set_auth_text_simple)
  key_id = __builtin__.property(_get_key_id, _set_key_id)
  auth_text_md5 = __builtin__.property(_get_auth_text_md5, _set_auth_text_md5)
  key_chain_name = __builtin__.property(_get_key_chain_name, _set_key_chain_name)


  _pyangbind_elements = OrderedDict([('mode', mode), ('auth_text_simple', auth_text_simple), ('key_id', key_id), ('auth_text_md5', auth_text_md5), ('key_chain_name', key_chain_name), ])


class yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_filter_lsa_out(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/filter-lsa-out. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure filter-lsa-out.
  """
  __slots__ = ('_path_helper', '_extmethods', '__all_flag','__sum_flag','__ase_flag','__nssa_flag',)

  _yang_name = 'filter-lsa-out'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__all_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__sum_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__ase_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    self.__nssa_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'filter-lsa-out']

  def _get_all_flag(self):
    """
    Getter method for all_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/all_flag (empty)

    YANG Description: Filter all types of LSAs.
    """
    return self.__all_flag
      
  def _set_all_flag(self, v, load=False):
    """
    Setter method for all_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/all_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_all_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_all_flag() directly.

    YANG Description: Filter all types of LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """all_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__all_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_all_flag(self):
    self.__all_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all-flag", parent=self, choice=('type', 'total'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_sum_flag(self):
    """
    Getter method for sum_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/sum_flag (empty)

    YANG Description: Filter type-3 Summary LSAs.
    """
    return self.__sum_flag
      
  def _set_sum_flag(self, v, load=False):
    """
    Setter method for sum_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/sum_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sum_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sum_flag() directly.

    YANG Description: Filter type-3 Summary LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sum_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__sum_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sum_flag(self):
    self.__sum_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sum-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_ase_flag(self):
    """
    Getter method for ase_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/ase_flag (empty)

    YANG Description: Filter type-5 ASE LSAs.
    """
    return self.__ase_flag
      
  def _set_ase_flag(self, v, load=False):
    """
    Setter method for ase_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/ase_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase_flag() directly.

    YANG Description: Filter type-5 ASE LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__ase_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase_flag(self):
    self.__ase_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ase-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)


  def _get_nssa_flag(self):
    """
    Getter method for nssa_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/nssa_flag (empty)

    YANG Description: Filter type-7 NSSA LSAs.
    """
    return self.__nssa_flag
      
  def _set_nssa_flag(self, v, load=False):
    """
    Setter method for nssa_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out/nssa_flag (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa_flag() directly.

    YANG Description: Filter type-7 NSSA LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa_flag must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)""",
        })

    self.__nssa_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa_flag(self):
    self.__nssa_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-flag", parent=self, choice=('type', 'other'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='empty', is_config=True)

  all_flag = __builtin__.property(_get_all_flag, _set_all_flag)
  sum_flag = __builtin__.property(_get_sum_flag, _set_sum_flag)
  ase_flag = __builtin__.property(_get_ase_flag, _set_ase_flag)
  nssa_flag = __builtin__.property(_get_nssa_flag, _set_nssa_flag)

  __choices__ = {'type': {'total': ['all_flag'], 'other': ['sum_flag', 'ase_flag', 'nssa_flag']}}
  _pyangbind_elements = OrderedDict([('all_flag', all_flag), ('sum_flag', sum_flag), ('ase_flag', ase_flag), ('nssa_flag', nssa_flag), ])


class yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping_peer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/suppress-flapping/peer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure flapping suppression peer. Not support Loopback.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__detect_interval','__threshold','__resume_interval','__hold_down_interval','__hold_max_cost',)

  _yang_name = 'peer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__detect_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__resume_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_down_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__hold_max_cost = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'suppress-flapping', 'peer']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/enable (boolean)

    YANG Description: Enable/disable interface peer flapping suppress.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable interface peer flapping suppress.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_detect_interval(self):
    """
    Getter method for detect_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/detect_interval (uint32)

    YANG Description: Detecting-interval.
    """
    return self.__detect_interval
      
  def _set_detect_interval(self, v, load=False):
    """
    Setter method for detect_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/detect_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detect_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detect_interval() directly.

    YANG Description: Detecting-interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detect_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__detect_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detect_interval(self):
    self.__detect_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..300']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(60), is_leaf=True, yang_name="detect-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/threshold (uint32)

    YANG Description: Threshold.
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: Threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_resume_interval(self):
    """
    Getter method for resume_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/resume_interval (uint32)

    YANG Description: Resume-interval.
    """
    return self.__resume_interval
      
  def _set_resume_interval(self, v, load=False):
    """
    Setter method for resume_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/resume_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resume_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resume_interval() directly.

    YANG Description: Resume-interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resume_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__resume_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resume_interval(self):
    self.__resume_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(120), is_leaf=True, yang_name="resume-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_down_interval(self):
    """
    Getter method for hold_down_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/hold_down_interval (uint32)

    YANG Description: Hold-down-interval.
    """
    return self.__hold_down_interval
      
  def _set_hold_down_interval(self, v, load=False):
    """
    Setter method for hold_down_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/hold_down_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_down_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_down_interval() directly.

    YANG Description: Hold-down-interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_down_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__hold_down_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_down_interval(self):
    self.__hold_down_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..86400']}), is_leaf=True, yang_name="hold-down-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_hold_max_cost(self):
    """
    Getter method for hold_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/hold_max_cost (boolean)

    YANG Description: Enable/disable hold max cost.
    """
    return self.__hold_max_cost
      
  def _set_hold_max_cost(self, v, load=False):
    """
    Setter method for hold_max_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer/hold_max_cost (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_max_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_max_cost() directly.

    YANG Description: Enable/disable hold max cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_max_cost must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__hold_max_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_max_cost(self):
    self.__hold_max_cost = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="hold-max-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  detect_interval = __builtin__.property(_get_detect_interval, _set_detect_interval)
  threshold = __builtin__.property(_get_threshold, _set_threshold)
  resume_interval = __builtin__.property(_get_resume_interval, _set_resume_interval)
  hold_down_interval = __builtin__.property(_get_hold_down_interval, _set_hold_down_interval)
  hold_max_cost = __builtin__.property(_get_hold_max_cost, _set_hold_max_cost)


  _pyangbind_elements = OrderedDict([('enable', enable), ('detect_interval', detect_interval), ('threshold', threshold), ('resume_interval', resume_interval), ('hold_down_interval', hold_down_interval), ('hold_max_cost', hold_max_cost), ])


class yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area/suppress-flapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure flapping suppression.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer',)

  _yang_name = 'suppress-flapping'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer = YANGDynClass(base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area', 'suppress-flapping']

  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer (container)

    YANG Description: Configure flapping suppression peer. Not support Loopback.
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping/peer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.

    YANG Description: Configure flapping suppression peer. Not support Loopback.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping_peer, is_container='container', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  peer = __builtin__.property(_get_peer, _set_peer) # type: yc_peer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping_peer


  _pyangbind_elements = OrderedDict([('peer', peer), ])


class yc_multi_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas/multi-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the interface enabled with OSPF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__area_id','__transmit_delay','__mtu_enable','__cost','__smart_discover','__ldp_sync_block','__ldp_sync_enable','__fallback_cost','__fallback_bw','__frr','__timer','__ldp_sync','__bfd','__authentication','__filter_lsa_out','__suppress_flapping',)

  _yang_name = 'multi-area'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__area_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__transmit_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__mtu_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__ldp_sync_block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__ldp_sync_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__fallback_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__fallback_bw = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__frr = YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__ldp_sync = YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__bfd = YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__filter_lsa_out = YANGDynClass(base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__suppress_flapping = YANGDynClass(base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas', 'multi-area']

  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/area_id (leafref)

    YANG Description: Multi area id.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/area_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Multi area id.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_transmit_delay(self):
    """
    Getter method for transmit_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/transmit_delay (int32)

    YANG Description: Delay for transmitting LSAs on an interface.
    """
    return self.__transmit_delay
      
  def _set_transmit_delay(self, v, load=False):
    """
    Setter method for transmit_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/transmit_delay (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transmit_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transmit_delay() directly.

    YANG Description: Delay for transmitting LSAs on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transmit_delay must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__transmit_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transmit_delay(self):
    self.__transmit_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_mtu_enable(self):
    """
    Getter method for mtu_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/mtu_enable (boolean)

    YANG Description: Enable/disable MTU.Configure the interface to fill in the MTU field (actual MTU of the interface) when the interface sends DD packets.
After a virtual connection is established through the virtual template or tunnel, different vendors may use different MTUs as default settings. To ensure consistency, the MTU is set to 0 by default when the interface sends DD packets. Thus, the ospf mtu-enable command usually does not need to be configured. OSPF does not support the preceding configuration on a null interface.
    """
    return self.__mtu_enable
      
  def _set_mtu_enable(self, v, load=False):
    """
    Setter method for mtu_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/mtu_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu_enable() directly.

    YANG Description: Enable/disable MTU.Configure the interface to fill in the MTU field (actual MTU of the interface) when the interface sends DD packets.
After a virtual connection is established through the virtual template or tunnel, different vendors may use different MTUs as default settings. To ensure consistency, the MTU is set to 0 by default when the interface sends DD packets. Thus, the ospf mtu-enable command usually does not need to be configured. OSPF does not support the preceding configuration on a null interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__mtu_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu_enable(self):
    self.__mtu_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/cost (uint32)

    YANG Description: To set the cost of an interface. The default value is 1. But the default of Loopback is 0.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: To set the cost of an interface. The default value is 1. But the default of Loopback is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_smart_discover(self):
    """
    Getter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/smart_discover (boolean)

    YANG Description: Enable/disable smart discover on an interface. When the neighbor status of a router or a DR or BDR on the multi-address network of the broadcast or NBMA type changes, the router can send Hello packets to the neighbor actively rather than wait for the expiration of the Hello timer.
    """
    return self.__smart_discover
      
  def _set_smart_discover(self, v, load=False):
    """
    Setter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/smart_discover (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smart_discover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smart_discover() directly.

    YANG Description: Enable/disable smart discover on an interface. When the neighbor status of a router or a DR or BDR on the multi-address network of the broadcast or NBMA type changes, the router can send Hello packets to the neighbor actively rather than wait for the expiration of the Hello timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smart_discover must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__smart_discover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smart_discover(self):
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_ldp_sync_block(self):
    """
    Getter method for ldp_sync_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync_block (boolean)

    YANG Description: Enable/disable ldp sync on this interface.
    """
    return self.__ldp_sync_block
      
  def _set_ldp_sync_block(self, v, load=False):
    """
    Setter method for ldp_sync_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync_block() directly.

    YANG Description: Enable/disable ldp sync on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__ldp_sync_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync_block(self):
    self.__ldp_sync_block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_ldp_sync_enable(self):
    """
    Getter method for ldp_sync_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync_enable (boolean)

    YANG Description: Enable/disable LDP and OSPF synchronization on an interface.
    """
    return self.__ldp_sync_enable
      
  def _set_ldp_sync_enable(self, v, load=False):
    """
    Setter method for ldp_sync_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync_enable() directly.

    YANG Description: Enable/disable LDP and OSPF synchronization on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__ldp_sync_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync_enable(self):
    self.__ldp_sync_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_fallback_cost(self):
    """
    Getter method for fallback_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/fallback_cost (uint16)

    YANG Description: Fallback cost.
    """
    return self.__fallback_cost
      
  def _set_fallback_cost(self, v, load=False):
    """
    Setter method for fallback_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/fallback_cost (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fallback_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fallback_cost() directly.

    YANG Description: Fallback cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fallback_cost must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__fallback_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fallback_cost(self):
    self.__fallback_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_fallback_bw(self):
    """
    Getter method for fallback_bw, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/fallback_bw (uint32)

    YANG Description: Fallback bandwidth threshold.
    """
    return self.__fallback_bw
      
  def _set_fallback_bw(self, v, load=False):
    """
    Setter method for fallback_bw, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/fallback_bw (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fallback_bw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fallback_bw() directly.

    YANG Description: Fallback bandwidth threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fallback_bw must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__fallback_bw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fallback_bw(self):
    self.__fallback_bw = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_frr(self):
    """
    Getter method for frr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr (container)

    YANG Description: Configure frr.
    """
    return self.__frr
      
  def _set_frr(self, v, load=False):
    """
    Setter method for frr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/frr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr() directly.

    YANG Description: Configure frr.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__frr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr(self):
    self.__frr = YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer (container)

    YANG Description: Configure timer.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/timer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Configure timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_ldp_sync(self):
    """
    Getter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync (container)

    YANG Description: Configure timer ldp sync.
    """
    return self.__ldp_sync
      
  def _set_ldp_sync(self, v, load=False):
    """
    Setter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/ldp_sync (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync() directly.

    YANG Description: Configure timer ldp sync.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ldp_sync = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync(self):
    self.__ldp_sync = YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/bfd (container)

    YANG Description: Configure BFD.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_authentication(self):
    """
    Getter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication (container)

    YANG Description: Configure authentication.
    """
    return self.__authentication
      
  def _set_authentication(self, v, load=False):
    """
    Setter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/authentication (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication() directly.

    YANG Description: Configure authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__authentication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication(self):
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_filter_lsa_out(self):
    """
    Getter method for filter_lsa_out, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out (container)

    YANG Description: Configure filter-lsa-out.
    """
    return self.__filter_lsa_out
      
  def _set_filter_lsa_out(self, v, load=False):
    """
    Setter method for filter_lsa_out, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/filter_lsa_out (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_lsa_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_lsa_out() directly.

    YANG Description: Configure filter-lsa-out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_lsa_out must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__filter_lsa_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_lsa_out(self):
    self.__filter_lsa_out = YANGDynClass(base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_suppress_flapping(self):
    """
    Getter method for suppress_flapping, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping (container)

    YANG Description: Configure flapping suppression.
    """
    return self.__suppress_flapping
      
  def _set_suppress_flapping(self, v, load=False):
    """
    Setter method for suppress_flapping, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area/suppress_flapping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_flapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_flapping() directly.

    YANG Description: Configure flapping suppression.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_flapping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__suppress_flapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_flapping(self):
    self.__suppress_flapping = YANGDynClass(base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  area_id = __builtin__.property(_get_area_id, _set_area_id)
  transmit_delay = __builtin__.property(_get_transmit_delay, _set_transmit_delay)
  mtu_enable = __builtin__.property(_get_mtu_enable, _set_mtu_enable)
  cost = __builtin__.property(_get_cost, _set_cost)
  smart_discover = __builtin__.property(_get_smart_discover, _set_smart_discover)
  ldp_sync_block = __builtin__.property(_get_ldp_sync_block, _set_ldp_sync_block)
  ldp_sync_enable = __builtin__.property(_get_ldp_sync_enable, _set_ldp_sync_enable)
  fallback_cost = __builtin__.property(_get_fallback_cost, _set_fallback_cost)
  fallback_bw = __builtin__.property(_get_fallback_bw, _set_fallback_bw)
  frr = __builtin__.property(_get_frr, _set_frr) # type: yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_frr
  timer = __builtin__.property(_get_timer, _set_timer) # type: yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_timer
  ldp_sync = __builtin__.property(_get_ldp_sync, _set_ldp_sync) # type: yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_ldp_sync
  bfd = __builtin__.property(_get_bfd, _set_bfd) # type: yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_bfd
  authentication = __builtin__.property(_get_authentication, _set_authentication) # type: yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_authentication
  filter_lsa_out = __builtin__.property(_get_filter_lsa_out, _set_filter_lsa_out) # type: yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_filter_lsa_out
  suppress_flapping = __builtin__.property(_get_suppress_flapping, _set_suppress_flapping) # type: yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area_suppress_flapping


  _pyangbind_elements = OrderedDict([('area_id', area_id), ('transmit_delay', transmit_delay), ('mtu_enable', mtu_enable), ('cost', cost), ('smart_discover', smart_discover), ('ldp_sync_block', ldp_sync_block), ('ldp_sync_enable', ldp_sync_enable), ('fallback_cost', fallback_cost), ('fallback_bw', fallback_bw), ('frr', frr), ('timer', timer), ('ldp_sync', ldp_sync), ('bfd', bfd), ('authentication', authentication), ('filter_lsa_out', filter_lsa_out), ('suppress_flapping', suppress_flapping), ])


class yc_multi_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi-areas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the information about the multi-area interface enabled with OSPF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__multi_area',)

  _yang_name = 'multi-areas'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__multi_area = YANGDynClass(base=YANGListType("area_id",yc_multi_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area, yang_name="multi-area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="multi-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'multi-areas']

  def _get_multi_area(self):
    """
    Getter method for multi_area, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area (list)

    YANG Description: Configure the interface enabled with OSPF.
    """
    return self.__multi_area
      
  def _set_multi_area(self, v, load=False):
    """
    Setter method for multi_area, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas/multi_area (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multi_area is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multi_area() directly.

    YANG Description: Configure the interface enabled with OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("area_id",yc_multi_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area, yang_name="multi-area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="multi-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multi_area must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("area_id",yc_multi_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area, yang_name="multi-area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="multi-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__multi_area = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multi_area(self):
    self.__multi_area = YANGDynClass(base=YANGListType("area_id",yc_multi_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area, yang_name="multi-area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="multi-area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  multi_area = __builtin__.property(_get_multi_area, _set_multi_area) # type: yc_multi_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas_multi_area


  _pyangbind_elements = OrderedDict([('multi_area', multi_area), ])


class yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_disp_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of OSPF interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress_reach_block','__silent_enable','__dr','__bdr','__state','__mtu','__ip','__cost','__gr_state','__previous_state','__opaque_id','__mpls_te_link','__peer_flap_status','__peer_flap_count','__peer_flap_threshold','__peer_flap_timer','__peer_flap_remain_timer','__bandwidth',)

  _yang_name = 'disp-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress_reach_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="suppress-reach-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    self.__silent_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="silent-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    self.__dr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__bdr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    self.__gr_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)
    self.__previous_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="previous-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)
    self.__opaque_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mpls_te_link = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-te-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    self.__peer_flap_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'hold-max-cost': {'value': 2}, 'hold-down': {'value': 3}},), is_leaf=True, yang_name="peer-flap-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-flapping-status', is_config=False)
    self.__peer_flap_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__peer_flap_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), is_leaf=True, yang_name="peer-flap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__peer_flap_timer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peer-flap-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__peer_flap_remain_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), is_leaf=True, yang_name="peer-flap-remain-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'disp-data']

  def _get_suppress_reach_block(self):
    """
    Getter method for suppress_reach_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/suppress_reach_block (boolean)

    YANG Description: Reachability suppression is disabled.
    """
    return self.__suppress_reach_block
      
  def _set_suppress_reach_block(self, v, load=False):
    """
    Setter method for suppress_reach_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/suppress_reach_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_reach_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_reach_block() directly.

    YANG Description: Reachability suppression is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="suppress-reach-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_reach_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="suppress-reach-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)""",
        })

    self.__suppress_reach_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_reach_block(self):
    self.__suppress_reach_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="suppress-reach-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)


  def _get_silent_enable(self):
    """
    Getter method for silent_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/silent_enable (boolean)

    YANG Description: To suppress an interface from sending or receiving OSPF packets.
    """
    return self.__silent_enable
      
  def _set_silent_enable(self, v, load=False):
    """
    Setter method for silent_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/silent_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_silent_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_silent_enable() directly.

    YANG Description: To suppress an interface from sending or receiving OSPF packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="silent-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """silent_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="silent-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)""",
        })

    self.__silent_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_silent_enable(self):
    self.__silent_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="silent-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)


  def _get_dr(self):
    """
    Getter method for dr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/dr (inet:ipv4-address-no-zone)

    YANG Description: DR of the network where an interface resides.
    """
    return self.__dr
      
  def _set_dr(self, v, load=False):
    """
    Setter method for dr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/dr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr() directly.

    YANG Description: DR of the network where an interface resides.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__dr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr(self):
    self.__dr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_bdr(self):
    """
    Getter method for bdr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/bdr (inet:ipv4-address-no-zone)

    YANG Description: BDR of the network where an interface resides.
    """
    return self.__bdr
      
  def _set_bdr(self, v, load=False):
    """
    Setter method for bdr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/bdr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bdr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bdr() directly.

    YANG Description: BDR of the network where an interface resides.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bdr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__bdr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bdr(self):
    self.__bdr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/state (intf-state)

    YANG Description: Status of an interface, which is determined according to the OSPF interface state machines.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/state (intf-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Status of an interface, which is determined according to the OSPF interface state machines.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with intf-state""",
          'defined-type': "huawei-ospfv2:intf-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/mtu (uint32)

    YANG Description: MTU of an interface.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: MTU of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/ip (inet:ipv4-address-no-zone)

    YANG Description: IP address of an interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IP address of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/cost (int32)

    YANG Description: Cost of an interface.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/cost (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Cost of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)


  def _get_gr_state(self):
    """
    Getter method for gr_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/gr_state (gr-state)

    YANG Description: Status of GR of an interface. The available options are as follows:
Normal: The interface is in normal state.
Restarter: The interface is in GR state.
Helper: The interface is in helper state.
    """
    return self.__gr_state
      
  def _set_gr_state(self, v, load=False):
    """
    Setter method for gr_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/gr_state (gr-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_state() directly.

    YANG Description: Status of GR of an interface. The available options are as follows:
Normal: The interface is in normal state.
Restarter: The interface is in GR state.
Helper: The interface is in helper state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_state must be of a type compatible with gr-state""",
          'defined-type': "huawei-ospfv2:gr-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)""",
        })

    self.__gr_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_state(self):
    self.__gr_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)


  def _get_previous_state(self):
    """
    Getter method for previous_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/previous_state (intf-state)

    YANG Description: Previous status of the interface.
    """
    return self.__previous_state
      
  def _set_previous_state(self, v, load=False):
    """
    Setter method for previous_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/previous_state (intf-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_previous_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_previous_state() directly.

    YANG Description: Previous status of the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="previous-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """previous_state must be of a type compatible with intf-state""",
          'defined-type': "huawei-ospfv2:intf-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="previous-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)""",
        })

    self.__previous_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_previous_state(self):
    self.__previous_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'waiting': {'value': 1}, 'p2p': {'value': 2}, 'dr': {'value': 3}, 'bdr': {'value': 4}, 'dr-other': {'value': 5}, 'loopback': {'value': 6}},), is_leaf=True, yang_name="previous-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='intf-state', is_config=False)


  def _get_opaque_id(self):
    """
    Getter method for opaque_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/opaque_id (uint32)

    YANG Description: Oapque ID of interface.
    """
    return self.__opaque_id
      
  def _set_opaque_id(self, v, load=False):
    """
    Setter method for opaque_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/opaque_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque_id() directly.

    YANG Description: Oapque ID of interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opaque_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque_id(self):
    self.__opaque_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mpls_te_link(self):
    """
    Getter method for mpls_te_link, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/mpls_te_link (boolean)

    YANG Description: MPLS TE link status enabled.
    """
    return self.__mpls_te_link
      
  def _set_mpls_te_link(self, v, load=False):
    """
    Setter method for mpls_te_link, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/mpls_te_link (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_te_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_te_link() directly.

    YANG Description: MPLS TE link status enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mpls-te-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_te_link must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-te-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)""",
        })

    self.__mpls_te_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_te_link(self):
    self.__mpls_te_link = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mpls-te-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)


  def _get_peer_flap_status(self):
    """
    Getter method for peer_flap_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_status (peer-flapping-status)

    YANG Description: Peer flapping suppress status.
    """
    return self.__peer_flap_status
      
  def _set_peer_flap_status(self, v, load=False):
    """
    Setter method for peer_flap_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_status (peer-flapping-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_flap_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_flap_status() directly.

    YANG Description: Peer flapping suppress status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'hold-max-cost': {'value': 2}, 'hold-down': {'value': 3}},), is_leaf=True, yang_name="peer-flap-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-flapping-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_flap_status must be of a type compatible with peer-flapping-status""",
          'defined-type': "huawei-ospfv2:peer-flapping-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'hold-max-cost': {'value': 2}, 'hold-down': {'value': 3}},), is_leaf=True, yang_name="peer-flap-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-flapping-status', is_config=False)""",
        })

    self.__peer_flap_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_flap_status(self):
    self.__peer_flap_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'hold-max-cost': {'value': 2}, 'hold-down': {'value': 3}},), is_leaf=True, yang_name="peer-flap-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-flapping-status', is_config=False)


  def _get_peer_flap_count(self):
    """
    Getter method for peer_flap_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_count (uint32)

    YANG Description: Peer flapping suppress count.
    """
    return self.__peer_flap_count
      
  def _set_peer_flap_count(self, v, load=False):
    """
    Setter method for peer_flap_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_flap_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_flap_count() directly.

    YANG Description: Peer flapping suppress count.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_flap_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__peer_flap_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_flap_count(self):
    self.__peer_flap_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_peer_flap_threshold(self):
    """
    Getter method for peer_flap_threshold, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_threshold (uint32)

    YANG Description: Peer flapping suppress threshold.
    """
    return self.__peer_flap_threshold
      
  def _set_peer_flap_threshold(self, v, load=False):
    """
    Setter method for peer_flap_threshold, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_flap_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_flap_threshold() directly.

    YANG Description: Peer flapping suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), is_leaf=True, yang_name="peer-flap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_flap_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), is_leaf=True, yang_name="peer-flap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__peer_flap_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_flap_threshold(self):
    self.__peer_flap_threshold = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000']}), is_leaf=True, yang_name="peer-flap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_peer_flap_timer(self):
    """
    Getter method for peer_flap_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_timer (string)

    YANG Description: Peer flapping suppress timer.
    """
    return self.__peer_flap_timer
      
  def _set_peer_flap_timer(self, v, load=False):
    """
    Setter method for peer_flap_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_timer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_flap_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_flap_timer() directly.

    YANG Description: Peer flapping suppress timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peer-flap-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_flap_timer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peer-flap-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__peer_flap_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_flap_timer(self):
    self.__peer_flap_timer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..40']}), is_leaf=True, yang_name="peer-flap-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_peer_flap_remain_timer(self):
    """
    Getter method for peer_flap_remain_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_remain_timer (uint32)

    YANG Description: Peer flapping suppress remain timer.
    """
    return self.__peer_flap_remain_timer
      
  def _set_peer_flap_remain_timer(self, v, load=False):
    """
    Setter method for peer_flap_remain_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/peer_flap_remain_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_flap_remain_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_flap_remain_timer() directly.

    YANG Description: Peer flapping suppress remain timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), is_leaf=True, yang_name="peer-flap-remain-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_flap_remain_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), is_leaf=True, yang_name="peer-flap-remain-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__peer_flap_remain_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_flap_remain_timer(self):
    self.__peer_flap_remain_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), is_leaf=True, yang_name="peer-flap-remain-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/bandwidth (uint32)

    YANG Description: Current interface bandwidth.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Current interface bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  suppress_reach_block = __builtin__.property(_get_suppress_reach_block)
  silent_enable = __builtin__.property(_get_silent_enable)
  dr = __builtin__.property(_get_dr)
  bdr = __builtin__.property(_get_bdr)
  state = __builtin__.property(_get_state)
  mtu = __builtin__.property(_get_mtu)
  ip = __builtin__.property(_get_ip)
  cost = __builtin__.property(_get_cost)
  gr_state = __builtin__.property(_get_gr_state)
  previous_state = __builtin__.property(_get_previous_state)
  opaque_id = __builtin__.property(_get_opaque_id)
  mpls_te_link = __builtin__.property(_get_mpls_te_link)
  peer_flap_status = __builtin__.property(_get_peer_flap_status)
  peer_flap_count = __builtin__.property(_get_peer_flap_count)
  peer_flap_threshold = __builtin__.property(_get_peer_flap_threshold)
  peer_flap_timer = __builtin__.property(_get_peer_flap_timer)
  peer_flap_remain_timer = __builtin__.property(_get_peer_flap_remain_timer)
  bandwidth = __builtin__.property(_get_bandwidth)


  _pyangbind_elements = OrderedDict([('suppress_reach_block', suppress_reach_block), ('silent_enable', silent_enable), ('dr', dr), ('bdr', bdr), ('state', state), ('mtu', mtu), ('ip', ip), ('cost', cost), ('gr_state', gr_state), ('previous_state', previous_state), ('opaque_id', opaque_id), ('mpls_te_link', mpls_te_link), ('peer_flap_status', peer_flap_status), ('peer_flap_count', peer_flap_count), ('peer_flap_threshold', peer_flap_threshold), ('peer_flap_timer', peer_flap_timer), ('peer_flap_remain_timer', peer_flap_remain_timer), ('bandwidth', bandwidth), ])


class yc_nbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics_nbr_statistic(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr-statistics/nbr-statistic. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of OSPF peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__ip','__intf_ip','__gr_state','__state','__mode','__priority','__dr','__bdr','__intf_mtu','__dead_due_timer','__retran_intv','__up_time','__up_time_stamp','__auth_sequence','__adj_sid','__adj_weight','__adj_flags',)

  _yang_name = 'nbr-statistic'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__intf_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__gr_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    self.__dr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__bdr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__intf_mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intf-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dead_due_timer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__retran_intv = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__up_time_stamp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)
    self.__auth_sequence = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__adj_sid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__adj_weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__adj_flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="adj-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'nbr-statistics', 'nbr-statistic']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/router_id (inet:ipv4-address-no-zone)

    YANG Description: ID of a neighbor router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: ID of a neighbor router.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/ip (inet:ipv4-address-no-zone)

    YANG Description: Address of a neighbor interface.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: Address of a neighbor interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_intf_ip(self):
    """
    Getter method for intf_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/intf_ip (inet:ipv4-address-no-zone)

    YANG Description: IP address of an interface.
    """
    return self.__intf_ip
      
  def _set_intf_ip(self, v, load=False):
    """
    Setter method for intf_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/intf_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intf_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intf_ip() directly.

    YANG Description: IP address of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intf_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__intf_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intf_ip(self):
    self.__intf_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="intf-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_gr_state(self):
    """
    Getter method for gr_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/gr_state (nbr-gr-state)

    YANG Description: GR state.
    """
    return self.__gr_state
      
  def _set_gr_state(self, v, load=False):
    """
    Setter method for gr_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/gr_state (nbr-gr-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_state() directly.

    YANG Description: GR state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_state must be of a type compatible with nbr-gr-state""",
          'defined-type': "huawei-ospfv2:nbr-gr-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)""",
        })

    self.__gr_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_state(self):
    self.__gr_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/state (nbr-state)

    YANG Description: Neighbor status.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/state (nbr-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Neighbor status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with nbr-state""",
          'defined-type': "huawei-ospfv2:nbr-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/mode (nbr-mode)

    YANG Description: Mode of the DD. The available options are master and slave.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/mode (nbr-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Mode of the DD. The available options are master and slave.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with nbr-mode""",
          'defined-type': "huawei-ospfv2:nbr-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/priority (int32)

    YANG Description: Priority of a neighbor router.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/priority (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Priority of a neighbor router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)


  def _get_dr(self):
    """
    Getter method for dr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/dr (inet:ipv4-address-no-zone)

    YANG Description: Designated router.
    """
    return self.__dr
      
  def _set_dr(self, v, load=False):
    """
    Setter method for dr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/dr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr() directly.

    YANG Description: Designated router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__dr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr(self):
    self.__dr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_bdr(self):
    """
    Getter method for bdr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/bdr (inet:ipv4-address-no-zone)

    YANG Description: Backup designated router.
    """
    return self.__bdr
      
  def _set_bdr(self, v, load=False):
    """
    Setter method for bdr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/bdr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bdr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bdr() directly.

    YANG Description: Backup designated router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bdr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__bdr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bdr(self):
    self.__bdr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_intf_mtu(self):
    """
    Getter method for intf_mtu, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/intf_mtu (uint32)

    YANG Description: MTU of a neighbor.
    """
    return self.__intf_mtu
      
  def _set_intf_mtu(self, v, load=False):
    """
    Setter method for intf_mtu, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/intf_mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_intf_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_intf_mtu() directly.

    YANG Description: MTU of a neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intf-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """intf_mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intf-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__intf_mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_intf_mtu(self):
    self.__intf_mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="intf-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dead_due_timer(self):
    """
    Getter method for dead_due_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/dead_due_timer (string)

    YANG Description: Dead due timer.
    """
    return self.__dead_due_timer
      
  def _set_dead_due_timer(self, v, load=False):
    """
    Setter method for dead_due_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/dead_due_timer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_due_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_due_timer() directly.

    YANG Description: Dead due timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_due_timer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__dead_due_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_due_timer(self):
    self.__dead_due_timer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_retran_intv(self):
    """
    Getter method for retran_intv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/retran_intv (uint32)

    YANG Description: Neighbor retranIntv.
    """
    return self.__retran_intv
      
  def _set_retran_intv(self, v, load=False):
    """
    Setter method for retran_intv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/retran_intv (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retran_intv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retran_intv() directly.

    YANG Description: Neighbor retranIntv.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retran_intv must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__retran_intv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retran_intv(self):
    self.__retran_intv = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_up_time(self):
    """
    Getter method for up_time, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/up_time (string)

    YANG Description: Time when a neighbor goes up.
    """
    return self.__up_time
      
  def _set_up_time(self, v, load=False):
    """
    Setter method for up_time, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/up_time (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_time() directly.

    YANG Description: Time when a neighbor goes up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_time must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_time(self):
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_up_time_stamp(self):
    """
    Getter method for up_time_stamp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/up_time_stamp (yang:date-and-time)

    YANG Description: Neighbor up time stamp.
    """
    return self.__up_time_stamp
      
  def _set_up_time_stamp(self, v, load=False):
    """
    Setter method for up_time_stamp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/up_time_stamp (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_time_stamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_time_stamp() directly.

    YANG Description: Neighbor up time stamp.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_time_stamp must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__up_time_stamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_time_stamp(self):
    self.__up_time_stamp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)


  def _get_auth_sequence(self):
    """
    Getter method for auth_sequence, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/auth_sequence (uint32)

    YANG Description: Neighbor authentication sequence number.
    """
    return self.__auth_sequence
      
  def _set_auth_sequence(self, v, load=False):
    """
    Setter method for auth_sequence, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/auth_sequence (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_sequence is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_sequence() directly.

    YANG Description: Neighbor authentication sequence number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_sequence must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__auth_sequence = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_sequence(self):
    self.__auth_sequence = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_adj_sid(self):
    """
    Getter method for adj_sid, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/adj_sid (uint32)

    YANG Description: Adjacency SID.
    """
    return self.__adj_sid
      
  def _set_adj_sid(self, v, load=False):
    """
    Setter method for adj_sid, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/adj_sid (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_sid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_sid() directly.

    YANG Description: Adjacency SID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_sid must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__adj_sid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_sid(self):
    self.__adj_sid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-sid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_adj_weight(self):
    """
    Getter method for adj_weight, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/adj_weight (uint32)

    YANG Description: Adjacency weight.
    """
    return self.__adj_weight
      
  def _set_adj_weight(self, v, load=False):
    """
    Setter method for adj_weight, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/adj_weight (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_weight() directly.

    YANG Description: Adjacency weight.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_weight must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__adj_weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_weight(self):
    self.__adj_weight = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="adj-weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_adj_flags(self):
    """
    Getter method for adj_flags, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/adj_flags (string)

    YANG Description: Adjacency flags.
    """
    return self.__adj_flags
      
  def _set_adj_flags(self, v, load=False):
    """
    Setter method for adj_flags, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic/adj_flags (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_flags() directly.

    YANG Description: Adjacency flags.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="adj-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_flags must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="adj-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__adj_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_flags(self):
    self.__adj_flags = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..20']}), is_leaf=True, yang_name="adj-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  ip = __builtin__.property(_get_ip)
  intf_ip = __builtin__.property(_get_intf_ip)
  gr_state = __builtin__.property(_get_gr_state)
  state = __builtin__.property(_get_state)
  mode = __builtin__.property(_get_mode)
  priority = __builtin__.property(_get_priority)
  dr = __builtin__.property(_get_dr)
  bdr = __builtin__.property(_get_bdr)
  intf_mtu = __builtin__.property(_get_intf_mtu)
  dead_due_timer = __builtin__.property(_get_dead_due_timer)
  retran_intv = __builtin__.property(_get_retran_intv)
  up_time = __builtin__.property(_get_up_time)
  up_time_stamp = __builtin__.property(_get_up_time_stamp)
  auth_sequence = __builtin__.property(_get_auth_sequence)
  adj_sid = __builtin__.property(_get_adj_sid)
  adj_weight = __builtin__.property(_get_adj_weight)
  adj_flags = __builtin__.property(_get_adj_flags)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('ip', ip), ('intf_ip', intf_ip), ('gr_state', gr_state), ('state', state), ('mode', mode), ('priority', priority), ('dr', dr), ('bdr', bdr), ('intf_mtu', intf_mtu), ('dead_due_timer', dead_due_timer), ('retran_intv', retran_intv), ('up_time', up_time), ('up_time_stamp', up_time_stamp), ('auth_sequence', auth_sequence), ('adj_sid', adj_sid), ('adj_weight', adj_weight), ('adj_flags', adj_flags), ])


class yc_nbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OSPF peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nbr_statistic',)

  _yang_name = 'nbr-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nbr_statistic = YANGDynClass(base=YANGListType("router_id ip",yc_nbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics_nbr_statistic, yang_name="nbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id ip', extensions=None), is_container='list', yang_name="nbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'nbr-statistics']

  def _get_nbr_statistic(self):
    """
    Getter method for nbr_statistic, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic (list)

    YANG Description: Statistics of OSPF peer.
    """
    return self.__nbr_statistic
      
  def _set_nbr_statistic(self, v, load=False):
    """
    Setter method for nbr_statistic, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics/nbr_statistic (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nbr_statistic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nbr_statistic() directly.

    YANG Description: Statistics of OSPF peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("router_id ip",yc_nbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics_nbr_statistic, yang_name="nbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id ip', extensions=None), is_container='list', yang_name="nbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nbr_statistic must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("router_id ip",yc_nbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics_nbr_statistic, yang_name="nbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id ip', extensions=None), is_container='list', yang_name="nbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__nbr_statistic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nbr_statistic(self):
    self.__nbr_statistic = YANGDynClass(base=YANGListType("router_id ip",yc_nbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics_nbr_statistic, yang_name="nbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='router-id ip', extensions=None), is_container='list', yang_name="nbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  nbr_statistic = __builtin__.property(_get_nbr_statistic) # type: yc_nbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics_nbr_statistic


  _pyangbind_elements = OrderedDict([('nbr_statistic', nbr_statistic), ])


class yc_error_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_error_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of error data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__same_ip_pkt_cnt','__bad_pkt_cnt','__bad_ver_cnt','__bad_chksum_pkt_cnt','__bad_area_pkt_cnt','__pkt_rcv_unnumber','__bad_virt_link_cnt','__auth_type_fail_cnt','__auth_key_fail_cnt','__short_pkt_cnt','__long_pkt_cnt','__tx_err_cnt','__if_down_cnt','__no_nbr','__mis_netmask_cnt','__mis_hello_intl_cnt','__mis_dead_intl_cnt','__mis_ext_cnt','__router_id_confusion','__vlink_nbr_mis_cnt','__nbma_nbr_err_cnt','__inval_src_hello_cnt','__dd_nbr_low_cnt','__dd_rtrid_cnt','__dd_opt_mismatch_cnt','__dd_unknwn_lsa_cnt','__dd_mtu_mismatch_cnt','__ack_nbr_low_cnt','__ack_bad_cnt','__ack_duplicate_cnt','__ack_unknwn_lsa_cnt','__req_nbr_low_cnt','__req_empty_cnt','__req_bad_cnt','__upd_nbr_low_cnt','__upd_self_newr_cnt','__upd_min_lsarr_cnt','__upd_ls_chksum_cnt','__upd_les_recent_cnt','__upd_unknw_lsa_cnt','__opq9_flood_cnt','__opq10_flood_cnt','__opq11_flood_cnt','__rxmt_dd_err_cnt','__rxmt_req_err_cnt','__rxmt_upd_err_cnt','__gr_invalid_lsa_cnt','__gr_invalid_pol_cnt','__gr_invalid_prd_cnt','__tunnel_cost_cnt','__peer_net_type_cnt','__hello_dr_mis_cnt',)

  _yang_name = 'error-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__same_ip_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_ver_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_chksum_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chksum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_area_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__pkt_rcv_unnumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_virt_link_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__auth_type_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__auth_key_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__short_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__long_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__tx_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__if_down_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__no_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_netmask_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_hello_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_dead_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_ext_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__router_id_confusion = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__vlink_nbr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__nbma_nbr_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__inval_src_hello_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-hello-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_rtrid_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-rtrid-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_opt_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_unknwn_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_mtu_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_duplicate_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_unknwn_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__req_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__req_empty_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__req_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_self_newr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_min_lsarr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_ls_chksum_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-chksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_les_recent_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_unknw_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknw-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opq9_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opq10_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opq11_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__rxmt_dd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__rxmt_req_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__rxmt_upd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__gr_invalid_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__gr_invalid_pol_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__gr_invalid_prd_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__tunnel_cost_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__peer_net_type_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__hello_dr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface', 'error-data']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/router_id (inet:ipv4-address-no-zone)

    YANG Description: Router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_same_ip_pkt_cnt(self):
    """
    Getter method for same_ip_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/same_ip_pkt_cnt (uint32)

    YANG Description: SameIp packet count.
    """
    return self.__same_ip_pkt_cnt
      
  def _set_same_ip_pkt_cnt(self, v, load=False):
    """
    Setter method for same_ip_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/same_ip_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_same_ip_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_same_ip_pkt_cnt() directly.

    YANG Description: SameIp packet count.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """same_ip_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__same_ip_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_same_ip_pkt_cnt(self):
    self.__same_ip_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_pkt_cnt(self):
    """
    Getter method for bad_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_pkt_cnt (uint32)

    YANG Description: Bad packet.
    """
    return self.__bad_pkt_cnt
      
  def _set_bad_pkt_cnt(self, v, load=False):
    """
    Setter method for bad_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_pkt_cnt() directly.

    YANG Description: Bad packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_pkt_cnt(self):
    self.__bad_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_ver_cnt(self):
    """
    Getter method for bad_ver_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_ver_cnt (uint32)

    YANG Description: Bad version.
    """
    return self.__bad_ver_cnt
      
  def _set_bad_ver_cnt(self, v, load=False):
    """
    Setter method for bad_ver_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_ver_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_ver_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_ver_cnt() directly.

    YANG Description: Bad version.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_ver_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_ver_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_ver_cnt(self):
    self.__bad_ver_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_chksum_pkt_cnt(self):
    """
    Getter method for bad_chksum_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_chksum_pkt_cnt (uint32)

    YANG Description: Bad checksum.
    """
    return self.__bad_chksum_pkt_cnt
      
  def _set_bad_chksum_pkt_cnt(self, v, load=False):
    """
    Setter method for bad_chksum_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_chksum_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_chksum_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_chksum_pkt_cnt() directly.

    YANG Description: Bad checksum.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chksum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_chksum_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chksum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_chksum_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_chksum_pkt_cnt(self):
    self.__bad_chksum_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chksum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_area_pkt_cnt(self):
    """
    Getter method for bad_area_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_area_pkt_cnt (uint32)

    YANG Description: Bad area ID.
    """
    return self.__bad_area_pkt_cnt
      
  def _set_bad_area_pkt_cnt(self, v, load=False):
    """
    Setter method for bad_area_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_area_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_area_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_area_pkt_cnt() directly.

    YANG Description: Bad area ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_area_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_area_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_area_pkt_cnt(self):
    self.__bad_area_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_pkt_rcv_unnumber(self):
    """
    Getter method for pkt_rcv_unnumber, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/pkt_rcv_unnumber (uint32)

    YANG Description: Drop on unnumbered interface.
    """
    return self.__pkt_rcv_unnumber
      
  def _set_pkt_rcv_unnumber(self, v, load=False):
    """
    Setter method for pkt_rcv_unnumber, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/pkt_rcv_unnumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pkt_rcv_unnumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pkt_rcv_unnumber() directly.

    YANG Description: Drop on unnumbered interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pkt_rcv_unnumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__pkt_rcv_unnumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pkt_rcv_unnumber(self):
    self.__pkt_rcv_unnumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_virt_link_cnt(self):
    """
    Getter method for bad_virt_link_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_virt_link_cnt (uint32)

    YANG Description: Bad virtual link.
    """
    return self.__bad_virt_link_cnt
      
  def _set_bad_virt_link_cnt(self, v, load=False):
    """
    Setter method for bad_virt_link_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/bad_virt_link_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_virt_link_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_virt_link_cnt() directly.

    YANG Description: Bad virtual link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_virt_link_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_virt_link_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_virt_link_cnt(self):
    self.__bad_virt_link_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_auth_type_fail_cnt(self):
    """
    Getter method for auth_type_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/auth_type_fail_cnt (uint32)

    YANG Description: Bad authentication type.
    """
    return self.__auth_type_fail_cnt
      
  def _set_auth_type_fail_cnt(self, v, load=False):
    """
    Setter method for auth_type_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/auth_type_fail_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_type_fail_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_type_fail_cnt() directly.

    YANG Description: Bad authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_type_fail_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__auth_type_fail_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_type_fail_cnt(self):
    self.__auth_type_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_auth_key_fail_cnt(self):
    """
    Getter method for auth_key_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/auth_key_fail_cnt (uint32)

    YANG Description: Bad authentication key.
    """
    return self.__auth_key_fail_cnt
      
  def _set_auth_key_fail_cnt(self, v, load=False):
    """
    Setter method for auth_key_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/auth_key_fail_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_key_fail_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_key_fail_cnt() directly.

    YANG Description: Bad authentication key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_key_fail_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__auth_key_fail_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_key_fail_cnt(self):
    self.__auth_key_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_short_pkt_cnt(self):
    """
    Getter method for short_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/short_pkt_cnt (uint32)

    YANG Description: Packet too small.
    """
    return self.__short_pkt_cnt
      
  def _set_short_pkt_cnt(self, v, load=False):
    """
    Setter method for short_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/short_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_pkt_cnt() directly.

    YANG Description: Packet too small.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__short_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_pkt_cnt(self):
    self.__short_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_long_pkt_cnt(self):
    """
    Getter method for long_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/long_pkt_cnt (uint32)

    YANG Description: Packet size > IP length.
    """
    return self.__long_pkt_cnt
      
  def _set_long_pkt_cnt(self, v, load=False):
    """
    Setter method for long_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/long_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_long_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_long_pkt_cnt() directly.

    YANG Description: Packet size > IP length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """long_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__long_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_long_pkt_cnt(self):
    self.__long_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_tx_err_cnt(self):
    """
    Getter method for tx_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/tx_err_cnt (uint32)

    YANG Description: Transmit error.
    """
    return self.__tx_err_cnt
      
  def _set_tx_err_cnt(self, v, load=False):
    """
    Setter method for tx_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/tx_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_err_cnt() directly.

    YANG Description: Transmit error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tx_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_err_cnt(self):
    self.__tx_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_if_down_cnt(self):
    """
    Getter method for if_down_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/if_down_cnt (uint32)

    YANG Description: Interface down.
    """
    return self.__if_down_cnt
      
  def _set_if_down_cnt(self, v, load=False):
    """
    Setter method for if_down_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/if_down_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_down_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_down_cnt() directly.

    YANG Description: Interface down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_down_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__if_down_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_down_cnt(self):
    self.__if_down_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_no_nbr(self):
    """
    Getter method for no_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/no_nbr (uint32)

    YANG Description: Unknown neighbor.
    """
    return self.__no_nbr
      
  def _set_no_nbr(self, v, load=False):
    """
    Setter method for no_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/no_nbr (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_nbr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_nbr() directly.

    YANG Description: Unknown neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_nbr must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__no_nbr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_nbr(self):
    self.__no_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_netmask_cnt(self):
    """
    Getter method for mis_netmask_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_netmask_cnt (uint32)

    YANG Description: Netmask mismatch.
    """
    return self.__mis_netmask_cnt
      
  def _set_mis_netmask_cnt(self, v, load=False):
    """
    Setter method for mis_netmask_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_netmask_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_netmask_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_netmask_cnt() directly.

    YANG Description: Netmask mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_netmask_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_netmask_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_netmask_cnt(self):
    self.__mis_netmask_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_hello_intl_cnt(self):
    """
    Getter method for mis_hello_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_hello_intl_cnt (uint32)

    YANG Description: Hello timer mismatch.
    """
    return self.__mis_hello_intl_cnt
      
  def _set_mis_hello_intl_cnt(self, v, load=False):
    """
    Setter method for mis_hello_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_hello_intl_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_hello_intl_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_hello_intl_cnt() directly.

    YANG Description: Hello timer mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_hello_intl_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_hello_intl_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_hello_intl_cnt(self):
    self.__mis_hello_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_dead_intl_cnt(self):
    """
    Getter method for mis_dead_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_dead_intl_cnt (uint32)

    YANG Description: Dead timer mismatch.
    """
    return self.__mis_dead_intl_cnt
      
  def _set_mis_dead_intl_cnt(self, v, load=False):
    """
    Setter method for mis_dead_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_dead_intl_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_dead_intl_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_dead_intl_cnt() directly.

    YANG Description: Dead timer mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_dead_intl_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_dead_intl_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_dead_intl_cnt(self):
    self.__mis_dead_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_ext_cnt(self):
    """
    Getter method for mis_ext_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_ext_cnt (uint32)

    YANG Description: Extern option mismatch.
    """
    return self.__mis_ext_cnt
      
  def _set_mis_ext_cnt(self, v, load=False):
    """
    Setter method for mis_ext_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/mis_ext_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_ext_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_ext_cnt() directly.

    YANG Description: Extern option mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_ext_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_ext_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_ext_cnt(self):
    self.__mis_ext_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_router_id_confusion(self):
    """
    Getter method for router_id_confusion, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/router_id_confusion (uint32)

    YANG Description: DD router ID confusion.
    """
    return self.__router_id_confusion
      
  def _set_router_id_confusion(self, v, load=False):
    """
    Setter method for router_id_confusion, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/router_id_confusion (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id_confusion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id_confusion() directly.

    YANG Description: DD router ID confusion.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id_confusion must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__router_id_confusion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id_confusion(self):
    self.__router_id_confusion = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_vlink_nbr_mis_cnt(self):
    """
    Getter method for vlink_nbr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/vlink_nbr_mis_cnt (uint32)

    YANG Description: Virtual neighbor unknown.
    """
    return self.__vlink_nbr_mis_cnt
      
  def _set_vlink_nbr_mis_cnt(self, v, load=False):
    """
    Setter method for vlink_nbr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/vlink_nbr_mis_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlink_nbr_mis_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlink_nbr_mis_cnt() directly.

    YANG Description: Virtual neighbor unknown.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlink_nbr_mis_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__vlink_nbr_mis_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlink_nbr_mis_cnt(self):
    self.__vlink_nbr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_nbma_nbr_err_cnt(self):
    """
    Getter method for nbma_nbr_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/nbma_nbr_err_cnt (uint32)

    YANG Description: NBMA neighbor unknown.
    """
    return self.__nbma_nbr_err_cnt
      
  def _set_nbma_nbr_err_cnt(self, v, load=False):
    """
    Setter method for nbma_nbr_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/nbma_nbr_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nbma_nbr_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nbma_nbr_err_cnt() directly.

    YANG Description: NBMA neighbor unknown.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nbma_nbr_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__nbma_nbr_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nbma_nbr_err_cnt(self):
    self.__nbma_nbr_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_inval_src_hello_cnt(self):
    """
    Getter method for inval_src_hello_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/inval_src_hello_cnt (uint32)

    YANG Description: Invalid source.
    """
    return self.__inval_src_hello_cnt
      
  def _set_inval_src_hello_cnt(self, v, load=False):
    """
    Setter method for inval_src_hello_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/inval_src_hello_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inval_src_hello_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inval_src_hello_cnt() directly.

    YANG Description: Invalid source.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-hello-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inval_src_hello_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-hello-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__inval_src_hello_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inval_src_hello_cnt(self):
    self.__inval_src_hello_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-hello-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_nbr_low_cnt(self):
    """
    Getter method for dd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for DD.
    """
    return self.__dd_nbr_low_cnt
      
  def _set_dd_nbr_low_cnt(self, v, load=False):
    """
    Setter method for dd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for DD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_nbr_low_cnt(self):
    self.__dd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_rtrid_cnt(self):
    """
    Getter method for dd_rtrid_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_rtrid_cnt (uint32)

    YANG Description: DD router ID confusion.
    """
    return self.__dd_rtrid_cnt
      
  def _set_dd_rtrid_cnt(self, v, load=False):
    """
    Setter method for dd_rtrid_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_rtrid_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_rtrid_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_rtrid_cnt() directly.

    YANG Description: DD router ID confusion.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-rtrid-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_rtrid_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-rtrid-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_rtrid_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_rtrid_cnt(self):
    self.__dd_rtrid_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-rtrid-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_opt_mismatch_cnt(self):
    """
    Getter method for dd_opt_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_opt_mismatch_cnt (uint32)

    YANG Description: Extern option mismatch.
    """
    return self.__dd_opt_mismatch_cnt
      
  def _set_dd_opt_mismatch_cnt(self, v, load=False):
    """
    Setter method for dd_opt_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_opt_mismatch_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_opt_mismatch_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_opt_mismatch_cnt() directly.

    YANG Description: Extern option mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_opt_mismatch_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_opt_mismatch_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_opt_mismatch_cnt(self):
    self.__dd_opt_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_unknwn_lsa_cnt(self):
    """
    Getter method for dd_unknwn_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_unknwn_lsa_cnt (uint32)

    YANG Description: DD packet unknown LSA type.
    """
    return self.__dd_unknwn_lsa_cnt
      
  def _set_dd_unknwn_lsa_cnt(self, v, load=False):
    """
    Setter method for dd_unknwn_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_unknwn_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_unknwn_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_unknwn_lsa_cnt() directly.

    YANG Description: DD packet unknown LSA type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_unknwn_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_unknwn_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_unknwn_lsa_cnt(self):
    self.__dd_unknwn_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_mtu_mismatch_cnt(self):
    """
    Getter method for dd_mtu_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_mtu_mismatch_cnt (uint32)

    YANG Description: MTU option mismatch.
    """
    return self.__dd_mtu_mismatch_cnt
      
  def _set_dd_mtu_mismatch_cnt(self, v, load=False):
    """
    Setter method for dd_mtu_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/dd_mtu_mismatch_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_mtu_mismatch_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_mtu_mismatch_cnt() directly.

    YANG Description: MTU option mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_mtu_mismatch_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_mtu_mismatch_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_mtu_mismatch_cnt(self):
    self.__dd_mtu_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_nbr_low_cnt(self):
    """
    Getter method for ack_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for LS acknowledgement.
    """
    return self.__ack_nbr_low_cnt
      
  def _set_ack_nbr_low_cnt(self, v, load=False):
    """
    Setter method for ack_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for LS acknowledgement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_nbr_low_cnt(self):
    self.__ack_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_bad_cnt(self):
    """
    Getter method for ack_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_bad_cnt (uint32)

    YANG Description: Bad ack.
    """
    return self.__ack_bad_cnt
      
  def _set_ack_bad_cnt(self, v, load=False):
    """
    Setter method for ack_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_bad_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_bad_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_bad_cnt() directly.

    YANG Description: Bad ack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_bad_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_bad_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_bad_cnt(self):
    self.__ack_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_duplicate_cnt(self):
    """
    Getter method for ack_duplicate_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_duplicate_cnt (uint32)

    YANG Description: Duplicate ack.
    """
    return self.__ack_duplicate_cnt
      
  def _set_ack_duplicate_cnt(self, v, load=False):
    """
    Setter method for ack_duplicate_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_duplicate_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_duplicate_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_duplicate_cnt() directly.

    YANG Description: Duplicate ack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_duplicate_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_duplicate_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_duplicate_cnt(self):
    self.__ack_duplicate_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_unknwn_lsa_cnt(self):
    """
    Getter method for ack_unknwn_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_unknwn_lsa_cnt (uint32)

    YANG Description: LSAck packet unknown LSA type.
    """
    return self.__ack_unknwn_lsa_cnt
      
  def _set_ack_unknwn_lsa_cnt(self, v, load=False):
    """
    Setter method for ack_unknwn_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/ack_unknwn_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_unknwn_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_unknwn_lsa_cnt() directly.

    YANG Description: LSAck packet unknown LSA type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_unknwn_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_unknwn_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_unknwn_lsa_cnt(self):
    self.__ack_unknwn_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_req_nbr_low_cnt(self):
    """
    Getter method for req_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/req_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for LS request.
    """
    return self.__req_nbr_low_cnt
      
  def _set_req_nbr_low_cnt(self, v, load=False):
    """
    Setter method for req_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/req_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_req_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_req_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for LS request.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """req_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__req_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_req_nbr_low_cnt(self):
    self.__req_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_req_empty_cnt(self):
    """
    Getter method for req_empty_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/req_empty_cnt (uint32)

    YANG Description: Empty request.
    """
    return self.__req_empty_cnt
      
  def _set_req_empty_cnt(self, v, load=False):
    """
    Setter method for req_empty_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/req_empty_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_req_empty_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_req_empty_cnt() directly.

    YANG Description: Empty request.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """req_empty_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__req_empty_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_req_empty_cnt(self):
    self.__req_empty_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_req_bad_cnt(self):
    """
    Getter method for req_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/req_bad_cnt (uint32)

    YANG Description: Bad request.
    """
    return self.__req_bad_cnt
      
  def _set_req_bad_cnt(self, v, load=False):
    """
    Setter method for req_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/req_bad_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_req_bad_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_req_bad_cnt() directly.

    YANG Description: Bad request.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """req_bad_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__req_bad_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_req_bad_cnt(self):
    self.__req_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_nbr_low_cnt(self):
    """
    Getter method for upd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for LS update.
    """
    return self.__upd_nbr_low_cnt
      
  def _set_upd_nbr_low_cnt(self, v, load=False):
    """
    Setter method for upd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for LS update.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_nbr_low_cnt(self):
    self.__upd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_self_newr_cnt(self):
    """
    Getter method for upd_self_newr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_self_newr_cnt (uint32)

    YANG Description: Newer self generate LSA.
    """
    return self.__upd_self_newr_cnt
      
  def _set_upd_self_newr_cnt(self, v, load=False):
    """
    Setter method for upd_self_newr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_self_newr_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_self_newr_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_self_newr_cnt() directly.

    YANG Description: Newer self generate LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_self_newr_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_self_newr_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_self_newr_cnt(self):
    self.__upd_self_newr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_min_lsarr_cnt(self):
    """
    Getter method for upd_min_lsarr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_min_lsarr_cnt (uint32)

    YANG Description: Received LSA within LSA arrival interval.
    """
    return self.__upd_min_lsarr_cnt
      
  def _set_upd_min_lsarr_cnt(self, v, load=False):
    """
    Setter method for upd_min_lsarr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_min_lsarr_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_min_lsarr_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_min_lsarr_cnt() directly.

    YANG Description: Received LSA within LSA arrival interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_min_lsarr_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_min_lsarr_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_min_lsarr_cnt(self):
    self.__upd_min_lsarr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_ls_chksum_cnt(self):
    """
    Getter method for upd_ls_chksum_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_ls_chksum_cnt (uint32)

    YANG Description: LSA checksum bad.
    """
    return self.__upd_ls_chksum_cnt
      
  def _set_upd_ls_chksum_cnt(self, v, load=False):
    """
    Setter method for upd_ls_chksum_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_ls_chksum_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_ls_chksum_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_ls_chksum_cnt() directly.

    YANG Description: LSA checksum bad.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-chksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_ls_chksum_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-chksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_ls_chksum_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_ls_chksum_cnt(self):
    self.__upd_ls_chksum_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-chksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_les_recent_cnt(self):
    """
    Getter method for upd_les_recent_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_les_recent_cnt (uint32)

    YANG Description: Received less recent LSA.
    """
    return self.__upd_les_recent_cnt
      
  def _set_upd_les_recent_cnt(self, v, load=False):
    """
    Setter method for upd_les_recent_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_les_recent_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_les_recent_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_les_recent_cnt() directly.

    YANG Description: Received less recent LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_les_recent_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_les_recent_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_les_recent_cnt(self):
    self.__upd_les_recent_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_unknw_lsa_cnt(self):
    """
    Getter method for upd_unknw_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_unknw_lsa_cnt (uint32)

    YANG Description: LSUpdate packet unknown LSA type.
    """
    return self.__upd_unknw_lsa_cnt
      
  def _set_upd_unknw_lsa_cnt(self, v, load=False):
    """
    Setter method for upd_unknw_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/upd_unknw_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_unknw_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_unknw_lsa_cnt() directly.

    YANG Description: LSUpdate packet unknown LSA type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknw-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_unknw_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknw-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_unknw_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_unknw_lsa_cnt(self):
    self.__upd_unknw_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknw-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opq9_flood_cnt(self):
    """
    Getter method for opq9_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/opq9_flood_cnt (uint32)

    YANG Description: Opq9 of flooding scope.
    """
    return self.__opq9_flood_cnt
      
  def _set_opq9_flood_cnt(self, v, load=False):
    """
    Setter method for opq9_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/opq9_flood_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opq9_flood_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opq9_flood_cnt() directly.

    YANG Description: Opq9 of flooding scope.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opq9_flood_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opq9_flood_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opq9_flood_cnt(self):
    self.__opq9_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opq10_flood_cnt(self):
    """
    Getter method for opq10_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/opq10_flood_cnt (uint32)

    YANG Description: Opq10 of flooding scope.
    """
    return self.__opq10_flood_cnt
      
  def _set_opq10_flood_cnt(self, v, load=False):
    """
    Setter method for opq10_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/opq10_flood_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opq10_flood_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opq10_flood_cnt() directly.

    YANG Description: Opq10 of flooding scope.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opq10_flood_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opq10_flood_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opq10_flood_cnt(self):
    self.__opq10_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opq11_flood_cnt(self):
    """
    Getter method for opq11_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/opq11_flood_cnt (uint32)

    YANG Description: Opq11 of flooding scope.
    """
    return self.__opq11_flood_cnt
      
  def _set_opq11_flood_cnt(self, v, load=False):
    """
    Setter method for opq11_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/opq11_flood_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opq11_flood_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opq11_flood_cnt() directly.

    YANG Description: Opq11 of flooding scope.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opq11_flood_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opq11_flood_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opq11_flood_cnt(self):
    self.__opq11_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_rxmt_dd_err_cnt(self):
    """
    Getter method for rxmt_dd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/rxmt_dd_err_cnt (uint32)

    YANG Description: Number for DD packet.
    """
    return self.__rxmt_dd_err_cnt
      
  def _set_rxmt_dd_err_cnt(self, v, load=False):
    """
    Setter method for rxmt_dd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/rxmt_dd_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxmt_dd_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxmt_dd_err_cnt() directly.

    YANG Description: Number for DD packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxmt_dd_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__rxmt_dd_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxmt_dd_err_cnt(self):
    self.__rxmt_dd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_rxmt_req_err_cnt(self):
    """
    Getter method for rxmt_req_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/rxmt_req_err_cnt (uint32)

    YANG Description: Number for request packet.
    """
    return self.__rxmt_req_err_cnt
      
  def _set_rxmt_req_err_cnt(self, v, load=False):
    """
    Setter method for rxmt_req_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/rxmt_req_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxmt_req_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxmt_req_err_cnt() directly.

    YANG Description: Number for request packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxmt_req_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__rxmt_req_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxmt_req_err_cnt(self):
    self.__rxmt_req_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_rxmt_upd_err_cnt(self):
    """
    Getter method for rxmt_upd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/rxmt_upd_err_cnt (uint32)

    YANG Description: Number for update packet.
    """
    return self.__rxmt_upd_err_cnt
      
  def _set_rxmt_upd_err_cnt(self, v, load=False):
    """
    Setter method for rxmt_upd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/rxmt_upd_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxmt_upd_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxmt_upd_err_cnt() directly.

    YANG Description: Number for update packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxmt_upd_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__rxmt_upd_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxmt_upd_err_cnt(self):
    self.__rxmt_upd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_gr_invalid_lsa_cnt(self):
    """
    Getter method for gr_invalid_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/gr_invalid_lsa_cnt (uint32)

    YANG Description: Number of invalid LSAs.
    """
    return self.__gr_invalid_lsa_cnt
      
  def _set_gr_invalid_lsa_cnt(self, v, load=False):
    """
    Setter method for gr_invalid_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/gr_invalid_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_invalid_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_invalid_lsa_cnt() directly.

    YANG Description: Number of invalid LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_invalid_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__gr_invalid_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_invalid_lsa_cnt(self):
    self.__gr_invalid_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_gr_invalid_pol_cnt(self):
    """
    Getter method for gr_invalid_pol_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/gr_invalid_pol_cnt (uint32)

    YANG Description: Number of policy failed LSAs.
    """
    return self.__gr_invalid_pol_cnt
      
  def _set_gr_invalid_pol_cnt(self, v, load=False):
    """
    Setter method for gr_invalid_pol_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/gr_invalid_pol_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_invalid_pol_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_invalid_pol_cnt() directly.

    YANG Description: Number of policy failed LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_invalid_pol_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__gr_invalid_pol_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_invalid_pol_cnt(self):
    self.__gr_invalid_pol_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_gr_invalid_prd_cnt(self):
    """
    Getter method for gr_invalid_prd_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/gr_invalid_prd_cnt (uint32)

    YANG Description: Number of wrong period LSAs.
    """
    return self.__gr_invalid_prd_cnt
      
  def _set_gr_invalid_prd_cnt(self, v, load=False):
    """
    Setter method for gr_invalid_prd_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/gr_invalid_prd_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_invalid_prd_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_invalid_prd_cnt() directly.

    YANG Description: Number of wrong period LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_invalid_prd_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__gr_invalid_prd_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_invalid_prd_cnt(self):
    self.__gr_invalid_prd_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_tunnel_cost_cnt(self):
    """
    Getter method for tunnel_cost_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/tunnel_cost_cnt (uint32)

    YANG Description: Tunnel cost mistake.
    """
    return self.__tunnel_cost_cnt
      
  def _set_tunnel_cost_cnt(self, v, load=False):
    """
    Setter method for tunnel_cost_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/tunnel_cost_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_cost_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_cost_cnt() directly.

    YANG Description: Tunnel cost mistake.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_cost_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tunnel_cost_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_cost_cnt(self):
    self.__tunnel_cost_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_peer_net_type_cnt(self):
    """
    Getter method for peer_net_type_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/peer_net_type_cnt (uint32)

    YANG Description: The network type of the neighbor interface is not consistent.
    """
    return self.__peer_net_type_cnt
      
  def _set_peer_net_type_cnt(self, v, load=False):
    """
    Setter method for peer_net_type_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/peer_net_type_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_net_type_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_net_type_cnt() directly.

    YANG Description: The network type of the neighbor interface is not consistent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_net_type_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__peer_net_type_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_net_type_cnt(self):
    self.__peer_net_type_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_hello_dr_mis_cnt(self):
    """
    Getter method for hello_dr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/hello_dr_mis_cnt (uint32)

    YANG Description: The DR or BDR in receiving hello packet is not same with the DR or BDR.
    """
    return self.__hello_dr_mis_cnt
      
  def _set_hello_dr_mis_cnt(self, v, load=False):
    """
    Setter method for hello_dr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data/hello_dr_mis_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_dr_mis_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_dr_mis_cnt() directly.

    YANG Description: The DR or BDR in receiving hello packet is not same with the DR or BDR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_dr_mis_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__hello_dr_mis_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_dr_mis_cnt(self):
    self.__hello_dr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  same_ip_pkt_cnt = __builtin__.property(_get_same_ip_pkt_cnt)
  bad_pkt_cnt = __builtin__.property(_get_bad_pkt_cnt)
  bad_ver_cnt = __builtin__.property(_get_bad_ver_cnt)
  bad_chksum_pkt_cnt = __builtin__.property(_get_bad_chksum_pkt_cnt)
  bad_area_pkt_cnt = __builtin__.property(_get_bad_area_pkt_cnt)
  pkt_rcv_unnumber = __builtin__.property(_get_pkt_rcv_unnumber)
  bad_virt_link_cnt = __builtin__.property(_get_bad_virt_link_cnt)
  auth_type_fail_cnt = __builtin__.property(_get_auth_type_fail_cnt)
  auth_key_fail_cnt = __builtin__.property(_get_auth_key_fail_cnt)
  short_pkt_cnt = __builtin__.property(_get_short_pkt_cnt)
  long_pkt_cnt = __builtin__.property(_get_long_pkt_cnt)
  tx_err_cnt = __builtin__.property(_get_tx_err_cnt)
  if_down_cnt = __builtin__.property(_get_if_down_cnt)
  no_nbr = __builtin__.property(_get_no_nbr)
  mis_netmask_cnt = __builtin__.property(_get_mis_netmask_cnt)
  mis_hello_intl_cnt = __builtin__.property(_get_mis_hello_intl_cnt)
  mis_dead_intl_cnt = __builtin__.property(_get_mis_dead_intl_cnt)
  mis_ext_cnt = __builtin__.property(_get_mis_ext_cnt)
  router_id_confusion = __builtin__.property(_get_router_id_confusion)
  vlink_nbr_mis_cnt = __builtin__.property(_get_vlink_nbr_mis_cnt)
  nbma_nbr_err_cnt = __builtin__.property(_get_nbma_nbr_err_cnt)
  inval_src_hello_cnt = __builtin__.property(_get_inval_src_hello_cnt)
  dd_nbr_low_cnt = __builtin__.property(_get_dd_nbr_low_cnt)
  dd_rtrid_cnt = __builtin__.property(_get_dd_rtrid_cnt)
  dd_opt_mismatch_cnt = __builtin__.property(_get_dd_opt_mismatch_cnt)
  dd_unknwn_lsa_cnt = __builtin__.property(_get_dd_unknwn_lsa_cnt)
  dd_mtu_mismatch_cnt = __builtin__.property(_get_dd_mtu_mismatch_cnt)
  ack_nbr_low_cnt = __builtin__.property(_get_ack_nbr_low_cnt)
  ack_bad_cnt = __builtin__.property(_get_ack_bad_cnt)
  ack_duplicate_cnt = __builtin__.property(_get_ack_duplicate_cnt)
  ack_unknwn_lsa_cnt = __builtin__.property(_get_ack_unknwn_lsa_cnt)
  req_nbr_low_cnt = __builtin__.property(_get_req_nbr_low_cnt)
  req_empty_cnt = __builtin__.property(_get_req_empty_cnt)
  req_bad_cnt = __builtin__.property(_get_req_bad_cnt)
  upd_nbr_low_cnt = __builtin__.property(_get_upd_nbr_low_cnt)
  upd_self_newr_cnt = __builtin__.property(_get_upd_self_newr_cnt)
  upd_min_lsarr_cnt = __builtin__.property(_get_upd_min_lsarr_cnt)
  upd_ls_chksum_cnt = __builtin__.property(_get_upd_ls_chksum_cnt)
  upd_les_recent_cnt = __builtin__.property(_get_upd_les_recent_cnt)
  upd_unknw_lsa_cnt = __builtin__.property(_get_upd_unknw_lsa_cnt)
  opq9_flood_cnt = __builtin__.property(_get_opq9_flood_cnt)
  opq10_flood_cnt = __builtin__.property(_get_opq10_flood_cnt)
  opq11_flood_cnt = __builtin__.property(_get_opq11_flood_cnt)
  rxmt_dd_err_cnt = __builtin__.property(_get_rxmt_dd_err_cnt)
  rxmt_req_err_cnt = __builtin__.property(_get_rxmt_req_err_cnt)
  rxmt_upd_err_cnt = __builtin__.property(_get_rxmt_upd_err_cnt)
  gr_invalid_lsa_cnt = __builtin__.property(_get_gr_invalid_lsa_cnt)
  gr_invalid_pol_cnt = __builtin__.property(_get_gr_invalid_pol_cnt)
  gr_invalid_prd_cnt = __builtin__.property(_get_gr_invalid_prd_cnt)
  tunnel_cost_cnt = __builtin__.property(_get_tunnel_cost_cnt)
  peer_net_type_cnt = __builtin__.property(_get_peer_net_type_cnt)
  hello_dr_mis_cnt = __builtin__.property(_get_hello_dr_mis_cnt)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('same_ip_pkt_cnt', same_ip_pkt_cnt), ('bad_pkt_cnt', bad_pkt_cnt), ('bad_ver_cnt', bad_ver_cnt), ('bad_chksum_pkt_cnt', bad_chksum_pkt_cnt), ('bad_area_pkt_cnt', bad_area_pkt_cnt), ('pkt_rcv_unnumber', pkt_rcv_unnumber), ('bad_virt_link_cnt', bad_virt_link_cnt), ('auth_type_fail_cnt', auth_type_fail_cnt), ('auth_key_fail_cnt', auth_key_fail_cnt), ('short_pkt_cnt', short_pkt_cnt), ('long_pkt_cnt', long_pkt_cnt), ('tx_err_cnt', tx_err_cnt), ('if_down_cnt', if_down_cnt), ('no_nbr', no_nbr), ('mis_netmask_cnt', mis_netmask_cnt), ('mis_hello_intl_cnt', mis_hello_intl_cnt), ('mis_dead_intl_cnt', mis_dead_intl_cnt), ('mis_ext_cnt', mis_ext_cnt), ('router_id_confusion', router_id_confusion), ('vlink_nbr_mis_cnt', vlink_nbr_mis_cnt), ('nbma_nbr_err_cnt', nbma_nbr_err_cnt), ('inval_src_hello_cnt', inval_src_hello_cnt), ('dd_nbr_low_cnt', dd_nbr_low_cnt), ('dd_rtrid_cnt', dd_rtrid_cnt), ('dd_opt_mismatch_cnt', dd_opt_mismatch_cnt), ('dd_unknwn_lsa_cnt', dd_unknwn_lsa_cnt), ('dd_mtu_mismatch_cnt', dd_mtu_mismatch_cnt), ('ack_nbr_low_cnt', ack_nbr_low_cnt), ('ack_bad_cnt', ack_bad_cnt), ('ack_duplicate_cnt', ack_duplicate_cnt), ('ack_unknwn_lsa_cnt', ack_unknwn_lsa_cnt), ('req_nbr_low_cnt', req_nbr_low_cnt), ('req_empty_cnt', req_empty_cnt), ('req_bad_cnt', req_bad_cnt), ('upd_nbr_low_cnt', upd_nbr_low_cnt), ('upd_self_newr_cnt', upd_self_newr_cnt), ('upd_min_lsarr_cnt', upd_min_lsarr_cnt), ('upd_ls_chksum_cnt', upd_ls_chksum_cnt), ('upd_les_recent_cnt', upd_les_recent_cnt), ('upd_unknw_lsa_cnt', upd_unknw_lsa_cnt), ('opq9_flood_cnt', opq9_flood_cnt), ('opq10_flood_cnt', opq10_flood_cnt), ('opq11_flood_cnt', opq11_flood_cnt), ('rxmt_dd_err_cnt', rxmt_dd_err_cnt), ('rxmt_req_err_cnt', rxmt_req_err_cnt), ('rxmt_upd_err_cnt', rxmt_upd_err_cnt), ('gr_invalid_lsa_cnt', gr_invalid_lsa_cnt), ('gr_invalid_pol_cnt', gr_invalid_pol_cnt), ('gr_invalid_prd_cnt', gr_invalid_prd_cnt), ('tunnel_cost_cnt', tunnel_cost_cnt), ('peer_net_type_cnt', peer_net_type_cnt), ('hello_dr_mis_cnt', hello_dr_mis_cnt), ])


class yc_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the interface enabled with OSPF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__network_type','__peer_ip_ignore','__transmit_delay','__mtu_enable','__dr_priority','__cost','__smart_discover','__p2mp_mask_ignore','__ldp_sync_block','__ldp_sync_enable','__link_cost','__suppress_reachability','__mpls_ldp_auto_flag','__dcn_opq_blk_enable','__peer_hold_max_timer','__fallback_cost','__fallback_bw','__source_sub_ip_address','__frr','__timer','__ldp_sync','__bfd','__authentication','__filter_lsa_out','__suppress_flapping','__flush_source_trace','__mpls_te_peers','__multi_areas','__disp_data','__nbr_statistics','__error_data',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    self.__network_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'broadcast': {'value': 1}, 'nbma': {'value': 2}, 'p2mp': {'value': 5}, 'p2p': {'value': 3}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='network-type', is_config=True)
    self.__peer_ip_ignore = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("disable"), is_leaf=True, yang_name="peer-ip-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-ip-ignore-type', is_config=True)
    self.__transmit_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__mtu_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__p2mp_mask_ignore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2mp-mask-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__ldp_sync_block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__ldp_sync_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__link_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__suppress_reachability = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'not-configured': {'value': 2}},), default=six.text_type("not-configured"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='suppr-reach', is_config=True)
    self.__mpls_ldp_auto_flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 1}, 'disable': {'value': 0}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='if-auto-cfg-state', is_config=True)
    self.__dcn_opq_blk_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dcn-opq-blk-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__peer_hold_max_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peer-hold-max-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__fallback_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__fallback_bw = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__source_sub_ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="source-sub-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__frr = YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__ldp_sync = YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__bfd = YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__filter_lsa_out = YANGDynClass(base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__suppress_flapping = YANGDynClass(base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__flush_source_trace = YANGDynClass(base=yc_flush_source_trace_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__mpls_te_peers = YANGDynClass(base=yc_mpls_te_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers, is_container='container', yang_name="mpls-te-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__multi_areas = YANGDynClass(base=yc_multi_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas, is_container='container', yang_name="multi-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__disp_data = YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__nbr_statistics = YANGDynClass(base=yc_nbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics, is_container='container', yang_name="nbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__error_data = YANGDynClass(base=yc_error_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_error_data, is_container='container', yang_name="error-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/name (leafref)

    YANG Description: Interface name. OSPF does not support the configuration of a NULL/LMP/MTUNNEL/RPR/STACKPORT/SIP/ATMBUNDLE/IMAGROUP/Remote-Ap/VBridge interface types.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Interface name. OSPF does not support the configuration of a NULL/LMP/MTUNNEL/RPR/STACKPORT/SIP/ATMBUNDLE/IMAGROUP/Remote-Ap/VBridge interface types.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)


  def _get_network_type(self):
    """
    Getter method for network_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/network_type (network-type)

    YANG Description: Network type of an OSPF interface. By default, the network type of an interface is determined by the physical interface.
In the same network segment, if only two routers run OSPF, you can change the network type of an interface to P2P.
    """
    return self.__network_type
      
  def _set_network_type(self, v, load=False):
    """
    Setter method for network_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/network_type (network-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_type() directly.

    YANG Description: Network type of an OSPF interface. By default, the network type of an interface is determined by the physical interface.
In the same network segment, if only two routers run OSPF, you can change the network type of an interface to P2P.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'broadcast': {'value': 1}, 'nbma': {'value': 2}, 'p2mp': {'value': 5}, 'p2p': {'value': 3}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='network-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_type must be of a type compatible with network-type""",
          'defined-type': "huawei-ospfv2:network-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'broadcast': {'value': 1}, 'nbma': {'value': 2}, 'p2mp': {'value': 5}, 'p2p': {'value': 3}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='network-type', is_config=True)""",
        })

    self.__network_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_type(self):
    self.__network_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'broadcast': {'value': 1}, 'nbma': {'value': 2}, 'p2mp': {'value': 5}, 'p2p': {'value': 3}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='network-type', is_config=True)


  def _get_peer_ip_ignore(self):
    """
    Getter method for peer_ip_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/peer_ip_ignore (peer-ip-ignore-type)

    YANG Description: Ignores the subnet match check in multi access interface when network type P2P is configured along with this option.
    """
    return self.__peer_ip_ignore
      
  def _set_peer_ip_ignore(self, v, load=False):
    """
    Setter method for peer_ip_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/peer_ip_ignore (peer-ip-ignore-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_ip_ignore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_ip_ignore() directly.

    YANG Description: Ignores the subnet match check in multi access interface when network type P2P is configured along with this option.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("disable"), is_leaf=True, yang_name="peer-ip-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-ip-ignore-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_ip_ignore must be of a type compatible with peer-ip-ignore-type""",
          'defined-type': "huawei-ospfv2:peer-ip-ignore-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("disable"), is_leaf=True, yang_name="peer-ip-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-ip-ignore-type', is_config=True)""",
        })

    self.__peer_ip_ignore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_ip_ignore(self):
    self.__peer_ip_ignore = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("disable"), is_leaf=True, yang_name="peer-ip-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='peer-ip-ignore-type', is_config=True)


  def _get_transmit_delay(self):
    """
    Getter method for transmit_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/transmit_delay (int32)

    YANG Description: Delay for transmitting LSAs on an interface.
    """
    return self.__transmit_delay
      
  def _set_transmit_delay(self, v, load=False):
    """
    Setter method for transmit_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/transmit_delay (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transmit_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transmit_delay() directly.

    YANG Description: Delay for transmitting LSAs on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transmit_delay must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__transmit_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transmit_delay(self):
    self.__transmit_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['1..500']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="transmit-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_mtu_enable(self):
    """
    Getter method for mtu_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mtu_enable (boolean)

    YANG Description: Enable/disable MTU filled in a DD packet when the packet is sent. The default MTU in the DD packet is 0. Using the command, you can manually configure the interface to fill in the MTU field (actual MTU of the interface) when the interface sends DD packets.
After a virtual connection is established through the virtual template or tunnel, different vendors may use different MTUs as default settings. To ensure consistency, the MTU is set to 0 by default when the interface sends DD packets. Thus, the ospf mtu-enable command usually does not need to be configured.
OSPF does not support the preceding configuration on a null interface.
    """
    return self.__mtu_enable
      
  def _set_mtu_enable(self, v, load=False):
    """
    Setter method for mtu_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mtu_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu_enable() directly.

    YANG Description: Enable/disable MTU filled in a DD packet when the packet is sent. The default MTU in the DD packet is 0. Using the command, you can manually configure the interface to fill in the MTU field (actual MTU of the interface) when the interface sends DD packets.
After a virtual connection is established through the virtual template or tunnel, different vendors may use different MTUs as default settings. To ensure consistency, the MTU is set to 0 by default when the interface sends DD packets. Thus, the ospf mtu-enable command usually does not need to be configured.
OSPF does not support the preceding configuration on a null interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__mtu_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu_enable(self):
    self.__mtu_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_dr_priority(self):
    """
    Getter method for dr_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/dr_priority (int32)

    YANG Description: Priority of the interface that participates in the DR and BDR election. The greater the value is, the higher the priority is. The router whose priority is 0 cannot be elected as a DR or a BDR.
    """
    return self.__dr_priority
      
  def _set_dr_priority(self, v, load=False):
    """
    Setter method for dr_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/dr_priority (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_priority() directly.

    YANG Description: Priority of the interface that participates in the DR and BDR election. The greater the value is, the higher the priority is. The router whose priority is 0 cannot be elected as a DR or a BDR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_priority must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)""",
        })

    self.__dr_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_priority(self):
    self.__dr_priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32)(1), is_leaf=True, yang_name="dr-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=True)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/cost (uint32)

    YANG Description: To set the cost of an interface. The default value is 1. But the default of Loopback is 0.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: To set the cost of an interface. The default value is 1. But the default of Loopback is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_smart_discover(self):
    """
    Getter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/smart_discover (boolean)

    YANG Description: Enable/disable smart discover on an interface. When the neighbor status of a router or a DR or BDR on the multi address network of the broadcast or NBMA type changes, the router can send hello packets to the neighbor actively rather than wait for the expiration of the hello timer.
    """
    return self.__smart_discover
      
  def _set_smart_discover(self, v, load=False):
    """
    Setter method for smart_discover, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/smart_discover (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smart_discover is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smart_discover() directly.

    YANG Description: Enable/disable smart discover on an interface. When the neighbor status of a router or a DR or BDR on the multi address network of the broadcast or NBMA type changes, the router can send hello packets to the neighbor actively rather than wait for the expiration of the hello timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smart_discover must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__smart_discover = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smart_discover(self):
    self.__smart_discover = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="smart-discover", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_p2mp_mask_ignore(self):
    """
    Getter method for p2mp_mask_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/p2mp_mask_ignore (boolean)

    YANG Description: Enable/disable to ignore the check of network masks on a P2MP network. On a P2MP network, when the lengths of device masks are inconsistent, the check of network masks in hello packets can be ignored through this command. In this case, the OSPF neighbor relationship can be normally established.
    """
    return self.__p2mp_mask_ignore
      
  def _set_p2mp_mask_ignore(self, v, load=False):
    """
    Setter method for p2mp_mask_ignore, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/p2mp_mask_ignore (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_p2mp_mask_ignore is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_p2mp_mask_ignore() directly.

    YANG Description: Enable/disable to ignore the check of network masks on a P2MP network. On a P2MP network, when the lengths of device masks are inconsistent, the check of network masks in hello packets can be ignored through this command. In this case, the OSPF neighbor relationship can be normally established.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2mp-mask-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """p2mp_mask_ignore must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2mp-mask-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__p2mp_mask_ignore = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_p2mp_mask_ignore(self):
    self.__p2mp_mask_ignore = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="p2mp-mask-ignore", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_ldp_sync_block(self):
    """
    Getter method for ldp_sync_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync_block (boolean)

    YANG Description: Enable/disable LDP sync on this interface.
    """
    return self.__ldp_sync_block
      
  def _set_ldp_sync_block(self, v, load=False):
    """
    Setter method for ldp_sync_block, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync_block() directly.

    YANG Description: Enable/disable LDP sync on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__ldp_sync_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync_block(self):
    self.__ldp_sync_block = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_ldp_sync_enable(self):
    """
    Getter method for ldp_sync_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync_enable (boolean)

    YANG Description: Enable/disable LDP and OSPF synchronization on an interface.
    """
    return self.__ldp_sync_enable
      
  def _set_ldp_sync_enable(self, v, load=False):
    """
    Setter method for ldp_sync_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync_enable() directly.

    YANG Description: Enable/disable LDP and OSPF synchronization on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__ldp_sync_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync_enable(self):
    self.__ldp_sync_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ldp-sync-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_link_cost(self):
    """
    Getter method for link_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/link_cost (uint32)

    YANG Description: Link cost to be incremented when link quality is low. The default of Loopback is 0,others is 1.
    """
    return self.__link_cost
      
  def _set_link_cost(self, v, load=False):
    """
    Setter method for link_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/link_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_cost() directly.

    YANG Description: Link cost to be incremented when link quality is low. The default of Loopback is 0,others is 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__link_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_cost(self):
    self.__link_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_suppress_reachability(self):
    """
    Getter method for suppress_reachability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_reachability (suppr-reach)

    YANG Description: Suppress its own prefixes and ignore the suppressed prefixes.
    """
    return self.__suppress_reachability
      
  def _set_suppress_reachability(self, v, load=False):
    """
    Setter method for suppress_reachability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_reachability (suppr-reach)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_reachability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_reachability() directly.

    YANG Description: Suppress its own prefixes and ignore the suppressed prefixes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'not-configured': {'value': 2}},), default=six.text_type("not-configured"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='suppr-reach', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_reachability must be of a type compatible with suppr-reach""",
          'defined-type': "huawei-ospfv2:suppr-reach",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'not-configured': {'value': 2}},), default=six.text_type("not-configured"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='suppr-reach', is_config=True)""",
        })

    self.__suppress_reachability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_reachability(self):
    self.__suppress_reachability = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'not-configured': {'value': 2}},), default=six.text_type("not-configured"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='suppr-reach', is_config=True)


  def _get_mpls_ldp_auto_flag(self):
    """
    Getter method for mpls_ldp_auto_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_ldp_auto_flag (if-auto-cfg-state)

    YANG Description: Block MPLS LDP auto configuration on the interface.
    """
    return self.__mpls_ldp_auto_flag
      
  def _set_mpls_ldp_auto_flag(self, v, load=False):
    """
    Setter method for mpls_ldp_auto_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_ldp_auto_flag (if-auto-cfg-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ldp_auto_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ldp_auto_flag() directly.

    YANG Description: Block MPLS LDP auto configuration on the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 1}, 'disable': {'value': 0}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='if-auto-cfg-state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ldp_auto_flag must be of a type compatible with if-auto-cfg-state""",
          'defined-type': "huawei-ospfv2:if-auto-cfg-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 1}, 'disable': {'value': 0}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='if-auto-cfg-state', is_config=True)""",
        })

    self.__mpls_ldp_auto_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ldp_auto_flag(self):
    self.__mpls_ldp_auto_flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 1}, 'disable': {'value': 0}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='if-auto-cfg-state', is_config=True)


  def _get_dcn_opq_blk_enable(self):
    """
    Getter method for dcn_opq_blk_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/dcn_opq_blk_enable (boolean)

    YANG Description: Enable/disable filter type-10 dcn opaque LSAs.
    """
    return self.__dcn_opq_blk_enable
      
  def _set_dcn_opq_blk_enable(self, v, load=False):
    """
    Setter method for dcn_opq_blk_enable, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/dcn_opq_blk_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dcn_opq_blk_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dcn_opq_blk_enable() directly.

    YANG Description: Enable/disable filter type-10 dcn opaque LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dcn-opq-blk-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dcn_opq_blk_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dcn-opq-blk-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__dcn_opq_blk_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dcn_opq_blk_enable(self):
    self.__dcn_opq_blk_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dcn-opq-blk-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_peer_hold_max_timer(self):
    """
    Getter method for peer_hold_max_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/peer_hold_max_timer (uint32)

    YANG Description: Config peer hold max cost interval.
    """
    return self.__peer_hold_max_timer
      
  def _set_peer_hold_max_timer(self, v, load=False):
    """
    Setter method for peer_hold_max_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/peer_hold_max_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_hold_max_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_hold_max_timer() directly.

    YANG Description: Config peer hold max cost interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peer-hold-max-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_hold_max_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peer-hold-max-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__peer_hold_max_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_hold_max_timer(self):
    self.__peer_hold_max_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['100..1000000']}), is_leaf=True, yang_name="peer-hold-max-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_fallback_cost(self):
    """
    Getter method for fallback_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/fallback_cost (uint32)

    YANG Description: Fallback cost.
    """
    return self.__fallback_cost
      
  def _set_fallback_cost(self, v, load=False):
    """
    Setter method for fallback_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/fallback_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fallback_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fallback_cost() directly.

    YANG Description: Fallback cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fallback_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__fallback_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fallback_cost(self):
    self.__fallback_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..65535']}), is_leaf=True, yang_name="fallback-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_fallback_bw(self):
    """
    Getter method for fallback_bw, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/fallback_bw (uint32)

    YANG Description: Fallback bandwidth threshold.
    """
    return self.__fallback_bw
      
  def _set_fallback_bw(self, v, load=False):
    """
    Setter method for fallback_bw, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/fallback_bw (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fallback_bw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fallback_bw() directly.

    YANG Description: Fallback bandwidth threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fallback_bw must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__fallback_bw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fallback_bw(self):
    self.__fallback_bw = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="fallback-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_source_sub_ip_address(self):
    """
    Getter method for source_sub_ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/source_sub_ip_address (inet:ipv4-address-no-zone)

    YANG Description: Source address indicating a subordinate IP address.
    """
    return self.__source_sub_ip_address
      
  def _set_source_sub_ip_address(self, v, load=False):
    """
    Setter method for source_sub_ip_address, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/source_sub_ip_address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_sub_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_sub_ip_address() directly.

    YANG Description: Source address indicating a subordinate IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="source-sub-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_sub_ip_address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="source-sub-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__source_sub_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_sub_ip_address(self):
    self.__source_sub_ip_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="source-sub-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_frr(self):
    """
    Getter method for frr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr (container)

    YANG Description: Configure FRR.
    """
    return self.__frr
      
  def _set_frr(self, v, load=False):
    """
    Setter method for frr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/frr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr() directly.

    YANG Description: Configure FRR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__frr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr(self):
    self.__frr = YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer (container)

    YANG Description: Configure timer.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/timer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Configure timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_ldp_sync(self):
    """
    Getter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync (container)

    YANG Description: Configure timer ldp sync.
    """
    return self.__ldp_sync
      
  def _set_ldp_sync(self, v, load=False):
    """
    Setter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/ldp_sync (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync() directly.

    YANG Description: Configure timer ldp sync.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ldp_sync = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync(self):
    self.__ldp_sync = YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd (container)

    YANG Description: Configure BFD.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: Configure BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_authentication(self):
    """
    Getter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication (container)

    YANG Description: Configure authentication.
    """
    return self.__authentication
      
  def _set_authentication(self, v, load=False):
    """
    Setter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/authentication (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication() directly.

    YANG Description: Configure authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__authentication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication(self):
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_filter_lsa_out(self):
    """
    Getter method for filter_lsa_out, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out (container)

    YANG Description: Configure filter lsa out.
    """
    return self.__filter_lsa_out
      
  def _set_filter_lsa_out(self, v, load=False):
    """
    Setter method for filter_lsa_out, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/filter_lsa_out (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_lsa_out is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_lsa_out() directly.

    YANG Description: Configure filter lsa out.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_lsa_out must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__filter_lsa_out = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_lsa_out(self):
    self.__filter_lsa_out = YANGDynClass(base=yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_filter_lsa_out, is_container='container', yang_name="filter-lsa-out", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_suppress_flapping(self):
    """
    Getter method for suppress_flapping, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping (container)

    YANG Description: Configure flapping suppression.
    """
    return self.__suppress_flapping
      
  def _set_suppress_flapping(self, v, load=False):
    """
    Setter method for suppress_flapping, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/suppress_flapping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_flapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_flapping() directly.

    YANG Description: Configure flapping suppression.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_flapping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__suppress_flapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_flapping(self):
    self.__suppress_flapping = YANGDynClass(base=yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping, is_container='container', yang_name="suppress-flapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_flush_source_trace(self):
    """
    Getter method for flush_source_trace, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/flush_source_trace (container)

    YANG Description: Configure OSPF flush source trace function.
    """
    return self.__flush_source_trace
      
  def _set_flush_source_trace(self, v, load=False):
    """
    Setter method for flush_source_trace, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/flush_source_trace (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flush_source_trace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flush_source_trace() directly.

    YANG Description: Configure OSPF flush source trace function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_flush_source_trace_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flush_source_trace must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_flush_source_trace_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__flush_source_trace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flush_source_trace(self):
    self.__flush_source_trace = YANGDynClass(base=yc_flush_source_trace_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_mpls_te_peers(self):
    """
    Getter method for mpls_te_peers, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers (container)

    YANG Description: List of OSPF passive peer.
    """
    return self.__mpls_te_peers
      
  def _set_mpls_te_peers(self, v, load=False):
    """
    Setter method for mpls_te_peers, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/mpls_te_peers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_te_peers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_te_peers() directly.

    YANG Description: List of OSPF passive peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mpls_te_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers, is_container='container', yang_name="mpls-te-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_te_peers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mpls_te_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers, is_container='container', yang_name="mpls-te-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__mpls_te_peers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_te_peers(self):
    self.__mpls_te_peers = YANGDynClass(base=yc_mpls_te_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers, is_container='container', yang_name="mpls-te-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_multi_areas(self):
    """
    Getter method for multi_areas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas (container)

    YANG Description: List of the information about the multi-area interface enabled with OSPF.
    """
    return self.__multi_areas
      
  def _set_multi_areas(self, v, load=False):
    """
    Setter method for multi_areas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/multi_areas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multi_areas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multi_areas() directly.

    YANG Description: List of the information about the multi-area interface enabled with OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_multi_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas, is_container='container', yang_name="multi-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multi_areas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_multi_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas, is_container='container', yang_name="multi-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__multi_areas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multi_areas(self):
    self.__multi_areas = YANGDynClass(base=yc_multi_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas, is_container='container', yang_name="multi-areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_disp_data(self):
    """
    Getter method for disp_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data (container)

    YANG Description: Statistics of OSPF interface.
    """
    return self.__disp_data
      
  def _set_disp_data(self, v, load=False):
    """
    Setter method for disp_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/disp_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disp_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disp_data() directly.

    YANG Description: Statistics of OSPF interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disp_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__disp_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disp_data(self):
    self.__disp_data = YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_nbr_statistics(self):
    """
    Getter method for nbr_statistics, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics (container)

    YANG Description: List of OSPF peer.
    """
    return self.__nbr_statistics
      
  def _set_nbr_statistics(self, v, load=False):
    """
    Setter method for nbr_statistics, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/nbr_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nbr_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nbr_statistics() directly.

    YANG Description: List of OSPF peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics, is_container='container', yang_name="nbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nbr_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics, is_container='container', yang_name="nbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__nbr_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nbr_statistics(self):
    self.__nbr_statistics = YANGDynClass(base=yc_nbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics, is_container='container', yang_name="nbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_error_data(self):
    """
    Getter method for error_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data (container)

    YANG Description: Statistics of error data.
    """
    return self.__error_data
      
  def _set_error_data(self, v, load=False):
    """
    Setter method for error_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface/error_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_data() directly.

    YANG Description: Statistics of error data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_error_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_error_data, is_container='container', yang_name="error-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_error_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_error_data, is_container='container', yang_name="error-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__error_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_data(self):
    self.__error_data = YANGDynClass(base=yc_error_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_error_data, is_container='container', yang_name="error-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  network_type = __builtin__.property(_get_network_type, _set_network_type)
  peer_ip_ignore = __builtin__.property(_get_peer_ip_ignore, _set_peer_ip_ignore)
  transmit_delay = __builtin__.property(_get_transmit_delay, _set_transmit_delay)
  mtu_enable = __builtin__.property(_get_mtu_enable, _set_mtu_enable)
  dr_priority = __builtin__.property(_get_dr_priority, _set_dr_priority)
  cost = __builtin__.property(_get_cost, _set_cost)
  smart_discover = __builtin__.property(_get_smart_discover, _set_smart_discover)
  p2mp_mask_ignore = __builtin__.property(_get_p2mp_mask_ignore, _set_p2mp_mask_ignore)
  ldp_sync_block = __builtin__.property(_get_ldp_sync_block, _set_ldp_sync_block)
  ldp_sync_enable = __builtin__.property(_get_ldp_sync_enable, _set_ldp_sync_enable)
  link_cost = __builtin__.property(_get_link_cost, _set_link_cost)
  suppress_reachability = __builtin__.property(_get_suppress_reachability, _set_suppress_reachability)
  mpls_ldp_auto_flag = __builtin__.property(_get_mpls_ldp_auto_flag, _set_mpls_ldp_auto_flag)
  dcn_opq_blk_enable = __builtin__.property(_get_dcn_opq_blk_enable, _set_dcn_opq_blk_enable)
  peer_hold_max_timer = __builtin__.property(_get_peer_hold_max_timer, _set_peer_hold_max_timer)
  fallback_cost = __builtin__.property(_get_fallback_cost, _set_fallback_cost)
  fallback_bw = __builtin__.property(_get_fallback_bw, _set_fallback_bw)
  source_sub_ip_address = __builtin__.property(_get_source_sub_ip_address, _set_source_sub_ip_address)
  frr = __builtin__.property(_get_frr, _set_frr) # type: yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_frr
  timer = __builtin__.property(_get_timer, _set_timer) # type: yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_timer
  ldp_sync = __builtin__.property(_get_ldp_sync, _set_ldp_sync) # type: yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_ldp_sync
  bfd = __builtin__.property(_get_bfd, _set_bfd) # type: yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_bfd
  authentication = __builtin__.property(_get_authentication, _set_authentication) # type: yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_authentication
  filter_lsa_out = __builtin__.property(_get_filter_lsa_out, _set_filter_lsa_out) # type: yc_filter_lsa_out_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_filter_lsa_out
  suppress_flapping = __builtin__.property(_get_suppress_flapping, _set_suppress_flapping) # type: yc_suppress_flapping_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_suppress_flapping
  flush_source_trace = __builtin__.property(_get_flush_source_trace, _set_flush_source_trace) # type: yc_flush_source_trace_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_flush_source_trace
  mpls_te_peers = __builtin__.property(_get_mpls_te_peers, _set_mpls_te_peers) # type: yc_mpls_te_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_mpls_te_peers
  multi_areas = __builtin__.property(_get_multi_areas, _set_multi_areas) # type: yc_multi_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_multi_areas
  disp_data = __builtin__.property(_get_disp_data, _set_disp_data) # type: yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_disp_data
  nbr_statistics = __builtin__.property(_get_nbr_statistics, _set_nbr_statistics) # type: yc_nbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_nbr_statistics
  error_data = __builtin__.property(_get_error_data, _set_error_data) # type: yc_error_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface_error_data


  _pyangbind_elements = OrderedDict([('name', name), ('network_type', network_type), ('peer_ip_ignore', peer_ip_ignore), ('transmit_delay', transmit_delay), ('mtu_enable', mtu_enable), ('dr_priority', dr_priority), ('cost', cost), ('smart_discover', smart_discover), ('p2mp_mask_ignore', p2mp_mask_ignore), ('ldp_sync_block', ldp_sync_block), ('ldp_sync_enable', ldp_sync_enable), ('link_cost', link_cost), ('suppress_reachability', suppress_reachability), ('mpls_ldp_auto_flag', mpls_ldp_auto_flag), ('dcn_opq_blk_enable', dcn_opq_blk_enable), ('peer_hold_max_timer', peer_hold_max_timer), ('fallback_cost', fallback_cost), ('fallback_bw', fallback_bw), ('source_sub_ip_address', source_sub_ip_address), ('frr', frr), ('timer', timer), ('ldp_sync', ldp_sync), ('bfd', bfd), ('authentication', authentication), ('filter_lsa_out', filter_lsa_out), ('suppress_flapping', suppress_flapping), ('flush_source_trace', flush_source_trace), ('mpls_te_peers', mpls_te_peers), ('multi_areas', multi_areas), ('disp_data', disp_data), ('nbr_statistics', nbr_statistics), ('error_data', error_data), ])


class yc_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the interface enabled with OSPF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface (list)

    YANG Description: Configure the interface enabled with OSPF.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Configure the interface enabled with OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface) # type: yc_interface_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_disp_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area/disp-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of OSPF area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__spf_schedule_times','__interface_count','__exchange_and_loading_nbr','__router_id_conflict','__import_limit_status','__self_nssa_lsa_count','__nssa_trans_state','__nssa_trans_role','__nssa_trans_stab_intv',)

  _yang_name = 'disp-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__spf_schedule_times = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-schedule-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__interface_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__exchange_and_loading_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__router_id_conflict = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'wait-select': {'value': 1}, 'selecting': {'value': 2}, 'changed': {'value': 3}, 'suspend': {'value': 4}, 'none': {'value': 5}},), is_leaf=True, yang_name="router-id-conflict", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-id-conflict-state', is_config=False)
    self.__import_limit_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)
    self.__self_nssa_lsa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-nssa-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__nssa_trans_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enabled': {'value': 1}, 'elected': {'value': 2}, 'disabled': {'value': 3}},), is_leaf=True, yang_name="nssa-trans-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-state', is_config=False)
    self.__nssa_trans_role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'always': {'value': 1}, 'candidate': {'value': 2}},), is_leaf=True, yang_name="nssa-trans-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-role', is_config=False)
    self.__nssa_trans_stab_intv = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-trans-stab-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area', 'disp-data']

  def _get_spf_schedule_times(self):
    """
    Getter method for spf_schedule_times, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/spf_schedule_times (uint32)

    YANG Description: Times of calculating SPF.
    """
    return self.__spf_schedule_times
      
  def _set_spf_schedule_times(self, v, load=False):
    """
    Setter method for spf_schedule_times, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/spf_schedule_times (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_schedule_times is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_schedule_times() directly.

    YANG Description: Times of calculating SPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-schedule-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_schedule_times must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-schedule-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__spf_schedule_times = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_schedule_times(self):
    self.__spf_schedule_times = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-schedule-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_interface_count(self):
    """
    Getter method for interface_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/interface_count (uint32)

    YANG Description: Number of interfaces.
    """
    return self.__interface_count
      
  def _set_interface_count(self, v, load=False):
    """
    Setter method for interface_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/interface_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_count() directly.

    YANG Description: Number of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__interface_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_count(self):
    self.__interface_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_exchange_and_loading_nbr(self):
    """
    Getter method for exchange_and_loading_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/exchange_and_loading_nbr (uint32)

    YANG Description: Number of neighbors in exchange/loading state.
    """
    return self.__exchange_and_loading_nbr
      
  def _set_exchange_and_loading_nbr(self, v, load=False):
    """
    Setter method for exchange_and_loading_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/exchange_and_loading_nbr (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exchange_and_loading_nbr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exchange_and_loading_nbr() directly.

    YANG Description: Number of neighbors in exchange/loading state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exchange_and_loading_nbr must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__exchange_and_loading_nbr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exchange_and_loading_nbr(self):
    self.__exchange_and_loading_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_router_id_conflict(self):
    """
    Getter method for router_id_conflict, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/router_id_conflict (router-id-conflict-state)

    YANG Description: Router ID conflict state.
    """
    return self.__router_id_conflict
      
  def _set_router_id_conflict(self, v, load=False):
    """
    Setter method for router_id_conflict, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/router_id_conflict (router-id-conflict-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id_conflict is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id_conflict() directly.

    YANG Description: Router ID conflict state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'wait-select': {'value': 1}, 'selecting': {'value': 2}, 'changed': {'value': 3}, 'suspend': {'value': 4}, 'none': {'value': 5}},), is_leaf=True, yang_name="router-id-conflict", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-id-conflict-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id_conflict must be of a type compatible with router-id-conflict-state""",
          'defined-type': "huawei-ospfv2:router-id-conflict-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'wait-select': {'value': 1}, 'selecting': {'value': 2}, 'changed': {'value': 3}, 'suspend': {'value': 4}, 'none': {'value': 5}},), is_leaf=True, yang_name="router-id-conflict", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-id-conflict-state', is_config=False)""",
        })

    self.__router_id_conflict = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id_conflict(self):
    self.__router_id_conflict = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'wait-select': {'value': 1}, 'selecting': {'value': 2}, 'changed': {'value': 3}, 'suspend': {'value': 4}, 'none': {'value': 5}},), is_leaf=True, yang_name="router-id-conflict", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-id-conflict-state', is_config=False)


  def _get_import_limit_status(self):
    """
    Getter method for import_limit_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/import_limit_status (import-limit-status)

    YANG Description: Limit status of imported routes.
    """
    return self.__import_limit_status
      
  def _set_import_limit_status(self, v, load=False):
    """
    Setter method for import_limit_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/import_limit_status (import-limit-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_limit_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_limit_status() directly.

    YANG Description: Limit status of imported routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_limit_status must be of a type compatible with import-limit-status""",
          'defined-type': "huawei-ospfv2:import-limit-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)""",
        })

    self.__import_limit_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_limit_status(self):
    self.__import_limit_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)


  def _get_self_nssa_lsa_count(self):
    """
    Getter method for self_nssa_lsa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/self_nssa_lsa_count (uint32)

    YANG Description: Number of NSSA LSAs that are generated locally.
    """
    return self.__self_nssa_lsa_count
      
  def _set_self_nssa_lsa_count(self, v, load=False):
    """
    Setter method for self_nssa_lsa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/self_nssa_lsa_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_self_nssa_lsa_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_self_nssa_lsa_count() directly.

    YANG Description: Number of NSSA LSAs that are generated locally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-nssa-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """self_nssa_lsa_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-nssa-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__self_nssa_lsa_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_self_nssa_lsa_count(self):
    self.__self_nssa_lsa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-nssa-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_nssa_trans_state(self):
    """
    Getter method for nssa_trans_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/nssa_trans_state (nssa-trans-state)

    YANG Description: NSSA translator state.
    """
    return self.__nssa_trans_state
      
  def _set_nssa_trans_state(self, v, load=False):
    """
    Setter method for nssa_trans_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/nssa_trans_state (nssa-trans-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa_trans_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa_trans_state() directly.

    YANG Description: NSSA translator state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enabled': {'value': 1}, 'elected': {'value': 2}, 'disabled': {'value': 3}},), is_leaf=True, yang_name="nssa-trans-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa_trans_state must be of a type compatible with nssa-trans-state""",
          'defined-type': "huawei-ospfv2:nssa-trans-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enabled': {'value': 1}, 'elected': {'value': 2}, 'disabled': {'value': 3}},), is_leaf=True, yang_name="nssa-trans-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-state', is_config=False)""",
        })

    self.__nssa_trans_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa_trans_state(self):
    self.__nssa_trans_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enabled': {'value': 1}, 'elected': {'value': 2}, 'disabled': {'value': 3}},), is_leaf=True, yang_name="nssa-trans-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-state', is_config=False)


  def _get_nssa_trans_role(self):
    """
    Getter method for nssa_trans_role, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/nssa_trans_role (nssa-trans-role)

    YANG Description: NSSA translator role.
    """
    return self.__nssa_trans_role
      
  def _set_nssa_trans_role(self, v, load=False):
    """
    Setter method for nssa_trans_role, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/nssa_trans_role (nssa-trans-role)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa_trans_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa_trans_role() directly.

    YANG Description: NSSA translator role.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'always': {'value': 1}, 'candidate': {'value': 2}},), is_leaf=True, yang_name="nssa-trans-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-role', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa_trans_role must be of a type compatible with nssa-trans-role""",
          'defined-type': "huawei-ospfv2:nssa-trans-role",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'always': {'value': 1}, 'candidate': {'value': 2}},), is_leaf=True, yang_name="nssa-trans-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-role', is_config=False)""",
        })

    self.__nssa_trans_role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa_trans_role(self):
    self.__nssa_trans_role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'always': {'value': 1}, 'candidate': {'value': 2}},), is_leaf=True, yang_name="nssa-trans-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nssa-trans-role', is_config=False)


  def _get_nssa_trans_stab_intv(self):
    """
    Getter method for nssa_trans_stab_intv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/nssa_trans_stab_intv (boolean)

    YANG Description: Continuing NSSA translation duties during stability interval.
    """
    return self.__nssa_trans_stab_intv
      
  def _set_nssa_trans_stab_intv(self, v, load=False):
    """
    Setter method for nssa_trans_stab_intv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data/nssa_trans_stab_intv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa_trans_stab_intv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa_trans_stab_intv() directly.

    YANG Description: Continuing NSSA translation duties during stability interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nssa-trans-stab-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa_trans_stab_intv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-trans-stab-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)""",
        })

    self.__nssa_trans_stab_intv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa_trans_stab_intv(self):
    self.__nssa_trans_stab_intv = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nssa-trans-stab-intv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)

  spf_schedule_times = __builtin__.property(_get_spf_schedule_times)
  interface_count = __builtin__.property(_get_interface_count)
  exchange_and_loading_nbr = __builtin__.property(_get_exchange_and_loading_nbr)
  router_id_conflict = __builtin__.property(_get_router_id_conflict)
  import_limit_status = __builtin__.property(_get_import_limit_status)
  self_nssa_lsa_count = __builtin__.property(_get_self_nssa_lsa_count)
  nssa_trans_state = __builtin__.property(_get_nssa_trans_state)
  nssa_trans_role = __builtin__.property(_get_nssa_trans_role)
  nssa_trans_stab_intv = __builtin__.property(_get_nssa_trans_stab_intv)


  _pyangbind_elements = OrderedDict([('spf_schedule_times', spf_schedule_times), ('interface_count', interface_count), ('exchange_and_loading_nbr', exchange_and_loading_nbr), ('router_id_conflict', router_id_conflict), ('import_limit_status', import_limit_status), ('self_nssa_lsa_count', self_nssa_lsa_count), ('nssa_trans_state', nssa_trans_state), ('nssa_trans_role', nssa_trans_role), ('nssa_trans_stab_intv', nssa_trans_stab_intv), ])


class yc_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas/area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__area_id','__area_type','__description','__networks','__stub','__nssa','__ldp_sync','__mpls_te','__authentication','__abr_summary_prefixs','__vlink_peers','__sham_links','__filters','__interfaces','__disp_data',)

  _yang_name = 'area'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__area_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'stub': {'value': 2}, 'nssa': {'value': 3}},), default=six.text_type("normal"), is_leaf=True, yang_name="area-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-type', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    self.__networks = YANGDynClass(base=yc_networks_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__stub = YANGDynClass(base=yc_stub_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_stub, is_container='container', yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__nssa = YANGDynClass(base=yc_nssa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_nssa, is_container='container', yang_name="nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__ldp_sync = YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__mpls_te = YANGDynClass(base=yc_mpls_te_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_mpls_te, is_container='container', yang_name="mpls-te", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__abr_summary_prefixs = YANGDynClass(base=yc_abr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs, is_container='container', yang_name="abr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__vlink_peers = YANGDynClass(base=yc_vlink_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers, is_container='container', yang_name="vlink-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__sham_links = YANGDynClass(base=yc_sham_links_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__filters = YANGDynClass(base=yc_filters_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__disp_data = YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas', 'area']

  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/area_id (inet:ipv4-address-no-zone)

    YANG Description: Area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_area_type(self):
    """
    Getter method for area_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/area_type (area-type)

    YANG Description: Area type.
    """
    return self.__area_type
      
  def _set_area_type(self, v, load=False):
    """
    Setter method for area_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/area_type (area-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_type() directly.

    YANG Description: Area type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'stub': {'value': 2}, 'nssa': {'value': 3}},), default=six.text_type("normal"), is_leaf=True, yang_name="area-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_type must be of a type compatible with area-type""",
          'defined-type': "huawei-ospfv2:area-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'stub': {'value': 2}, 'nssa': {'value': 3}},), default=six.text_type("normal"), is_leaf=True, yang_name="area-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-type', is_config=True)""",
        })

    self.__area_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_type(self):
    self.__area_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'stub': {'value': 2}, 'nssa': {'value': 3}},), default=six.text_type("normal"), is_leaf=True, yang_name="area-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='area-type', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/description (string)

    YANG Description: Description of an OSPF area.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of an OSPF area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)


  def _get_networks(self):
    """
    Getter method for networks, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks (container)

    YANG Description: List of the interface that runs OSPF and the area to which the interface belongs to.
    """
    return self.__networks
      
  def _set_networks(self, v, load=False):
    """
    Setter method for networks, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/networks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networks() directly.

    YANG Description: List of the interface that runs OSPF and the area to which the interface belongs to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_networks_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_networks_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networks(self):
    self.__networks = YANGDynClass(base=yc_networks_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_stub(self):
    """
    Getter method for stub, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub (container)

    YANG Description: Configure stub area.
    """
    return self.__stub
      
  def _set_stub(self, v, load=False):
    """
    Setter method for stub, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/stub (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stub is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stub() directly.

    YANG Description: Configure stub area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_stub_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_stub, is_container='container', yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stub must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_stub_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_stub, is_container='container', yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__stub = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stub(self):
    self.__stub = YANGDynClass(base=yc_stub_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_stub, is_container='container', yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_nssa(self):
    """
    Getter method for nssa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa (container)

    YANG Description: Configure nssa area.
    """
    return self.__nssa
      
  def _set_nssa(self, v, load=False):
    """
    Setter method for nssa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/nssa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa() directly.

    YANG Description: Configure nssa area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nssa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_nssa, is_container='container', yang_name="nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nssa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_nssa, is_container='container', yang_name="nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__nssa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa(self):
    self.__nssa = YANGDynClass(base=yc_nssa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_nssa, is_container='container', yang_name="nssa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_ldp_sync(self):
    """
    Getter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync (container)

    YANG Description: Configure timer ldp sync.
    """
    return self.__ldp_sync
      
  def _set_ldp_sync(self, v, load=False):
    """
    Setter method for ldp_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/ldp_sync (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldp_sync is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldp_sync() directly.

    YANG Description: Configure timer ldp sync.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldp_sync must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ldp_sync = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldp_sync(self):
    self.__ldp_sync = YANGDynClass(base=yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_ldp_sync, is_container='container', yang_name="ldp-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_mpls_te(self):
    """
    Getter method for mpls_te, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/mpls_te (container)

    YANG Description: Configure OSPF processes enabled with the TE capability.
    """
    return self.__mpls_te
      
  def _set_mpls_te(self, v, load=False):
    """
    Setter method for mpls_te, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/mpls_te (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_te is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_te() directly.

    YANG Description: Configure OSPF processes enabled with the TE capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mpls_te_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_mpls_te, is_container='container', yang_name="mpls-te", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_te must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mpls_te_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_mpls_te, is_container='container', yang_name="mpls-te", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__mpls_te = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_te(self):
    self.__mpls_te = YANGDynClass(base=yc_mpls_te_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_mpls_te, is_container='container', yang_name="mpls-te", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_authentication(self):
    """
    Getter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication (container)

    YANG Description: Configure authentication.
    """
    return self.__authentication
      
  def _set_authentication(self, v, load=False):
    """
    Setter method for authentication, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/authentication (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication() directly.

    YANG Description: Configure authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__authentication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication(self):
    self.__authentication = YANGDynClass(base=yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_authentication, is_container='container', yang_name="authentication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_abr_summary_prefixs(self):
    """
    Getter method for abr_summary_prefixs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs (container)

    YANG Description: List of ABR route aggregation method.
    """
    return self.__abr_summary_prefixs
      
  def _set_abr_summary_prefixs(self, v, load=False):
    """
    Setter method for abr_summary_prefixs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/abr_summary_prefixs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_summary_prefixs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_summary_prefixs() directly.

    YANG Description: List of ABR route aggregation method.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_abr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs, is_container='container', yang_name="abr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_summary_prefixs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_abr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs, is_container='container', yang_name="abr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__abr_summary_prefixs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_summary_prefixs(self):
    self.__abr_summary_prefixs = YANGDynClass(base=yc_abr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs, is_container='container', yang_name="abr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_vlink_peers(self):
    """
    Getter method for vlink_peers, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers (container)

    YANG Description: List of virtual link and its parameters.
    """
    return self.__vlink_peers
      
  def _set_vlink_peers(self, v, load=False):
    """
    Setter method for vlink_peers, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/vlink_peers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlink_peers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlink_peers() directly.

    YANG Description: List of virtual link and its parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vlink_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers, is_container='container', yang_name="vlink-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlink_peers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vlink_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers, is_container='container', yang_name="vlink-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__vlink_peers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlink_peers(self):
    self.__vlink_peers = YANGDynClass(base=yc_vlink_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers, is_container='container', yang_name="vlink-peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_sham_links(self):
    """
    Getter method for sham_links, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links (container)

    YANG Description: List of sham link and its parameters.
    """
    return self.__sham_links
      
  def _set_sham_links(self, v, load=False):
    """
    Setter method for sham_links, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/sham_links (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sham_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sham_links() directly.

    YANG Description: List of sham link and its parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sham_links_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sham_links must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sham_links_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__sham_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sham_links(self):
    self.__sham_links = YANGDynClass(base=yc_sham_links_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_filters(self):
    """
    Getter method for filters, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters (container)

    YANG Description: List of ABR to filter outgoing or incoming summary LSAs of the local area.
    """
    return self.__filters
      
  def _set_filters(self, v, load=False):
    """
    Setter method for filters, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/filters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filters() directly.

    YANG Description: List of ABR to filter outgoing or incoming summary LSAs of the local area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filters_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filters_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__filters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filters(self):
    self.__filters = YANGDynClass(base=yc_filters_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters, is_container='container', yang_name="filters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces (container)

    YANG Description: List of the interface enabled with OSPF.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: List of the interface enabled with OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_disp_data(self):
    """
    Getter method for disp_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data (container)

    YANG Description: Statistics of OSPF area.
    """
    return self.__disp_data
      
  def _set_disp_data(self, v, load=False):
    """
    Setter method for disp_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area/disp_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disp_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disp_data() directly.

    YANG Description: Statistics of OSPF area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disp_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__disp_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disp_data(self):
    self.__disp_data = YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  area_id = __builtin__.property(_get_area_id, _set_area_id)
  area_type = __builtin__.property(_get_area_type, _set_area_type)
  description = __builtin__.property(_get_description, _set_description)
  networks = __builtin__.property(_get_networks, _set_networks) # type: yc_networks_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_networks
  stub = __builtin__.property(_get_stub, _set_stub) # type: yc_stub_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_stub
  nssa = __builtin__.property(_get_nssa, _set_nssa) # type: yc_nssa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_nssa
  ldp_sync = __builtin__.property(_get_ldp_sync, _set_ldp_sync) # type: yc_ldp_sync_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_ldp_sync
  mpls_te = __builtin__.property(_get_mpls_te, _set_mpls_te) # type: yc_mpls_te_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_mpls_te
  authentication = __builtin__.property(_get_authentication, _set_authentication) # type: yc_authentication_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_authentication
  abr_summary_prefixs = __builtin__.property(_get_abr_summary_prefixs, _set_abr_summary_prefixs) # type: yc_abr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_abr_summary_prefixs
  vlink_peers = __builtin__.property(_get_vlink_peers, _set_vlink_peers) # type: yc_vlink_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_vlink_peers
  sham_links = __builtin__.property(_get_sham_links, _set_sham_links) # type: yc_sham_links_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_sham_links
  filters = __builtin__.property(_get_filters, _set_filters) # type: yc_filters_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_filters
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_interfaces
  disp_data = __builtin__.property(_get_disp_data, _set_disp_data) # type: yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area_disp_data


  _pyangbind_elements = OrderedDict([('area_id', area_id), ('area_type', area_type), ('description', description), ('networks', networks), ('stub', stub), ('nssa', nssa), ('ldp_sync', ldp_sync), ('mpls_te', mpls_te), ('authentication', authentication), ('abr_summary_prefixs', abr_summary_prefixs), ('vlink_peers', vlink_peers), ('sham_links', sham_links), ('filters', filters), ('interfaces', interfaces), ('disp_data', disp_data), ])


class yc_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/areas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OSPF area.
  """
  __slots__ = ('_path_helper', '_extmethods', '__area',)

  _yang_name = 'areas'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__area = YANGDynClass(base=YANGListType("area_id",yc_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area, yang_name="area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'areas']

  def _get_area(self):
    """
    Getter method for area, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area (list)

    YANG Description: Configure OSPF area.
    """
    return self.__area
      
  def _set_area(self, v, load=False):
    """
    Setter method for area, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas/area (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area() directly.

    YANG Description: Configure OSPF area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("area_id",yc_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area, yang_name="area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("area_id",yc_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area, yang_name="area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__area = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area(self):
    self.__area = YANGDynClass(base=YANGListType("area_id",yc_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area, yang_name="area", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="area", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  area = __builtin__.property(_get_area, _set_area) # type: yc_area_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas_area


  _pyangbind_elements = OrderedDict([('area', area), ])


class yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/disp-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of OSPF site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__effective_router_id','__border_router','__ietf_mode','__spf_count','__area_count','__nssa_count','__exchange_and_loading_nbr','__lsdb_overflow_status','__non_default_ase_lsa_count','__lsdb_overflow_remain','__import_limit_status','__self_ase_lsa_count',)

  _yang_name = 'disp-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__effective_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="effective-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__border_router = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'area': {'value': 1}, 'as': {'value': 2}, 'area-as': {'value': 3}, 'nssa': {'value': 4}, 'area-nssa': {'value': 5}, 'as-nssa': {'value': 6}, 'area-as-nssa': {'value': 7}},), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='border-router', is_config=False)
    self.__ietf_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'non-standard': {'value': 0}, 'standard': {'value': 1}},), is_leaf=True, yang_name="ietf-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ietf-mode', is_config=False)
    self.__spf_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__area_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="area-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__nssa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nssa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__exchange_and_loading_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__lsdb_overflow_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'approach': {'value': 1}, 'overflow': {'value': 2}},), is_leaf=True, yang_name="lsdb-overflow-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-overflow-status', is_config=False)
    self.__non_default_ase_lsa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="non-default-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__lsdb_overflow_remain = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsdb-overflow-remain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__import_limit_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)
    self.__self_ase_lsa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'disp-data']

  def _get_effective_router_id(self):
    """
    Getter method for effective_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/effective_router_id (inet:ipv4-address-no-zone)

    YANG Description: Effective router ID.
    """
    return self.__effective_router_id
      
  def _set_effective_router_id(self, v, load=False):
    """
    Setter method for effective_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/effective_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effective_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effective_router_id() directly.

    YANG Description: Effective router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="effective-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effective_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="effective-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__effective_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effective_router_id(self):
    self.__effective_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="effective-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_border_router(self):
    """
    Getter method for border_router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/border_router (border-router)

    YANG Description: Router type.
    """
    return self.__border_router
      
  def _set_border_router(self, v, load=False):
    """
    Setter method for border_router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/border_router (border-router)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_border_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_border_router() directly.

    YANG Description: Router type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'area': {'value': 1}, 'as': {'value': 2}, 'area-as': {'value': 3}, 'nssa': {'value': 4}, 'area-nssa': {'value': 5}, 'as-nssa': {'value': 6}, 'area-as-nssa': {'value': 7}},), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='border-router', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """border_router must be of a type compatible with border-router""",
          'defined-type': "huawei-ospfv2:border-router",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'area': {'value': 1}, 'as': {'value': 2}, 'area-as': {'value': 3}, 'nssa': {'value': 4}, 'area-nssa': {'value': 5}, 'as-nssa': {'value': 6}, 'area-as-nssa': {'value': 7}},), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='border-router', is_config=False)""",
        })

    self.__border_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_border_router(self):
    self.__border_router = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'area': {'value': 1}, 'as': {'value': 2}, 'area-as': {'value': 3}, 'nssa': {'value': 4}, 'area-nssa': {'value': 5}, 'as-nssa': {'value': 6}, 'area-as-nssa': {'value': 7}},), is_leaf=True, yang_name="border-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='border-router', is_config=False)


  def _get_ietf_mode(self):
    """
    Getter method for ietf_mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/ietf_mode (ietf-mode)

    YANG Description: Global DS TE mode.
    """
    return self.__ietf_mode
      
  def _set_ietf_mode(self, v, load=False):
    """
    Setter method for ietf_mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/ietf_mode (ietf-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ietf_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ietf_mode() directly.

    YANG Description: Global DS TE mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'non-standard': {'value': 0}, 'standard': {'value': 1}},), is_leaf=True, yang_name="ietf-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ietf-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ietf_mode must be of a type compatible with ietf-mode""",
          'defined-type': "huawei-ospfv2:ietf-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'non-standard': {'value': 0}, 'standard': {'value': 1}},), is_leaf=True, yang_name="ietf-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ietf-mode', is_config=False)""",
        })

    self.__ietf_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ietf_mode(self):
    self.__ietf_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'non-standard': {'value': 0}, 'standard': {'value': 1}},), is_leaf=True, yang_name="ietf-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='ietf-mode', is_config=False)


  def _get_spf_count(self):
    """
    Getter method for spf_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/spf_count (uint32)

    YANG Description: SPF computation count.
    """
    return self.__spf_count
      
  def _set_spf_count(self, v, load=False):
    """
    Setter method for spf_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/spf_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_count() directly.

    YANG Description: SPF computation count.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__spf_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_count(self):
    self.__spf_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="spf-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_area_count(self):
    """
    Getter method for area_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/area_count (uint32)

    YANG Description: Number of areas.
    """
    return self.__area_count
      
  def _set_area_count(self, v, load=False):
    """
    Setter method for area_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/area_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_count() directly.

    YANG Description: Number of areas.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="area-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="area-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__area_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_count(self):
    self.__area_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="area-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_nssa_count(self):
    """
    Getter method for nssa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/nssa_count (uint32)

    YANG Description: Number of NSSA areas.
    """
    return self.__nssa_count
      
  def _set_nssa_count(self, v, load=False):
    """
    Setter method for nssa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/nssa_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nssa_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nssa_count() directly.

    YANG Description: Number of NSSA areas.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nssa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nssa_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nssa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__nssa_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nssa_count(self):
    self.__nssa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nssa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_exchange_and_loading_nbr(self):
    """
    Getter method for exchange_and_loading_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/exchange_and_loading_nbr (uint32)

    YANG Description: Neighbor in exchange/loading state.
    """
    return self.__exchange_and_loading_nbr
      
  def _set_exchange_and_loading_nbr(self, v, load=False):
    """
    Setter method for exchange_and_loading_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/exchange_and_loading_nbr (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exchange_and_loading_nbr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exchange_and_loading_nbr() directly.

    YANG Description: Neighbor in exchange/loading state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exchange_and_loading_nbr must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__exchange_and_loading_nbr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exchange_and_loading_nbr(self):
    self.__exchange_and_loading_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="exchange-and-loading-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_lsdb_overflow_status(self):
    """
    Getter method for lsdb_overflow_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/lsdb_overflow_status (lsdb-overflow-status)

    YANG Description: LSDB overflow status.
    """
    return self.__lsdb_overflow_status
      
  def _set_lsdb_overflow_status(self, v, load=False):
    """
    Setter method for lsdb_overflow_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/lsdb_overflow_status (lsdb-overflow-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_overflow_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_overflow_status() directly.

    YANG Description: LSDB overflow status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'approach': {'value': 1}, 'overflow': {'value': 2}},), is_leaf=True, yang_name="lsdb-overflow-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-overflow-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_overflow_status must be of a type compatible with lsdb-overflow-status""",
          'defined-type': "huawei-ospfv2:lsdb-overflow-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'approach': {'value': 1}, 'overflow': {'value': 2}},), is_leaf=True, yang_name="lsdb-overflow-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-overflow-status', is_config=False)""",
        })

    self.__lsdb_overflow_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_overflow_status(self):
    self.__lsdb_overflow_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'approach': {'value': 1}, 'overflow': {'value': 2}},), is_leaf=True, yang_name="lsdb-overflow-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-overflow-status', is_config=False)


  def _get_non_default_ase_lsa_count(self):
    """
    Getter method for non_default_ase_lsa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/non_default_ase_lsa_count (uint32)

    YANG Description: Number of non default AS external LSAs.
    """
    return self.__non_default_ase_lsa_count
      
  def _set_non_default_ase_lsa_count(self, v, load=False):
    """
    Setter method for non_default_ase_lsa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/non_default_ase_lsa_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_non_default_ase_lsa_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_non_default_ase_lsa_count() directly.

    YANG Description: Number of non default AS external LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="non-default-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """non_default_ase_lsa_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="non-default-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__non_default_ase_lsa_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_non_default_ase_lsa_count(self):
    self.__non_default_ase_lsa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="non-default-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_lsdb_overflow_remain(self):
    """
    Getter method for lsdb_overflow_remain, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/lsdb_overflow_remain (uint32)

    YANG Description: Remaining time of the overflow state.
    """
    return self.__lsdb_overflow_remain
      
  def _set_lsdb_overflow_remain(self, v, load=False):
    """
    Setter method for lsdb_overflow_remain, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/lsdb_overflow_remain (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_overflow_remain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_overflow_remain() directly.

    YANG Description: Remaining time of the overflow state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsdb-overflow-remain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_overflow_remain must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsdb-overflow-remain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__lsdb_overflow_remain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_overflow_remain(self):
    self.__lsdb_overflow_remain = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsdb-overflow-remain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_import_limit_status(self):
    """
    Getter method for import_limit_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/import_limit_status (import-limit-status)

    YANG Description: Limit status of imported external routes.
    """
    return self.__import_limit_status
      
  def _set_import_limit_status(self, v, load=False):
    """
    Setter method for import_limit_status, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/import_limit_status (import-limit-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_limit_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_limit_status() directly.

    YANG Description: Limit status of imported external routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_limit_status must be of a type compatible with import-limit-status""",
          'defined-type': "huawei-ospfv2:import-limit-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)""",
        })

    self.__import_limit_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_limit_status(self):
    self.__import_limit_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disable': {'value': 0}, 'enable': {'value': 1}, 'alarm': {'value': 2}, 'over-limit': {'value': 3}},), is_leaf=True, yang_name="import-limit-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='import-limit-status', is_config=False)


  def _get_self_ase_lsa_count(self):
    """
    Getter method for self_ase_lsa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/self_ase_lsa_count (uint32)

    YANG Description: Number of AS external LSAs that are generated locally.
    """
    return self.__self_ase_lsa_count
      
  def _set_self_ase_lsa_count(self, v, load=False):
    """
    Setter method for self_ase_lsa_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data/self_ase_lsa_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_self_ase_lsa_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_self_ase_lsa_count() directly.

    YANG Description: Number of AS external LSAs that are generated locally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """self_ase_lsa_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__self_ase_lsa_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_self_ase_lsa_count(self):
    self.__self_ase_lsa_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="self-ase-lsa-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  effective_router_id = __builtin__.property(_get_effective_router_id)
  border_router = __builtin__.property(_get_border_router)
  ietf_mode = __builtin__.property(_get_ietf_mode)
  spf_count = __builtin__.property(_get_spf_count)
  area_count = __builtin__.property(_get_area_count)
  nssa_count = __builtin__.property(_get_nssa_count)
  exchange_and_loading_nbr = __builtin__.property(_get_exchange_and_loading_nbr)
  lsdb_overflow_status = __builtin__.property(_get_lsdb_overflow_status)
  non_default_ase_lsa_count = __builtin__.property(_get_non_default_ase_lsa_count)
  lsdb_overflow_remain = __builtin__.property(_get_lsdb_overflow_remain)
  import_limit_status = __builtin__.property(_get_import_limit_status)
  self_ase_lsa_count = __builtin__.property(_get_self_ase_lsa_count)


  _pyangbind_elements = OrderedDict([('effective_router_id', effective_router_id), ('border_router', border_router), ('ietf_mode', ietf_mode), ('spf_count', spf_count), ('area_count', area_count), ('nssa_count', nssa_count), ('exchange_and_loading_nbr', exchange_and_loading_nbr), ('lsdb_overflow_status', lsdb_overflow_status), ('non_default_ase_lsa_count', non_default_ase_lsa_count), ('lsdb_overflow_remain', lsdb_overflow_remain), ('import_limit_status', import_limit_status), ('self_ase_lsa_count', self_ase_lsa_count), ])


class yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas_nexthop_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/migp-routings/migp-routing/nexthop-datas/nexthop-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of nexthop data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_addr','__adv_router_id','__area_id','__flags_disp','__tag','__if_name',)

  _yang_name = 'nexthop-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__adv_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__flags_disp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'migp-routings', 'migp-routing', 'nexthop-datas', 'nexthop-data']

  def _get_ip_addr(self):
    """
    Getter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/ip_addr (inet:ipv4-address-no-zone)

    YANG Description: Nexthop IP address.
    """
    return self.__ip_addr
      
  def _set_ip_addr(self, v, load=False):
    """
    Setter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/ip_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_addr() directly.

    YANG Description: Nexthop IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_addr(self):
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_adv_router_id(self):
    """
    Getter method for adv_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/adv_router_id (inet:ipv4-address-no-zone)

    YANG Description: Next hop advertising router ID.
    """
    return self.__adv_router_id
      
  def _set_adv_router_id(self, v, load=False):
    """
    Setter method for adv_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/adv_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adv_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adv_router_id() directly.

    YANG Description: Next hop advertising router ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adv_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__adv_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adv_router_id(self):
    self.__adv_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/area_id (inet:ipv4-address-no-zone)

    YANG Description: Next hop area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Next hop area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_flags_disp(self):
    """
    Getter method for flags_disp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/flags_disp (string)

    YANG Description: Next hop flags.
    """
    return self.__flags_disp
      
  def _set_flags_disp(self, v, load=False):
    """
    Setter method for flags_disp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/flags_disp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags_disp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags_disp() directly.

    YANG Description: Next hop flags.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags_disp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__flags_disp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags_disp(self):
    self.__flags_disp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/tag (uint32)

    YANG Description: Next hop tag.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Next hop tag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/if_name (string)

    YANG Description: Next hop outgoing interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Next hop outgoing interface name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)

  ip_addr = __builtin__.property(_get_ip_addr)
  adv_router_id = __builtin__.property(_get_adv_router_id)
  area_id = __builtin__.property(_get_area_id)
  flags_disp = __builtin__.property(_get_flags_disp)
  tag = __builtin__.property(_get_tag)
  if_name = __builtin__.property(_get_if_name)


  _pyangbind_elements = OrderedDict([('ip_addr', ip_addr), ('adv_router_id', adv_router_id), ('area_id', area_id), ('flags_disp', flags_disp), ('tag', tag), ('if_name', if_name), ])


class yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/migp-routings/migp-routing/nexthop-datas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of nexthop data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nexthop_data',)

  _yang_name = 'nexthop-datas'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nexthop_data = YANGDynClass(base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'migp-routings', 'migp-routing', 'nexthop-datas']

  def _get_nexthop_data(self):
    """
    Getter method for nexthop_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data (list)

    YANG Description: Statistics of nexthop data.
    """
    return self.__nexthop_data
      
  def _set_nexthop_data(self, v, load=False):
    """
    Setter method for nexthop_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas/nexthop_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_data() directly.

    YANG Description: Statistics of nexthop data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_data must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__nexthop_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_data(self):
    self.__nexthop_data = YANGDynClass(base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  nexthop_data = __builtin__.property(_get_nexthop_data) # type: yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas_nexthop_data


  _pyangbind_elements = OrderedDict([('nexthop_data', nexthop_data), ])


class yc_migp_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/migp-routings/migp-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of the OSPF MIGP routing table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dest_ip','__mask_length','__cost','__prefix_priority','__path_type','__nexthop_datas',)

  _yang_name = 'migp-routing'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dest_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__prefix_priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)
    self.__path_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)
    self.__nexthop_datas = YANGDynClass(base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'migp-routings', 'migp-routing']

  def _get_dest_ip(self):
    """
    Getter method for dest_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/dest_ip (inet:ipv4-address-no-zone)

    YANG Description: Destination IP address.
    """
    return self.__dest_ip
      
  def _set_dest_ip(self, v, load=False):
    """
    Setter method for dest_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/dest_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_ip() directly.

    YANG Description: Destination IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__dest_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_ip(self):
    self.__dest_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_mask_length(self):
    """
    Getter method for mask_length, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/mask_length (uint32)

    YANG Description: Mask length.
    """
    return self.__mask_length
      
  def _set_mask_length(self, v, load=False):
    """
    Setter method for mask_length, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/mask_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask_length() directly.

    YANG Description: Mask length.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mask_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask_length(self):
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/cost (uint32)

    YANG Description: Cost to the destination address.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Cost to the destination address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_prefix_priority(self):
    """
    Getter method for prefix_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/prefix_priority (pre-priority)

    YANG Description: Prefix priority.
    """
    return self.__prefix_priority
      
  def _set_prefix_priority(self, v, load=False):
    """
    Setter method for prefix_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/prefix_priority (pre-priority)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_priority() directly.

    YANG Description: Prefix priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_priority must be of a type compatible with pre-priority""",
          'defined-type': "huawei-ospfv2:pre-priority",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)""",
        })

    self.__prefix_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_priority(self):
    self.__prefix_priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)


  def _get_path_type(self):
    """
    Getter method for path_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/path_type (path-type)

    YANG Description: Route type.
    """
    return self.__path_type
      
  def _set_path_type(self, v, load=False):
    """
    Setter method for path_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/path_type (path-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_type() directly.

    YANG Description: Route type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_type must be of a type compatible with path-type""",
          'defined-type': "huawei-ospfv2:path-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)""",
        })

    self.__path_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_type(self):
    self.__path_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)


  def _get_nexthop_datas(self):
    """
    Getter method for nexthop_datas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas (container)

    YANG Description: List of nexthop data.
    """
    return self.__nexthop_datas
      
  def _set_nexthop_datas(self, v, load=False):
    """
    Setter method for nexthop_datas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing/nexthop_datas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_datas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_datas() directly.

    YANG Description: List of nexthop data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_datas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)""",
        })

    self.__nexthop_datas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_datas(self):
    self.__nexthop_datas = YANGDynClass(base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

  dest_ip = __builtin__.property(_get_dest_ip)
  mask_length = __builtin__.property(_get_mask_length)
  cost = __builtin__.property(_get_cost)
  prefix_priority = __builtin__.property(_get_prefix_priority)
  path_type = __builtin__.property(_get_path_type)
  nexthop_datas = __builtin__.property(_get_nexthop_datas) # type: yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing_nexthop_datas


  _pyangbind_elements = OrderedDict([('dest_ip', dest_ip), ('mask_length', mask_length), ('cost', cost), ('prefix_priority', prefix_priority), ('path_type', path_type), ('nexthop_datas', nexthop_datas), ])


class yc_migp_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/migp-routings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the OSPF MIGP routing table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__migp_routing',)

  _yang_name = 'migp-routings'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__migp_routing = YANGDynClass(base=YANGListType("dest_ip mask_length",yc_migp_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing, yang_name="migp-routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length', extensions=None), is_container='list', yang_name="migp-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'migp-routings']

  def _get_migp_routing(self):
    """
    Getter method for migp_routing, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing (list)

    YANG Description: Statistics of the OSPF MIGP routing table.
    """
    return self.__migp_routing
      
  def _set_migp_routing(self, v, load=False):
    """
    Setter method for migp_routing, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings/migp_routing (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_migp_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_migp_routing() directly.

    YANG Description: Statistics of the OSPF MIGP routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("dest_ip mask_length",yc_migp_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing, yang_name="migp-routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length', extensions=None), is_container='list', yang_name="migp-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """migp_routing must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("dest_ip mask_length",yc_migp_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing, yang_name="migp-routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length', extensions=None), is_container='list', yang_name="migp-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__migp_routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_migp_routing(self):
    self.__migp_routing = YANGDynClass(base=YANGListType("dest_ip mask_length",yc_migp_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing, yang_name="migp-routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length', extensions=None), is_container='list', yang_name="migp-routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  migp_routing = __builtin__.property(_get_migp_routing) # type: yc_migp_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings_migp_routing


  _pyangbind_elements = OrderedDict([('migp_routing', migp_routing), ])


class yc_abr_asbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics_abr_asbr_statistic(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/abr-asbr-statistics/abr-asbr-statistic. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of the OSPF ABR and ASBR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__if_index','__nexthop_ip','__area_id','__destination_id','__if_name','__router_id','__path_type','__cost','__router_type',)

  _yang_name = 'abr-asbr-statistic'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__nexthop_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="nexthop-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__destination_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__path_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__router_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'abr-asbr-statistics', 'abr-asbr-statistic']

  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/if_index (uint32)

    YANG Description: Abr or asbr interface index.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/if_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: Abr or asbr interface index.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_nexthop_ip(self):
    """
    Getter method for nexthop_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/nexthop_ip (inet:ipv4-address-no-zone)

    YANG Description: Next hop IP address for sending packets to an ABR or ASBR.
    """
    return self.__nexthop_ip
      
  def _set_nexthop_ip(self, v, load=False):
    """
    Setter method for nexthop_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/nexthop_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_ip() directly.

    YANG Description: Next hop IP address for sending packets to an ABR or ASBR.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="nexthop-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="nexthop-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__nexthop_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_ip(self):
    self.__nexthop_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="nexthop-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/area_id (inet:ipv4-address-no-zone)

    YANG Description: Abr or asbr area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Abr or asbr area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_destination_id(self):
    """
    Getter method for destination_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/destination_id (inet:ipv4-address-no-zone)

    YANG Description: ID of an ABR or ASBR.
    """
    return self.__destination_id
      
  def _set_destination_id(self, v, load=False):
    """
    Setter method for destination_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/destination_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_id() directly.

    YANG Description: ID of an ABR or ASBR.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__destination_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_id(self):
    self.__destination_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="destination-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/if_name (string)

    YANG Description: Abr or asbr interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Abr or asbr interface name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/router_id (inet:ipv4-address-no-zone)

    YANG Description: ID of the local router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: ID of the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_path_type(self):
    """
    Getter method for path_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/path_type (path-type)

    YANG Description: Inter area or intra area router.
    """
    return self.__path_type
      
  def _set_path_type(self, v, load=False):
    """
    Setter method for path_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/path_type (path-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_type() directly.

    YANG Description: Inter area or intra area router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_type must be of a type compatible with path-type""",
          'defined-type': "huawei-ospfv2:path-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)""",
        })

    self.__path_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_type(self):
    self.__path_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/cost (uint32)

    YANG Description: Cost from a router to an ABR or ASBR.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Cost from a router to an ABR or ASBR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_router_type(self):
    """
    Getter method for router_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/router_type (router-type)

    YANG Description: Abr or asbr router type.
    """
    return self.__router_type
      
  def _set_router_type(self, v, load=False):
    """
    Setter method for router_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic/router_type (router-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_type() directly.

    YANG Description: Abr or asbr router type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_type must be of a type compatible with router-type""",
          'defined-type': "huawei-ospfv2:router-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-type', is_config=False)""",
        })

    self.__router_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_type(self):
    self.__router_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='router-type', is_config=False)

  if_index = __builtin__.property(_get_if_index)
  nexthop_ip = __builtin__.property(_get_nexthop_ip)
  area_id = __builtin__.property(_get_area_id)
  destination_id = __builtin__.property(_get_destination_id)
  if_name = __builtin__.property(_get_if_name)
  router_id = __builtin__.property(_get_router_id)
  path_type = __builtin__.property(_get_path_type)
  cost = __builtin__.property(_get_cost)
  router_type = __builtin__.property(_get_router_type)


  _pyangbind_elements = OrderedDict([('if_index', if_index), ('nexthop_ip', nexthop_ip), ('area_id', area_id), ('destination_id', destination_id), ('if_name', if_name), ('router_id', router_id), ('path_type', path_type), ('cost', cost), ('router_type', router_type), ])


class yc_abr_asbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/abr-asbr-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the OSPF ABR and ASBR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__abr_asbr_statistic',)

  _yang_name = 'abr-asbr-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__abr_asbr_statistic = YANGDynClass(base=YANGListType("if_index nexthop_ip area_id destination_id",yc_abr_asbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics_abr_asbr_statistic, yang_name="abr-asbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-index nexthop-ip area-id destination-id', extensions=None), is_container='list', yang_name="abr-asbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'abr-asbr-statistics']

  def _get_abr_asbr_statistic(self):
    """
    Getter method for abr_asbr_statistic, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic (list)

    YANG Description: Statistics of the OSPF ABR and ASBR.
    """
    return self.__abr_asbr_statistic
      
  def _set_abr_asbr_statistic(self, v, load=False):
    """
    Setter method for abr_asbr_statistic, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics/abr_asbr_statistic (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_asbr_statistic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_asbr_statistic() directly.

    YANG Description: Statistics of the OSPF ABR and ASBR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("if_index nexthop_ip area_id destination_id",yc_abr_asbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics_abr_asbr_statistic, yang_name="abr-asbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-index nexthop-ip area-id destination-id', extensions=None), is_container='list', yang_name="abr-asbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_asbr_statistic must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("if_index nexthop_ip area_id destination_id",yc_abr_asbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics_abr_asbr_statistic, yang_name="abr-asbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-index nexthop-ip area-id destination-id', extensions=None), is_container='list', yang_name="abr-asbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__abr_asbr_statistic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_asbr_statistic(self):
    self.__abr_asbr_statistic = YANGDynClass(base=YANGListType("if_index nexthop_ip area_id destination_id",yc_abr_asbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics_abr_asbr_statistic, yang_name="abr-asbr-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-index nexthop-ip area-id destination-id', extensions=None), is_container='list', yang_name="abr-asbr-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  abr_asbr_statistic = __builtin__.property(_get_abr_asbr_statistic) # type: yc_abr_asbr_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics_abr_asbr_statistic


  _pyangbind_elements = OrderedDict([('abr_asbr_statistic', abr_asbr_statistic), ])


class yc_nexthop_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras_nexthop_para(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/nexthop-paras/nexthop-para. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of the next hop of an OSPF process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addr','__rt_source_type','__if_addr','__if_name','__referece_count','__router_id',)

  _yang_name = 'nexthop-para'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__rt_source_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'local': {'value': 0}, 'unknow': {'value': 1}},), is_leaf=True, yang_name="rt-source-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='route-source-type', is_config=False)
    self.__if_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__referece_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="referece-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'nexthop-paras', 'nexthop-para']

  def _get_addr(self):
    """
    Getter method for addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/addr (inet:ipv4-address-no-zone)

    YANG Description: Details about the next hop.
    """
    return self.__addr
      
  def _set_addr(self, v, load=False):
    """
    Setter method for addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addr() directly.

    YANG Description: Details about the next hop.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addr(self):
    self.__addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_rt_source_type(self):
    """
    Getter method for rt_source_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/rt_source_type (route-source-type)

    YANG Description: Type of route origination.
    """
    return self.__rt_source_type
      
  def _set_rt_source_type(self, v, load=False):
    """
    Setter method for rt_source_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/rt_source_type (route-source-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rt_source_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rt_source_type() directly.

    YANG Description: Type of route origination.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'local': {'value': 0}, 'unknow': {'value': 1}},), is_leaf=True, yang_name="rt-source-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='route-source-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rt_source_type must be of a type compatible with route-source-type""",
          'defined-type': "huawei-ospfv2:route-source-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'local': {'value': 0}, 'unknow': {'value': 1}},), is_leaf=True, yang_name="rt-source-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='route-source-type', is_config=False)""",
        })

    self.__rt_source_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rt_source_type(self):
    self.__rt_source_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'local': {'value': 0}, 'unknow': {'value': 1}},), is_leaf=True, yang_name="rt-source-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='route-source-type', is_config=False)


  def _get_if_addr(self):
    """
    Getter method for if_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/if_addr (inet:ipv4-address-no-zone)

    YANG Description: Interface address.
    """
    return self.__if_addr
      
  def _set_if_addr(self, v, load=False):
    """
    Setter method for if_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/if_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_addr() directly.

    YANG Description: Interface address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__if_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_addr(self):
    self.__if_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/if_name (string)

    YANG Description: Interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_referece_count(self):
    """
    Getter method for referece_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/referece_count (uint32)

    YANG Description: Number of OSPF routes using the next hop.
    """
    return self.__referece_count
      
  def _set_referece_count(self, v, load=False):
    """
    Setter method for referece_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/referece_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_referece_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_referece_count() directly.

    YANG Description: Number of OSPF routes using the next hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="referece-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """referece_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="referece-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__referece_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_referece_count(self):
    self.__referece_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="referece-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/router_id (inet:ipv4-address-no-zone)

    YANG Description: ID of the local router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: ID of the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)

  addr = __builtin__.property(_get_addr)
  rt_source_type = __builtin__.property(_get_rt_source_type)
  if_addr = __builtin__.property(_get_if_addr)
  if_name = __builtin__.property(_get_if_name)
  referece_count = __builtin__.property(_get_referece_count)
  router_id = __builtin__.property(_get_router_id)


  _pyangbind_elements = OrderedDict([('addr', addr), ('rt_source_type', rt_source_type), ('if_addr', if_addr), ('if_name', if_name), ('referece_count', referece_count), ('router_id', router_id), ])


class yc_nexthop_paras_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/nexthop-paras. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the next hop of an OSPF process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nexthop_para',)

  _yang_name = 'nexthop-paras'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nexthop_para = YANGDynClass(base=YANGListType("addr rt_source_type if_addr if_name",yc_nexthop_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras_nexthop_para, yang_name="nexthop-para", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addr rt-source-type if-addr if-name', extensions=None), is_container='list', yang_name="nexthop-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'nexthop-paras']

  def _get_nexthop_para(self):
    """
    Getter method for nexthop_para, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para (list)

    YANG Description: Statistics of the next hop of an OSPF process.
    """
    return self.__nexthop_para
      
  def _set_nexthop_para(self, v, load=False):
    """
    Setter method for nexthop_para, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras/nexthop_para (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_para is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_para() directly.

    YANG Description: Statistics of the next hop of an OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("addr rt_source_type if_addr if_name",yc_nexthop_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras_nexthop_para, yang_name="nexthop-para", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addr rt-source-type if-addr if-name', extensions=None), is_container='list', yang_name="nexthop-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_para must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("addr rt_source_type if_addr if_name",yc_nexthop_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras_nexthop_para, yang_name="nexthop-para", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addr rt-source-type if-addr if-name', extensions=None), is_container='list', yang_name="nexthop-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__nexthop_para = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_para(self):
    self.__nexthop_para = YANGDynClass(base=YANGListType("addr rt_source_type if_addr if_name",yc_nexthop_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras_nexthop_para, yang_name="nexthop-para", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addr rt-source-type if-addr if-name', extensions=None), is_container='list', yang_name="nexthop-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  nexthop_para = __builtin__.property(_get_nexthop_para) # type: yc_nexthop_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras_nexthop_para


  _pyangbind_elements = OrderedDict([('nexthop_para', nexthop_para), ])


class yc_lsabody_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys_lsabody(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-statistics/lsdb-statistic/lsabodys/lsabody. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of lsabody.
  """
  __slots__ = ('_path_helper', '_extmethods', '__link_id','__link_data','__link_type','__attach_router','__forward_ip','__tos_id','__tos_metric','__route_tag','__opaque_type','__opaque_id','__ext_metric_type',)

  _yang_name = 'lsabody'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__link_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__link_data = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__link_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'p2p': {'value': 1}, 'trans-net': {'value': 2}, 'stub-net': {'value': 3}, 'virtual': {'value': 4}},), is_leaf=True, yang_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-link-type', is_config=False)
    self.__attach_router = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="attach-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__forward_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="forward-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__tos_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tos-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)
    self.__tos_metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tos-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__route_tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opaque_type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opaque_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ext_metric_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ext-metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-statistics', 'lsdb-statistic', 'lsabodys', 'lsabody']

  def _get_link_id(self):
    """
    Getter method for link_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/link_id (inet:ipv4-address-no-zone)

    YANG Description: Link ID of the router LSA.
    """
    return self.__link_id
      
  def _set_link_id(self, v, load=False):
    """
    Setter method for link_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/link_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_id() directly.

    YANG Description: Link ID of the router LSA.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__link_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_id(self):
    self.__link_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_link_data(self):
    """
    Getter method for link_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/link_data (inet:ipv4-address-no-zone)

    YANG Description: Link data about the router LSA.
    """
    return self.__link_data
      
  def _set_link_data(self, v, load=False):
    """
    Setter method for link_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/link_data (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_data() directly.

    YANG Description: Link data about the router LSA.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_data must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__link_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_data(self):
    self.__link_data = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_link_type(self):
    """
    Getter method for link_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/link_type (lsdb-link-type)

    YANG Description: Link type of the router LSA. The available options are Point-to-Point, TransNet, StubNet, and Virtual.
    """
    return self.__link_type
      
  def _set_link_type(self, v, load=False):
    """
    Setter method for link_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/link_type (lsdb-link-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_type() directly.

    YANG Description: Link type of the router LSA. The available options are Point-to-Point, TransNet, StubNet, and Virtual.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'p2p': {'value': 1}, 'trans-net': {'value': 2}, 'stub-net': {'value': 3}, 'virtual': {'value': 4}},), is_leaf=True, yang_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-link-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_type must be of a type compatible with lsdb-link-type""",
          'defined-type': "huawei-ospfv2:lsdb-link-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'p2p': {'value': 1}, 'trans-net': {'value': 2}, 'stub-net': {'value': 3}, 'virtual': {'value': 4}},), is_leaf=True, yang_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-link-type', is_config=False)""",
        })

    self.__link_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_type(self):
    self.__link_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'p2p': {'value': 1}, 'trans-net': {'value': 2}, 'stub-net': {'value': 3}, 'virtual': {'value': 4}},), is_leaf=True, yang_name="link-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-link-type', is_config=False)


  def _get_attach_router(self):
    """
    Getter method for attach_router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/attach_router (inet:ipv4-address-no-zone)

    YANG Description: Router connected to the network.
    """
    return self.__attach_router
      
  def _set_attach_router(self, v, load=False):
    """
    Setter method for attach_router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/attach_router (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attach_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attach_router() directly.

    YANG Description: Router connected to the network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="attach-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attach_router must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="attach-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__attach_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attach_router(self):
    self.__attach_router = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="attach-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_forward_ip(self):
    """
    Getter method for forward_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/forward_ip (inet:ipv4-address-no-zone)

    YANG Description: Forwarding IP address.
    """
    return self.__forward_ip
      
  def _set_forward_ip(self, v, load=False):
    """
    Setter method for forward_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/forward_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forward_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forward_ip() directly.

    YANG Description: Forwarding IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="forward-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forward_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="forward-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__forward_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forward_ip(self):
    self.__forward_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="forward-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_tos_id(self):
    """
    Getter method for tos_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/tos_id (uint8)

    YANG Description: ToS ID.
    """
    return self.__tos_id
      
  def _set_tos_id(self, v, load=False):
    """
    Setter method for tos_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/tos_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tos_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tos_id() directly.

    YANG Description: ToS ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tos-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tos_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tos-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)""",
        })

    self.__tos_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tos_id(self):
    self.__tos_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tos-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)


  def _get_tos_metric(self):
    """
    Getter method for tos_metric, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/tos_metric (uint32)

    YANG Description: ToS metric.
    """
    return self.__tos_metric
      
  def _set_tos_metric(self, v, load=False):
    """
    Setter method for tos_metric, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/tos_metric (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tos_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tos_metric() directly.

    YANG Description: ToS metric.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tos-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tos_metric must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tos-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tos_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tos_metric(self):
    self.__tos_metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tos-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_route_tag(self):
    """
    Getter method for route_tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/route_tag (uint32)

    YANG Description: Route tag, which is used to prevent route Loopback and applicable to Type5 or Type7 LSAs, of 32 bytes.
    """
    return self.__route_tag
      
  def _set_route_tag(self, v, load=False):
    """
    Setter method for route_tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/route_tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_tag() directly.

    YANG Description: Route tag, which is used to prevent route Loopback and applicable to Type5 or Type7 LSAs, of 32 bytes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__route_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_tag(self):
    self.__route_tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opaque_type(self):
    """
    Getter method for opaque_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/opaque_type (uint32)

    YANG Description: Opaque type.
    """
    return self.__opaque_type
      
  def _set_opaque_type(self, v, load=False):
    """
    Setter method for opaque_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/opaque_type (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque_type() directly.

    YANG Description: Opaque type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque_type must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opaque_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque_type(self):
    self.__opaque_type = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opaque_id(self):
    """
    Getter method for opaque_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/opaque_id (uint32)

    YANG Description: Opaque LSA ID. Opaque type + Opaque ID = Link state ID in the LSA header.
    """
    return self.__opaque_id
      
  def _set_opaque_id(self, v, load=False):
    """
    Setter method for opaque_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/opaque_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque_id() directly.

    YANG Description: Opaque LSA ID. Opaque type + Opaque ID = Link state ID in the LSA header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opaque_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque_id(self):
    self.__opaque_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ext_metric_type(self):
    """
    Getter method for ext_metric_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/ext_metric_type (uint8)

    YANG Description: E type of ASE/NSSA LSAs.
    """
    return self.__ext_metric_type
      
  def _set_ext_metric_type(self, v, load=False):
    """
    Setter method for ext_metric_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody/ext_metric_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_metric_type() directly.

    YANG Description: E type of ASE/NSSA LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ext-metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_metric_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ext-metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)""",
        })

    self.__ext_metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_metric_type(self):
    self.__ext_metric_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ext-metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint8', is_config=False)

  link_id = __builtin__.property(_get_link_id)
  link_data = __builtin__.property(_get_link_data)
  link_type = __builtin__.property(_get_link_type)
  attach_router = __builtin__.property(_get_attach_router)
  forward_ip = __builtin__.property(_get_forward_ip)
  tos_id = __builtin__.property(_get_tos_id)
  tos_metric = __builtin__.property(_get_tos_metric)
  route_tag = __builtin__.property(_get_route_tag)
  opaque_type = __builtin__.property(_get_opaque_type)
  opaque_id = __builtin__.property(_get_opaque_id)
  ext_metric_type = __builtin__.property(_get_ext_metric_type)


  _pyangbind_elements = OrderedDict([('link_id', link_id), ('link_data', link_data), ('link_type', link_type), ('attach_router', attach_router), ('forward_ip', forward_ip), ('tos_id', tos_id), ('tos_metric', tos_metric), ('route_tag', route_tag), ('opaque_type', opaque_type), ('opaque_id', opaque_id), ('ext_metric_type', ext_metric_type), ])


class yc_lsabodys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-statistics/lsdb-statistic/lsabodys. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of lsabody.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lsabody',)

  _yang_name = 'lsabodys'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lsabody = YANGDynClass(base=YANGListType("link_id link_data link_type attach_router forward_ip",yc_lsabody_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys_lsabody, yang_name="lsabody", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id link-data link-type attach-router forward-ip', extensions=None), is_container='list', yang_name="lsabody", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-statistics', 'lsdb-statistic', 'lsabodys']

  def _get_lsabody(self):
    """
    Getter method for lsabody, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody (list)

    YANG Description: Statistics of lsabody.
    """
    return self.__lsabody
      
  def _set_lsabody(self, v, load=False):
    """
    Setter method for lsabody, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys/lsabody (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsabody is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsabody() directly.

    YANG Description: Statistics of lsabody.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("link_id link_data link_type attach_router forward_ip",yc_lsabody_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys_lsabody, yang_name="lsabody", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id link-data link-type attach-router forward-ip', extensions=None), is_container='list', yang_name="lsabody", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsabody must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("link_id link_data link_type attach_router forward_ip",yc_lsabody_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys_lsabody, yang_name="lsabody", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id link-data link-type attach-router forward-ip', extensions=None), is_container='list', yang_name="lsabody", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__lsabody = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsabody(self):
    self.__lsabody = YANGDynClass(base=YANGListType("link_id link_data link_type attach_router forward_ip",yc_lsabody_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys_lsabody, yang_name="lsabody", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id link-data link-type attach-router forward-ip', extensions=None), is_container='list', yang_name="lsabody", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  lsabody = __builtin__.property(_get_lsabody) # type: yc_lsabody_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys_lsabody


  _pyangbind_elements = OrderedDict([('lsabody', lsabody), ])


class yc_rilsa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_rilsa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-statistics/lsdb-statistic/rilsa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of LSA TLV information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__host_name','__algorithm',)

  _yang_name = 'rilsa'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__algorithm = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-statistics', 'lsdb-statistic', 'rilsa']

  def _get_host_name(self):
    """
    Getter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/rilsa/host_name (string)

    YANG Description: Host name TLV.
    """
    return self.__host_name
      
  def _set_host_name(self, v, load=False):
    """
    Setter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/rilsa/host_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_name() directly.

    YANG Description: Host name TLV.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__host_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_name(self):
    self.__host_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_algorithm(self):
    """
    Getter method for algorithm, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/rilsa/algorithm (string)

    YANG Description: SR algorithm.
    """
    return self.__algorithm
      
  def _set_algorithm(self, v, load=False):
    """
    Setter method for algorithm, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/rilsa/algorithm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: SR algorithm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__algorithm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm(self):
    self.__algorithm = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)

  host_name = __builtin__.property(_get_host_name)
  algorithm = __builtin__.property(_get_algorithm)


  _pyangbind_elements = OrderedDict([('host_name', host_name), ('algorithm', algorithm), ])


class yc_lsdb_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-statistics/lsdb-statistic. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of OSPF LSDBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__area_id','__lsa_type','__link_state_id','__adv_router_id','__lsa_age','__lsa_sequence_num','__check_sum','__lsa_length','__options','__option_flag','__link_count','__network_mask','__host_name','__lsabodys','__rilsa',)

  _yang_name = 'lsdb-statistic'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__lsa_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'router': {'value': 1}, 'network': {'value': 2}, 'sum-net': {'value': 3}, 'sum-asbr': {'value': 4}, 'external': {'value': 5}, 'lsa-type-6': {'value': 6}, 'nssa': {'value': 7}, 'lsa-type-8': {'value': 8}, 'opq-link': {'value': 9}, 'opq-area': {'value': 10}, 'opq-as': {'value': 11}},), is_leaf=True, yang_name="lsa-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsa-type', is_config=False)
    self.__link_state_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-state-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__adv_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__lsa_age = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="lsa-age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    self.__lsa_sequence_num = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="lsa-sequence-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__check_sum = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..10']}), is_leaf=True, yang_name="check-sum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__lsa_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsa-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__options = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'e': {'value': 2}, 'mc': {'value': 4}, 'mc-e': {'value': 6}, 'np': {'value': 8}, 'np-e': {'value': 10}, 'np-mc': {'value': 12}, 'np-mc-e': {'value': 14}, 'ea': {'value': 16}, 'ea-e': {'value': 18}, 'ea-mc': {'value': 20}, 'ea-mc-e': {'value': 22}, 'ea-np': {'value': 24}, 'ea-np-e': {'value': 26}, 'ea-np-mc': {'value': 28}, 'ea-np-mc-e': {'value': 30}, 'dc': {'value': 32}, 'dc-e': {'value': 34}, 'dc-mc': {'value': 36}, 'dc-mc-e': {'value': 38}, 'dc-np': {'value': 40}, 'dc-np-e': {'value': 42}, 'dc-np-mc': {'value': 44}, 'dc-np-mc-e': {'value': 46}, 'dc-ea': {'value': 48}, 'dc-ea-e': {'value': 50}, 'dc-ea-mc': {'value': 52}, 'dc-ea-mc-e': {'value': 54}, 'dc-ea-np': {'value': 56}, 'dc-ea-np-e': {'value': 58}, 'dc-ea-np-mc': {'value': 60}, 'dc-ea-np-mc-e': {'value': 62}, 'dn': {'value': 128}, 'e-dn': {'value': 130}, 'np-dn': {'value': 136}},), is_leaf=True, yang_name="options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option', is_config=False)
    self.__option_flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {'value': 0}, 'abr': {'value': 256}, 'asbr': {'value': 512}, 'asbr-abr': {'value': 768}, 'virtual': {'value': 1024}, 'abr-virtual': {'value': 1280}, 'asbr-virtual': {'value': 1536}, 'asbr-abr-virtual': {'value': 1792}, 'nt': {'value': 4096}, 'abr-nt': {'value': 4352}, 'asbr-nt': {'value': 4608}, 'asbr-abr-nt': {'value': 4864}, 'virtual-nt': {'value': 5120}, 'abr-virtual-nt': {'value': 5376}, 'asbr-virtual-nt': {'value': 5632}, 'asbr-abr-virtual-nt': {'value': 5888}},), is_leaf=True, yang_name="option-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option-flag', is_config=False)
    self.__link_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="link-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__network_mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__host_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__lsabodys = YANGDynClass(base=yc_lsabodys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys, is_container='container', yang_name="lsabodys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)
    self.__rilsa = YANGDynClass(base=yc_rilsa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_rilsa, is_container='container', yang_name="rilsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-statistics', 'lsdb-statistic']

  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/area_id (inet:ipv4-address-no-zone)

    YANG Description: Area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_lsa_type(self):
    """
    Getter method for lsa_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_type (lsa-type)

    YANG Description: The value can be router, network, sum net, sum asbr, NSSA, external, opq link, opq area, or opq AS.
    """
    return self.__lsa_type
      
  def _set_lsa_type(self, v, load=False):
    """
    Setter method for lsa_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_type (lsa-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_type() directly.

    YANG Description: The value can be router, network, sum net, sum asbr, NSSA, external, opq link, opq area, or opq AS.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'router': {'value': 1}, 'network': {'value': 2}, 'sum-net': {'value': 3}, 'sum-asbr': {'value': 4}, 'external': {'value': 5}, 'lsa-type-6': {'value': 6}, 'nssa': {'value': 7}, 'lsa-type-8': {'value': 8}, 'opq-link': {'value': 9}, 'opq-area': {'value': 10}, 'opq-as': {'value': 11}},), is_leaf=True, yang_name="lsa-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsa-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_type must be of a type compatible with lsa-type""",
          'defined-type': "huawei-ospfv2:lsa-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'router': {'value': 1}, 'network': {'value': 2}, 'sum-net': {'value': 3}, 'sum-asbr': {'value': 4}, 'external': {'value': 5}, 'lsa-type-6': {'value': 6}, 'nssa': {'value': 7}, 'lsa-type-8': {'value': 8}, 'opq-link': {'value': 9}, 'opq-area': {'value': 10}, 'opq-as': {'value': 11}},), is_leaf=True, yang_name="lsa-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsa-type', is_config=False)""",
        })

    self.__lsa_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_type(self):
    self.__lsa_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'router': {'value': 1}, 'network': {'value': 2}, 'sum-net': {'value': 3}, 'sum-asbr': {'value': 4}, 'external': {'value': 5}, 'lsa-type-6': {'value': 6}, 'nssa': {'value': 7}, 'lsa-type-8': {'value': 8}, 'opq-link': {'value': 9}, 'opq-area': {'value': 10}, 'opq-as': {'value': 11}},), is_leaf=True, yang_name="lsa-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsa-type', is_config=False)


  def _get_link_state_id(self):
    """
    Getter method for link_state_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/link_state_id (inet:ipv4-address-no-zone)

    YANG Description: Link state ID in the LSA header.
    """
    return self.__link_state_id
      
  def _set_link_state_id(self, v, load=False):
    """
    Setter method for link_state_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/link_state_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_state_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_state_id() directly.

    YANG Description: Link state ID in the LSA header.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-state-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_state_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-state-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__link_state_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_state_id(self):
    self.__link_state_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="link-state-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_adv_router_id(self):
    """
    Getter method for adv_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/adv_router_id (inet:ipv4-address-no-zone)

    YANG Description: Router that advertises or generates LSAs.
    """
    return self.__adv_router_id
      
  def _set_adv_router_id(self, v, load=False):
    """
    Setter method for adv_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/adv_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adv_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adv_router_id() directly.

    YANG Description: Router that advertises or generates LSAs.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adv_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__adv_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adv_router_id(self):
    self.__adv_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_lsa_age(self):
    """
    Getter method for lsa_age, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_age (int32)

    YANG Description: LSA aging time.
    """
    return self.__lsa_age
      
  def _set_lsa_age(self, v, load=False):
    """
    Setter method for lsa_age, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_age (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_age is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_age() directly.

    YANG Description: LSA aging time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="lsa-age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_age must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="lsa-age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)""",
        })

    self.__lsa_age = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_age(self):
    self.__lsa_age = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="lsa-age", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)


  def _get_lsa_sequence_num(self):
    """
    Getter method for lsa_sequence_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_sequence_num (string)

    YANG Description: LSA sequence number (from the LSA header).
    """
    return self.__lsa_sequence_num
      
  def _set_lsa_sequence_num(self, v, load=False):
    """
    Setter method for lsa_sequence_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_sequence_num (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_sequence_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_sequence_num() directly.

    YANG Description: LSA sequence number (from the LSA header).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="lsa-sequence-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_sequence_num must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="lsa-sequence-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__lsa_sequence_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_sequence_num(self):
    self.__lsa_sequence_num = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..12']}), is_leaf=True, yang_name="lsa-sequence-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_check_sum(self):
    """
    Getter method for check_sum, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/check_sum (string)

    YANG Description: Checksum.
    """
    return self.__check_sum
      
  def _set_check_sum(self, v, load=False):
    """
    Setter method for check_sum, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/check_sum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_check_sum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_check_sum() directly.

    YANG Description: Checksum.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..10']}), is_leaf=True, yang_name="check-sum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """check_sum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..10']}), is_leaf=True, yang_name="check-sum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__check_sum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_check_sum(self):
    self.__check_sum = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..10']}), is_leaf=True, yang_name="check-sum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_lsa_length(self):
    """
    Getter method for lsa_length, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_length (uint32)

    YANG Description: LSA length.
    """
    return self.__lsa_length
      
  def _set_lsa_length(self, v, load=False):
    """
    Setter method for lsa_length, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsa_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_length() directly.

    YANG Description: LSA length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsa-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsa-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__lsa_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_length(self):
    self.__lsa_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lsa-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_options(self):
    """
    Getter method for options, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/options (lsdb-option)

    YANG Description: LSA option.
    """
    return self.__options
      
  def _set_options(self, v, load=False):
    """
    Setter method for options, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/options (lsdb-option)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_options() directly.

    YANG Description: LSA option.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'e': {'value': 2}, 'mc': {'value': 4}, 'mc-e': {'value': 6}, 'np': {'value': 8}, 'np-e': {'value': 10}, 'np-mc': {'value': 12}, 'np-mc-e': {'value': 14}, 'ea': {'value': 16}, 'ea-e': {'value': 18}, 'ea-mc': {'value': 20}, 'ea-mc-e': {'value': 22}, 'ea-np': {'value': 24}, 'ea-np-e': {'value': 26}, 'ea-np-mc': {'value': 28}, 'ea-np-mc-e': {'value': 30}, 'dc': {'value': 32}, 'dc-e': {'value': 34}, 'dc-mc': {'value': 36}, 'dc-mc-e': {'value': 38}, 'dc-np': {'value': 40}, 'dc-np-e': {'value': 42}, 'dc-np-mc': {'value': 44}, 'dc-np-mc-e': {'value': 46}, 'dc-ea': {'value': 48}, 'dc-ea-e': {'value': 50}, 'dc-ea-mc': {'value': 52}, 'dc-ea-mc-e': {'value': 54}, 'dc-ea-np': {'value': 56}, 'dc-ea-np-e': {'value': 58}, 'dc-ea-np-mc': {'value': 60}, 'dc-ea-np-mc-e': {'value': 62}, 'dn': {'value': 128}, 'e-dn': {'value': 130}, 'np-dn': {'value': 136}},), is_leaf=True, yang_name="options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """options must be of a type compatible with lsdb-option""",
          'defined-type': "huawei-ospfv2:lsdb-option",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'e': {'value': 2}, 'mc': {'value': 4}, 'mc-e': {'value': 6}, 'np': {'value': 8}, 'np-e': {'value': 10}, 'np-mc': {'value': 12}, 'np-mc-e': {'value': 14}, 'ea': {'value': 16}, 'ea-e': {'value': 18}, 'ea-mc': {'value': 20}, 'ea-mc-e': {'value': 22}, 'ea-np': {'value': 24}, 'ea-np-e': {'value': 26}, 'ea-np-mc': {'value': 28}, 'ea-np-mc-e': {'value': 30}, 'dc': {'value': 32}, 'dc-e': {'value': 34}, 'dc-mc': {'value': 36}, 'dc-mc-e': {'value': 38}, 'dc-np': {'value': 40}, 'dc-np-e': {'value': 42}, 'dc-np-mc': {'value': 44}, 'dc-np-mc-e': {'value': 46}, 'dc-ea': {'value': 48}, 'dc-ea-e': {'value': 50}, 'dc-ea-mc': {'value': 52}, 'dc-ea-mc-e': {'value': 54}, 'dc-ea-np': {'value': 56}, 'dc-ea-np-e': {'value': 58}, 'dc-ea-np-mc': {'value': 60}, 'dc-ea-np-mc-e': {'value': 62}, 'dn': {'value': 128}, 'e-dn': {'value': 130}, 'np-dn': {'value': 136}},), is_leaf=True, yang_name="options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option', is_config=False)""",
        })

    self.__options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_options(self):
    self.__options = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'e': {'value': 2}, 'mc': {'value': 4}, 'mc-e': {'value': 6}, 'np': {'value': 8}, 'np-e': {'value': 10}, 'np-mc': {'value': 12}, 'np-mc-e': {'value': 14}, 'ea': {'value': 16}, 'ea-e': {'value': 18}, 'ea-mc': {'value': 20}, 'ea-mc-e': {'value': 22}, 'ea-np': {'value': 24}, 'ea-np-e': {'value': 26}, 'ea-np-mc': {'value': 28}, 'ea-np-mc-e': {'value': 30}, 'dc': {'value': 32}, 'dc-e': {'value': 34}, 'dc-mc': {'value': 36}, 'dc-mc-e': {'value': 38}, 'dc-np': {'value': 40}, 'dc-np-e': {'value': 42}, 'dc-np-mc': {'value': 44}, 'dc-np-mc-e': {'value': 46}, 'dc-ea': {'value': 48}, 'dc-ea-e': {'value': 50}, 'dc-ea-mc': {'value': 52}, 'dc-ea-mc-e': {'value': 54}, 'dc-ea-np': {'value': 56}, 'dc-ea-np-e': {'value': 58}, 'dc-ea-np-mc': {'value': 60}, 'dc-ea-np-mc-e': {'value': 62}, 'dn': {'value': 128}, 'e-dn': {'value': 130}, 'np-dn': {'value': 136}},), is_leaf=True, yang_name="options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option', is_config=False)


  def _get_option_flag(self):
    """
    Getter method for option_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/option_flag (lsdb-option-flag)

    YANG Description: LSA option flag. The available options are V, B, and E.
    """
    return self.__option_flag
      
  def _set_option_flag(self, v, load=False):
    """
    Setter method for option_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/option_flag (lsdb-option-flag)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_option_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_option_flag() directly.

    YANG Description: LSA option flag. The available options are V, B, and E.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {'value': 0}, 'abr': {'value': 256}, 'asbr': {'value': 512}, 'asbr-abr': {'value': 768}, 'virtual': {'value': 1024}, 'abr-virtual': {'value': 1280}, 'asbr-virtual': {'value': 1536}, 'asbr-abr-virtual': {'value': 1792}, 'nt': {'value': 4096}, 'abr-nt': {'value': 4352}, 'asbr-nt': {'value': 4608}, 'asbr-abr-nt': {'value': 4864}, 'virtual-nt': {'value': 5120}, 'abr-virtual-nt': {'value': 5376}, 'asbr-virtual-nt': {'value': 5632}, 'asbr-abr-virtual-nt': {'value': 5888}},), is_leaf=True, yang_name="option-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option-flag', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """option_flag must be of a type compatible with lsdb-option-flag""",
          'defined-type': "huawei-ospfv2:lsdb-option-flag",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {'value': 0}, 'abr': {'value': 256}, 'asbr': {'value': 512}, 'asbr-abr': {'value': 768}, 'virtual': {'value': 1024}, 'abr-virtual': {'value': 1280}, 'asbr-virtual': {'value': 1536}, 'asbr-abr-virtual': {'value': 1792}, 'nt': {'value': 4096}, 'abr-nt': {'value': 4352}, 'asbr-nt': {'value': 4608}, 'asbr-abr-nt': {'value': 4864}, 'virtual-nt': {'value': 5120}, 'abr-virtual-nt': {'value': 5376}, 'asbr-virtual-nt': {'value': 5632}, 'asbr-abr-virtual-nt': {'value': 5888}},), is_leaf=True, yang_name="option-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option-flag', is_config=False)""",
        })

    self.__option_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_option_flag(self):
    self.__option_flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'null': {'value': 0}, 'abr': {'value': 256}, 'asbr': {'value': 512}, 'asbr-abr': {'value': 768}, 'virtual': {'value': 1024}, 'abr-virtual': {'value': 1280}, 'asbr-virtual': {'value': 1536}, 'asbr-abr-virtual': {'value': 1792}, 'nt': {'value': 4096}, 'abr-nt': {'value': 4352}, 'asbr-nt': {'value': 4608}, 'asbr-abr-nt': {'value': 4864}, 'virtual-nt': {'value': 5120}, 'abr-virtual-nt': {'value': 5376}, 'asbr-virtual-nt': {'value': 5632}, 'asbr-abr-virtual-nt': {'value': 5888}},), is_leaf=True, yang_name="option-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='lsdb-option-flag', is_config=False)


  def _get_link_count(self):
    """
    Getter method for link_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/link_count (uint32)

    YANG Description: Number of links.
    """
    return self.__link_count
      
  def _set_link_count(self, v, load=False):
    """
    Setter method for link_count, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/link_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_count() directly.

    YANG Description: Number of links.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="link-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="link-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__link_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_count(self):
    self.__link_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="link-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_network_mask(self):
    """
    Getter method for network_mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/network_mask (inet:ipv4-address-no-zone)

    YANG Description: Network mask of the network LSA.
    """
    return self.__network_mask
      
  def _set_network_mask(self, v, load=False):
    """
    Setter method for network_mask, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/network_mask (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_mask() directly.

    YANG Description: Network mask of the network LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_mask must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__network_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_mask(self):
    self.__network_mask = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="network-mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_host_name(self):
    """
    Getter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/host_name (string)

    YANG Description: Host name.
    """
    return self.__host_name
      
  def _set_host_name(self, v, load=False):
    """
    Setter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/host_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_name() directly.

    YANG Description: Host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__host_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_name(self):
    self.__host_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_lsabodys(self):
    """
    Getter method for lsabodys, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys (container)

    YANG Description: List of lsabody.
    """
    return self.__lsabodys
      
  def _set_lsabodys(self, v, load=False):
    """
    Setter method for lsabodys, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/lsabodys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsabodys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsabodys() directly.

    YANG Description: List of lsabody.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsabodys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys, is_container='container', yang_name="lsabodys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsabodys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsabodys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys, is_container='container', yang_name="lsabodys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)""",
        })

    self.__lsabodys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsabodys(self):
    self.__lsabodys = YANGDynClass(base=yc_lsabodys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys, is_container='container', yang_name="lsabodys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)


  def _get_rilsa(self):
    """
    Getter method for rilsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/rilsa (container)

    YANG Description: Statistics of LSA TLV information.
    """
    return self.__rilsa
      
  def _set_rilsa(self, v, load=False):
    """
    Setter method for rilsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic/rilsa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rilsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rilsa() directly.

    YANG Description: Statistics of LSA TLV information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rilsa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_rilsa, is_container='container', yang_name="rilsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rilsa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rilsa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_rilsa, is_container='container', yang_name="rilsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)""",
        })

    self.__rilsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rilsa(self):
    self.__rilsa = YANGDynClass(base=yc_rilsa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_rilsa, is_container='container', yang_name="rilsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

  area_id = __builtin__.property(_get_area_id)
  lsa_type = __builtin__.property(_get_lsa_type)
  link_state_id = __builtin__.property(_get_link_state_id)
  adv_router_id = __builtin__.property(_get_adv_router_id)
  lsa_age = __builtin__.property(_get_lsa_age)
  lsa_sequence_num = __builtin__.property(_get_lsa_sequence_num)
  check_sum = __builtin__.property(_get_check_sum)
  lsa_length = __builtin__.property(_get_lsa_length)
  options = __builtin__.property(_get_options)
  option_flag = __builtin__.property(_get_option_flag)
  link_count = __builtin__.property(_get_link_count)
  network_mask = __builtin__.property(_get_network_mask)
  host_name = __builtin__.property(_get_host_name)
  lsabodys = __builtin__.property(_get_lsabodys) # type: yc_lsabodys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_lsabodys
  rilsa = __builtin__.property(_get_rilsa) # type: yc_rilsa_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic_rilsa


  _pyangbind_elements = OrderedDict([('area_id', area_id), ('lsa_type', lsa_type), ('link_state_id', link_state_id), ('adv_router_id', adv_router_id), ('lsa_age', lsa_age), ('lsa_sequence_num', lsa_sequence_num), ('check_sum', check_sum), ('lsa_length', lsa_length), ('options', options), ('option_flag', option_flag), ('link_count', link_count), ('network_mask', network_mask), ('host_name', host_name), ('lsabodys', lsabodys), ('rilsa', rilsa), ])


class yc_lsdb_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OSPF LSDBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lsdb_statistic',)

  _yang_name = 'lsdb-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lsdb_statistic = YANGDynClass(base=YANGListType("area_id lsa_type link_state_id adv_router_id",yc_lsdb_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic, yang_name="lsdb-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id lsa-type link-state-id adv-router-id', extensions=None), is_container='list', yang_name="lsdb-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-statistics']

  def _get_lsdb_statistic(self):
    """
    Getter method for lsdb_statistic, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic (list)

    YANG Description: Statistics of OSPF LSDBs.
    """
    return self.__lsdb_statistic
      
  def _set_lsdb_statistic(self, v, load=False):
    """
    Setter method for lsdb_statistic, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics/lsdb_statistic (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_statistic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_statistic() directly.

    YANG Description: Statistics of OSPF LSDBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("area_id lsa_type link_state_id adv_router_id",yc_lsdb_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic, yang_name="lsdb-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id lsa-type link-state-id adv-router-id', extensions=None), is_container='list', yang_name="lsdb-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_statistic must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("area_id lsa_type link_state_id adv_router_id",yc_lsdb_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic, yang_name="lsdb-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id lsa-type link-state-id adv-router-id', extensions=None), is_container='list', yang_name="lsdb-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__lsdb_statistic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_statistic(self):
    self.__lsdb_statistic = YANGDynClass(base=YANGListType("area_id lsa_type link_state_id adv_router_id",yc_lsdb_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic, yang_name="lsdb-statistic", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id lsa-type link-state-id adv-router-id', extensions=None), is_container='list', yang_name="lsdb-statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  lsdb_statistic = __builtin__.property(_get_lsdb_statistic) # type: yc_lsdb_statistic_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics_lsdb_statistic


  _pyangbind_elements = OrderedDict([('lsdb_statistic', lsdb_statistic), ])


class yc_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs_lsdb_brief(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-briefs/lsdb-brief. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of LSDB statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__area_id','__router_id','__stub','__router','__network','__summary_net','__asbr','__type7','__opaque9','__opaque10','__sub_total',)

  _yang_name = 'lsdb-brief'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__stub = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__router = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__network = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__summary_net = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="summary-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__asbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="asbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__type7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opaque9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opaque10 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque10", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__sub_total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-briefs', 'lsdb-brief']

  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/area_id (inet:ipv4-address-no-zone)

    YANG Description: Area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/router_id (inet:ipv4-address-no-zone)

    YANG Description: ID of the local router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: ID of the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_stub(self):
    """
    Getter method for stub, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/stub (uint32)

    YANG Description: Number of stubs.
    """
    return self.__stub
      
  def _set_stub(self, v, load=False):
    """
    Setter method for stub, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/stub (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stub is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stub() directly.

    YANG Description: Number of stubs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stub must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__stub = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stub(self):
    self.__stub = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_router(self):
    """
    Getter method for router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/router (uint32)

    YANG Description: Number of router LSAs.
    """
    return self.__router
      
  def _set_router(self, v, load=False):
    """
    Setter method for router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/router (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router() directly.

    YANG Description: Number of router LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router(self):
    self.__router = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/network (uint32)

    YANG Description: Number of network LSAs.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/network (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: Number of network LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_summary_net(self):
    """
    Getter method for summary_net, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/summary_net (uint32)

    YANG Description: Number of summary net LSAs.
    """
    return self.__summary_net
      
  def _set_summary_net(self, v, load=False):
    """
    Setter method for summary_net, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/summary_net (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary_net is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary_net() directly.

    YANG Description: Number of summary net LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="summary-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary_net must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="summary-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__summary_net = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary_net(self):
    self.__summary_net = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="summary-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_asbr(self):
    """
    Getter method for asbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/asbr (uint32)

    YANG Description: Number of ASBR LSAs.
    """
    return self.__asbr
      
  def _set_asbr(self, v, load=False):
    """
    Setter method for asbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/asbr (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asbr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asbr() directly.

    YANG Description: Number of ASBR LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="asbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asbr must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="asbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__asbr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asbr(self):
    self.__asbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="asbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_type7(self):
    """
    Getter method for type7, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/type7 (uint32)

    YANG Description: Number of Type7 LSAs.
    """
    return self.__type7
      
  def _set_type7(self, v, load=False):
    """
    Setter method for type7, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/type7 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type7() directly.

    YANG Description: Number of Type7 LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type7 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__type7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type7(self):
    self.__type7 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="type7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opaque9(self):
    """
    Getter method for opaque9, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/opaque9 (uint32)

    YANG Description: Number of Type9 opaque LSAs.
    """
    return self.__opaque9
      
  def _set_opaque9(self, v, load=False):
    """
    Setter method for opaque9, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/opaque9 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque9 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque9() directly.

    YANG Description: Number of Type9 opaque LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque9 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opaque9 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque9(self):
    self.__opaque9 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque9", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opaque10(self):
    """
    Getter method for opaque10, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/opaque10 (uint32)

    YANG Description: Number of Type10 opaque LSAs.
    """
    return self.__opaque10
      
  def _set_opaque10(self, v, load=False):
    """
    Setter method for opaque10, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/opaque10 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque10 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque10() directly.

    YANG Description: Number of Type10 opaque LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque10", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque10 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque10", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opaque10 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque10(self):
    self.__opaque10 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque10", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_sub_total(self):
    """
    Getter method for sub_total, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/sub_total (uint32)

    YANG Description: Sub type sum.
    """
    return self.__sub_total
      
  def _set_sub_total(self, v, load=False):
    """
    Setter method for sub_total, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief/sub_total (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_total() directly.

    YANG Description: Sub type sum.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_total must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__sub_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_total(self):
    self.__sub_total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  area_id = __builtin__.property(_get_area_id)
  router_id = __builtin__.property(_get_router_id)
  stub = __builtin__.property(_get_stub)
  router = __builtin__.property(_get_router)
  network = __builtin__.property(_get_network)
  summary_net = __builtin__.property(_get_summary_net)
  asbr = __builtin__.property(_get_asbr)
  type7 = __builtin__.property(_get_type7)
  opaque9 = __builtin__.property(_get_opaque9)
  opaque10 = __builtin__.property(_get_opaque10)
  sub_total = __builtin__.property(_get_sub_total)


  _pyangbind_elements = OrderedDict([('area_id', area_id), ('router_id', router_id), ('stub', stub), ('router', router), ('network', network), ('summary_net', summary_net), ('asbr', asbr), ('type7', type7), ('opaque9', opaque9), ('opaque10', opaque10), ('sub_total', sub_total), ])


class yc_lsdb_briefs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/lsdb-briefs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LSDB statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lsdb_brief',)

  _yang_name = 'lsdb-briefs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lsdb_brief = YANGDynClass(base=YANGListType("area_id",yc_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs_lsdb_brief, yang_name="lsdb-brief", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'lsdb-briefs']

  def _get_lsdb_brief(self):
    """
    Getter method for lsdb_brief, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief (list)

    YANG Description: Statistics of LSDB statistics.
    """
    return self.__lsdb_brief
      
  def _set_lsdb_brief(self, v, load=False):
    """
    Setter method for lsdb_brief, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs/lsdb_brief (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_brief is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_brief() directly.

    YANG Description: Statistics of LSDB statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("area_id",yc_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs_lsdb_brief, yang_name="lsdb-brief", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_brief must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("area_id",yc_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs_lsdb_brief, yang_name="lsdb-brief", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__lsdb_brief = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_brief(self):
    self.__lsdb_brief = YANGDynClass(base=YANGListType("area_id",yc_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs_lsdb_brief, yang_name="lsdb-brief", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id', extensions=None), is_container='list', yang_name="lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  lsdb_brief = __builtin__.property(_get_lsdb_brief) # type: yc_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs_lsdb_brief


  _pyangbind_elements = OrderedDict([('lsdb_brief', lsdb_brief), ])


class yc_last_down_nbr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs_last_down_nbr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/last-down-nbrs/last-down-nbr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of the OSPF neighbor that goes down for the last time.
  """
  __slots__ = ('_path_helper', '_extmethods', '__list_index','__area_id','__ip_addr','__router_id','__if_name','__immediate_reason','__primary_reason','__time','__local_router_id','__type',)

  _yang_name = 'last-down-nbr'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__list_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="list-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__immediate_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'neighbor-down-due-to-inactivity': {'value': 0}, 'neighbor-down-due-to-ll-down': {'value': 1}, 'neighbor-down-due-to-kill-neighbor': {'value': 2}, 'neighbor-down-due-to-1-wayhello-received': {'value': 3}, 'neighbor-down-due-to-adjok': {'value': 4}, 'neighbor-down-due-to-sequence-num-mismatch': {'value': 5}, 'neighbor-down-due-to-bad-ls-req': {'value': 6}},), is_leaf=True, yang_name="immediate-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-imm-reason', is_config=False)
    self.__primary_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down-reason-init-value': {'value': 0}, 'hello-not-seen': {'value': 1}, 'interface-parameter-mismatch': {'value': 2}, 'logical-interface-state-change': {'value': 3}, 'link-fault-or-interface-configuration-change': {'value': 4}, 'ospf-process-reset': {'value': 5}, 'area-reset': {'value': 6}, 'area-option-mis-match': {'value': 7}, 'vlink-peer-not-reachable': {'value': 8}, 'sham-link-unreachable': {'value': 9}, 'undo-network-command': {'value': 10}, 'undo-nbma-peer': {'value': 11}, 'passive-interface-down': {'value': 12}, 'opaque-capability-enabled': {'value': 13}, 'opaque-capability-disabled': {'value': 14}, 'virtual-interface-state-change': {'value': 15}, 'bfd-session-down': {'value': 16}, 'retransmission-limit-exceed': {'value': 17}, '1-wayhello-received': {'value': 18}, 'router-state-change-from-dr-or-bdr-to-drother': {'value': 19}, 'neighbor-state-change-from-dr-or-bdr-to-drother': {'value': 20}, 'nssa-area-configure-change': {'value': 21}, 'stub-area-configure-change': {'value': 22}, 'received-invalid-dd-packet': {'value': 23}, 'not-received-dd-during-router-dead-interval': {'value': 24}, 'm-i-ms-bit-or-sequence-num-incorrect': {'value': 25}, 'unable-opaque-capability-find-9-10-11-type-lsa': {'value': 26}, 'not-nssa-find-7-type-lsa-in-summary-list': {'value': 27}, 'ls-request-packet-unknown-reason': {'value': 28}, 'nssa-or-stub-area-find-5-11-type-lsa': {'value': 29}, 'ls-request-packet-request-lsa-is-not-in-the-lsdb': {'value': 30}, 'ls-request-packet-exist-same-lsa-in-the-lsdb': {'value': 31}, 'ls-request-packet-exist-newer-lsa-in-the-lsdb': {'value': 32}, 'neighbor-state-was-not-full-when-lsdb-overflow': {'value': 33}, 'filter-lsa-configuration-change': {'value': 34}, 'acl-changed-for-filter-lsa': {'value': 35}, 'reset-ospf-peer': {'value': 36}, 'interface-reset': {'value': 37}, 'undo-ospf-interface-undo-area-undo-network': {'value': 38}, 'undo-ospf-area': {'value': 39}, 'cpu-overload': {'value': 40}, 'interface-state-changed-to-standby': {'value': 41}, 'undo-router-id': {'value': 42}, 'neighbor-router-id-changed-or-ip-conflicted': {'value': 43}, 'component-is-in-implement-stat': {'value': 44}, 'seqeunce-number-mismatched': {'value': 45}, 'i-bit-incorrect-in-dd': {'value': 46}, 'ms-bit-incorrect-in-dd': {'value': 47}, 'options-incorrect-in-dd': {'value': 48}, 'received-mtu-mismatched-dd-packet': {'value': 49}, 'ospf-process-shutdown': {'value': 51}, 'ospf-max-nbr-in-adj': {'value': 52}, 'ospf-dcn-intf-para-mis-match': {'value': 53}, 'ospf-gr-master-force-down': {'value': 54}, 'dd-retrans-times-upto-limit': {'value': 55}, 'ospf-overflow': {'value': 56}, 'undo-ospf-interface-undo-area': {'value': 100}},), is_leaf=True, yang_name="primary-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-prim-reason', is_config=False)
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)
    self.__local_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="local-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'vlink': {'value': 2}, 'slink': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'last-down-nbrs', 'last-down-nbr']

  def _get_list_index(self):
    """
    Getter method for list_index, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/list_index (uint32)

    YANG Description: The serial number of the node for the particular last down neighbor.
    """
    return self.__list_index
      
  def _set_list_index(self, v, load=False):
    """
    Setter method for list_index, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/list_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_list_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_list_index() directly.

    YANG Description: The serial number of the node for the particular last down neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="list-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """list_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="list-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__list_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_list_index(self):
    self.__list_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="list-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/area_id (inet:ipv4-address-no-zone)

    YANG Description: Area to which the neighbor belongs.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Area to which the neighbor belongs.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_ip_addr(self):
    """
    Getter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/ip_addr (inet:ipv4-address-no-zone)

    YANG Description: Address of the neighbor interface.
    """
    return self.__ip_addr
      
  def _set_ip_addr(self, v, load=False):
    """
    Setter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/ip_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_addr() directly.

    YANG Description: Address of the neighbor interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_addr(self):
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/router_id (inet:ipv4-address-no-zone)

    YANG Description: Router ID of the neighbor.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Router ID of the neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/if_name (string)

    YANG Description: Interface that connects to the neighbor.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Interface that connects to the neighbor.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_immediate_reason(self):
    """
    Getter method for immediate_reason, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/immediate_reason (nbr-down-imm-reason)

    YANG Description: Direct reason that the neighbor goes down.
    """
    return self.__immediate_reason
      
  def _set_immediate_reason(self, v, load=False):
    """
    Setter method for immediate_reason, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/immediate_reason (nbr-down-imm-reason)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_immediate_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_immediate_reason() directly.

    YANG Description: Direct reason that the neighbor goes down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'neighbor-down-due-to-inactivity': {'value': 0}, 'neighbor-down-due-to-ll-down': {'value': 1}, 'neighbor-down-due-to-kill-neighbor': {'value': 2}, 'neighbor-down-due-to-1-wayhello-received': {'value': 3}, 'neighbor-down-due-to-adjok': {'value': 4}, 'neighbor-down-due-to-sequence-num-mismatch': {'value': 5}, 'neighbor-down-due-to-bad-ls-req': {'value': 6}},), is_leaf=True, yang_name="immediate-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-imm-reason', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """immediate_reason must be of a type compatible with nbr-down-imm-reason""",
          'defined-type': "huawei-ospfv2:nbr-down-imm-reason",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'neighbor-down-due-to-inactivity': {'value': 0}, 'neighbor-down-due-to-ll-down': {'value': 1}, 'neighbor-down-due-to-kill-neighbor': {'value': 2}, 'neighbor-down-due-to-1-wayhello-received': {'value': 3}, 'neighbor-down-due-to-adjok': {'value': 4}, 'neighbor-down-due-to-sequence-num-mismatch': {'value': 5}, 'neighbor-down-due-to-bad-ls-req': {'value': 6}},), is_leaf=True, yang_name="immediate-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-imm-reason', is_config=False)""",
        })

    self.__immediate_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_immediate_reason(self):
    self.__immediate_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'neighbor-down-due-to-inactivity': {'value': 0}, 'neighbor-down-due-to-ll-down': {'value': 1}, 'neighbor-down-due-to-kill-neighbor': {'value': 2}, 'neighbor-down-due-to-1-wayhello-received': {'value': 3}, 'neighbor-down-due-to-adjok': {'value': 4}, 'neighbor-down-due-to-sequence-num-mismatch': {'value': 5}, 'neighbor-down-due-to-bad-ls-req': {'value': 6}},), is_leaf=True, yang_name="immediate-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-imm-reason', is_config=False)


  def _get_primary_reason(self):
    """
    Getter method for primary_reason, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/primary_reason (nbr-down-prim-reason)

    YANG Description: Primary reason that the neighbor goes down.
    """
    return self.__primary_reason
      
  def _set_primary_reason(self, v, load=False):
    """
    Setter method for primary_reason, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/primary_reason (nbr-down-prim-reason)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_reason() directly.

    YANG Description: Primary reason that the neighbor goes down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down-reason-init-value': {'value': 0}, 'hello-not-seen': {'value': 1}, 'interface-parameter-mismatch': {'value': 2}, 'logical-interface-state-change': {'value': 3}, 'link-fault-or-interface-configuration-change': {'value': 4}, 'ospf-process-reset': {'value': 5}, 'area-reset': {'value': 6}, 'area-option-mis-match': {'value': 7}, 'vlink-peer-not-reachable': {'value': 8}, 'sham-link-unreachable': {'value': 9}, 'undo-network-command': {'value': 10}, 'undo-nbma-peer': {'value': 11}, 'passive-interface-down': {'value': 12}, 'opaque-capability-enabled': {'value': 13}, 'opaque-capability-disabled': {'value': 14}, 'virtual-interface-state-change': {'value': 15}, 'bfd-session-down': {'value': 16}, 'retransmission-limit-exceed': {'value': 17}, '1-wayhello-received': {'value': 18}, 'router-state-change-from-dr-or-bdr-to-drother': {'value': 19}, 'neighbor-state-change-from-dr-or-bdr-to-drother': {'value': 20}, 'nssa-area-configure-change': {'value': 21}, 'stub-area-configure-change': {'value': 22}, 'received-invalid-dd-packet': {'value': 23}, 'not-received-dd-during-router-dead-interval': {'value': 24}, 'm-i-ms-bit-or-sequence-num-incorrect': {'value': 25}, 'unable-opaque-capability-find-9-10-11-type-lsa': {'value': 26}, 'not-nssa-find-7-type-lsa-in-summary-list': {'value': 27}, 'ls-request-packet-unknown-reason': {'value': 28}, 'nssa-or-stub-area-find-5-11-type-lsa': {'value': 29}, 'ls-request-packet-request-lsa-is-not-in-the-lsdb': {'value': 30}, 'ls-request-packet-exist-same-lsa-in-the-lsdb': {'value': 31}, 'ls-request-packet-exist-newer-lsa-in-the-lsdb': {'value': 32}, 'neighbor-state-was-not-full-when-lsdb-overflow': {'value': 33}, 'filter-lsa-configuration-change': {'value': 34}, 'acl-changed-for-filter-lsa': {'value': 35}, 'reset-ospf-peer': {'value': 36}, 'interface-reset': {'value': 37}, 'undo-ospf-interface-undo-area-undo-network': {'value': 38}, 'undo-ospf-area': {'value': 39}, 'cpu-overload': {'value': 40}, 'interface-state-changed-to-standby': {'value': 41}, 'undo-router-id': {'value': 42}, 'neighbor-router-id-changed-or-ip-conflicted': {'value': 43}, 'component-is-in-implement-stat': {'value': 44}, 'seqeunce-number-mismatched': {'value': 45}, 'i-bit-incorrect-in-dd': {'value': 46}, 'ms-bit-incorrect-in-dd': {'value': 47}, 'options-incorrect-in-dd': {'value': 48}, 'received-mtu-mismatched-dd-packet': {'value': 49}, 'ospf-process-shutdown': {'value': 51}, 'ospf-max-nbr-in-adj': {'value': 52}, 'ospf-dcn-intf-para-mis-match': {'value': 53}, 'ospf-gr-master-force-down': {'value': 54}, 'dd-retrans-times-upto-limit': {'value': 55}, 'ospf-overflow': {'value': 56}, 'undo-ospf-interface-undo-area': {'value': 100}},), is_leaf=True, yang_name="primary-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-prim-reason', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_reason must be of a type compatible with nbr-down-prim-reason""",
          'defined-type': "huawei-ospfv2:nbr-down-prim-reason",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down-reason-init-value': {'value': 0}, 'hello-not-seen': {'value': 1}, 'interface-parameter-mismatch': {'value': 2}, 'logical-interface-state-change': {'value': 3}, 'link-fault-or-interface-configuration-change': {'value': 4}, 'ospf-process-reset': {'value': 5}, 'area-reset': {'value': 6}, 'area-option-mis-match': {'value': 7}, 'vlink-peer-not-reachable': {'value': 8}, 'sham-link-unreachable': {'value': 9}, 'undo-network-command': {'value': 10}, 'undo-nbma-peer': {'value': 11}, 'passive-interface-down': {'value': 12}, 'opaque-capability-enabled': {'value': 13}, 'opaque-capability-disabled': {'value': 14}, 'virtual-interface-state-change': {'value': 15}, 'bfd-session-down': {'value': 16}, 'retransmission-limit-exceed': {'value': 17}, '1-wayhello-received': {'value': 18}, 'router-state-change-from-dr-or-bdr-to-drother': {'value': 19}, 'neighbor-state-change-from-dr-or-bdr-to-drother': {'value': 20}, 'nssa-area-configure-change': {'value': 21}, 'stub-area-configure-change': {'value': 22}, 'received-invalid-dd-packet': {'value': 23}, 'not-received-dd-during-router-dead-interval': {'value': 24}, 'm-i-ms-bit-or-sequence-num-incorrect': {'value': 25}, 'unable-opaque-capability-find-9-10-11-type-lsa': {'value': 26}, 'not-nssa-find-7-type-lsa-in-summary-list': {'value': 27}, 'ls-request-packet-unknown-reason': {'value': 28}, 'nssa-or-stub-area-find-5-11-type-lsa': {'value': 29}, 'ls-request-packet-request-lsa-is-not-in-the-lsdb': {'value': 30}, 'ls-request-packet-exist-same-lsa-in-the-lsdb': {'value': 31}, 'ls-request-packet-exist-newer-lsa-in-the-lsdb': {'value': 32}, 'neighbor-state-was-not-full-when-lsdb-overflow': {'value': 33}, 'filter-lsa-configuration-change': {'value': 34}, 'acl-changed-for-filter-lsa': {'value': 35}, 'reset-ospf-peer': {'value': 36}, 'interface-reset': {'value': 37}, 'undo-ospf-interface-undo-area-undo-network': {'value': 38}, 'undo-ospf-area': {'value': 39}, 'cpu-overload': {'value': 40}, 'interface-state-changed-to-standby': {'value': 41}, 'undo-router-id': {'value': 42}, 'neighbor-router-id-changed-or-ip-conflicted': {'value': 43}, 'component-is-in-implement-stat': {'value': 44}, 'seqeunce-number-mismatched': {'value': 45}, 'i-bit-incorrect-in-dd': {'value': 46}, 'ms-bit-incorrect-in-dd': {'value': 47}, 'options-incorrect-in-dd': {'value': 48}, 'received-mtu-mismatched-dd-packet': {'value': 49}, 'ospf-process-shutdown': {'value': 51}, 'ospf-max-nbr-in-adj': {'value': 52}, 'ospf-dcn-intf-para-mis-match': {'value': 53}, 'ospf-gr-master-force-down': {'value': 54}, 'dd-retrans-times-upto-limit': {'value': 55}, 'ospf-overflow': {'value': 56}, 'undo-ospf-interface-undo-area': {'value': 100}},), is_leaf=True, yang_name="primary-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-prim-reason', is_config=False)""",
        })

    self.__primary_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_reason(self):
    self.__primary_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down-reason-init-value': {'value': 0}, 'hello-not-seen': {'value': 1}, 'interface-parameter-mismatch': {'value': 2}, 'logical-interface-state-change': {'value': 3}, 'link-fault-or-interface-configuration-change': {'value': 4}, 'ospf-process-reset': {'value': 5}, 'area-reset': {'value': 6}, 'area-option-mis-match': {'value': 7}, 'vlink-peer-not-reachable': {'value': 8}, 'sham-link-unreachable': {'value': 9}, 'undo-network-command': {'value': 10}, 'undo-nbma-peer': {'value': 11}, 'passive-interface-down': {'value': 12}, 'opaque-capability-enabled': {'value': 13}, 'opaque-capability-disabled': {'value': 14}, 'virtual-interface-state-change': {'value': 15}, 'bfd-session-down': {'value': 16}, 'retransmission-limit-exceed': {'value': 17}, '1-wayhello-received': {'value': 18}, 'router-state-change-from-dr-or-bdr-to-drother': {'value': 19}, 'neighbor-state-change-from-dr-or-bdr-to-drother': {'value': 20}, 'nssa-area-configure-change': {'value': 21}, 'stub-area-configure-change': {'value': 22}, 'received-invalid-dd-packet': {'value': 23}, 'not-received-dd-during-router-dead-interval': {'value': 24}, 'm-i-ms-bit-or-sequence-num-incorrect': {'value': 25}, 'unable-opaque-capability-find-9-10-11-type-lsa': {'value': 26}, 'not-nssa-find-7-type-lsa-in-summary-list': {'value': 27}, 'ls-request-packet-unknown-reason': {'value': 28}, 'nssa-or-stub-area-find-5-11-type-lsa': {'value': 29}, 'ls-request-packet-request-lsa-is-not-in-the-lsdb': {'value': 30}, 'ls-request-packet-exist-same-lsa-in-the-lsdb': {'value': 31}, 'ls-request-packet-exist-newer-lsa-in-the-lsdb': {'value': 32}, 'neighbor-state-was-not-full-when-lsdb-overflow': {'value': 33}, 'filter-lsa-configuration-change': {'value': 34}, 'acl-changed-for-filter-lsa': {'value': 35}, 'reset-ospf-peer': {'value': 36}, 'interface-reset': {'value': 37}, 'undo-ospf-interface-undo-area-undo-network': {'value': 38}, 'undo-ospf-area': {'value': 39}, 'cpu-overload': {'value': 40}, 'interface-state-changed-to-standby': {'value': 41}, 'undo-router-id': {'value': 42}, 'neighbor-router-id-changed-or-ip-conflicted': {'value': 43}, 'component-is-in-implement-stat': {'value': 44}, 'seqeunce-number-mismatched': {'value': 45}, 'i-bit-incorrect-in-dd': {'value': 46}, 'ms-bit-incorrect-in-dd': {'value': 47}, 'options-incorrect-in-dd': {'value': 48}, 'received-mtu-mismatched-dd-packet': {'value': 49}, 'ospf-process-shutdown': {'value': 51}, 'ospf-max-nbr-in-adj': {'value': 52}, 'ospf-dcn-intf-para-mis-match': {'value': 53}, 'ospf-gr-master-force-down': {'value': 54}, 'dd-retrans-times-upto-limit': {'value': 55}, 'ospf-overflow': {'value': 56}, 'undo-ospf-interface-undo-area': {'value': 100}},), is_leaf=True, yang_name="primary-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-down-prim-reason', is_config=False)


  def _get_time(self):
    """
    Getter method for time, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/time (yang:date-and-time)

    YANG Description: Time when the neighbor goes down.
    """
    return self.__time
      
  def _set_time(self, v, load=False):
    """
    Setter method for time, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time() directly.

    YANG Description: Time when the neighbor goes down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time(self):
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)


  def _get_local_router_id(self):
    """
    Getter method for local_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/local_router_id (inet:ipv4-address-no-zone)

    YANG Description: ID of the local router.
    """
    return self.__local_router_id
      
  def _set_local_router_id(self, v, load=False):
    """
    Setter method for local_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/local_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_router_id() directly.

    YANG Description: ID of the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="local-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="local-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__local_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_router_id(self):
    self.__local_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="local-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/type (nbr-type)

    YANG Description: Last down neighbor type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr/type (nbr-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Last down neighbor type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'vlink': {'value': 2}, 'slink': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with nbr-type""",
          'defined-type': "huawei-ospfv2:nbr-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'vlink': {'value': 2}, 'slink': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 1}, 'vlink': {'value': 2}, 'slink': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-type', is_config=False)

  list_index = __builtin__.property(_get_list_index)
  area_id = __builtin__.property(_get_area_id)
  ip_addr = __builtin__.property(_get_ip_addr)
  router_id = __builtin__.property(_get_router_id)
  if_name = __builtin__.property(_get_if_name)
  immediate_reason = __builtin__.property(_get_immediate_reason)
  primary_reason = __builtin__.property(_get_primary_reason)
  time = __builtin__.property(_get_time)
  local_router_id = __builtin__.property(_get_local_router_id)
  type = __builtin__.property(_get_type)


  _pyangbind_elements = OrderedDict([('list_index', list_index), ('area_id', area_id), ('ip_addr', ip_addr), ('router_id', router_id), ('if_name', if_name), ('immediate_reason', immediate_reason), ('primary_reason', primary_reason), ('time', time), ('local_router_id', local_router_id), ('type', type), ])


class yc_last_down_nbrs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/last-down-nbrs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the OSPF neighbor that goes down for the last time.
  """
  __slots__ = ('_path_helper', '_extmethods', '__last_down_nbr',)

  _yang_name = 'last-down-nbrs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__last_down_nbr = YANGDynClass(base=YANGListType("list_index area_id ip_addr router_id if_name",yc_last_down_nbr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs_last_down_nbr, yang_name="last-down-nbr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-index area-id ip-addr router-id if-name', extensions=None), is_container='list', yang_name="last-down-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'last-down-nbrs']

  def _get_last_down_nbr(self):
    """
    Getter method for last_down_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr (list)

    YANG Description: Statistics of the OSPF neighbor that goes down for the last time.
    """
    return self.__last_down_nbr
      
  def _set_last_down_nbr(self, v, load=False):
    """
    Setter method for last_down_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs/last_down_nbr (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_down_nbr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_down_nbr() directly.

    YANG Description: Statistics of the OSPF neighbor that goes down for the last time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("list_index area_id ip_addr router_id if_name",yc_last_down_nbr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs_last_down_nbr, yang_name="last-down-nbr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-index area-id ip-addr router-id if-name', extensions=None), is_container='list', yang_name="last-down-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_down_nbr must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("list_index area_id ip_addr router_id if_name",yc_last_down_nbr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs_last_down_nbr, yang_name="last-down-nbr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-index area-id ip-addr router-id if-name', extensions=None), is_container='list', yang_name="last-down-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__last_down_nbr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_down_nbr(self):
    self.__last_down_nbr = YANGDynClass(base=YANGListType("list_index area_id ip_addr router_id if_name",yc_last_down_nbr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs_last_down_nbr, yang_name="last-down-nbr", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='list-index area-id ip-addr router-id if-name', extensions=None), is_container='list', yang_name="last-down-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  last_down_nbr = __builtin__.property(_get_last_down_nbr) # type: yc_last_down_nbr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs_last_down_nbr


  _pyangbind_elements = OrderedDict([('last_down_nbr', last_down_nbr), ])


class yc_disp_graceful_restart_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/disp-graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of graceful restart information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__capability','__help_role','__current_state','__on_helper','__nbr_num',)

  _yang_name = 'disp-graceful-restart'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__capability = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-capabality', is_config=False)
    self.__help_role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'planned-strict-lsa-check': {'value': 1}, 'un-planned-strict-lsa-check': {'value': 2}, 'planned-un-planned-strict-lsa-check': {'value': 3}, 'ignore-external-lsa-check': {'value': 4}, 'planned-ignore-external-lsa-check': {'value': 5}, 'un-planned-ignore-external-lsa-check': {'value': 6}, 'planned-un-planned-ignore-external-lsa-check': {'value': 7}, 'never': {'value': 8}, 'planned-un-planned-non-ietf': {'value': 35}},), is_leaf=True, yang_name="help-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-support', is_config=False)
    self.__current_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="current-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)
    self.__on_helper = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'successful-exit': {'value': 1}, 'grace-period-expired': {'value': 2}, 'received-flushed-grace-lsa': {'value': 3}, 'flooding-changed-lsa': {'value': 4}, 'policy-check-failed-for-received-grace-lsa': {'value': 6}, 'neighbor-reset': {'value': 7}, 'interface-status-changed': {'value': 8}, 'graceful-restart-unconfigured-at-process-level': {'value': 9}, 'grace-lsa-not-found': {'value': 10}},), is_leaf=True, yang_name="on-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='on-helper', is_config=False)
    self.__nbr_num = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbr-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'disp-graceful-restart']

  def _get_capability(self):
    """
    Getter method for capability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/capability (helper-capabality)

    YANG Description: Graceful restart capability.
    """
    return self.__capability
      
  def _set_capability(self, v, load=False):
    """
    Setter method for capability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/capability (helper-capabality)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capability() directly.

    YANG Description: Graceful restart capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-capabality', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capability must be of a type compatible with helper-capabality""",
          'defined-type': "huawei-ospfv2:helper-capabality",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-capabality', is_config=False)""",
        })

    self.__capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capability(self):
    self.__capability = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'disabled': {'value': 0}, 'enabled': {'value': 1}},), is_leaf=True, yang_name="capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-capabality', is_config=False)


  def _get_help_role(self):
    """
    Getter method for help_role, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/help_role (helper-support)

    YANG Description: Helper policy support.
    """
    return self.__help_role
      
  def _set_help_role(self, v, load=False):
    """
    Setter method for help_role, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/help_role (helper-support)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_help_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_help_role() directly.

    YANG Description: Helper policy support.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'planned-strict-lsa-check': {'value': 1}, 'un-planned-strict-lsa-check': {'value': 2}, 'planned-un-planned-strict-lsa-check': {'value': 3}, 'ignore-external-lsa-check': {'value': 4}, 'planned-ignore-external-lsa-check': {'value': 5}, 'un-planned-ignore-external-lsa-check': {'value': 6}, 'planned-un-planned-ignore-external-lsa-check': {'value': 7}, 'never': {'value': 8}, 'planned-un-planned-non-ietf': {'value': 35}},), is_leaf=True, yang_name="help-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-support', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """help_role must be of a type compatible with helper-support""",
          'defined-type': "huawei-ospfv2:helper-support",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'planned-strict-lsa-check': {'value': 1}, 'un-planned-strict-lsa-check': {'value': 2}, 'planned-un-planned-strict-lsa-check': {'value': 3}, 'ignore-external-lsa-check': {'value': 4}, 'planned-ignore-external-lsa-check': {'value': 5}, 'un-planned-ignore-external-lsa-check': {'value': 6}, 'planned-un-planned-ignore-external-lsa-check': {'value': 7}, 'never': {'value': 8}, 'planned-un-planned-non-ietf': {'value': 35}},), is_leaf=True, yang_name="help-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-support', is_config=False)""",
        })

    self.__help_role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_help_role(self):
    self.__help_role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'planned-strict-lsa-check': {'value': 1}, 'un-planned-strict-lsa-check': {'value': 2}, 'planned-un-planned-strict-lsa-check': {'value': 3}, 'ignore-external-lsa-check': {'value': 4}, 'planned-ignore-external-lsa-check': {'value': 5}, 'un-planned-ignore-external-lsa-check': {'value': 6}, 'planned-un-planned-ignore-external-lsa-check': {'value': 7}, 'never': {'value': 8}, 'planned-un-planned-non-ietf': {'value': 35}},), is_leaf=True, yang_name="help-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='helper-support', is_config=False)


  def _get_current_state(self):
    """
    Getter method for current_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/current_state (gr-state)

    YANG Description: Current GR status.
    """
    return self.__current_state
      
  def _set_current_state(self, v, load=False):
    """
    Setter method for current_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/current_state (gr-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_state() directly.

    YANG Description: Current GR status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="current-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_state must be of a type compatible with gr-state""",
          'defined-type': "huawei-ospfv2:gr-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="current-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)""",
        })

    self.__current_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_state(self):
    self.__current_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'helper': {'value': 1}, 'null': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="current-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='gr-state', is_config=False)


  def _get_on_helper(self):
    """
    Getter method for on_helper, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/on_helper (on-helper)

    YANG Description: Cause for exiting GR by the helper.
    """
    return self.__on_helper
      
  def _set_on_helper(self, v, load=False):
    """
    Setter method for on_helper, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/on_helper (on-helper)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_on_helper is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_on_helper() directly.

    YANG Description: Cause for exiting GR by the helper.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'successful-exit': {'value': 1}, 'grace-period-expired': {'value': 2}, 'received-flushed-grace-lsa': {'value': 3}, 'flooding-changed-lsa': {'value': 4}, 'policy-check-failed-for-received-grace-lsa': {'value': 6}, 'neighbor-reset': {'value': 7}, 'interface-status-changed': {'value': 8}, 'graceful-restart-unconfigured-at-process-level': {'value': 9}, 'grace-lsa-not-found': {'value': 10}},), is_leaf=True, yang_name="on-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='on-helper', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """on_helper must be of a type compatible with on-helper""",
          'defined-type': "huawei-ospfv2:on-helper",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'successful-exit': {'value': 1}, 'grace-period-expired': {'value': 2}, 'received-flushed-grace-lsa': {'value': 3}, 'flooding-changed-lsa': {'value': 4}, 'policy-check-failed-for-received-grace-lsa': {'value': 6}, 'neighbor-reset': {'value': 7}, 'interface-status-changed': {'value': 8}, 'graceful-restart-unconfigured-at-process-level': {'value': 9}, 'grace-lsa-not-found': {'value': 10}},), is_leaf=True, yang_name="on-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='on-helper', is_config=False)""",
        })

    self.__on_helper = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_on_helper(self):
    self.__on_helper = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'successful-exit': {'value': 1}, 'grace-period-expired': {'value': 2}, 'received-flushed-grace-lsa': {'value': 3}, 'flooding-changed-lsa': {'value': 4}, 'policy-check-failed-for-received-grace-lsa': {'value': 6}, 'neighbor-reset': {'value': 7}, 'interface-status-changed': {'value': 8}, 'graceful-restart-unconfigured-at-process-level': {'value': 9}, 'grace-lsa-not-found': {'value': 10}},), is_leaf=True, yang_name="on-helper", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='on-helper', is_config=False)


  def _get_nbr_num(self):
    """
    Getter method for nbr_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/nbr_num (uint32)

    YANG Description: Re starting neighbor count.
    """
    return self.__nbr_num
      
  def _set_nbr_num(self, v, load=False):
    """
    Setter method for nbr_num, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart/nbr_num (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nbr_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nbr_num() directly.

    YANG Description: Re starting neighbor count.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbr-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nbr_num must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbr-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__nbr_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nbr_num(self):
    self.__nbr_num = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbr-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  capability = __builtin__.property(_get_capability)
  help_role = __builtin__.property(_get_help_role)
  current_state = __builtin__.property(_get_current_state)
  on_helper = __builtin__.property(_get_on_helper)
  nbr_num = __builtin__.property(_get_nbr_num)


  _pyangbind_elements = OrderedDict([('capability', capability), ('help_role', help_role), ('current_state', current_state), ('on_helper', on_helper), ('nbr_num', nbr_num), ])


class yc_error_process_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_error_process_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/error-process-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of error data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__same_ip_pkt_cnt','__bad_pkt_cnt','__bad_ver_cnt','__bad_chk_sum_pkt_cnt','__bad_area_pkt_cnt','__pkt_rcv_unnumber','__bad_virt_link_cnt','__auth_type_fail_cnt','__auth_key_fail_cnt','__short_pkt_cnt','__long_pkt_cnt','__tx_err_cnt','__if_down_cnt','__no_nbr','__mis_netmask_cnt','__mis_hello_intl_cnt','__mis_dead_intl_cnt','__mis_ext_rou_cap_cnt','__router_id_confusion','__vlink_nbr_mis_cnt','__nbma_nbr_err_cnt','__inval_src_helo_cnt','__dd_nbr_low_cnt','__dd_router_id_cnt','__dd_opt_mismatch_cnt','__dd_unknwn_lsa_cnt','__dd_mtu_mismatch_cnt','__ack_nbr_low_cnt','__ack_bad_cnt','__ack_duplicate_cnt','__ack_unknown_lsa_cnt','__req_nbr_low_cnt','__req_empty_cnt','__req_bad_cnt','__upd_nbr_low_cnt','__upd_self_newr_cnt','__upd_min_lsa_lsarr_cnt','__upd_ls_checksum_cnt','__upd_les_recent_cnt','__upd_unknow_lsa_cnt','__opq9_flood_cnt','__opq10_flood_cnt','__opq11_flood_cnt','__unknown_tlv','__rxmt_dd_err_cnt','__rxmt_req_err_cnt','__rxmt_upd_err_cnt','__gr_invalid_lsa_cnt','__gr_invalid_pol_cnt','__gr_invalid_prd_cnt','__tunnel_cost_cnt','__peer_net_type_cnt','__hello_dr_mis_cnt',)

  _yang_name = 'error-process-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__same_ip_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_ver_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_chk_sum_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chk-sum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_area_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__pkt_rcv_unnumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bad_virt_link_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__auth_type_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__auth_key_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__short_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__long_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__tx_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__if_down_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__no_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_netmask_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_hello_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_dead_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__mis_ext_rou_cap_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-rou-cap-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__router_id_confusion = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__vlink_nbr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__nbma_nbr_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__inval_src_helo_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-helo-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_router_id_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-router-id-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_opt_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_unknwn_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dd_mtu_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_duplicate_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ack_unknown_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknown-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__req_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__req_empty_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__req_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_self_newr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_min_lsa_lsarr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsa-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_ls_checksum_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-checksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_les_recent_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__upd_unknow_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknow-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opq9_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opq10_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__opq11_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__unknown_tlv = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__rxmt_dd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__rxmt_req_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__rxmt_upd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__gr_invalid_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__gr_invalid_pol_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__gr_invalid_prd_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__tunnel_cost_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__peer_net_type_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__hello_dr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'error-process-data']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/router_id (inet:ipv4-address-no-zone)

    YANG Description: Router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_same_ip_pkt_cnt(self):
    """
    Getter method for same_ip_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/same_ip_pkt_cnt (uint32)

    YANG Description: Same IP packet count.
    """
    return self.__same_ip_pkt_cnt
      
  def _set_same_ip_pkt_cnt(self, v, load=False):
    """
    Setter method for same_ip_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/same_ip_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_same_ip_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_same_ip_pkt_cnt() directly.

    YANG Description: Same IP packet count.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """same_ip_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__same_ip_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_same_ip_pkt_cnt(self):
    self.__same_ip_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="same-ip-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_pkt_cnt(self):
    """
    Getter method for bad_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_pkt_cnt (uint32)

    YANG Description: Bad packet.
    """
    return self.__bad_pkt_cnt
      
  def _set_bad_pkt_cnt(self, v, load=False):
    """
    Setter method for bad_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_pkt_cnt() directly.

    YANG Description: Bad packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_pkt_cnt(self):
    self.__bad_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_ver_cnt(self):
    """
    Getter method for bad_ver_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_ver_cnt (uint32)

    YANG Description: Bad version.
    """
    return self.__bad_ver_cnt
      
  def _set_bad_ver_cnt(self, v, load=False):
    """
    Setter method for bad_ver_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_ver_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_ver_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_ver_cnt() directly.

    YANG Description: Bad version.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_ver_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_ver_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_ver_cnt(self):
    self.__bad_ver_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-ver-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_chk_sum_pkt_cnt(self):
    """
    Getter method for bad_chk_sum_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_chk_sum_pkt_cnt (uint32)

    YANG Description: Bad checksum.
    """
    return self.__bad_chk_sum_pkt_cnt
      
  def _set_bad_chk_sum_pkt_cnt(self, v, load=False):
    """
    Setter method for bad_chk_sum_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_chk_sum_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_chk_sum_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_chk_sum_pkt_cnt() directly.

    YANG Description: Bad checksum.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chk-sum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_chk_sum_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chk-sum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_chk_sum_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_chk_sum_pkt_cnt(self):
    self.__bad_chk_sum_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-chk-sum-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_area_pkt_cnt(self):
    """
    Getter method for bad_area_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_area_pkt_cnt (uint32)

    YANG Description: Bad area ID.
    """
    return self.__bad_area_pkt_cnt
      
  def _set_bad_area_pkt_cnt(self, v, load=False):
    """
    Setter method for bad_area_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_area_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_area_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_area_pkt_cnt() directly.

    YANG Description: Bad area ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_area_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_area_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_area_pkt_cnt(self):
    self.__bad_area_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-area-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_pkt_rcv_unnumber(self):
    """
    Getter method for pkt_rcv_unnumber, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/pkt_rcv_unnumber (uint32)

    YANG Description: Drop on unnumbered interface.
    """
    return self.__pkt_rcv_unnumber
      
  def _set_pkt_rcv_unnumber(self, v, load=False):
    """
    Setter method for pkt_rcv_unnumber, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/pkt_rcv_unnumber (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pkt_rcv_unnumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pkt_rcv_unnumber() directly.

    YANG Description: Drop on unnumbered interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pkt_rcv_unnumber must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__pkt_rcv_unnumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pkt_rcv_unnumber(self):
    self.__pkt_rcv_unnumber = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="pkt-rcv-unnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bad_virt_link_cnt(self):
    """
    Getter method for bad_virt_link_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_virt_link_cnt (uint32)

    YANG Description: Bad virtual link.
    """
    return self.__bad_virt_link_cnt
      
  def _set_bad_virt_link_cnt(self, v, load=False):
    """
    Setter method for bad_virt_link_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/bad_virt_link_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bad_virt_link_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bad_virt_link_cnt() directly.

    YANG Description: Bad virtual link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bad_virt_link_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__bad_virt_link_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bad_virt_link_cnt(self):
    self.__bad_virt_link_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bad-virt-link-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_auth_type_fail_cnt(self):
    """
    Getter method for auth_type_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/auth_type_fail_cnt (uint32)

    YANG Description: Bad authentication type.
    """
    return self.__auth_type_fail_cnt
      
  def _set_auth_type_fail_cnt(self, v, load=False):
    """
    Setter method for auth_type_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/auth_type_fail_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_type_fail_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_type_fail_cnt() directly.

    YANG Description: Bad authentication type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_type_fail_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__auth_type_fail_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_type_fail_cnt(self):
    self.__auth_type_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-type-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_auth_key_fail_cnt(self):
    """
    Getter method for auth_key_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/auth_key_fail_cnt (uint32)

    YANG Description: Bad authentication key.
    """
    return self.__auth_key_fail_cnt
      
  def _set_auth_key_fail_cnt(self, v, load=False):
    """
    Setter method for auth_key_fail_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/auth_key_fail_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_key_fail_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_key_fail_cnt() directly.

    YANG Description: Bad authentication key.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_key_fail_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__auth_key_fail_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_key_fail_cnt(self):
    self.__auth_key_fail_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-key-fail-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_short_pkt_cnt(self):
    """
    Getter method for short_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/short_pkt_cnt (uint32)

    YANG Description: Packet too small.
    """
    return self.__short_pkt_cnt
      
  def _set_short_pkt_cnt(self, v, load=False):
    """
    Setter method for short_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/short_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_pkt_cnt() directly.

    YANG Description: Packet too small.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__short_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_pkt_cnt(self):
    self.__short_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="short-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_long_pkt_cnt(self):
    """
    Getter method for long_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/long_pkt_cnt (uint32)

    YANG Description: Packet size > ip length.
    """
    return self.__long_pkt_cnt
      
  def _set_long_pkt_cnt(self, v, load=False):
    """
    Setter method for long_pkt_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/long_pkt_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_long_pkt_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_long_pkt_cnt() directly.

    YANG Description: Packet size > ip length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """long_pkt_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__long_pkt_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_long_pkt_cnt(self):
    self.__long_pkt_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="long-pkt-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_tx_err_cnt(self):
    """
    Getter method for tx_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/tx_err_cnt (uint32)

    YANG Description: Transmit error.
    """
    return self.__tx_err_cnt
      
  def _set_tx_err_cnt(self, v, load=False):
    """
    Setter method for tx_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/tx_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_err_cnt() directly.

    YANG Description: Transmit error.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tx_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_err_cnt(self):
    self.__tx_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tx-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_if_down_cnt(self):
    """
    Getter method for if_down_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/if_down_cnt (uint32)

    YANG Description: Interface down.
    """
    return self.__if_down_cnt
      
  def _set_if_down_cnt(self, v, load=False):
    """
    Setter method for if_down_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/if_down_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_down_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_down_cnt() directly.

    YANG Description: Interface down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_down_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__if_down_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_down_cnt(self):
    self.__if_down_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-down-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_no_nbr(self):
    """
    Getter method for no_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/no_nbr (uint32)

    YANG Description: Unknown neighbor.
    """
    return self.__no_nbr
      
  def _set_no_nbr(self, v, load=False):
    """
    Setter method for no_nbr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/no_nbr (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_nbr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_nbr() directly.

    YANG Description: Unknown neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_nbr must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__no_nbr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_nbr(self):
    self.__no_nbr = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="no-nbr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_netmask_cnt(self):
    """
    Getter method for mis_netmask_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_netmask_cnt (uint32)

    YANG Description: Netmask mismatch.
    """
    return self.__mis_netmask_cnt
      
  def _set_mis_netmask_cnt(self, v, load=False):
    """
    Setter method for mis_netmask_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_netmask_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_netmask_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_netmask_cnt() directly.

    YANG Description: Netmask mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_netmask_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_netmask_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_netmask_cnt(self):
    self.__mis_netmask_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-netmask-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_hello_intl_cnt(self):
    """
    Getter method for mis_hello_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_hello_intl_cnt (uint32)

    YANG Description: Hello timer mismatch.
    """
    return self.__mis_hello_intl_cnt
      
  def _set_mis_hello_intl_cnt(self, v, load=False):
    """
    Setter method for mis_hello_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_hello_intl_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_hello_intl_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_hello_intl_cnt() directly.

    YANG Description: Hello timer mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_hello_intl_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_hello_intl_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_hello_intl_cnt(self):
    self.__mis_hello_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-hello-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_dead_intl_cnt(self):
    """
    Getter method for mis_dead_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_dead_intl_cnt (uint32)

    YANG Description: Dead timer mismatch.
    """
    return self.__mis_dead_intl_cnt
      
  def _set_mis_dead_intl_cnt(self, v, load=False):
    """
    Setter method for mis_dead_intl_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_dead_intl_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_dead_intl_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_dead_intl_cnt() directly.

    YANG Description: Dead timer mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_dead_intl_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_dead_intl_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_dead_intl_cnt(self):
    self.__mis_dead_intl_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-dead-intl-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_mis_ext_rou_cap_cnt(self):
    """
    Getter method for mis_ext_rou_cap_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_ext_rou_cap_cnt (uint32)

    YANG Description: Extern option mismatch.
    """
    return self.__mis_ext_rou_cap_cnt
      
  def _set_mis_ext_rou_cap_cnt(self, v, load=False):
    """
    Setter method for mis_ext_rou_cap_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/mis_ext_rou_cap_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mis_ext_rou_cap_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mis_ext_rou_cap_cnt() directly.

    YANG Description: Extern option mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-rou-cap-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mis_ext_rou_cap_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-rou-cap-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mis_ext_rou_cap_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mis_ext_rou_cap_cnt(self):
    self.__mis_ext_rou_cap_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mis-ext-rou-cap-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_router_id_confusion(self):
    """
    Getter method for router_id_confusion, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/router_id_confusion (uint32)

    YANG Description: DD router ID confusion.
    """
    return self.__router_id_confusion
      
  def _set_router_id_confusion(self, v, load=False):
    """
    Setter method for router_id_confusion, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/router_id_confusion (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id_confusion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id_confusion() directly.

    YANG Description: DD router ID confusion.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id_confusion must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__router_id_confusion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id_confusion(self):
    self.__router_id_confusion = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="router-id-confusion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_vlink_nbr_mis_cnt(self):
    """
    Getter method for vlink_nbr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/vlink_nbr_mis_cnt (uint32)

    YANG Description: Virtual neighbor unknown.
    """
    return self.__vlink_nbr_mis_cnt
      
  def _set_vlink_nbr_mis_cnt(self, v, load=False):
    """
    Setter method for vlink_nbr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/vlink_nbr_mis_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlink_nbr_mis_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlink_nbr_mis_cnt() directly.

    YANG Description: Virtual neighbor unknown.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlink_nbr_mis_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__vlink_nbr_mis_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlink_nbr_mis_cnt(self):
    self.__vlink_nbr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vlink-nbr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_nbma_nbr_err_cnt(self):
    """
    Getter method for nbma_nbr_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/nbma_nbr_err_cnt (uint32)

    YANG Description: NBMA neighbor unknown.
    """
    return self.__nbma_nbr_err_cnt
      
  def _set_nbma_nbr_err_cnt(self, v, load=False):
    """
    Setter method for nbma_nbr_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/nbma_nbr_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nbma_nbr_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nbma_nbr_err_cnt() directly.

    YANG Description: NBMA neighbor unknown.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nbma_nbr_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__nbma_nbr_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nbma_nbr_err_cnt(self):
    self.__nbma_nbr_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nbma-nbr-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_inval_src_helo_cnt(self):
    """
    Getter method for inval_src_helo_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/inval_src_helo_cnt (uint32)

    YANG Description: Invalid source.
    """
    return self.__inval_src_helo_cnt
      
  def _set_inval_src_helo_cnt(self, v, load=False):
    """
    Setter method for inval_src_helo_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/inval_src_helo_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inval_src_helo_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inval_src_helo_cnt() directly.

    YANG Description: Invalid source.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-helo-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inval_src_helo_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-helo-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__inval_src_helo_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inval_src_helo_cnt(self):
    self.__inval_src_helo_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="inval-src-helo-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_nbr_low_cnt(self):
    """
    Getter method for dd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for DD.
    """
    return self.__dd_nbr_low_cnt
      
  def _set_dd_nbr_low_cnt(self, v, load=False):
    """
    Setter method for dd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for DD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_nbr_low_cnt(self):
    self.__dd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_router_id_cnt(self):
    """
    Getter method for dd_router_id_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_router_id_cnt (uint32)

    YANG Description: DD router ID confusion.
    """
    return self.__dd_router_id_cnt
      
  def _set_dd_router_id_cnt(self, v, load=False):
    """
    Setter method for dd_router_id_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_router_id_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_router_id_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_router_id_cnt() directly.

    YANG Description: DD router ID confusion.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-router-id-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_router_id_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-router-id-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_router_id_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_router_id_cnt(self):
    self.__dd_router_id_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-router-id-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_opt_mismatch_cnt(self):
    """
    Getter method for dd_opt_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_opt_mismatch_cnt (uint32)

    YANG Description: Extern option mismatch.
    """
    return self.__dd_opt_mismatch_cnt
      
  def _set_dd_opt_mismatch_cnt(self, v, load=False):
    """
    Setter method for dd_opt_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_opt_mismatch_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_opt_mismatch_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_opt_mismatch_cnt() directly.

    YANG Description: Extern option mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_opt_mismatch_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_opt_mismatch_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_opt_mismatch_cnt(self):
    self.__dd_opt_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-opt-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_unknwn_lsa_cnt(self):
    """
    Getter method for dd_unknwn_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_unknwn_lsa_cnt (uint32)

    YANG Description: DD packet unknown LSA type.
    """
    return self.__dd_unknwn_lsa_cnt
      
  def _set_dd_unknwn_lsa_cnt(self, v, load=False):
    """
    Setter method for dd_unknwn_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_unknwn_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_unknwn_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_unknwn_lsa_cnt() directly.

    YANG Description: DD packet unknown LSA type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_unknwn_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_unknwn_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_unknwn_lsa_cnt(self):
    self.__dd_unknwn_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-unknwn-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dd_mtu_mismatch_cnt(self):
    """
    Getter method for dd_mtu_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_mtu_mismatch_cnt (uint32)

    YANG Description: MTU option mismatch.
    """
    return self.__dd_mtu_mismatch_cnt
      
  def _set_dd_mtu_mismatch_cnt(self, v, load=False):
    """
    Setter method for dd_mtu_mismatch_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/dd_mtu_mismatch_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dd_mtu_mismatch_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dd_mtu_mismatch_cnt() directly.

    YANG Description: MTU option mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dd_mtu_mismatch_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__dd_mtu_mismatch_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dd_mtu_mismatch_cnt(self):
    self.__dd_mtu_mismatch_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dd-mtu-mismatch-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_nbr_low_cnt(self):
    """
    Getter method for ack_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for LS acknowledgement.
    """
    return self.__ack_nbr_low_cnt
      
  def _set_ack_nbr_low_cnt(self, v, load=False):
    """
    Setter method for ack_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for LS acknowledgement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_nbr_low_cnt(self):
    self.__ack_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_bad_cnt(self):
    """
    Getter method for ack_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_bad_cnt (uint32)

    YANG Description: Bad ack.
    """
    return self.__ack_bad_cnt
      
  def _set_ack_bad_cnt(self, v, load=False):
    """
    Setter method for ack_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_bad_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_bad_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_bad_cnt() directly.

    YANG Description: Bad ack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_bad_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_bad_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_bad_cnt(self):
    self.__ack_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_duplicate_cnt(self):
    """
    Getter method for ack_duplicate_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_duplicate_cnt (uint32)

    YANG Description: Duplicate ack.
    """
    return self.__ack_duplicate_cnt
      
  def _set_ack_duplicate_cnt(self, v, load=False):
    """
    Setter method for ack_duplicate_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_duplicate_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_duplicate_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_duplicate_cnt() directly.

    YANG Description: Duplicate ack.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_duplicate_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_duplicate_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_duplicate_cnt(self):
    self.__ack_duplicate_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-duplicate-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ack_unknown_lsa_cnt(self):
    """
    Getter method for ack_unknown_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_unknown_lsa_cnt (uint32)

    YANG Description: LSAck packet unknown LSA type.
    """
    return self.__ack_unknown_lsa_cnt
      
  def _set_ack_unknown_lsa_cnt(self, v, load=False):
    """
    Setter method for ack_unknown_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/ack_unknown_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ack_unknown_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ack_unknown_lsa_cnt() directly.

    YANG Description: LSAck packet unknown LSA type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknown-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ack_unknown_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknown-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ack_unknown_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ack_unknown_lsa_cnt(self):
    self.__ack_unknown_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ack-unknown-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_req_nbr_low_cnt(self):
    """
    Getter method for req_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/req_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for LS request.
    """
    return self.__req_nbr_low_cnt
      
  def _set_req_nbr_low_cnt(self, v, load=False):
    """
    Setter method for req_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/req_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_req_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_req_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for LS request.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """req_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__req_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_req_nbr_low_cnt(self):
    self.__req_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_req_empty_cnt(self):
    """
    Getter method for req_empty_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/req_empty_cnt (uint32)

    YANG Description: Empty request.
    """
    return self.__req_empty_cnt
      
  def _set_req_empty_cnt(self, v, load=False):
    """
    Setter method for req_empty_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/req_empty_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_req_empty_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_req_empty_cnt() directly.

    YANG Description: Empty request.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """req_empty_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__req_empty_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_req_empty_cnt(self):
    self.__req_empty_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-empty-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_req_bad_cnt(self):
    """
    Getter method for req_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/req_bad_cnt (uint32)

    YANG Description: Bad request.
    """
    return self.__req_bad_cnt
      
  def _set_req_bad_cnt(self, v, load=False):
    """
    Setter method for req_bad_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/req_bad_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_req_bad_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_req_bad_cnt() directly.

    YANG Description: Bad request.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """req_bad_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__req_bad_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_req_bad_cnt(self):
    self.__req_bad_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="req-bad-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_nbr_low_cnt(self):
    """
    Getter method for upd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_nbr_low_cnt (uint32)

    YANG Description: Neighbour state low for LS update.
    """
    return self.__upd_nbr_low_cnt
      
  def _set_upd_nbr_low_cnt(self, v, load=False):
    """
    Setter method for upd_nbr_low_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_nbr_low_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_nbr_low_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_nbr_low_cnt() directly.

    YANG Description: Neighbour state low for LS update.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_nbr_low_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_nbr_low_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_nbr_low_cnt(self):
    self.__upd_nbr_low_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-nbr-low-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_self_newr_cnt(self):
    """
    Getter method for upd_self_newr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_self_newr_cnt (uint32)

    YANG Description: Newer self generate LSA.
    """
    return self.__upd_self_newr_cnt
      
  def _set_upd_self_newr_cnt(self, v, load=False):
    """
    Setter method for upd_self_newr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_self_newr_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_self_newr_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_self_newr_cnt() directly.

    YANG Description: Newer self generate LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_self_newr_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_self_newr_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_self_newr_cnt(self):
    self.__upd_self_newr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-self-newr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_min_lsa_lsarr_cnt(self):
    """
    Getter method for upd_min_lsa_lsarr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_min_lsa_lsarr_cnt (uint32)

    YANG Description: Received LSA within LSA arrival interval.
    """
    return self.__upd_min_lsa_lsarr_cnt
      
  def _set_upd_min_lsa_lsarr_cnt(self, v, load=False):
    """
    Setter method for upd_min_lsa_lsarr_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_min_lsa_lsarr_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_min_lsa_lsarr_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_min_lsa_lsarr_cnt() directly.

    YANG Description: Received LSA within LSA arrival interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsa-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_min_lsa_lsarr_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsa-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_min_lsa_lsarr_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_min_lsa_lsarr_cnt(self):
    self.__upd_min_lsa_lsarr_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-min-lsa-lsarr-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_ls_checksum_cnt(self):
    """
    Getter method for upd_ls_checksum_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_ls_checksum_cnt (uint32)

    YANG Description: LSA checksum bad.
    """
    return self.__upd_ls_checksum_cnt
      
  def _set_upd_ls_checksum_cnt(self, v, load=False):
    """
    Setter method for upd_ls_checksum_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_ls_checksum_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_ls_checksum_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_ls_checksum_cnt() directly.

    YANG Description: LSA checksum bad.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-checksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_ls_checksum_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-checksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_ls_checksum_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_ls_checksum_cnt(self):
    self.__upd_ls_checksum_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-ls-checksum-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_les_recent_cnt(self):
    """
    Getter method for upd_les_recent_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_les_recent_cnt (uint32)

    YANG Description: Received less recent LSA.
    """
    return self.__upd_les_recent_cnt
      
  def _set_upd_les_recent_cnt(self, v, load=False):
    """
    Setter method for upd_les_recent_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_les_recent_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_les_recent_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_les_recent_cnt() directly.

    YANG Description: Received less recent LSA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_les_recent_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_les_recent_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_les_recent_cnt(self):
    self.__upd_les_recent_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-les-recent-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_upd_unknow_lsa_cnt(self):
    """
    Getter method for upd_unknow_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_unknow_lsa_cnt (uint32)

    YANG Description: LSUpdate packet unknown LSA type.
    """
    return self.__upd_unknow_lsa_cnt
      
  def _set_upd_unknow_lsa_cnt(self, v, load=False):
    """
    Setter method for upd_unknow_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/upd_unknow_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upd_unknow_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upd_unknow_lsa_cnt() directly.

    YANG Description: LSUpdate packet unknown LSA type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknow-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upd_unknow_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknow-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__upd_unknow_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upd_unknow_lsa_cnt(self):
    self.__upd_unknow_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="upd-unknow-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opq9_flood_cnt(self):
    """
    Getter method for opq9_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/opq9_flood_cnt (uint32)

    YANG Description: Opq9 of flooding scope.
    """
    return self.__opq9_flood_cnt
      
  def _set_opq9_flood_cnt(self, v, load=False):
    """
    Setter method for opq9_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/opq9_flood_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opq9_flood_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opq9_flood_cnt() directly.

    YANG Description: Opq9 of flooding scope.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opq9_flood_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opq9_flood_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opq9_flood_cnt(self):
    self.__opq9_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq9-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opq10_flood_cnt(self):
    """
    Getter method for opq10_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/opq10_flood_cnt (uint32)

    YANG Description: Opq10 of flooding scope.
    """
    return self.__opq10_flood_cnt
      
  def _set_opq10_flood_cnt(self, v, load=False):
    """
    Setter method for opq10_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/opq10_flood_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opq10_flood_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opq10_flood_cnt() directly.

    YANG Description: Opq10 of flooding scope.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opq10_flood_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opq10_flood_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opq10_flood_cnt(self):
    self.__opq10_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq10-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_opq11_flood_cnt(self):
    """
    Getter method for opq11_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/opq11_flood_cnt (uint32)

    YANG Description: Opq11 of flooding scope.
    """
    return self.__opq11_flood_cnt
      
  def _set_opq11_flood_cnt(self, v, load=False):
    """
    Setter method for opq11_flood_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/opq11_flood_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opq11_flood_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opq11_flood_cnt() directly.

    YANG Description: Opq11 of flooding scope.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opq11_flood_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opq11_flood_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opq11_flood_cnt(self):
    self.__opq11_flood_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opq11-flood-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_unknown_tlv(self):
    """
    Getter method for unknown_tlv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/unknown_tlv (uint32)

    YANG Description: Unknown TLV type.
    """
    return self.__unknown_tlv
      
  def _set_unknown_tlv(self, v, load=False):
    """
    Setter method for unknown_tlv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/unknown_tlv (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_tlv() directly.

    YANG Description: Unknown TLV type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_tlv must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__unknown_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_tlv(self):
    self.__unknown_tlv = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unknown-tlv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_rxmt_dd_err_cnt(self):
    """
    Getter method for rxmt_dd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/rxmt_dd_err_cnt (uint32)

    YANG Description: Number for DD packet.
    """
    return self.__rxmt_dd_err_cnt
      
  def _set_rxmt_dd_err_cnt(self, v, load=False):
    """
    Setter method for rxmt_dd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/rxmt_dd_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxmt_dd_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxmt_dd_err_cnt() directly.

    YANG Description: Number for DD packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxmt_dd_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__rxmt_dd_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxmt_dd_err_cnt(self):
    self.__rxmt_dd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-dd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_rxmt_req_err_cnt(self):
    """
    Getter method for rxmt_req_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/rxmt_req_err_cnt (uint32)

    YANG Description: Number for request packet.
    """
    return self.__rxmt_req_err_cnt
      
  def _set_rxmt_req_err_cnt(self, v, load=False):
    """
    Setter method for rxmt_req_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/rxmt_req_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxmt_req_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxmt_req_err_cnt() directly.

    YANG Description: Number for request packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxmt_req_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__rxmt_req_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxmt_req_err_cnt(self):
    self.__rxmt_req_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-req-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_rxmt_upd_err_cnt(self):
    """
    Getter method for rxmt_upd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/rxmt_upd_err_cnt (uint32)

    YANG Description: Number for update packet.
    """
    return self.__rxmt_upd_err_cnt
      
  def _set_rxmt_upd_err_cnt(self, v, load=False):
    """
    Setter method for rxmt_upd_err_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/rxmt_upd_err_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rxmt_upd_err_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rxmt_upd_err_cnt() directly.

    YANG Description: Number for update packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rxmt_upd_err_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__rxmt_upd_err_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rxmt_upd_err_cnt(self):
    self.__rxmt_upd_err_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="rxmt-upd-err-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_gr_invalid_lsa_cnt(self):
    """
    Getter method for gr_invalid_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/gr_invalid_lsa_cnt (uint32)

    YANG Description: Number of invalid LSAs.
    """
    return self.__gr_invalid_lsa_cnt
      
  def _set_gr_invalid_lsa_cnt(self, v, load=False):
    """
    Setter method for gr_invalid_lsa_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/gr_invalid_lsa_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_invalid_lsa_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_invalid_lsa_cnt() directly.

    YANG Description: Number of invalid LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_invalid_lsa_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__gr_invalid_lsa_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_invalid_lsa_cnt(self):
    self.__gr_invalid_lsa_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-lsa-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_gr_invalid_pol_cnt(self):
    """
    Getter method for gr_invalid_pol_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/gr_invalid_pol_cnt (uint32)

    YANG Description: Number of policy failed LSAs.
    """
    return self.__gr_invalid_pol_cnt
      
  def _set_gr_invalid_pol_cnt(self, v, load=False):
    """
    Setter method for gr_invalid_pol_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/gr_invalid_pol_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_invalid_pol_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_invalid_pol_cnt() directly.

    YANG Description: Number of policy failed LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_invalid_pol_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__gr_invalid_pol_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_invalid_pol_cnt(self):
    self.__gr_invalid_pol_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-pol-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_gr_invalid_prd_cnt(self):
    """
    Getter method for gr_invalid_prd_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/gr_invalid_prd_cnt (uint32)

    YANG Description: Number of wrong period LSAs.
    """
    return self.__gr_invalid_prd_cnt
      
  def _set_gr_invalid_prd_cnt(self, v, load=False):
    """
    Setter method for gr_invalid_prd_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/gr_invalid_prd_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_invalid_prd_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_invalid_prd_cnt() directly.

    YANG Description: Number of wrong period LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_invalid_prd_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__gr_invalid_prd_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_invalid_prd_cnt(self):
    self.__gr_invalid_prd_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="gr-invalid-prd-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_tunnel_cost_cnt(self):
    """
    Getter method for tunnel_cost_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/tunnel_cost_cnt (uint32)

    YANG Description: Tunnel cost mistake.
    """
    return self.__tunnel_cost_cnt
      
  def _set_tunnel_cost_cnt(self, v, load=False):
    """
    Setter method for tunnel_cost_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/tunnel_cost_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_cost_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_cost_cnt() directly.

    YANG Description: Tunnel cost mistake.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_cost_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tunnel_cost_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_cost_cnt(self):
    self.__tunnel_cost_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-cost-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_peer_net_type_cnt(self):
    """
    Getter method for peer_net_type_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/peer_net_type_cnt (uint32)

    YANG Description: The network type of the neighbor interface is not consistent.
    """
    return self.__peer_net_type_cnt
      
  def _set_peer_net_type_cnt(self, v, load=False):
    """
    Setter method for peer_net_type_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/peer_net_type_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_net_type_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_net_type_cnt() directly.

    YANG Description: The network type of the neighbor interface is not consistent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_net_type_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__peer_net_type_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_net_type_cnt(self):
    self.__peer_net_type_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-net-type-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_hello_dr_mis_cnt(self):
    """
    Getter method for hello_dr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/hello_dr_mis_cnt (uint32)

    YANG Description: The DR or BDR in receiving hello packet is not same with the DR or BDR.
    """
    return self.__hello_dr_mis_cnt
      
  def _set_hello_dr_mis_cnt(self, v, load=False):
    """
    Setter method for hello_dr_mis_cnt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data/hello_dr_mis_cnt (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_dr_mis_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_dr_mis_cnt() directly.

    YANG Description: The DR or BDR in receiving hello packet is not same with the DR or BDR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_dr_mis_cnt must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__hello_dr_mis_cnt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_dr_mis_cnt(self):
    self.__hello_dr_mis_cnt = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-dr-mis-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  same_ip_pkt_cnt = __builtin__.property(_get_same_ip_pkt_cnt)
  bad_pkt_cnt = __builtin__.property(_get_bad_pkt_cnt)
  bad_ver_cnt = __builtin__.property(_get_bad_ver_cnt)
  bad_chk_sum_pkt_cnt = __builtin__.property(_get_bad_chk_sum_pkt_cnt)
  bad_area_pkt_cnt = __builtin__.property(_get_bad_area_pkt_cnt)
  pkt_rcv_unnumber = __builtin__.property(_get_pkt_rcv_unnumber)
  bad_virt_link_cnt = __builtin__.property(_get_bad_virt_link_cnt)
  auth_type_fail_cnt = __builtin__.property(_get_auth_type_fail_cnt)
  auth_key_fail_cnt = __builtin__.property(_get_auth_key_fail_cnt)
  short_pkt_cnt = __builtin__.property(_get_short_pkt_cnt)
  long_pkt_cnt = __builtin__.property(_get_long_pkt_cnt)
  tx_err_cnt = __builtin__.property(_get_tx_err_cnt)
  if_down_cnt = __builtin__.property(_get_if_down_cnt)
  no_nbr = __builtin__.property(_get_no_nbr)
  mis_netmask_cnt = __builtin__.property(_get_mis_netmask_cnt)
  mis_hello_intl_cnt = __builtin__.property(_get_mis_hello_intl_cnt)
  mis_dead_intl_cnt = __builtin__.property(_get_mis_dead_intl_cnt)
  mis_ext_rou_cap_cnt = __builtin__.property(_get_mis_ext_rou_cap_cnt)
  router_id_confusion = __builtin__.property(_get_router_id_confusion)
  vlink_nbr_mis_cnt = __builtin__.property(_get_vlink_nbr_mis_cnt)
  nbma_nbr_err_cnt = __builtin__.property(_get_nbma_nbr_err_cnt)
  inval_src_helo_cnt = __builtin__.property(_get_inval_src_helo_cnt)
  dd_nbr_low_cnt = __builtin__.property(_get_dd_nbr_low_cnt)
  dd_router_id_cnt = __builtin__.property(_get_dd_router_id_cnt)
  dd_opt_mismatch_cnt = __builtin__.property(_get_dd_opt_mismatch_cnt)
  dd_unknwn_lsa_cnt = __builtin__.property(_get_dd_unknwn_lsa_cnt)
  dd_mtu_mismatch_cnt = __builtin__.property(_get_dd_mtu_mismatch_cnt)
  ack_nbr_low_cnt = __builtin__.property(_get_ack_nbr_low_cnt)
  ack_bad_cnt = __builtin__.property(_get_ack_bad_cnt)
  ack_duplicate_cnt = __builtin__.property(_get_ack_duplicate_cnt)
  ack_unknown_lsa_cnt = __builtin__.property(_get_ack_unknown_lsa_cnt)
  req_nbr_low_cnt = __builtin__.property(_get_req_nbr_low_cnt)
  req_empty_cnt = __builtin__.property(_get_req_empty_cnt)
  req_bad_cnt = __builtin__.property(_get_req_bad_cnt)
  upd_nbr_low_cnt = __builtin__.property(_get_upd_nbr_low_cnt)
  upd_self_newr_cnt = __builtin__.property(_get_upd_self_newr_cnt)
  upd_min_lsa_lsarr_cnt = __builtin__.property(_get_upd_min_lsa_lsarr_cnt)
  upd_ls_checksum_cnt = __builtin__.property(_get_upd_ls_checksum_cnt)
  upd_les_recent_cnt = __builtin__.property(_get_upd_les_recent_cnt)
  upd_unknow_lsa_cnt = __builtin__.property(_get_upd_unknow_lsa_cnt)
  opq9_flood_cnt = __builtin__.property(_get_opq9_flood_cnt)
  opq10_flood_cnt = __builtin__.property(_get_opq10_flood_cnt)
  opq11_flood_cnt = __builtin__.property(_get_opq11_flood_cnt)
  unknown_tlv = __builtin__.property(_get_unknown_tlv)
  rxmt_dd_err_cnt = __builtin__.property(_get_rxmt_dd_err_cnt)
  rxmt_req_err_cnt = __builtin__.property(_get_rxmt_req_err_cnt)
  rxmt_upd_err_cnt = __builtin__.property(_get_rxmt_upd_err_cnt)
  gr_invalid_lsa_cnt = __builtin__.property(_get_gr_invalid_lsa_cnt)
  gr_invalid_pol_cnt = __builtin__.property(_get_gr_invalid_pol_cnt)
  gr_invalid_prd_cnt = __builtin__.property(_get_gr_invalid_prd_cnt)
  tunnel_cost_cnt = __builtin__.property(_get_tunnel_cost_cnt)
  peer_net_type_cnt = __builtin__.property(_get_peer_net_type_cnt)
  hello_dr_mis_cnt = __builtin__.property(_get_hello_dr_mis_cnt)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('same_ip_pkt_cnt', same_ip_pkt_cnt), ('bad_pkt_cnt', bad_pkt_cnt), ('bad_ver_cnt', bad_ver_cnt), ('bad_chk_sum_pkt_cnt', bad_chk_sum_pkt_cnt), ('bad_area_pkt_cnt', bad_area_pkt_cnt), ('pkt_rcv_unnumber', pkt_rcv_unnumber), ('bad_virt_link_cnt', bad_virt_link_cnt), ('auth_type_fail_cnt', auth_type_fail_cnt), ('auth_key_fail_cnt', auth_key_fail_cnt), ('short_pkt_cnt', short_pkt_cnt), ('long_pkt_cnt', long_pkt_cnt), ('tx_err_cnt', tx_err_cnt), ('if_down_cnt', if_down_cnt), ('no_nbr', no_nbr), ('mis_netmask_cnt', mis_netmask_cnt), ('mis_hello_intl_cnt', mis_hello_intl_cnt), ('mis_dead_intl_cnt', mis_dead_intl_cnt), ('mis_ext_rou_cap_cnt', mis_ext_rou_cap_cnt), ('router_id_confusion', router_id_confusion), ('vlink_nbr_mis_cnt', vlink_nbr_mis_cnt), ('nbma_nbr_err_cnt', nbma_nbr_err_cnt), ('inval_src_helo_cnt', inval_src_helo_cnt), ('dd_nbr_low_cnt', dd_nbr_low_cnt), ('dd_router_id_cnt', dd_router_id_cnt), ('dd_opt_mismatch_cnt', dd_opt_mismatch_cnt), ('dd_unknwn_lsa_cnt', dd_unknwn_lsa_cnt), ('dd_mtu_mismatch_cnt', dd_mtu_mismatch_cnt), ('ack_nbr_low_cnt', ack_nbr_low_cnt), ('ack_bad_cnt', ack_bad_cnt), ('ack_duplicate_cnt', ack_duplicate_cnt), ('ack_unknown_lsa_cnt', ack_unknown_lsa_cnt), ('req_nbr_low_cnt', req_nbr_low_cnt), ('req_empty_cnt', req_empty_cnt), ('req_bad_cnt', req_bad_cnt), ('upd_nbr_low_cnt', upd_nbr_low_cnt), ('upd_self_newr_cnt', upd_self_newr_cnt), ('upd_min_lsa_lsarr_cnt', upd_min_lsa_lsarr_cnt), ('upd_ls_checksum_cnt', upd_ls_checksum_cnt), ('upd_les_recent_cnt', upd_les_recent_cnt), ('upd_unknow_lsa_cnt', upd_unknow_lsa_cnt), ('opq9_flood_cnt', opq9_flood_cnt), ('opq10_flood_cnt', opq10_flood_cnt), ('opq11_flood_cnt', opq11_flood_cnt), ('unknown_tlv', unknown_tlv), ('rxmt_dd_err_cnt', rxmt_dd_err_cnt), ('rxmt_req_err_cnt', rxmt_req_err_cnt), ('rxmt_upd_err_cnt', rxmt_upd_err_cnt), ('gr_invalid_lsa_cnt', gr_invalid_lsa_cnt), ('gr_invalid_pol_cnt', gr_invalid_pol_cnt), ('gr_invalid_prd_cnt', gr_invalid_prd_cnt), ('tunnel_cost_cnt', tunnel_cost_cnt), ('peer_net_type_cnt', peer_net_type_cnt), ('hello_dr_mis_cnt', hello_dr_mis_cnt), ])


class yc_as_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_as_lsdb_brief(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/as-lsdb-brief. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of AS LSDB statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__opaque11','__ase','__sub_total',)

  _yang_name = 'as-lsdb-brief'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__opaque11 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque11", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__ase = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__sub_total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'as-lsdb-brief']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/router_id (inet:ipv4-address-no-zone)

    YANG Description: ID of the local router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: ID of the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_opaque11(self):
    """
    Getter method for opaque11, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/opaque11 (uint32)

    YANG Description: Number of Type11 opaque LSAs.
    """
    return self.__opaque11
      
  def _set_opaque11(self, v, load=False):
    """
    Setter method for opaque11, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/opaque11 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque11 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque11() directly.

    YANG Description: Number of Type11 opaque LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque11", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque11 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque11", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__opaque11 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque11(self):
    self.__opaque11 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="opaque11", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_ase(self):
    """
    Getter method for ase, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/ase (uint32)

    YANG Description: Number of ASE LSAs.
    """
    return self.__ase
      
  def _set_ase(self, v, load=False):
    """
    Setter method for ase, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/ase (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ase() directly.

    YANG Description: Number of ASE LSAs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ase must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__ase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ase(self):
    self.__ase = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_sub_total(self):
    """
    Getter method for sub_total, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/sub_total (uint32)

    YANG Description: Sub type sum.
    """
    return self.__sub_total
      
  def _set_sub_total(self, v, load=False):
    """
    Setter method for sub_total, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief/sub_total (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_total() directly.

    YANG Description: Sub type sum.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_total must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__sub_total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_total(self):
    self.__sub_total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-total", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  opaque11 = __builtin__.property(_get_opaque11)
  ase = __builtin__.property(_get_ase)
  sub_total = __builtin__.property(_get_sub_total)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('opaque11', opaque11), ('ase', ase), ('sub_total', sub_total), ])


class yc_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of neighbor data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__if_ip','__gr_state','__mode','__priority','__dr','__bdr','__if_mtu','__dead_due_timer','__retran_interval','__up_time','__up_time_stamp','__auth_sequence',)

  _yang_name = 'data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__if_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__gr_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    self.__dr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__bdr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__if_mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__dead_due_timer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__retran_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__up_time_stamp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)
    self.__auth_sequence = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'neighbors', 'neighbor', 'datas', 'data']

  def _get_if_ip(self):
    """
    Getter method for if_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/if_ip (inet:ipv4-address-no-zone)

    YANG Description: Neighbor interface IP address.
    """
    return self.__if_ip
      
  def _set_if_ip(self, v, load=False):
    """
    Setter method for if_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/if_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_ip() directly.

    YANG Description: Neighbor interface IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__if_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_ip(self):
    self.__if_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="if-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_gr_state(self):
    """
    Getter method for gr_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/gr_state (nbr-gr-state)

    YANG Description: Neighbor GR state.
    """
    return self.__gr_state
      
  def _set_gr_state(self, v, load=False):
    """
    Setter method for gr_state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/gr_state (nbr-gr-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_state() directly.

    YANG Description: Neighbor GR state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_state must be of a type compatible with nbr-gr-state""",
          'defined-type': "huawei-ospfv2:nbr-gr-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)""",
        })

    self.__gr_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_state(self):
    self.__gr_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'normal': {'value': 0}, 'doing-gr': {'value': 1}, 'helper': {'value': 2}, 'none': {'value': 3}},), is_leaf=True, yang_name="gr-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-gr-state', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/mode (nbr-mode)

    YANG Description: Neighbor mode.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/mode (nbr-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Neighbor mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with nbr-mode""",
          'defined-type': "huawei-ospfv2:nbr-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slave': {'value': 0}, 'master': {'value': 1}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-mode', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/priority (int32)

    YANG Description: Neighbor priority.
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/priority (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Neighbor priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='int32', is_config=False)


  def _get_dr(self):
    """
    Getter method for dr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/dr (inet:ipv4-address-no-zone)

    YANG Description: Neighbor DR.
    """
    return self.__dr
      
  def _set_dr(self, v, load=False):
    """
    Setter method for dr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/dr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr() directly.

    YANG Description: Neighbor DR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__dr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr(self):
    self.__dr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_bdr(self):
    """
    Getter method for bdr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/bdr (inet:ipv4-address-no-zone)

    YANG Description: Neighbor BDR.
    """
    return self.__bdr
      
  def _set_bdr(self, v, load=False):
    """
    Setter method for bdr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/bdr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bdr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bdr() directly.

    YANG Description: Neighbor BDR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bdr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__bdr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bdr(self):
    self.__bdr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bdr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_if_mtu(self):
    """
    Getter method for if_mtu, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/if_mtu (uint32)

    YANG Description: Neighbor interface MTU.
    """
    return self.__if_mtu
      
  def _set_if_mtu(self, v, load=False):
    """
    Setter method for if_mtu, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/if_mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_mtu() directly.

    YANG Description: Neighbor interface MTU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__if_mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_mtu(self):
    self.__if_mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_dead_due_timer(self):
    """
    Getter method for dead_due_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/dead_due_timer (string)

    YANG Description: Neighbor dead due timer.
    """
    return self.__dead_due_timer
      
  def _set_dead_due_timer(self, v, load=False):
    """
    Setter method for dead_due_timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/dead_due_timer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dead_due_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dead_due_timer() directly.

    YANG Description: Neighbor dead due timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dead_due_timer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__dead_due_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dead_due_timer(self):
    self.__dead_due_timer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="dead-due-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_retran_interval(self):
    """
    Getter method for retran_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/retran_interval (uint32)

    YANG Description: Neighbor retransmit interval.
    """
    return self.__retran_interval
      
  def _set_retran_interval(self, v, load=False):
    """
    Setter method for retran_interval, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/retran_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retran_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retran_interval() directly.

    YANG Description: Neighbor retransmit interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retran_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__retran_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retran_interval(self):
    self.__retran_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="retran-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_up_time(self):
    """
    Getter method for up_time, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/up_time (string)

    YANG Description: Neighbor up time.
    """
    return self.__up_time
      
  def _set_up_time(self, v, load=False):
    """
    Setter method for up_time, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/up_time (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_time() directly.

    YANG Description: Neighbor up time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_time must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_time(self):
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..16']}), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_up_time_stamp(self):
    """
    Getter method for up_time_stamp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/up_time_stamp (yang:date-and-time)

    YANG Description: Neighbor up time stamp.
    """
    return self.__up_time_stamp
      
  def _set_up_time_stamp(self, v, load=False):
    """
    Setter method for up_time_stamp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/up_time_stamp (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_time_stamp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_time_stamp() directly.

    YANG Description: Neighbor up time stamp.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_time_stamp must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__up_time_stamp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_time_stamp(self):
    self.__up_time_stamp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="up-time-stamp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='yang:date-and-time', is_config=False)


  def _get_auth_sequence(self):
    """
    Getter method for auth_sequence, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/auth_sequence (uint32)

    YANG Description: Neighbor authentication sequence number.
    """
    return self.__auth_sequence
      
  def _set_auth_sequence(self, v, load=False):
    """
    Setter method for auth_sequence, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data/auth_sequence (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_sequence is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_sequence() directly.

    YANG Description: Neighbor authentication sequence number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_sequence must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__auth_sequence = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_sequence(self):
    self.__auth_sequence = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="auth-sequence", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)

  if_ip = __builtin__.property(_get_if_ip)
  gr_state = __builtin__.property(_get_gr_state)
  mode = __builtin__.property(_get_mode)
  priority = __builtin__.property(_get_priority)
  dr = __builtin__.property(_get_dr)
  bdr = __builtin__.property(_get_bdr)
  if_mtu = __builtin__.property(_get_if_mtu)
  dead_due_timer = __builtin__.property(_get_dead_due_timer)
  retran_interval = __builtin__.property(_get_retran_interval)
  up_time = __builtin__.property(_get_up_time)
  up_time_stamp = __builtin__.property(_get_up_time_stamp)
  auth_sequence = __builtin__.property(_get_auth_sequence)


  _pyangbind_elements = OrderedDict([('if_ip', if_ip), ('gr_state', gr_state), ('mode', mode), ('priority', priority), ('dr', dr), ('bdr', bdr), ('if_mtu', if_mtu), ('dead_due_timer', dead_due_timer), ('retran_interval', retran_interval), ('up_time', up_time), ('up_time_stamp', up_time_stamp), ('auth_sequence', auth_sequence), ])


class yc_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbor data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__data',)

  _yang_name = 'datas'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__data = YANGDynClass(base=YANGListType("if_ip",yc_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas_data, yang_name="data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-ip', extensions=None), is_container='list', yang_name="data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'neighbors', 'neighbor', 'datas']

  def _get_data(self):
    """
    Getter method for data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data (list)

    YANG Description: Statistics of neighbor data.
    """
    return self.__data
      
  def _set_data(self, v, load=False):
    """
    Setter method for data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas/data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data() directly.

    YANG Description: Statistics of neighbor data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("if_ip",yc_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas_data, yang_name="data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-ip', extensions=None), is_container='list', yang_name="data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("if_ip",yc_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas_data, yang_name="data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-ip', extensions=None), is_container='list', yang_name="data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data(self):
    self.__data = YANGDynClass(base=YANGListType("if_ip",yc_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas_data, yang_name="data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='if-ip', extensions=None), is_container='list', yang_name="data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  data = __builtin__.property(_get_data) # type: yc_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas_data


  _pyangbind_elements = OrderedDict([('data', data), ])


class yc_neighbor_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__area_id','__if_name','__router_id','__ip_addr','__multi_area_flag','__state','__host_name','__datas',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__multi_area_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multi-area-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)
    self.__host_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__datas = YANGDynClass(base=yc_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas, is_container='container', yang_name="datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'neighbors', 'neighbor']

  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/area_id (inet:ipv4-address-no-zone)

    YANG Description: Neighbor area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Neighbor area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/if_name (string)

    YANG Description: Neighbor interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Neighbor interface name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/router_id (inet:ipv4-address-no-zone)

    YANG Description: Neighbor router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Neighbor router ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_ip_addr(self):
    """
    Getter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/ip_addr (inet:ipv4-address-no-zone)

    YANG Description: Neighbor IP address.
    """
    return self.__ip_addr
      
  def _set_ip_addr(self, v, load=False):
    """
    Setter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/ip_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_addr() directly.

    YANG Description: Neighbor IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_addr(self):
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_multi_area_flag(self):
    """
    Getter method for multi_area_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/multi_area_flag (boolean)

    YANG Description: The symoble of multi area.
    """
    return self.__multi_area_flag
      
  def _set_multi_area_flag(self, v, load=False):
    """
    Setter method for multi_area_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/multi_area_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multi_area_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multi_area_flag() directly.

    YANG Description: The symoble of multi area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="multi-area-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multi_area_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multi-area-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)""",
        })

    self.__multi_area_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multi_area_flag(self):
    self.__multi_area_flag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="multi-area-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/state (nbr-state)

    YANG Description: Neighbor state.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/state (nbr-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Neighbor state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with nbr-state""",
          'defined-type': "huawei-ospfv2:nbr-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'init': {'value': 1}, 'attempt': {'value': 2}, '2-way': {'value': 3}, 'exstart': {'value': 4}, 'exchange': {'value': 5}, 'loading': {'value': 6}, 'full': {'value': 7}},), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='nbr-state', is_config=False)


  def _get_host_name(self):
    """
    Getter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/host_name (string)

    YANG Description: Neighbor host name.
    """
    return self.__host_name
      
  def _set_host_name(self, v, load=False):
    """
    Setter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/host_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_name() directly.

    YANG Description: Neighbor host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__host_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_name(self):
    self.__host_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..255']}), is_leaf=True, yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_datas(self):
    """
    Getter method for datas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas (container)

    YANG Description: List of neighbor data.
    """
    return self.__datas
      
  def _set_datas(self, v, load=False):
    """
    Setter method for datas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor/datas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_datas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_datas() directly.

    YANG Description: List of neighbor data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas, is_container='container', yang_name="datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """datas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas, is_container='container', yang_name="datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)""",
        })

    self.__datas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_datas(self):
    self.__datas = YANGDynClass(base=yc_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas, is_container='container', yang_name="datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

  area_id = __builtin__.property(_get_area_id)
  if_name = __builtin__.property(_get_if_name)
  router_id = __builtin__.property(_get_router_id)
  ip_addr = __builtin__.property(_get_ip_addr)
  multi_area_flag = __builtin__.property(_get_multi_area_flag)
  state = __builtin__.property(_get_state)
  host_name = __builtin__.property(_get_host_name)
  datas = __builtin__.property(_get_datas) # type: yc_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor_datas


  _pyangbind_elements = OrderedDict([('area_id', area_id), ('if_name', if_name), ('router_id', router_id), ('ip_addr', ip_addr), ('multi_area_flag', multi_area_flag), ('state', state), ('host_name', host_name), ('datas', datas), ])


class yc_neighbors_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("area_id if_name router_id ip_addr",yc_neighbor_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id if-name router-id ip-addr', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor (list)

    YANG Description: Statistics of neighbor.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: Statistics of neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("area_id if_name router_id ip_addr",yc_neighbor_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id if-name router-id ip-addr', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("area_id if_name router_id ip_addr",yc_neighbor_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id if-name router-id ip-addr', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("area_id if_name router_id ip_addr",yc_neighbor_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='area-id if-name router-id ip-addr', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  neighbor = __builtin__.property(_get_neighbor) # type: yc_neighbor_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors_neighbor


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas_nexthop_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop-datas/nexthop-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of nexthop data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_addr','__adv_router_id','__area_id','__if_name','__flags_disp','__tag','__bak_if_name','__bak_next_ip','__backup_type','__tunnel_dest','__tunnel_type',)

  _yang_name = 'nexthop-data'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__adv_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__flags_disp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__bak_if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="bak-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    self.__bak_next_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bak-next-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__backup_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lfa-link': {'value': 1}, 'lfa-link-node': {'value': 2}, 'remote-lfa-link': {'value': 5}, 'remote-lfa-link-node': {'value': 6}, 'tilfa-link': {'value': 7}, 'tilfa-link-node': {'value': 8}},), is_leaf=True, yang_name="backup-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='backup-type', is_config=False)
    self.__tunnel_dest = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__tunnel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='tunnel-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'routings', 'routing', 'nexthop-datas', 'nexthop-data']

  def _get_ip_addr(self):
    """
    Getter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/ip_addr (inet:ipv4-address-no-zone)

    YANG Description: Nexthop IP address.
    """
    return self.__ip_addr
      
  def _set_ip_addr(self, v, load=False):
    """
    Setter method for ip_addr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/ip_addr (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_addr() directly.

    YANG Description: Nexthop IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_addr must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_addr(self):
    self.__ip_addr = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_adv_router_id(self):
    """
    Getter method for adv_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/adv_router_id (inet:ipv4-address-no-zone)

    YANG Description: Next hop advertising router ID.
    """
    return self.__adv_router_id
      
  def _set_adv_router_id(self, v, load=False):
    """
    Setter method for adv_router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/adv_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adv_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adv_router_id() directly.

    YANG Description: Next hop advertising router ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adv_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__adv_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adv_router_id(self):
    self.__adv_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="adv-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_area_id(self):
    """
    Getter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/area_id (inet:ipv4-address-no-zone)

    YANG Description: Next hop area ID.
    """
    return self.__area_id
      
  def _set_area_id(self, v, load=False):
    """
    Setter method for area_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/area_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_id() directly.

    YANG Description: Next hop area ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__area_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_id(self):
    self.__area_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="area-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_if_name(self):
    """
    Getter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/if_name (string)

    YANG Description: Next hop outgoing interface name.
    """
    return self.__if_name
      
  def _set_if_name(self, v, load=False):
    """
    Setter method for if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_name() directly.

    YANG Description: Next hop outgoing interface name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_name(self):
    self.__if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_flags_disp(self):
    """
    Getter method for flags_disp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/flags_disp (string)

    YANG Description: Next hop flags.
    """
    return self.__flags_disp
      
  def _set_flags_disp(self, v, load=False):
    """
    Setter method for flags_disp, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/flags_disp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flags_disp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flags_disp() directly.

    YANG Description: Next hop flags.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flags_disp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__flags_disp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flags_disp(self):
    self.__flags_disp = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..8']}), is_leaf=True, yang_name="flags-disp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/tag (uint32)

    YANG Description: Next hop tag.
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/tag (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Next hop tag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_bak_if_name(self):
    """
    Getter method for bak_if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/bak_if_name (string)

    YANG Description: Backup outgoing interface name.
    """
    return self.__bak_if_name
      
  def _set_bak_if_name(self, v, load=False):
    """
    Setter method for bak_if_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/bak_if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bak_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bak_if_name() directly.

    YANG Description: Backup outgoing interface name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="bak-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bak_if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="bak-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)""",
        })

    self.__bak_if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bak_if_name(self):
    self.__bak_if_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..64']}), is_leaf=True, yang_name="bak-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=False)


  def _get_bak_next_ip(self):
    """
    Getter method for bak_next_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/bak_next_ip (inet:ipv4-address-no-zone)

    YANG Description: Backup nexthop IP address.
    """
    return self.__bak_next_ip
      
  def _set_bak_next_ip(self, v, load=False):
    """
    Setter method for bak_next_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/bak_next_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bak_next_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bak_next_ip() directly.

    YANG Description: Backup nexthop IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bak-next-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bak_next_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bak-next-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__bak_next_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bak_next_ip(self):
    self.__bak_next_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="bak-next-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_backup_type(self):
    """
    Getter method for backup_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/backup_type (backup-type)

    YANG Description: Type of backup.
    """
    return self.__backup_type
      
  def _set_backup_type(self, v, load=False):
    """
    Setter method for backup_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/backup_type (backup-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup_type() directly.

    YANG Description: Type of backup.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lfa-link': {'value': 1}, 'lfa-link-node': {'value': 2}, 'remote-lfa-link': {'value': 5}, 'remote-lfa-link-node': {'value': 6}, 'tilfa-link': {'value': 7}, 'tilfa-link-node': {'value': 8}},), is_leaf=True, yang_name="backup-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='backup-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup_type must be of a type compatible with backup-type""",
          'defined-type': "huawei-ospfv2:backup-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lfa-link': {'value': 1}, 'lfa-link-node': {'value': 2}, 'remote-lfa-link': {'value': 5}, 'remote-lfa-link-node': {'value': 6}, 'tilfa-link': {'value': 7}, 'tilfa-link-node': {'value': 8}},), is_leaf=True, yang_name="backup-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='backup-type', is_config=False)""",
        })

    self.__backup_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup_type(self):
    self.__backup_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lfa-link': {'value': 1}, 'lfa-link-node': {'value': 2}, 'remote-lfa-link': {'value': 5}, 'remote-lfa-link-node': {'value': 6}, 'tilfa-link': {'value': 7}, 'tilfa-link-node': {'value': 8}},), is_leaf=True, yang_name="backup-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='backup-type', is_config=False)


  def _get_tunnel_dest(self):
    """
    Getter method for tunnel_dest, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/tunnel_dest (inet:ipv4-address-no-zone)

    YANG Description: Tunnel destination.
    """
    return self.__tunnel_dest
      
  def _set_tunnel_dest(self, v, load=False):
    """
    Setter method for tunnel_dest, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/tunnel_dest (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_dest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_dest() directly.

    YANG Description: Tunnel destination.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_dest must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__tunnel_dest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_dest(self):
    self.__tunnel_dest = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="tunnel-dest", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_tunnel_type(self):
    """
    Getter method for tunnel_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/tunnel_type (tunnel-type)

    YANG Description: Type of tunnel.
    """
    return self.__tunnel_type
      
  def _set_tunnel_type(self, v, load=False):
    """
    Setter method for tunnel_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data/tunnel_type (tunnel-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_type() directly.

    YANG Description: Type of tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='tunnel-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_type must be of a type compatible with tunnel-type""",
          'defined-type': "huawei-ospfv2:tunnel-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='tunnel-type', is_config=False)""",
        })

    self.__tunnel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_type(self):
    self.__tunnel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='tunnel-type', is_config=False)

  ip_addr = __builtin__.property(_get_ip_addr)
  adv_router_id = __builtin__.property(_get_adv_router_id)
  area_id = __builtin__.property(_get_area_id)
  if_name = __builtin__.property(_get_if_name)
  flags_disp = __builtin__.property(_get_flags_disp)
  tag = __builtin__.property(_get_tag)
  bak_if_name = __builtin__.property(_get_bak_if_name)
  bak_next_ip = __builtin__.property(_get_bak_next_ip)
  backup_type = __builtin__.property(_get_backup_type)
  tunnel_dest = __builtin__.property(_get_tunnel_dest)
  tunnel_type = __builtin__.property(_get_tunnel_type)


  _pyangbind_elements = OrderedDict([('ip_addr', ip_addr), ('adv_router_id', adv_router_id), ('area_id', area_id), ('if_name', if_name), ('flags_disp', flags_disp), ('tag', tag), ('bak_if_name', bak_if_name), ('bak_next_ip', bak_next_ip), ('backup_type', backup_type), ('tunnel_dest', tunnel_dest), ('tunnel_type', tunnel_type), ])


class yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop-datas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of nexthop data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nexthop_data',)

  _yang_name = 'nexthop-datas'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nexthop_data = YANGDynClass(base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'routings', 'routing', 'nexthop-datas']

  def _get_nexthop_data(self):
    """
    Getter method for nexthop_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data (list)

    YANG Description: Statistics of nexthop data.
    """
    return self.__nexthop_data
      
  def _set_nexthop_data(self, v, load=False):
    """
    Setter method for nexthop_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas/nexthop_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_data() directly.

    YANG Description: Statistics of nexthop data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_data must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__nexthop_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_data(self):
    self.__nexthop_data = YANGDynClass(base=YANGListType("ip_addr adv_router_id area_id",yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas_nexthop_data, yang_name="nexthop-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-addr adv-router-id area-id', extensions=None), is_container='list', yang_name="nexthop-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  nexthop_data = __builtin__.property(_get_nexthop_data) # type: yc_nexthop_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas_nexthop_data


  _pyangbind_elements = OrderedDict([('nexthop_data', nexthop_data), ])


class yc_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/routings/routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of the OSPF routing table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dest_ip','__mask_length','__path_type','__cost','__prefix_priority','__nexthop_datas',)

  _yang_name = 'routing'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dest_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__path_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    self.__prefix_priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)
    self.__nexthop_datas = YANGDynClass(base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'routings', 'routing']

  def _get_dest_ip(self):
    """
    Getter method for dest_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/dest_ip (inet:ipv4-address-no-zone)

    YANG Description: Destination IP address.
    """
    return self.__dest_ip
      
  def _set_dest_ip(self, v, load=False):
    """
    Setter method for dest_ip, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/dest_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_ip() directly.

    YANG Description: Destination IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__dest_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_ip(self):
    self.__dest_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="dest-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_mask_length(self):
    """
    Getter method for mask_length, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/mask_length (uint32)

    YANG Description: Mask length.
    """
    return self.__mask_length
      
  def _set_mask_length(self, v, load=False):
    """
    Setter method for mask_length, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/mask_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask_length() directly.

    YANG Description: Mask length.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__mask_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask_length(self):
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_path_type(self):
    """
    Getter method for path_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/path_type (path-type)

    YANG Description: Route type.
    """
    return self.__path_type
      
  def _set_path_type(self, v, load=False):
    """
    Setter method for path_type, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/path_type (path-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_type() directly.

    YANG Description: Route type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_type must be of a type compatible with path-type""",
          'defined-type': "huawei-ospfv2:path-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)""",
        })

    self.__path_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_type(self):
    self.__path_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'unknow': {'value': 0}, 'intra-area': {'value': 1}, 'transit': {'value': 2}, 'stub': {'value': 3}, 'inter-area': {'value': 4}, 'direct': {'value': 5}, 'type1': {'value': 6}, 'type2': {'value': 7}},), is_leaf=True, yang_name="path-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='path-type', is_config=False)


  def _get_cost(self):
    """
    Getter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/cost (uint32)

    YANG Description: Cost to the destination address.
    """
    return self.__cost
      
  def _set_cost(self, v, load=False):
    """
    Setter method for cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost() directly.

    YANG Description: Cost to the destination address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)""",
        })

    self.__cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost(self):
    self.__cost = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=False)


  def _get_prefix_priority(self):
    """
    Getter method for prefix_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/prefix_priority (pre-priority)

    YANG Description: Prefix priority.
    """
    return self.__prefix_priority
      
  def _set_prefix_priority(self, v, load=False):
    """
    Setter method for prefix_priority, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/prefix_priority (pre-priority)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_priority() directly.

    YANG Description: Prefix priority.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_priority must be of a type compatible with pre-priority""",
          'defined-type': "huawei-ospfv2:pre-priority",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)""",
        })

    self.__prefix_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_priority(self):
    self.__prefix_priority = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'critical': {'value': 0}, 'high': {'value': 1}, 'medium': {'value': 2}, 'low': {'value': 3}},), is_leaf=True, yang_name="prefix-priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='pre-priority', is_config=False)


  def _get_nexthop_datas(self):
    """
    Getter method for nexthop_datas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas (container)

    YANG Description: List of nexthop data.
    """
    return self.__nexthop_datas
      
  def _set_nexthop_datas(self, v, load=False):
    """
    Setter method for nexthop_datas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing/nexthop_datas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_datas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_datas() directly.

    YANG Description: List of nexthop data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_datas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)""",
        })

    self.__nexthop_datas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_datas(self):
    self.__nexthop_datas = YANGDynClass(base=yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas, is_container='container', yang_name="nexthop-datas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=False)

  dest_ip = __builtin__.property(_get_dest_ip)
  mask_length = __builtin__.property(_get_mask_length)
  path_type = __builtin__.property(_get_path_type)
  cost = __builtin__.property(_get_cost)
  prefix_priority = __builtin__.property(_get_prefix_priority)
  nexthop_datas = __builtin__.property(_get_nexthop_datas) # type: yc_nexthop_datas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing_nexthop_datas


  _pyangbind_elements = OrderedDict([('dest_ip', dest_ip), ('mask_length', mask_length), ('path_type', path_type), ('cost', cost), ('prefix_priority', prefix_priority), ('nexthop_datas', nexthop_datas), ])


class yc_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site/routings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of the OSPF routing table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing',)

  _yang_name = 'routings'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing = YANGDynClass(base=YANGListType("dest_ip mask_length path_type",yc_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing, yang_name="routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length path-type', extensions=None), is_container='list', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site', 'routings']

  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing (list)

    YANG Description: Statistics of the OSPF routing table.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings/routing (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Statistics of the OSPF routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("dest_ip mask_length path_type",yc_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing, yang_name="routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length path-type', extensions=None), is_container='list', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("dest_ip mask_length path_type",yc_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing, yang_name="routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length path-type', extensions=None), is_container='list', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=YANGListType("dest_ip mask_length path_type",yc_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing, yang_name="routing", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='dest-ip mask-length path-type', extensions=None), is_container='list', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=False)

  routing = __builtin__.property(_get_routing) # type: yc_routing_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings_routing


  _pyangbind_elements = OrderedDict([('routing', routing), ])


class yc_site_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites/site. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__process_id','__description','__router_id','__opaque','__rfc1583_compatible','__silent_all_interface','__retransmission_limit','__retransmission_limit_value','__safe_sync','__traffic_adj','__traffic_adv','__local_mt','__advertise_mpls_lsr_id','__advertise_mpls_lsr_id_cost','__suppress_reachability','__lsa_refresh','__mpls_ldp_auto_flag','__lsdb_overflow_limit','__peer_flapping_suppress','__shutdown','__sham_hello','__max_link_cost','__maxage_lsa','__private_net','__host_name','__bandwidth','__timer','__bfd','__metric_delay','__bier','__stub_router','__bgp_ls','__import_limit','__spf_control','__default_para','__avoid_micro_loop','__asbr_summary_prefixs','__summary','__no_summary','__route_preferences','__nexthop_weights','__prefix_prioritys','__ecmp_prefer','__frr','__local_mt_filter','__peers','__filter_lsa_outs','__gr_ietf','__flood_control','__dn_bit','__filter_import','__filter_exports','__import_routes','__silent_interfaces','__undo_silent_interfaces','__cost_bindings','__areas','__disp_data','__migp_routings','__abr_asbr_statistics','__nexthop_paras','__lsdb_statistics','__lsdb_briefs','__last_down_nbrs','__disp_graceful_restart','__error_process_data','__as_lsdb_brief','__neighbors','__routings',)

  _yang_name = 'site'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__opaque = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="opaque", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__rfc1583_compatible = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="rfc1583-compatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__silent_all_interface = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silent-all-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__retransmission_limit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="retransmission-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__retransmission_limit_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retransmission-limit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__safe_sync = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="safe-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__traffic_adj = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__traffic_adv = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__local_mt = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="local-mt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__advertise_mpls_lsr_id = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-mpls-lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__advertise_mpls_lsr_id_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="advertise-mpls-lsr-id-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__suppress_reachability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__lsa_refresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lsa-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__mpls_ldp_auto_flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='proc-auto-cfg-state', is_config=True)
    self.__lsdb_overflow_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="lsdb-overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__peer_flapping_suppress = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peer-flapping-suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__shutdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__sham_hello = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sham-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__max_link_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65534']}), is_leaf=True, yang_name="max-link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__maxage_lsa = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="maxage-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__private_net = YANGDynClass(base=yc_private_net_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net, is_container='container', yang_name="private-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__host_name = YANGDynClass(base=yc_host_name_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_host_name, is_container='container', yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__bandwidth = YANGDynClass(base=yc_bandwidth_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bandwidth, is_container='container', yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__bfd = YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__metric_delay = YANGDynClass(base=yc_metric_delay_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_metric_delay, is_container='container', yang_name="metric-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__bier = YANGDynClass(base=yc_bier_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bier, is_container='container', yang_name="bier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__stub_router = YANGDynClass(base=yc_stub_router_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_stub_router, is_container='container', yang_name="stub-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__bgp_ls = YANGDynClass(base=yc_bgp_ls_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bgp_ls, is_container='container', yang_name="bgp-ls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__import_limit = YANGDynClass(base=yc_import_limit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_limit, is_container='container', yang_name="import-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__spf_control = YANGDynClass(base=yc_spf_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_spf_control, is_container='container', yang_name="spf-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__default_para = YANGDynClass(base=yc_default_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_default_para, is_container='container', yang_name="default-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__avoid_micro_loop = YANGDynClass(base=yc_avoid_micro_loop_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_avoid_micro_loop, is_container='container', yang_name="avoid-micro-loop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__asbr_summary_prefixs = YANGDynClass(base=yc_asbr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs, is_container='container', yang_name="asbr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__summary = YANGDynClass(base=yc_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_summary, is_container='container', yang_name="summary", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__no_summary = YANGDynClass(base=yc_no_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_no_summary, is_container='container', yang_name="no-summary", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__route_preferences = YANGDynClass(base=yc_route_preferences_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences, is_container='container', yang_name="route-preferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__nexthop_weights = YANGDynClass(base=yc_nexthop_weights_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights, is_container='container', yang_name="nexthop-weights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__prefix_prioritys = YANGDynClass(base=yc_prefix_prioritys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys, is_container='container', yang_name="prefix-prioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__ecmp_prefer = YANGDynClass(base=yc_ecmp_prefer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_ecmp_prefer, is_container='container', yang_name="ecmp-prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__frr = YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__local_mt_filter = YANGDynClass(base=yc_local_mt_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_local_mt_filter, is_container='container', yang_name="local-mt-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__peers = YANGDynClass(base=yc_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__filter_lsa_outs = YANGDynClass(base=yc_filter_lsa_outs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs, is_container='container', yang_name="filter-lsa-outs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__gr_ietf = YANGDynClass(base=yc_gr_ietf_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_gr_ietf, is_container='container', yang_name="gr-ietf", parent=self, choice=('graceful-restart', 'gr-ietf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__flood_control = YANGDynClass(base=yc_flood_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_flood_control, is_container='container', yang_name="flood-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__dn_bit = YANGDynClass(base=yc_dn_bit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit, is_container='container', yang_name="dn-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__filter_import = YANGDynClass(base=yc_filter_import_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_import, is_container='container', yang_name="filter-import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__filter_exports = YANGDynClass(base=yc_filter_exports_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports, is_container='container', yang_name="filter-exports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__import_routes = YANGDynClass(base=yc_import_routes_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes, is_container='container', yang_name="import-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__silent_interfaces = YANGDynClass(base=yc_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces, is_container='container', yang_name="silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__undo_silent_interfaces = YANGDynClass(base=yc_undo_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces, is_container='container', yang_name="undo-silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__cost_bindings = YANGDynClass(base=yc_cost_bindings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings, is_container='container', yang_name="cost-bindings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__areas = YANGDynClass(base=yc_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas, is_container='container', yang_name="areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__disp_data = YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__migp_routings = YANGDynClass(base=yc_migp_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings, is_container='container', yang_name="migp-routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__abr_asbr_statistics = YANGDynClass(base=yc_abr_asbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics, is_container='container', yang_name="abr-asbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__nexthop_paras = YANGDynClass(base=yc_nexthop_paras_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras, is_container='container', yang_name="nexthop-paras", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__lsdb_statistics = YANGDynClass(base=yc_lsdb_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics, is_container='container', yang_name="lsdb-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__lsdb_briefs = YANGDynClass(base=yc_lsdb_briefs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs, is_container='container', yang_name="lsdb-briefs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__last_down_nbrs = YANGDynClass(base=yc_last_down_nbrs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs, is_container='container', yang_name="last-down-nbrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__disp_graceful_restart = YANGDynClass(base=yc_disp_graceful_restart_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_graceful_restart, is_container='container', yang_name="disp-graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__error_process_data = YANGDynClass(base=yc_error_process_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_error_process_data, is_container='container', yang_name="error-process-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__as_lsdb_brief = YANGDynClass(base=yc_as_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_as_lsdb_brief, is_container='container', yang_name="as-lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__routings = YANGDynClass(base=yc_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings, is_container='container', yang_name="routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites', 'site']

  def _get_process_id(self):
    """
    Getter method for process_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/process_id (uint32)

    YANG Description: Process ID.
    """
    return self.__process_id
      
  def _set_process_id(self, v, load=False):
    """
    Setter method for process_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/process_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process_id() directly.

    YANG Description: Process ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__process_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process_id(self):
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..4294967295']}), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/description (string)

    YANG Description: Description of an OSPF process.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of an OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..80']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='string', is_config=True)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/router_id (inet:ipv4-address-no-zone)

    YANG Description: Router ID. It is used to set the OSPF private ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: Router ID. It is used to set the OSPF private ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_opaque(self):
    """
    Getter method for opaque, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/opaque (boolean)

    YANG Description: Enable/disable the opaque LSA capability. After it is enabled, an OSPF process can generate the opaque LSA and receive the opaque LSA from the neighbor device.
    """
    return self.__opaque
      
  def _set_opaque(self, v, load=False):
    """
    Setter method for opaque, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/opaque (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opaque is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opaque() directly.

    YANG Description: Enable/disable the opaque LSA capability. After it is enabled, an OSPF process can generate the opaque LSA and receive the opaque LSA from the neighbor device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="opaque", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opaque must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="opaque", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__opaque = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opaque(self):
    self.__opaque = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="opaque", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_rfc1583_compatible(self):
    """
    Getter method for rfc1583_compatible, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/rfc1583_compatible (boolean)

    YANG Description: Enable/disable the route selection rule that is compatible with RFC 1583.
    """
    return self.__rfc1583_compatible
      
  def _set_rfc1583_compatible(self, v, load=False):
    """
    Setter method for rfc1583_compatible, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/rfc1583_compatible (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rfc1583_compatible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rfc1583_compatible() directly.

    YANG Description: Enable/disable the route selection rule that is compatible with RFC 1583.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="rfc1583-compatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rfc1583_compatible must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="rfc1583-compatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__rfc1583_compatible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rfc1583_compatible(self):
    self.__rfc1583_compatible = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="rfc1583-compatible", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_silent_all_interface(self):
    """
    Getter method for silent_all_interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_all_interface (boolean)

    YANG Description: Enable/disable to suppress all interfaces in an OSPF process from sending or receiving OSPF packets.
    """
    return self.__silent_all_interface
      
  def _set_silent_all_interface(self, v, load=False):
    """
    Setter method for silent_all_interface, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_all_interface (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_silent_all_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_silent_all_interface() directly.

    YANG Description: Enable/disable to suppress all interfaces in an OSPF process from sending or receiving OSPF packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silent-all-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """silent_all_interface must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silent-all-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__silent_all_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_silent_all_interface(self):
    self.__silent_all_interface = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="silent-all-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_retransmission_limit(self):
    """
    Getter method for retransmission_limit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/retransmission_limit (boolean)

    YANG Description: Enable/disable maximum retransmission.
    """
    return self.__retransmission_limit
      
  def _set_retransmission_limit(self, v, load=False):
    """
    Setter method for retransmission_limit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/retransmission_limit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmission_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmission_limit() directly.

    YANG Description: Enable/disable maximum retransmission.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="retransmission-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmission_limit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="retransmission-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__retransmission_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmission_limit(self):
    self.__retransmission_limit = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="retransmission-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_retransmission_limit_value(self):
    """
    Getter method for retransmission_limit_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/retransmission_limit_value (uint32)

    YANG Description: Maximum retransmission times.
    """
    return self.__retransmission_limit_value
      
  def _set_retransmission_limit_value(self, v, load=False):
    """
    Setter method for retransmission_limit_value, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/retransmission_limit_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retransmission_limit_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retransmission_limit_value() directly.

    YANG Description: Maximum retransmission times.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retransmission-limit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retransmission_limit_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retransmission-limit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__retransmission_limit_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retransmission_limit_value(self):
    self.__retransmission_limit_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['2..255']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(30), is_leaf=True, yang_name="retransmission-limit-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_safe_sync(self):
    """
    Getter method for safe_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/safe_sync (boolean)

    YANG Description: Enable/disable safe synchronization.
    """
    return self.__safe_sync
      
  def _set_safe_sync(self, v, load=False):
    """
    Setter method for safe_sync, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/safe_sync (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_safe_sync is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_safe_sync() directly.

    YANG Description: Enable/disable safe synchronization.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="safe-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """safe_sync must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="safe-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__safe_sync = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_safe_sync(self):
    self.__safe_sync = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="safe-sync", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_traffic_adj(self):
    """
    Getter method for traffic_adj, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/traffic_adj (boolean)

    YANG Description: Enable/disable traffic adjust info.
    """
    return self.__traffic_adj
      
  def _set_traffic_adj(self, v, load=False):
    """
    Setter method for traffic_adj, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/traffic_adj (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_adj is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_adj() directly.

    YANG Description: Enable/disable traffic adjust info.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_adj must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__traffic_adj = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_adj(self):
    self.__traffic_adj = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adj", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_traffic_adv(self):
    """
    Getter method for traffic_adv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/traffic_adv (boolean)

    YANG Description: Enable/disable traffic advertise info.
    """
    return self.__traffic_adv
      
  def _set_traffic_adv(self, v, load=False):
    """
    Setter method for traffic_adv, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/traffic_adv (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_adv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_adv() directly.

    YANG Description: Enable/disable traffic advertise info.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_adv must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__traffic_adv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_adv(self):
    self.__traffic_adv = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-adv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_local_mt(self):
    """
    Getter method for local_mt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt (boolean)

    YANG Description: Enable/disable local multicast topology.
    """
    return self.__local_mt
      
  def _set_local_mt(self, v, load=False):
    """
    Setter method for local_mt, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_mt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_mt() directly.

    YANG Description: Enable/disable local multicast topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="local-mt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_mt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="local-mt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__local_mt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_mt(self):
    self.__local_mt = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="local-mt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_advertise_mpls_lsr_id(self):
    """
    Getter method for advertise_mpls_lsr_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/advertise_mpls_lsr_id (boolean)

    YANG Description: Enable/disable advertise MPLS LSR ID into multiple areas as an intra area route.
    """
    return self.__advertise_mpls_lsr_id
      
  def _set_advertise_mpls_lsr_id(self, v, load=False):
    """
    Setter method for advertise_mpls_lsr_id, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/advertise_mpls_lsr_id (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_mpls_lsr_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_mpls_lsr_id() directly.

    YANG Description: Enable/disable advertise MPLS LSR ID into multiple areas as an intra area route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-mpls-lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_mpls_lsr_id must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-mpls-lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_mpls_lsr_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_mpls_lsr_id(self):
    self.__advertise_mpls_lsr_id = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-mpls-lsr-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_advertise_mpls_lsr_id_cost(self):
    """
    Getter method for advertise_mpls_lsr_id_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/advertise_mpls_lsr_id_cost (uint32)

    YANG Description: MPLS LSR ID link cost.
    """
    return self.__advertise_mpls_lsr_id_cost
      
  def _set_advertise_mpls_lsr_id_cost(self, v, load=False):
    """
    Setter method for advertise_mpls_lsr_id_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/advertise_mpls_lsr_id_cost (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_mpls_lsr_id_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_mpls_lsr_id_cost() directly.

    YANG Description: MPLS LSR ID link cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="advertise-mpls-lsr-id-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_mpls_lsr_id_cost must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="advertise-mpls-lsr-id-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__advertise_mpls_lsr_id_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_mpls_lsr_id_cost(self):
    self.__advertise_mpls_lsr_id_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="advertise-mpls-lsr-id-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_suppress_reachability(self):
    """
    Getter method for suppress_reachability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/suppress_reachability (boolean)

    YANG Description: Enable/disable suppress reachability.
    """
    return self.__suppress_reachability
      
  def _set_suppress_reachability(self, v, load=False):
    """
    Setter method for suppress_reachability, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/suppress_reachability (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_reachability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_reachability() directly.

    YANG Description: Enable/disable suppress reachability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_reachability must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__suppress_reachability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_reachability(self):
    self.__suppress_reachability = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress-reachability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_lsa_refresh(self):
    """
    Getter method for lsa_refresh, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsa_refresh (boolean)

    YANG Description: Enable/disable refresh the age of LSA with greater lsa age.
    """
    return self.__lsa_refresh
      
  def _set_lsa_refresh(self, v, load=False):
    """
    Setter method for lsa_refresh, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsa_refresh (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsa_refresh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsa_refresh() directly.

    YANG Description: Enable/disable refresh the age of LSA with greater lsa age.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lsa-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsa_refresh must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lsa-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__lsa_refresh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsa_refresh(self):
    self.__lsa_refresh = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="lsa-refresh", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_mpls_ldp_auto_flag(self):
    """
    Getter method for mpls_ldp_auto_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/mpls_ldp_auto_flag (proc-auto-cfg-state)

    YANG Description: Enable LDP automatically on OSPF enabled interfaces, but need to set MPLS first.
    """
    return self.__mpls_ldp_auto_flag
      
  def _set_mpls_ldp_auto_flag(self, v, load=False):
    """
    Setter method for mpls_ldp_auto_flag, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/mpls_ldp_auto_flag (proc-auto-cfg-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_ldp_auto_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_ldp_auto_flag() directly.

    YANG Description: Enable LDP automatically on OSPF enabled interfaces, but need to set MPLS first.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='proc-auto-cfg-state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_ldp_auto_flag must be of a type compatible with proc-auto-cfg-state""",
          'defined-type': "huawei-ospfv2:proc-auto-cfg-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='proc-auto-cfg-state', is_config=True)""",
        })

    self.__mpls_ldp_auto_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_ldp_auto_flag(self):
    self.__mpls_ldp_auto_flag = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'enable': {'value': 1}},), default=six.text_type("none"), is_leaf=True, yang_name="mpls-ldp-auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='proc-auto-cfg-state', is_config=True)


  def _get_lsdb_overflow_limit(self):
    """
    Getter method for lsdb_overflow_limit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_overflow_limit (uint32)

    YANG Description: Maximum number of AS external LSAs allowed in the LSDB.
    """
    return self.__lsdb_overflow_limit
      
  def _set_lsdb_overflow_limit(self, v, load=False):
    """
    Setter method for lsdb_overflow_limit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_overflow_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_overflow_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_overflow_limit() directly.

    YANG Description: Maximum number of AS external LSAs allowed in the LSDB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="lsdb-overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_overflow_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="lsdb-overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__lsdb_overflow_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_overflow_limit(self):
    self.__lsdb_overflow_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="lsdb-overflow-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_peer_flapping_suppress(self):
    """
    Getter method for peer_flapping_suppress, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peer_flapping_suppress (boolean)

    YANG Description: Enable/disable peer flapping suppress feature.
    """
    return self.__peer_flapping_suppress
      
  def _set_peer_flapping_suppress(self, v, load=False):
    """
    Setter method for peer_flapping_suppress, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peer_flapping_suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_flapping_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_flapping_suppress() directly.

    YANG Description: Enable/disable peer flapping suppress feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peer-flapping-suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_flapping_suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peer-flapping-suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__peer_flapping_suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_flapping_suppress(self):
    self.__peer_flapping_suppress = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="peer-flapping-suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_shutdown(self):
    """
    Getter method for shutdown, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/shutdown (boolean)

    YANG Description: Enable/disable shutdown OSPFv2 service.
    """
    return self.__shutdown
      
  def _set_shutdown(self, v, load=False):
    """
    Setter method for shutdown, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/shutdown (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown() directly.

    YANG Description: Enable/disable shutdown OSPFv2 service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__shutdown = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown(self):
    self.__shutdown = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="shutdown", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_sham_hello(self):
    """
    Getter method for sham_hello, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/sham_hello (boolean)

    YANG Description: Enable/disable peers keep alive by receiving any valid OSPF packet.
    """
    return self.__sham_hello
      
  def _set_sham_hello(self, v, load=False):
    """
    Setter method for sham_hello, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/sham_hello (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sham_hello is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sham_hello() directly.

    YANG Description: Enable/disable peers keep alive by receiving any valid OSPF packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sham-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sham_hello must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sham-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__sham_hello = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sham_hello(self):
    self.__sham_hello = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="sham-hello", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_max_link_cost(self):
    """
    Getter method for max_link_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/max_link_cost (uint16)

    YANG Description: Set the max value of link cost.
    """
    return self.__max_link_cost
      
  def _set_max_link_cost(self, v, load=False):
    """
    Setter method for max_link_cost, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/max_link_cost (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_link_cost is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_link_cost() directly.

    YANG Description: Set the max value of link cost.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65534']}), is_leaf=True, yang_name="max-link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_link_cost must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65534']}), is_leaf=True, yang_name="max-link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__max_link_cost = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_link_cost(self):
    self.__max_link_cost = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..65534']}), is_leaf=True, yang_name="max-link-cost", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_maxage_lsa(self):
    """
    Getter method for maxage_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/maxage_lsa (uint32)

    YANG Description: Calculation of route delay when the OSPF LSA frequently flaps.
    """
    return self.__maxage_lsa
      
  def _set_maxage_lsa(self, v, load=False):
    """
    Setter method for maxage_lsa, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/maxage_lsa (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxage_lsa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxage_lsa() directly.

    YANG Description: Calculation of route delay when the OSPF LSA frequently flaps.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="maxage-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxage_lsa must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="maxage-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__maxage_lsa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxage_lsa(self):
    self.__maxage_lsa = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(20), is_leaf=True, yang_name="maxage-lsa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_private_net(self):
    """
    Getter method for private_net, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net (container)

    YANG Description: Configure private network configuration of OSPF.
    """
    return self.__private_net
      
  def _set_private_net(self, v, load=False):
    """
    Setter method for private_net, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/private_net (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_private_net is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_private_net() directly.

    YANG Description: Configure private network configuration of OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_private_net_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net, is_container='container', yang_name="private-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """private_net must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_private_net_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net, is_container='container', yang_name="private-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__private_net = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_private_net(self):
    self.__private_net = YANGDynClass(base=yc_private_net_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net, is_container='container', yang_name="private-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_host_name(self):
    """
    Getter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/host_name (container)

    YANG Description: Configure OSPF host name.
    """
    return self.__host_name
      
  def _set_host_name(self, v, load=False):
    """
    Setter method for host_name, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/host_name (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_name() directly.

    YANG Description: Configure OSPF host name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_host_name_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_host_name, is_container='container', yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_name must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_host_name_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_host_name, is_container='container', yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__host_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_name(self):
    self.__host_name = YANGDynClass(base=yc_host_name_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_host_name, is_container='container', yang_name="host-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bandwidth (container)

    YANG Description: Configure bandwidth.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bandwidth (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Configure bandwidth.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bandwidth_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bandwidth, is_container='container', yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bandwidth_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bandwidth, is_container='container', yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=yc_bandwidth_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bandwidth, is_container='container', yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_timer(self):
    """
    Getter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer (container)

    YANG Description: Configure timer.
    """
    return self.__timer
      
  def _set_timer(self, v, load=False):
    """
    Setter method for timer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/timer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timer() directly.

    YANG Description: Configure timer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timer(self):
    self.__timer = YANGDynClass(base=yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer, is_container='container', yang_name="timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd (container)

    YANG Description: Configure BFD in a OSPF process.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: Configure BFD in a OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_metric_delay(self):
    """
    Getter method for metric_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay (container)

    YANG Description: Configure metric delay in a OSPF process.
    """
    return self.__metric_delay
      
  def _set_metric_delay(self, v, load=False):
    """
    Setter method for metric_delay, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/metric_delay (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_delay() directly.

    YANG Description: Configure metric delay in a OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_metric_delay_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_metric_delay, is_container='container', yang_name="metric-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_delay must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_metric_delay_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_metric_delay, is_container='container', yang_name="metric-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__metric_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_delay(self):
    self.__metric_delay = YANGDynClass(base=yc_metric_delay_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_metric_delay, is_container='container', yang_name="metric-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_bier(self):
    """
    Getter method for bier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bier (container)

    YANG Description: Configure the bier.
    """
    return self.__bier
      
  def _set_bier(self, v, load=False):
    """
    Setter method for bier, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bier() directly.

    YANG Description: Configure the bier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bier_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bier, is_container='container', yang_name="bier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bier_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bier, is_container='container', yang_name="bier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__bier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bier(self):
    self.__bier = YANGDynClass(base=yc_bier_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bier, is_container='container', yang_name="bier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_stub_router(self):
    """
    Getter method for stub_router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router (container)

    YANG Description: Configure stub router is used to configure the router as stub router.
    """
    return self.__stub_router
      
  def _set_stub_router(self, v, load=False):
    """
    Setter method for stub_router, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/stub_router (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stub_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stub_router() directly.

    YANG Description: Configure stub router is used to configure the router as stub router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_stub_router_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_stub_router, is_container='container', yang_name="stub-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stub_router must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_stub_router_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_stub_router, is_container='container', yang_name="stub-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__stub_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stub_router(self):
    self.__stub_router = YANGDynClass(base=yc_stub_router_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_stub_router, is_container='container', yang_name="stub-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_bgp_ls(self):
    """
    Getter method for bgp_ls, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bgp_ls (container)

    YANG Description: Configure BGP LS.
    """
    return self.__bgp_ls
      
  def _set_bgp_ls(self, v, load=False):
    """
    Setter method for bgp_ls, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/bgp_ls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_ls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_ls() directly.

    YANG Description: Configure BGP LS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_ls_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bgp_ls, is_container='container', yang_name="bgp-ls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_ls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_ls_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bgp_ls, is_container='container', yang_name="bgp-ls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__bgp_ls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_ls(self):
    self.__bgp_ls = YANGDynClass(base=yc_bgp_ls_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bgp_ls, is_container='container', yang_name="bgp-ls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_import_limit(self):
    """
    Getter method for import_limit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit (container)

    YANG Description: Configure limits the maximum number of routes to be imported.
    """
    return self.__import_limit
      
  def _set_import_limit(self, v, load=False):
    """
    Setter method for import_limit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_limit() directly.

    YANG Description: Configure limits the maximum number of routes to be imported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_import_limit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_limit, is_container='container', yang_name="import-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_import_limit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_limit, is_container='container', yang_name="import-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__import_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_limit(self):
    self.__import_limit = YANGDynClass(base=yc_import_limit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_limit, is_container='container', yang_name="import-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_spf_control(self):
    """
    Getter method for spf_control, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/spf_control (container)

    YANG Description: Configure SPF calculation control.
    """
    return self.__spf_control
      
  def _set_spf_control(self, v, load=False):
    """
    Setter method for spf_control, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/spf_control (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spf_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spf_control() directly.

    YANG Description: Configure SPF calculation control.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_spf_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_spf_control, is_container='container', yang_name="spf-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spf_control must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_spf_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_spf_control, is_container='container', yang_name="spf-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__spf_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spf_control(self):
    self.__spf_control = YANGDynClass(base=yc_spf_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_spf_control, is_container='container', yang_name="spf-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_default_para(self):
    """
    Getter method for default_para, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para (container)

    YANG Description: Configure default parameter.
    """
    return self.__default_para
      
  def _set_default_para(self, v, load=False):
    """
    Setter method for default_para, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/default_para (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_para is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_para() directly.

    YANG Description: Configure default parameter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_default_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_default_para, is_container='container', yang_name="default-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_para must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_default_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_default_para, is_container='container', yang_name="default-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__default_para = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_para(self):
    self.__default_para = YANGDynClass(base=yc_default_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_default_para, is_container='container', yang_name="default-para", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_avoid_micro_loop(self):
    """
    Getter method for avoid_micro_loop, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop (container)

    YANG Description: Configure OSPF avoid microloop.
    """
    return self.__avoid_micro_loop
      
  def _set_avoid_micro_loop(self, v, load=False):
    """
    Setter method for avoid_micro_loop, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/avoid_micro_loop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avoid_micro_loop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avoid_micro_loop() directly.

    YANG Description: Configure OSPF avoid microloop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_avoid_micro_loop_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_avoid_micro_loop, is_container='container', yang_name="avoid-micro-loop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avoid_micro_loop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_avoid_micro_loop_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_avoid_micro_loop, is_container='container', yang_name="avoid-micro-loop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__avoid_micro_loop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avoid_micro_loop(self):
    self.__avoid_micro_loop = YANGDynClass(base=yc_avoid_micro_loop_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_avoid_micro_loop, is_container='container', yang_name="avoid-micro-loop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_asbr_summary_prefixs(self):
    """
    Getter method for asbr_summary_prefixs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs (container)

    YANG Description: List of aggregate addresses for OSPF (only for ASBR).
    """
    return self.__asbr_summary_prefixs
      
  def _set_asbr_summary_prefixs(self, v, load=False):
    """
    Setter method for asbr_summary_prefixs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/asbr_summary_prefixs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_asbr_summary_prefixs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_asbr_summary_prefixs() directly.

    YANG Description: List of aggregate addresses for OSPF (only for ASBR).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_asbr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs, is_container='container', yang_name="asbr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """asbr_summary_prefixs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_asbr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs, is_container='container', yang_name="asbr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__asbr_summary_prefixs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_asbr_summary_prefixs(self):
    self.__asbr_summary_prefixs = YANGDynClass(base=yc_asbr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs, is_container='container', yang_name="asbr-summary-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_summary(self):
    """
    Getter method for summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/summary (container)

    YANG Description: Configure advertises the type3 summary LSAs of the specified default route.
    """
    return self.__summary
      
  def _set_summary(self, v, load=False):
    """
    Setter method for summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/summary (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_summary() directly.

    YANG Description: Configure advertises the type3 summary LSAs of the specified default route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_summary, is_container='container', yang_name="summary", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """summary must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_summary, is_container='container', yang_name="summary", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_summary(self):
    self.__summary = YANGDynClass(base=yc_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_summary, is_container='container', yang_name="summary", parent=self, choice=('default-route', 'summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_no_summary(self):
    """
    Getter method for no_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary (container)

    YANG Description: Configure default routes to the OSPF routing area.
    """
    return self.__no_summary
      
  def _set_no_summary(self, v, load=False):
    """
    Setter method for no_summary, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/no_summary (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_summary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_summary() directly.

    YANG Description: Configure default routes to the OSPF routing area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_no_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_no_summary, is_container='container', yang_name="no-summary", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_summary must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_no_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_no_summary, is_container='container', yang_name="no-summary", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__no_summary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_summary(self):
    self.__no_summary = YANGDynClass(base=yc_no_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_no_summary, is_container='container', yang_name="no-summary", parent=self, choice=('default-route', 'no-summary'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_route_preferences(self):
    """
    Getter method for route_preferences, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences (container)

    YANG Description: List of preference of an OSPF route.
    """
    return self.__route_preferences
      
  def _set_route_preferences(self, v, load=False):
    """
    Setter method for route_preferences, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/route_preferences (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preferences is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preferences() directly.

    YANG Description: List of preference of an OSPF route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_preferences_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences, is_container='container', yang_name="route-preferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preferences must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_preferences_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences, is_container='container', yang_name="route-preferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__route_preferences = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preferences(self):
    self.__route_preferences = YANGDynClass(base=yc_route_preferences_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences, is_container='container', yang_name="route-preferences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_nexthop_weights(self):
    """
    Getter method for nexthop_weights, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights (container)

    YANG Description: List of preference of an equal cost route.
    """
    return self.__nexthop_weights
      
  def _set_nexthop_weights(self, v, load=False):
    """
    Setter method for nexthop_weights, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_weights (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_weights is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_weights() directly.

    YANG Description: List of preference of an equal cost route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nexthop_weights_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights, is_container='container', yang_name="nexthop-weights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_weights must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nexthop_weights_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights, is_container='container', yang_name="nexthop-weights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__nexthop_weights = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_weights(self):
    self.__nexthop_weights = YANGDynClass(base=yc_nexthop_weights_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights, is_container='container', yang_name="nexthop-weights", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_prefix_prioritys(self):
    """
    Getter method for prefix_prioritys, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys (container)

    YANG Description: List of priority of OSPF route.
    """
    return self.__prefix_prioritys
      
  def _set_prefix_prioritys(self, v, load=False):
    """
    Setter method for prefix_prioritys, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/prefix_prioritys (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_prioritys is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_prioritys() directly.

    YANG Description: List of priority of OSPF route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_prioritys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys, is_container='container', yang_name="prefix-prioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_prioritys must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_prioritys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys, is_container='container', yang_name="prefix-prioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__prefix_prioritys = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_prioritys(self):
    self.__prefix_prioritys = YANGDynClass(base=yc_prefix_prioritys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys, is_container='container', yang_name="prefix-prioritys", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_ecmp_prefer(self):
    """
    Getter method for ecmp_prefer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/ecmp_prefer (container)

    YANG Description: Configure equal cost multipath preference of OSPF routes.
    """
    return self.__ecmp_prefer
      
  def _set_ecmp_prefer(self, v, load=False):
    """
    Setter method for ecmp_prefer, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/ecmp_prefer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ecmp_prefer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ecmp_prefer() directly.

    YANG Description: Configure equal cost multipath preference of OSPF routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ecmp_prefer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_ecmp_prefer, is_container='container', yang_name="ecmp-prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ecmp_prefer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ecmp_prefer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_ecmp_prefer, is_container='container', yang_name="ecmp-prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ecmp_prefer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ecmp_prefer(self):
    self.__ecmp_prefer = YANGDynClass(base=yc_ecmp_prefer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_ecmp_prefer, is_container='container', yang_name="ecmp-prefer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_frr(self):
    """
    Getter method for frr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr (container)

    YANG Description: Configure OSPF fast rerouting.
    """
    return self.__frr
      
  def _set_frr(self, v, load=False):
    """
    Setter method for frr, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/frr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frr() directly.

    YANG Description: Configure OSPF fast rerouting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__frr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frr(self):
    self.__frr = YANGDynClass(base=yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr, is_container='container', yang_name="frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_local_mt_filter(self):
    """
    Getter method for local_mt_filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter (container)

    YANG Description: Configure OSPF local multicast topology filtering in routing updates.
    """
    return self.__local_mt_filter
      
  def _set_local_mt_filter(self, v, load=False):
    """
    Setter method for local_mt_filter, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/local_mt_filter (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_mt_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_mt_filter() directly.

    YANG Description: Configure OSPF local multicast topology filtering in routing updates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_local_mt_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_local_mt_filter, is_container='container', yang_name="local-mt-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_mt_filter must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_local_mt_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_local_mt_filter, is_container='container', yang_name="local-mt-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__local_mt_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_mt_filter(self):
    self.__local_mt_filter = YANGDynClass(base=yc_local_mt_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_local_mt_filter, is_container='container', yang_name="local-mt-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_peers(self):
    """
    Getter method for peers, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers (container)

    YANG Description: List of the IP address and DR priority of the neighbor router on the NBMA network.
    """
    return self.__peers
      
  def _set_peers(self, v, load=False):
    """
    Setter method for peers, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/peers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peers() directly.

    YANG Description: List of the IP address and DR priority of the neighbor router on the NBMA network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__peers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peers(self):
    self.__peers = YANGDynClass(base=yc_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_filter_lsa_outs(self):
    """
    Getter method for filter_lsa_outs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_lsa_outs (container)

    YANG Description: List of LSA filter policy.
    """
    return self.__filter_lsa_outs
      
  def _set_filter_lsa_outs(self, v, load=False):
    """
    Setter method for filter_lsa_outs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_lsa_outs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_lsa_outs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_lsa_outs() directly.

    YANG Description: List of LSA filter policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filter_lsa_outs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs, is_container='container', yang_name="filter-lsa-outs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_lsa_outs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filter_lsa_outs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs, is_container='container', yang_name="filter-lsa-outs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__filter_lsa_outs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_lsa_outs(self):
    self.__filter_lsa_outs = YANGDynClass(base=yc_filter_lsa_outs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs, is_container='container', yang_name="filter-lsa-outs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_gr_ietf(self):
    """
    Getter method for gr_ietf, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf (container)

    YANG Description: Configure OSPF IETF GR.
    """
    return self.__gr_ietf
      
  def _set_gr_ietf(self, v, load=False):
    """
    Setter method for gr_ietf, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/gr_ietf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gr_ietf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gr_ietf() directly.

    YANG Description: Configure OSPF IETF GR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_gr_ietf_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_gr_ietf, is_container='container', yang_name="gr-ietf", parent=self, choice=('graceful-restart', 'gr-ietf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gr_ietf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_gr_ietf_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_gr_ietf, is_container='container', yang_name="gr-ietf", parent=self, choice=('graceful-restart', 'gr-ietf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__gr_ietf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gr_ietf(self):
    self.__gr_ietf = YANGDynClass(base=yc_gr_ietf_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_gr_ietf, is_container='container', yang_name="gr-ietf", parent=self, choice=('graceful-restart', 'gr-ietf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_flood_control(self):
    """
    Getter method for flood_control, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/flood_control (container)

    YANG Description: Configure OSPF flooding control.
    """
    return self.__flood_control
      
  def _set_flood_control(self, v, load=False):
    """
    Setter method for flood_control, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/flood_control (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flood_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flood_control() directly.

    YANG Description: Configure OSPF flooding control.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_flood_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_flood_control, is_container='container', yang_name="flood-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flood_control must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_flood_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_flood_control, is_container='container', yang_name="flood-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__flood_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flood_control(self):
    self.__flood_control = YANGDynClass(base=yc_flood_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_flood_control, is_container='container', yang_name="flood-control", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_dn_bit(self):
    """
    Getter method for dn_bit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit (container)

    YANG Description: Configure VPN optionA feature will help PEs in inter AS exchange routes through OSPF. VPN optionA provide two ways to suppress DN bit so that so that inter AS can exchange routes through OSPF. First way dose not set DN bit while import routes from BGP, second way dose not check DN bit while learning the routes from neighbor router. In both the scenario PE will be able to learn route and propagate the route in the new VPN cloud.
    """
    return self.__dn_bit
      
  def _set_dn_bit(self, v, load=False):
    """
    Setter method for dn_bit, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/dn_bit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dn_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dn_bit() directly.

    YANG Description: Configure VPN optionA feature will help PEs in inter AS exchange routes through OSPF. VPN optionA provide two ways to suppress DN bit so that so that inter AS can exchange routes through OSPF. First way dose not set DN bit while import routes from BGP, second way dose not check DN bit while learning the routes from neighbor router. In both the scenario PE will be able to learn route and propagate the route in the new VPN cloud.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dn_bit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit, is_container='container', yang_name="dn-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dn_bit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dn_bit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit, is_container='container', yang_name="dn-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__dn_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dn_bit(self):
    self.__dn_bit = YANGDynClass(base=yc_dn_bit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit, is_container='container', yang_name="dn-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_filter_import(self):
    """
    Getter method for filter_import, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import (container)

    YANG Description: Configure the filter policy import command. You can set the rules for filtering intra area, inter area, and AS external routes of an OSPF process.
    """
    return self.__filter_import
      
  def _set_filter_import(self, v, load=False):
    """
    Setter method for filter_import, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_import (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_import is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_import() directly.

    YANG Description: Configure the filter policy import command. You can set the rules for filtering intra area, inter area, and AS external routes of an OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filter_import_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_import, is_container='container', yang_name="filter-import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_import must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filter_import_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_import, is_container='container', yang_name="filter-import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__filter_import = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_import(self):
    self.__filter_import = YANGDynClass(base=yc_filter_import_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_import, is_container='container', yang_name="filter-import", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_filter_exports(self):
    """
    Getter method for filter_exports, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports (container)

    YANG Description: List of the filter policy export command. You can set the rules for filtering the routes imported through the import route (OSPF) command when the routes are advertised in type5 LSAs to the OSPF AS.
    """
    return self.__filter_exports
      
  def _set_filter_exports(self, v, load=False):
    """
    Setter method for filter_exports, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/filter_exports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_exports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_exports() directly.

    YANG Description: List of the filter policy export command. You can set the rules for filtering the routes imported through the import route (OSPF) command when the routes are advertised in type5 LSAs to the OSPF AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_filter_exports_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports, is_container='container', yang_name="filter-exports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_exports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_filter_exports_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports, is_container='container', yang_name="filter-exports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__filter_exports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_exports(self):
    self.__filter_exports = YANGDynClass(base=yc_filter_exports_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports, is_container='container', yang_name="filter-exports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_import_routes(self):
    """
    Getter method for import_routes, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes (container)

    YANG Description: List of import the routes learned from other routing protocols.
    """
    return self.__import_routes
      
  def _set_import_routes(self, v, load=False):
    """
    Setter method for import_routes, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/import_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_routes() directly.

    YANG Description: List of import the routes learned from other routing protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_import_routes_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes, is_container='container', yang_name="import-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_import_routes_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes, is_container='container', yang_name="import-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__import_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_routes(self):
    self.__import_routes = YANGDynClass(base=yc_import_routes_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes, is_container='container', yang_name="import-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_silent_interfaces(self):
    """
    Getter method for silent_interfaces, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_interfaces (container)

    YANG Description: List of interface. To prevent the OSPF routing information from being received by routers in a network segment and forbid the local router to receive the routing update information that is advertised by other routers in the network segment, you can use the silent interface command to suppress the interface to receive or send the OSPF packets.
    """
    return self.__silent_interfaces
      
  def _set_silent_interfaces(self, v, load=False):
    """
    Setter method for silent_interfaces, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/silent_interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_silent_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_silent_interfaces() directly.

    YANG Description: List of interface. To prevent the OSPF routing information from being received by routers in a network segment and forbid the local router to receive the routing update information that is advertised by other routers in the network segment, you can use the silent interface command to suppress the interface to receive or send the OSPF packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces, is_container='container', yang_name="silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """silent_interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces, is_container='container', yang_name="silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__silent_interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_silent_interfaces(self):
    self.__silent_interfaces = YANGDynClass(base=yc_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces, is_container='container', yang_name="silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_undo_silent_interfaces(self):
    """
    Getter method for undo_silent_interfaces, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/undo_silent_interfaces (container)

    YANG Description: List of interface. Enables sending and receiving packet on this interface when true. This information is useful when sending and receiving packet is suppressed on all interface on process level and user want it to be enabled on certain interface.
    """
    return self.__undo_silent_interfaces
      
  def _set_undo_silent_interfaces(self, v, load=False):
    """
    Setter method for undo_silent_interfaces, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/undo_silent_interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_undo_silent_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_undo_silent_interfaces() directly.

    YANG Description: List of interface. Enables sending and receiving packet on this interface when true. This information is useful when sending and receiving packet is suppressed on all interface on process level and user want it to be enabled on certain interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_undo_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces, is_container='container', yang_name="undo-silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """undo_silent_interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_undo_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces, is_container='container', yang_name="undo-silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__undo_silent_interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_undo_silent_interfaces(self):
    self.__undo_silent_interfaces = YANGDynClass(base=yc_undo_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces, is_container='container', yang_name="undo-silent-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_cost_bindings(self):
    """
    Getter method for cost_bindings, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings (container)

    YANG Description: List of cost-binding. Indicate cost of routing from indicated router source ID binding interface.
    """
    return self.__cost_bindings
      
  def _set_cost_bindings(self, v, load=False):
    """
    Setter method for cost_bindings, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/cost_bindings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cost_bindings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cost_bindings() directly.

    YANG Description: List of cost-binding. Indicate cost of routing from indicated router source ID binding interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cost_bindings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings, is_container='container', yang_name="cost-bindings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cost_bindings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cost_bindings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings, is_container='container', yang_name="cost-bindings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__cost_bindings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cost_bindings(self):
    self.__cost_bindings = YANGDynClass(base=yc_cost_bindings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings, is_container='container', yang_name="cost-bindings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_areas(self):
    """
    Getter method for areas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas (container)

    YANG Description: List of OSPF area.
    """
    return self.__areas
      
  def _set_areas(self, v, load=False):
    """
    Setter method for areas, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/areas (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_areas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_areas() directly.

    YANG Description: List of OSPF area.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas, is_container='container', yang_name="areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """areas must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas, is_container='container', yang_name="areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__areas = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_areas(self):
    self.__areas = YANGDynClass(base=yc_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas, is_container='container', yang_name="areas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_disp_data(self):
    """
    Getter method for disp_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data (container)

    YANG Description: Statistics of OSPF site.
    """
    return self.__disp_data
      
  def _set_disp_data(self, v, load=False):
    """
    Setter method for disp_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disp_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disp_data() directly.

    YANG Description: Statistics of OSPF site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disp_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__disp_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disp_data(self):
    self.__disp_data = YANGDynClass(base=yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_data, is_container='container', yang_name="disp-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_migp_routings(self):
    """
    Getter method for migp_routings, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings (container)

    YANG Description: List of the OSPF MIGP routing table.
    """
    return self.__migp_routings
      
  def _set_migp_routings(self, v, load=False):
    """
    Setter method for migp_routings, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/migp_routings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_migp_routings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_migp_routings() directly.

    YANG Description: List of the OSPF MIGP routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_migp_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings, is_container='container', yang_name="migp-routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """migp_routings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_migp_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings, is_container='container', yang_name="migp-routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__migp_routings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_migp_routings(self):
    self.__migp_routings = YANGDynClass(base=yc_migp_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings, is_container='container', yang_name="migp-routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_abr_asbr_statistics(self):
    """
    Getter method for abr_asbr_statistics, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics (container)

    YANG Description: List of the OSPF ABR and ASBR.
    """
    return self.__abr_asbr_statistics
      
  def _set_abr_asbr_statistics(self, v, load=False):
    """
    Setter method for abr_asbr_statistics, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/abr_asbr_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_asbr_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_asbr_statistics() directly.

    YANG Description: List of the OSPF ABR and ASBR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_abr_asbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics, is_container='container', yang_name="abr-asbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_asbr_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_abr_asbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics, is_container='container', yang_name="abr-asbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__abr_asbr_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_asbr_statistics(self):
    self.__abr_asbr_statistics = YANGDynClass(base=yc_abr_asbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics, is_container='container', yang_name="abr-asbr-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_nexthop_paras(self):
    """
    Getter method for nexthop_paras, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras (container)

    YANG Description: List of the next hop of an OSPF process.
    """
    return self.__nexthop_paras
      
  def _set_nexthop_paras(self, v, load=False):
    """
    Setter method for nexthop_paras, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/nexthop_paras (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nexthop_paras is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nexthop_paras() directly.

    YANG Description: List of the next hop of an OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nexthop_paras_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras, is_container='container', yang_name="nexthop-paras", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nexthop_paras must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nexthop_paras_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras, is_container='container', yang_name="nexthop-paras", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__nexthop_paras = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nexthop_paras(self):
    self.__nexthop_paras = YANGDynClass(base=yc_nexthop_paras_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras, is_container='container', yang_name="nexthop-paras", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_lsdb_statistics(self):
    """
    Getter method for lsdb_statistics, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics (container)

    YANG Description: List of OSPF LSDBs.
    """
    return self.__lsdb_statistics
      
  def _set_lsdb_statistics(self, v, load=False):
    """
    Setter method for lsdb_statistics, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_statistics() directly.

    YANG Description: List of OSPF LSDBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsdb_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics, is_container='container', yang_name="lsdb-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsdb_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics, is_container='container', yang_name="lsdb-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__lsdb_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_statistics(self):
    self.__lsdb_statistics = YANGDynClass(base=yc_lsdb_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics, is_container='container', yang_name="lsdb-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_lsdb_briefs(self):
    """
    Getter method for lsdb_briefs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs (container)

    YANG Description: List of LSDB statistics.
    """
    return self.__lsdb_briefs
      
  def _set_lsdb_briefs(self, v, load=False):
    """
    Setter method for lsdb_briefs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/lsdb_briefs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsdb_briefs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsdb_briefs() directly.

    YANG Description: List of LSDB statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_lsdb_briefs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs, is_container='container', yang_name="lsdb-briefs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsdb_briefs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_lsdb_briefs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs, is_container='container', yang_name="lsdb-briefs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__lsdb_briefs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsdb_briefs(self):
    self.__lsdb_briefs = YANGDynClass(base=yc_lsdb_briefs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs, is_container='container', yang_name="lsdb-briefs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_last_down_nbrs(self):
    """
    Getter method for last_down_nbrs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs (container)

    YANG Description: List of the OSPF neighbor that goes down for the last time.
    """
    return self.__last_down_nbrs
      
  def _set_last_down_nbrs(self, v, load=False):
    """
    Setter method for last_down_nbrs, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/last_down_nbrs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_down_nbrs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_down_nbrs() directly.

    YANG Description: List of the OSPF neighbor that goes down for the last time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_last_down_nbrs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs, is_container='container', yang_name="last-down-nbrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_down_nbrs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_last_down_nbrs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs, is_container='container', yang_name="last-down-nbrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__last_down_nbrs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_down_nbrs(self):
    self.__last_down_nbrs = YANGDynClass(base=yc_last_down_nbrs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs, is_container='container', yang_name="last-down-nbrs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_disp_graceful_restart(self):
    """
    Getter method for disp_graceful_restart, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart (container)

    YANG Description: Statistics of graceful restart information.
    """
    return self.__disp_graceful_restart
      
  def _set_disp_graceful_restart(self, v, load=False):
    """
    Setter method for disp_graceful_restart, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/disp_graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disp_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disp_graceful_restart() directly.

    YANG Description: Statistics of graceful restart information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_disp_graceful_restart_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_graceful_restart, is_container='container', yang_name="disp-graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disp_graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_disp_graceful_restart_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_graceful_restart, is_container='container', yang_name="disp-graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__disp_graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disp_graceful_restart(self):
    self.__disp_graceful_restart = YANGDynClass(base=yc_disp_graceful_restart_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_graceful_restart, is_container='container', yang_name="disp-graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_error_process_data(self):
    """
    Getter method for error_process_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data (container)

    YANG Description: Statistics of error data.
    """
    return self.__error_process_data
      
  def _set_error_process_data(self, v, load=False):
    """
    Setter method for error_process_data, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/error_process_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_process_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_process_data() directly.

    YANG Description: Statistics of error data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_error_process_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_error_process_data, is_container='container', yang_name="error-process-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_process_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_error_process_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_error_process_data, is_container='container', yang_name="error-process-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__error_process_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_process_data(self):
    self.__error_process_data = YANGDynClass(base=yc_error_process_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_error_process_data, is_container='container', yang_name="error-process-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_as_lsdb_brief(self):
    """
    Getter method for as_lsdb_brief, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief (container)

    YANG Description: Statistics of AS LSDB statistics.
    """
    return self.__as_lsdb_brief
      
  def _set_as_lsdb_brief(self, v, load=False):
    """
    Setter method for as_lsdb_brief, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/as_lsdb_brief (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_lsdb_brief is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_lsdb_brief() directly.

    YANG Description: Statistics of AS LSDB statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_as_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_as_lsdb_brief, is_container='container', yang_name="as-lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_lsdb_brief must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_as_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_as_lsdb_brief, is_container='container', yang_name="as-lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__as_lsdb_brief = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_lsdb_brief(self):
    self.__as_lsdb_brief = YANGDynClass(base=yc_as_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_as_lsdb_brief, is_container='container', yang_name="as-lsdb-brief", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors (container)

    YANG Description: List of neighbor.
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: List of neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_routings(self):
    """
    Getter method for routings, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings (container)

    YANG Description: List of the OSPF routing table.
    """
    return self.__routings
      
  def _set_routings(self, v, load=False):
    """
    Setter method for routings, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site/routings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routings() directly.

    YANG Description: List of the OSPF routing table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings, is_container='container', yang_name="routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings, is_container='container', yang_name="routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__routings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routings(self):
    self.__routings = YANGDynClass(base=yc_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings, is_container='container', yang_name="routings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  process_id = __builtin__.property(_get_process_id, _set_process_id)
  description = __builtin__.property(_get_description, _set_description)
  router_id = __builtin__.property(_get_router_id, _set_router_id)
  opaque = __builtin__.property(_get_opaque, _set_opaque)
  rfc1583_compatible = __builtin__.property(_get_rfc1583_compatible, _set_rfc1583_compatible)
  silent_all_interface = __builtin__.property(_get_silent_all_interface, _set_silent_all_interface)
  retransmission_limit = __builtin__.property(_get_retransmission_limit, _set_retransmission_limit)
  retransmission_limit_value = __builtin__.property(_get_retransmission_limit_value, _set_retransmission_limit_value)
  safe_sync = __builtin__.property(_get_safe_sync, _set_safe_sync)
  traffic_adj = __builtin__.property(_get_traffic_adj, _set_traffic_adj)
  traffic_adv = __builtin__.property(_get_traffic_adv, _set_traffic_adv)
  local_mt = __builtin__.property(_get_local_mt, _set_local_mt)
  advertise_mpls_lsr_id = __builtin__.property(_get_advertise_mpls_lsr_id, _set_advertise_mpls_lsr_id)
  advertise_mpls_lsr_id_cost = __builtin__.property(_get_advertise_mpls_lsr_id_cost, _set_advertise_mpls_lsr_id_cost)
  suppress_reachability = __builtin__.property(_get_suppress_reachability, _set_suppress_reachability)
  lsa_refresh = __builtin__.property(_get_lsa_refresh, _set_lsa_refresh)
  mpls_ldp_auto_flag = __builtin__.property(_get_mpls_ldp_auto_flag, _set_mpls_ldp_auto_flag)
  lsdb_overflow_limit = __builtin__.property(_get_lsdb_overflow_limit, _set_lsdb_overflow_limit)
  peer_flapping_suppress = __builtin__.property(_get_peer_flapping_suppress, _set_peer_flapping_suppress)
  shutdown = __builtin__.property(_get_shutdown, _set_shutdown)
  sham_hello = __builtin__.property(_get_sham_hello, _set_sham_hello)
  max_link_cost = __builtin__.property(_get_max_link_cost, _set_max_link_cost)
  maxage_lsa = __builtin__.property(_get_maxage_lsa, _set_maxage_lsa)
  private_net = __builtin__.property(_get_private_net, _set_private_net) # type: yc_private_net_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_private_net
  host_name = __builtin__.property(_get_host_name, _set_host_name) # type: yc_host_name_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_host_name
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth) # type: yc_bandwidth_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bandwidth
  timer = __builtin__.property(_get_timer, _set_timer) # type: yc_timer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_timer
  bfd = __builtin__.property(_get_bfd, _set_bfd) # type: yc_bfd_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bfd
  metric_delay = __builtin__.property(_get_metric_delay, _set_metric_delay) # type: yc_metric_delay_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_metric_delay
  bier = __builtin__.property(_get_bier, _set_bier) # type: yc_bier_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bier
  stub_router = __builtin__.property(_get_stub_router, _set_stub_router) # type: yc_stub_router_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_stub_router
  bgp_ls = __builtin__.property(_get_bgp_ls, _set_bgp_ls) # type: yc_bgp_ls_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_bgp_ls
  import_limit = __builtin__.property(_get_import_limit, _set_import_limit) # type: yc_import_limit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_limit
  spf_control = __builtin__.property(_get_spf_control, _set_spf_control) # type: yc_spf_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_spf_control
  default_para = __builtin__.property(_get_default_para, _set_default_para) # type: yc_default_para_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_default_para
  avoid_micro_loop = __builtin__.property(_get_avoid_micro_loop, _set_avoid_micro_loop) # type: yc_avoid_micro_loop_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_avoid_micro_loop
  asbr_summary_prefixs = __builtin__.property(_get_asbr_summary_prefixs, _set_asbr_summary_prefixs) # type: yc_asbr_summary_prefixs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_asbr_summary_prefixs
  summary = __builtin__.property(_get_summary, _set_summary) # type: yc_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_summary
  no_summary = __builtin__.property(_get_no_summary, _set_no_summary) # type: yc_no_summary_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_no_summary
  route_preferences = __builtin__.property(_get_route_preferences, _set_route_preferences) # type: yc_route_preferences_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_route_preferences
  nexthop_weights = __builtin__.property(_get_nexthop_weights, _set_nexthop_weights) # type: yc_nexthop_weights_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_weights
  prefix_prioritys = __builtin__.property(_get_prefix_prioritys, _set_prefix_prioritys) # type: yc_prefix_prioritys_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_prefix_prioritys
  ecmp_prefer = __builtin__.property(_get_ecmp_prefer, _set_ecmp_prefer) # type: yc_ecmp_prefer_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_ecmp_prefer
  frr = __builtin__.property(_get_frr, _set_frr) # type: yc_frr_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_frr
  local_mt_filter = __builtin__.property(_get_local_mt_filter, _set_local_mt_filter) # type: yc_local_mt_filter_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_local_mt_filter
  peers = __builtin__.property(_get_peers, _set_peers) # type: yc_peers_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_peers
  filter_lsa_outs = __builtin__.property(_get_filter_lsa_outs, _set_filter_lsa_outs) # type: yc_filter_lsa_outs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_lsa_outs
  gr_ietf = __builtin__.property(_get_gr_ietf, _set_gr_ietf) # type: yc_gr_ietf_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_gr_ietf
  flood_control = __builtin__.property(_get_flood_control, _set_flood_control) # type: yc_flood_control_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_flood_control
  dn_bit = __builtin__.property(_get_dn_bit, _set_dn_bit) # type: yc_dn_bit_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_dn_bit
  filter_import = __builtin__.property(_get_filter_import, _set_filter_import) # type: yc_filter_import_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_import
  filter_exports = __builtin__.property(_get_filter_exports, _set_filter_exports) # type: yc_filter_exports_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_filter_exports
  import_routes = __builtin__.property(_get_import_routes, _set_import_routes) # type: yc_import_routes_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_import_routes
  silent_interfaces = __builtin__.property(_get_silent_interfaces, _set_silent_interfaces) # type: yc_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_silent_interfaces
  undo_silent_interfaces = __builtin__.property(_get_undo_silent_interfaces, _set_undo_silent_interfaces) # type: yc_undo_silent_interfaces_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_undo_silent_interfaces
  cost_bindings = __builtin__.property(_get_cost_bindings, _set_cost_bindings) # type: yc_cost_bindings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_cost_bindings
  areas = __builtin__.property(_get_areas, _set_areas) # type: yc_areas_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_areas
  disp_data = __builtin__.property(_get_disp_data, _set_disp_data) # type: yc_disp_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_data
  migp_routings = __builtin__.property(_get_migp_routings, _set_migp_routings) # type: yc_migp_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_migp_routings
  abr_asbr_statistics = __builtin__.property(_get_abr_asbr_statistics, _set_abr_asbr_statistics) # type: yc_abr_asbr_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_abr_asbr_statistics
  nexthop_paras = __builtin__.property(_get_nexthop_paras, _set_nexthop_paras) # type: yc_nexthop_paras_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_nexthop_paras
  lsdb_statistics = __builtin__.property(_get_lsdb_statistics, _set_lsdb_statistics) # type: yc_lsdb_statistics_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_statistics
  lsdb_briefs = __builtin__.property(_get_lsdb_briefs, _set_lsdb_briefs) # type: yc_lsdb_briefs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_lsdb_briefs
  last_down_nbrs = __builtin__.property(_get_last_down_nbrs, _set_last_down_nbrs) # type: yc_last_down_nbrs_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_last_down_nbrs
  disp_graceful_restart = __builtin__.property(_get_disp_graceful_restart, _set_disp_graceful_restart) # type: yc_disp_graceful_restart_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_disp_graceful_restart
  error_process_data = __builtin__.property(_get_error_process_data, _set_error_process_data) # type: yc_error_process_data_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_error_process_data
  as_lsdb_brief = __builtin__.property(_get_as_lsdb_brief, _set_as_lsdb_brief) # type: yc_as_lsdb_brief_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_as_lsdb_brief
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors) # type: yc_neighbors_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_neighbors
  routings = __builtin__.property(_get_routings, _set_routings) # type: yc_routings_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site_routings

  __choices__ = {'default-route': {'summary': ['summary'], 'no-summary': ['no_summary']}, 'graceful-restart': {'gr-ietf': ['gr_ietf']}}
  _pyangbind_elements = OrderedDict([('process_id', process_id), ('description', description), ('router_id', router_id), ('opaque', opaque), ('rfc1583_compatible', rfc1583_compatible), ('silent_all_interface', silent_all_interface), ('retransmission_limit', retransmission_limit), ('retransmission_limit_value', retransmission_limit_value), ('safe_sync', safe_sync), ('traffic_adj', traffic_adj), ('traffic_adv', traffic_adv), ('local_mt', local_mt), ('advertise_mpls_lsr_id', advertise_mpls_lsr_id), ('advertise_mpls_lsr_id_cost', advertise_mpls_lsr_id_cost), ('suppress_reachability', suppress_reachability), ('lsa_refresh', lsa_refresh), ('mpls_ldp_auto_flag', mpls_ldp_auto_flag), ('lsdb_overflow_limit', lsdb_overflow_limit), ('peer_flapping_suppress', peer_flapping_suppress), ('shutdown', shutdown), ('sham_hello', sham_hello), ('max_link_cost', max_link_cost), ('maxage_lsa', maxage_lsa), ('private_net', private_net), ('host_name', host_name), ('bandwidth', bandwidth), ('timer', timer), ('bfd', bfd), ('metric_delay', metric_delay), ('bier', bier), ('stub_router', stub_router), ('bgp_ls', bgp_ls), ('import_limit', import_limit), ('spf_control', spf_control), ('default_para', default_para), ('avoid_micro_loop', avoid_micro_loop), ('asbr_summary_prefixs', asbr_summary_prefixs), ('summary', summary), ('no_summary', no_summary), ('route_preferences', route_preferences), ('nexthop_weights', nexthop_weights), ('prefix_prioritys', prefix_prioritys), ('ecmp_prefer', ecmp_prefer), ('frr', frr), ('local_mt_filter', local_mt_filter), ('peers', peers), ('filter_lsa_outs', filter_lsa_outs), ('gr_ietf', gr_ietf), ('flood_control', flood_control), ('dn_bit', dn_bit), ('filter_import', filter_import), ('filter_exports', filter_exports), ('import_routes', import_routes), ('silent_interfaces', silent_interfaces), ('undo_silent_interfaces', undo_silent_interfaces), ('cost_bindings', cost_bindings), ('areas', areas), ('disp_data', disp_data), ('migp_routings', migp_routings), ('abr_asbr_statistics', abr_asbr_statistics), ('nexthop_paras', nexthop_paras), ('lsdb_statistics', lsdb_statistics), ('lsdb_briefs', lsdb_briefs), ('last_down_nbrs', last_down_nbrs), ('disp_graceful_restart', disp_graceful_restart), ('error_process_data', error_process_data), ('as_lsdb_brief', as_lsdb_brief), ('neighbors', neighbors), ('routings', routings), ])


class yc_sites_huawei_network_instance__network_instance_instances_instance_ospfv2_sites(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2/sites. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OSPF instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__site',)

  _yang_name = 'sites'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__site = YANGDynClass(base=YANGListType("process_id",yc_site_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site, yang_name="site", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='process-id', extensions=None), is_container='list', yang_name="site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2', 'sites']

  def _get_site(self):
    """
    Getter method for site, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site (list)

    YANG Description: Configure OSPF instance.
    """
    return self.__site
      
  def _set_site(self, v, load=False):
    """
    Setter method for site, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites/site (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_site is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_site() directly.

    YANG Description: Configure OSPF instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("process_id",yc_site_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site, yang_name="site", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='process-id', extensions=None), is_container='list', yang_name="site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """site must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("process_id",yc_site_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site, yang_name="site", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='process-id', extensions=None), is_container='list', yang_name="site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)""",
        })

    self.__site = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_site(self):
    self.__site = YANGDynClass(base=YANGListType("process_id",yc_site_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site, yang_name="site", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='process-id', extensions=None), is_container='list', yang_name="site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='list', is_config=True)

  site = __builtin__.property(_get_site, _set_site) # type: yc_site_huawei_network_instance__network_instance_instances_instance_ospfv2_sites_site


  _pyangbind_elements = OrderedDict([('site', site), ])


class yc_ospfv2_huawei_network_instance__network_instance_instances_instance_ospfv2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/ospfv2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPFv2.
  """
  __slots__ = ('_path_helper', '_extmethods', '__gtsm','__sites',)

  _yang_name = 'ospfv2'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__gtsm = YANGDynClass(base=yc_gtsm_huawei_network_instance__network_instance_instances_instance_ospfv2_gtsm, is_container='container', yang_name="gtsm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__sites = YANGDynClass(base=yc_sites_huawei_network_instance__network_instance_instances_instance_ospfv2_sites, is_container='container', yang_name="sites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'ospfv2']

  def _get_gtsm(self):
    """
    Getter method for gtsm, mapped from YANG variable /network_instance/instances/instance/ospfv2/gtsm (container)

    YANG Description: Configure the OSPF GTSM.
    """
    return self.__gtsm
      
  def _set_gtsm(self, v, load=False):
    """
    Setter method for gtsm, mapped from YANG variable /network_instance/instances/instance/ospfv2/gtsm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gtsm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gtsm() directly.

    YANG Description: Configure the OSPF GTSM.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_gtsm_huawei_network_instance__network_instance_instances_instance_ospfv2_gtsm, is_container='container', yang_name="gtsm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gtsm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_gtsm_huawei_network_instance__network_instance_instances_instance_ospfv2_gtsm, is_container='container', yang_name="gtsm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__gtsm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gtsm(self):
    self.__gtsm = YANGDynClass(base=yc_gtsm_huawei_network_instance__network_instance_instances_instance_ospfv2_gtsm, is_container='container', yang_name="gtsm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_sites(self):
    """
    Getter method for sites, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites (container)

    YANG Description: List of OSPF instance.
    """
    return self.__sites
      
  def _set_sites(self, v, load=False):
    """
    Setter method for sites, mapped from YANG variable /network_instance/instances/instance/ospfv2/sites (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sites is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sites() directly.

    YANG Description: List of OSPF instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sites_huawei_network_instance__network_instance_instances_instance_ospfv2_sites, is_container='container', yang_name="sites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sites must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sites_huawei_network_instance__network_instance_instances_instance_ospfv2_sites, is_container='container', yang_name="sites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__sites = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sites(self):
    self.__sites = YANGDynClass(base=yc_sites_huawei_network_instance__network_instance_instances_instance_ospfv2_sites, is_container='container', yang_name="sites", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  gtsm = __builtin__.property(_get_gtsm, _set_gtsm) # type: yc_gtsm_huawei_network_instance__network_instance_instances_instance_ospfv2_gtsm
  sites = __builtin__.property(_get_sites, _set_sites) # type: yc_sites_huawei_network_instance__network_instance_instances_instance_ospfv2_sites


  _pyangbind_elements = OrderedDict([('gtsm', gtsm), ('sites', sites), ])


class yc_instance_huawei_network_instance__network_instance_instances_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Multiple software features can be bound to multiple VPN instances to form a multi-instance that provides multiple features, for example, RIP multi-instance, OSPF multi-instance, IS-IS multi-instance, and BGP multi-instance. The _public_, dcn, ason, __mpp_vpn_inner__, __mpp_vpn_outer__, __mpp_vpn_inner_server__, and __LOCAL_OAM_VPN__ instances cannot be deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__sys_router_id','__vrf_id','__traffic_statistic_enable','__parameter','__afs','__ospfv2',)

  _yang_name = 'instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    self.__sys_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__vrf_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)
    self.__traffic_statistic_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__parameter = YANGDynClass(base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__ospfv2 = YANGDynClass(base=yc_ospfv2_huawei_network_instance__network_instance_instances_instance_ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instance/instances/instance/name (string)

    YANG Description: VPN instance name. It uniquely identifies a VPN instance. The name is a string of case-sensitive characters.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instance/instances/instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: VPN instance name. It uniquely identifies a VPN instance. The name is a string of case-sensitive characters.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instance/instances/instance/description (string)

    YANG Description: The description of a VPN instance. The value is a string, spaces supported.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instance/instances/instance/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of a VPN instance. The value is a string, spaces supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)


  def _get_sys_router_id(self):
    """
    Getter method for sys_router_id, mapped from YANG variable /network_instance/instances/instance/sys_router_id (inet:ipv4-address-no-zone)

    YANG Description: The router id of current use.
    """
    return self.__sys_router_id
      
  def _set_sys_router_id(self, v, load=False):
    """
    Setter method for sys_router_id, mapped from YANG variable /network_instance/instances/instance/sys_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sys_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sys_router_id() directly.

    YANG Description: The router id of current use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sys_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__sys_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sys_router_id(self):
    self.__sys_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_vrf_id(self):
    """
    Getter method for vrf_id, mapped from YANG variable /network_instance/instances/instance/vrf_id (uint32)

    YANG Description: Vpn Instances ID.
    """
    return self.__vrf_id
      
  def _set_vrf_id(self, v, load=False):
    """
    Setter method for vrf_id, mapped from YANG variable /network_instance/instances/instance/vrf_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_id() directly.

    YANG Description: Vpn Instances ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__vrf_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_id(self):
    self.__vrf_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)


  def _get_traffic_statistic_enable(self):
    """
    Getter method for traffic_statistic_enable, mapped from YANG variable /network_instance/instances/instance/traffic_statistic_enable (boolean)

    YANG Description: Enable/disable L3VPN traffic statistics.
    """
    return self.__traffic_statistic_enable
      
  def _set_traffic_statistic_enable(self, v, load=False):
    """
    Setter method for traffic_statistic_enable, mapped from YANG variable /network_instance/instances/instance/traffic_statistic_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_statistic_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_statistic_enable() directly.

    YANG Description: Enable/disable L3VPN traffic statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_statistic_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__traffic_statistic_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_statistic_enable(self):
    self.__traffic_statistic_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /network_instance/instances/instance/parameter (container)

    YANG Description: Configure L3VPN instances information.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /network_instance/instances/instance/parameter (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Configure L3VPN instances information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_afs(self):
    """
    Getter method for afs, mapped from YANG variable /network_instance/instances/instance/afs (container)

    YANG Description: List of VPN address families. A VPN instance supports the
configurations and functions of an address family only
after the address family is configured on the instance.
    """
    return self.__afs
      
  def _set_afs(self, v, load=False):
    """
    Setter method for afs, mapped from YANG variable /network_instance/instances/instance/afs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afs() directly.

    YANG Description: List of VPN address families. A VPN instance supports the
configurations and functions of an address family only
after the address family is configured on the instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__afs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afs(self):
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_ospfv2(self):
    """
    Getter method for ospfv2, mapped from YANG variable /network_instance/instances/instance/ospfv2 (container)

    YANG Description: Configure OSPFv2.
    """
    return self.__ospfv2
      
  def _set_ospfv2(self, v, load=False):
    """
    Setter method for ospfv2, mapped from YANG variable /network_instance/instances/instance/ospfv2 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospfv2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospfv2() directly.

    YANG Description: Configure OSPFv2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ospfv2_huawei_network_instance__network_instance_instances_instance_ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospfv2 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ospfv2_huawei_network_instance__network_instance_instances_instance_ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ospfv2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospfv2(self):
    self.__ospfv2 = YANGDynClass(base=yc_ospfv2_huawei_network_instance__network_instance_instances_instance_ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  sys_router_id = __builtin__.property(_get_sys_router_id)
  vrf_id = __builtin__.property(_get_vrf_id)
  traffic_statistic_enable = __builtin__.property(_get_traffic_statistic_enable, _set_traffic_statistic_enable)
  parameter = __builtin__.property(_get_parameter, _set_parameter) # type: yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter
  afs = __builtin__.property(_get_afs, _set_afs) # type: yc_afs_huawei_network_instance__network_instance_instances_instance_afs
  ospfv2 = __builtin__.property(_get_ospfv2, _set_ospfv2) # type: yc_ospfv2_huawei_network_instance__network_instance_instances_instance_ospfv2


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('sys_router_id', sys_router_id), ('vrf_id', vrf_id), ('traffic_statistic_enable', traffic_statistic_enable), ('parameter', parameter), ('afs', afs), ('ospfv2', ospfv2), ])


class yc_instances_huawei_network_instance__network_instance_instances(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Some software features can be bound to multiple VPN instances so that multiple instances can provide a same feature. For example, RIP, OSPF, IS-IS, and BGP multiple instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instance',)

  _yang_name = 'instances'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instance = YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances']

  def _get_instance(self):
    """
    Getter method for instance, mapped from YANG variable /network_instance/instances/instance (list)

    YANG Description: Configure VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Multiple software features can be bound to multiple VPN instances to form a multi-instance that provides multiple features, for example, RIP multi-instance, OSPF multi-instance, IS-IS multi-instance, and BGP multi-instance. The _public_, dcn, ason, __mpp_vpn_inner__, __mpp_vpn_outer__, __mpp_vpn_inner_server__, and __LOCAL_OAM_VPN__ instances cannot be deleted.
    """
    return self.__instance
      
  def _set_instance(self, v, load=False):
    """
    Setter method for instance, mapped from YANG variable /network_instance/instances/instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance() directly.

    YANG Description: Configure VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Multiple software features can be bound to multiple VPN instances to form a multi-instance that provides multiple features, for example, RIP multi-instance, OSPF multi-instance, IS-IS multi-instance, and BGP multi-instance. The _public_, dcn, ason, __mpp_vpn_inner__, __mpp_vpn_outer__, __mpp_vpn_inner_server__, and __LOCAL_OAM_VPN__ instances cannot be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)""",
        })

    self.__instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance(self):
    self.__instance = YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)

  instance = __builtin__.property(_get_instance, _set_instance) # type: yc_instance_huawei_network_instance__network_instance_instances_instance


  _pyangbind_elements = OrderedDict([('instance', instance), ])


class yc_network_instance_huawei_network_instance__network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_','__instances',)

  _yang_name = 'network-instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_ = YANGDynClass(base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    self.__instances = YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance']

  def _get_global_(self):
    """
    Getter method for global_, mapped from YANG variable /network_instance/global (container)

    YANG Description: Configure the global layer 3 virtual private network (L3VPN).
    """
    return self.__global_
      
  def _set_global_(self, v, load=False):
    """
    Setter method for global_, mapped from YANG variable /network_instance/global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_() directly.

    YANG Description: Configure the global layer 3 virtual private network (L3VPN).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__global_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_(self):
    self.__global_ = YANGDynClass(base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /network_instance/instances (container)

    YANG Description: List of VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Some software features can be bound to multiple VPN instances so that multiple instances can provide a same feature. For example, RIP, OSPF, IS-IS, and BGP multiple instances.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /network_instance/instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: List of VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Some software features can be bound to multiple VPN instances so that multiple instances can provide a same feature. For example, RIP, OSPF, IS-IS, and BGP multiple instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

  global_ = __builtin__.property(_get_global_, _set_global_) # type: yc_global__huawei_network_instance__network_instance_global
  instances = __builtin__.property(_get_instances, _set_instances) # type: yc_instances_huawei_network_instance__network_instance_instances


  _pyangbind_elements = OrderedDict([('global_', global_), ('instances', instances), ])


class huawei_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /huawei-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instance',)

  _yang_name = 'huawei-network-instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instance = YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instance (container)

    YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

  network_instance = __builtin__.property(_get_network_instance, _set_network_instance) # type: yc_network_instance_huawei_network_instance__network_instance


  _pyangbind_elements = OrderedDict([('network_instance', network_instance), ])


class yc_check_rt_id_huawei_ospfv2__ospfv2_check_rt_id(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2/check-rt-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure automatic modification of conflicted router IDs. If enable, check and resolve OSPF router ID conflict.
  """
  __slots__ = ('_path_helper', '_extmethods', '__conflict_flag',)

  _yang_name = 'check-rt-id'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__conflict_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="conflict-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2', 'check-rt-id']

  def _get_conflict_flag(self):
    """
    Getter method for conflict_flag, mapped from YANG variable /ospfv2/check_rt_id/conflict_flag (boolean)

    YANG Description: Enable/disable automatic modification of conflicted router IDs. If enable, check and resolve OSPF router ID conflict.
    """
    return self.__conflict_flag
      
  def _set_conflict_flag(self, v, load=False):
    """
    Setter method for conflict_flag, mapped from YANG variable /ospfv2/check_rt_id/conflict_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conflict_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conflict_flag() directly.

    YANG Description: Enable/disable automatic modification of conflicted router IDs. If enable, check and resolve OSPF router ID conflict.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="conflict-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conflict_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="conflict-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__conflict_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conflict_flag(self):
    self.__conflict_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="conflict-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  conflict_flag = __builtin__.property(_get_conflict_flag, _set_conflict_flag)


  _pyangbind_elements = OrderedDict([('conflict_flag', conflict_flag), ])


class yc_session_car_huawei_ospfv2__ospfv2_session_car(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2/session-car. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF Session CAR.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__cir_interval','__cbs_interval','__pir_interval','__pbs_interval',)

  _yang_name = 'session-car'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__cir_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="cir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__cbs_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="cbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__pir_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16000), is_leaf=True, yang_name="pir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    self.__pbs_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(9000000), is_leaf=True, yang_name="pbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2', 'session-car']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /ospfv2/session_car/enable (boolean)

    YANG Description: Enable/disable OSPF Session CAR.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /ospfv2/session_car/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable OSPF Session CAR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_cir_interval(self):
    """
    Getter method for cir_interval, mapped from YANG variable /ospfv2/session_car/cir_interval (uint32)

    YANG Description: Specify the Session CAR CIR interval.
    """
    return self.__cir_interval
      
  def _set_cir_interval(self, v, load=False):
    """
    Setter method for cir_interval, mapped from YANG variable /ospfv2/session_car/cir_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cir_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cir_interval() directly.

    YANG Description: Specify the Session CAR CIR interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="cir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cir_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="cir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cir_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cir_interval(self):
    self.__cir_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(8), is_leaf=True, yang_name="cir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_cbs_interval(self):
    """
    Getter method for cbs_interval, mapped from YANG variable /ospfv2/session_car/cbs_interval (uint32)

    YANG Description: Specify the Session CAR CBS interval.
    """
    return self.__cbs_interval
      
  def _set_cbs_interval(self, v, load=False):
    """
    Setter method for cbs_interval, mapped from YANG variable /ospfv2/session_car/cbs_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cbs_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cbs_interval() directly.

    YANG Description: Specify the Session CAR CBS interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="cbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cbs_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="cbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__cbs_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cbs_interval(self):
    self.__cbs_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100000), is_leaf=True, yang_name="cbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_pir_interval(self):
    """
    Getter method for pir_interval, mapped from YANG variable /ospfv2/session_car/pir_interval (uint32)

    YANG Description: Specify the Session CAR PIR interval.
    """
    return self.__pir_interval
      
  def _set_pir_interval(self, v, load=False):
    """
    Setter method for pir_interval, mapped from YANG variable /ospfv2/session_car/pir_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pir_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pir_interval() directly.

    YANG Description: Specify the Session CAR PIR interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16000), is_leaf=True, yang_name="pir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pir_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16000), is_leaf=True, yang_name="pir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__pir_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pir_interval(self):
    self.__pir_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(16000), is_leaf=True, yang_name="pir-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)


  def _get_pbs_interval(self):
    """
    Getter method for pbs_interval, mapped from YANG variable /ospfv2/session_car/pbs_interval (uint32)

    YANG Description: Specify the Session CAR PBS interval.
    """
    return self.__pbs_interval
      
  def _set_pbs_interval(self, v, load=False):
    """
    Setter method for pbs_interval, mapped from YANG variable /ospfv2/session_car/pbs_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pbs_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pbs_interval() directly.

    YANG Description: Specify the Session CAR PBS interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(9000000), is_leaf=True, yang_name="pbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pbs_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(9000000), is_leaf=True, yang_name="pbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)""",
        })

    self.__pbs_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pbs_interval(self):
    self.__pbs_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..10000000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(9000000), is_leaf=True, yang_name="pbs-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint32', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  cir_interval = __builtin__.property(_get_cir_interval, _set_cir_interval)
  cbs_interval = __builtin__.property(_get_cbs_interval, _set_cbs_interval)
  pir_interval = __builtin__.property(_get_pir_interval, _set_pir_interval)
  pbs_interval = __builtin__.property(_get_pbs_interval, _set_pbs_interval)


  _pyangbind_elements = OrderedDict([('enable', enable), ('cir_interval', cir_interval), ('cbs_interval', cbs_interval), ('pir_interval', pir_interval), ('pbs_interval', pbs_interval), ])


class yc_maxage_lsa_protect_huawei_ospfv2__ospfv2_maxage_lsa_protect(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2/maxage-lsa-protect. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure auto protect of purge LSA error for OSPF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__disable',)

  _yang_name = 'maxage-lsa-protect'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2', 'maxage-lsa-protect']

  def _get_disable(self):
    """
    Getter method for disable, mapped from YANG variable /ospfv2/maxage_lsa_protect/disable (boolean)

    YANG Description: Enable/disable auto protect of purge LSA error for OSPF.
    """
    return self.__disable
      
  def _set_disable(self, v, load=False):
    """
    Setter method for disable, mapped from YANG variable /ospfv2/maxage_lsa_protect/disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable() directly.

    YANG Description: Enable/disable auto protect of purge LSA error for OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable(self):
    self.__disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  disable = __builtin__.property(_get_disable, _set_disable)


  _pyangbind_elements = OrderedDict([('disable', disable), ])


class yc_suppress_flap_intf_huawei_ospfv2__ospfv2_suppress_flap_intf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2/suppress-flap-intf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF suppress flapping interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__disable',)

  _yang_name = 'suppress-flap-intf'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2', 'suppress-flap-intf']

  def _get_disable(self):
    """
    Getter method for disable, mapped from YANG variable /ospfv2/suppress_flap_intf/disable (boolean)

    YANG Description: Enable/disable cancel the current setting or default setting.
    """
    return self.__disable
      
  def _set_disable(self, v, load=False):
    """
    Setter method for disable, mapped from YANG variable /ospfv2/suppress_flap_intf/disable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disable() directly.

    YANG Description: Enable/disable cancel the current setting or default setting.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__disable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disable(self):
    self.__disable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="disable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)

  disable = __builtin__.property(_get_disable, _set_disable)


  _pyangbind_elements = OrderedDict([('disable', disable), ])


class yc_mib_binding_huawei_ospfv2__ospfv2_mib_binding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2/mib-binding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure MIB binding a OSPF process.
  """
  __slots__ = ('_path_helper', '_extmethods', '__process_id',)

  _yang_name = 'mib-binding'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__process_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2', 'mib-binding']

  def _get_process_id(self):
    """
    Getter method for process_id, mapped from YANG variable /ospfv2/mib_binding/process_id (leafref)

    YANG Description: Process ID.
    """
    return self.__process_id
      
  def _set_process_id(self, v, load=False):
    """
    Setter method for process_id, mapped from YANG variable /ospfv2/mib_binding/process_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process_id() directly.

    YANG Description: Process ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)""",
        })

    self.__process_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process_id(self):
    self.__process_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='leafref', is_config=True)

  process_id = __builtin__.property(_get_process_id, _set_process_id)


  _pyangbind_elements = OrderedDict([('process_id', process_id), ])


class yc_flush_source_trace_huawei_ospfv2__ospfv2_flush_source_trace(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2/flush-source-trace. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPF flush source trace globally.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__vlink_enable','__port','__vlink_port',)

  _yang_name = 'flush-source-trace'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__vlink_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="vlink-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50122), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    self.__vlink_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50123), is_leaf=True, yang_name="vlink-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2', 'flush-source-trace']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /ospfv2/flush_source_trace/enable (boolean)

    YANG Description: Enable/disable OSPF flush source trace globally.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /ospfv2/flush_source_trace/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable/disable OSPF flush source trace globally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_vlink_enable(self):
    """
    Getter method for vlink_enable, mapped from YANG variable /ospfv2/flush_source_trace/vlink_enable (boolean)

    YANG Description: Enable/disable OSPF vlink flush source trace globally.
    """
    return self.__vlink_enable
      
  def _set_vlink_enable(self, v, load=False):
    """
    Setter method for vlink_enable, mapped from YANG variable /ospfv2/flush_source_trace/vlink_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlink_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlink_enable() directly.

    YANG Description: Enable/disable OSPF vlink flush source trace globally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="vlink-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlink_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="vlink-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)""",
        })

    self.__vlink_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlink_enable(self):
    self.__vlink_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="vlink-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='boolean', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /ospfv2/flush_source_trace/port (uint16)

    YANG Description: Set OSPF flush source trace port allocated by huawei-pp4.The related CLI is 'display ip port info | inc UDP'.
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /ospfv2/flush_source_trace/port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Set OSPF flush source trace port allocated by huawei-pp4.The related CLI is 'display ip port info | inc UDP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50122), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50122), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50122), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)


  def _get_vlink_port(self):
    """
    Getter method for vlink_port, mapped from YANG variable /ospfv2/flush_source_trace/vlink_port (uint16)

    YANG Description: Set OSPF vlink flush source trace port allocated by huawei-pp4.The related CLI is 'display ip port info | inc UDP'.
    """
    return self.__vlink_port
      
  def _set_vlink_port(self, v, load=False):
    """
    Setter method for vlink_port, mapped from YANG variable /ospfv2/flush_source_trace/vlink_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlink_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlink_port() directly.

    YANG Description: Set OSPF vlink flush source trace port allocated by huawei-pp4.The related CLI is 'display ip port info | inc UDP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50123), is_leaf=True, yang_name="vlink-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlink_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50123), is_leaf=True, yang_name="vlink-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)""",
        })

    self.__vlink_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlink_port(self):
    self.__vlink_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1025..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(50123), is_leaf=True, yang_name="vlink-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='uint16', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  vlink_enable = __builtin__.property(_get_vlink_enable, _set_vlink_enable)
  port = __builtin__.property(_get_port, _set_port)
  vlink_port = __builtin__.property(_get_vlink_port, _set_vlink_port)


  _pyangbind_elements = OrderedDict([('enable', enable), ('vlink_enable', vlink_enable), ('port', port), ('vlink_port', vlink_port), ])


class yc_ospfv2_huawei_ospfv2__ospfv2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /ospfv2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure OSPFv2 config.
  """
  __slots__ = ('_path_helper', '_extmethods', '__check_rt_id','__session_car','__maxage_lsa_protect','__suppress_flap_intf','__mib_binding','__flush_source_trace',)

  _yang_name = 'ospfv2'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__check_rt_id = YANGDynClass(base=yc_check_rt_id_huawei_ospfv2__ospfv2_check_rt_id, is_container='container', yang_name="check-rt-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__session_car = YANGDynClass(base=yc_session_car_huawei_ospfv2__ospfv2_session_car, is_container='container', yang_name="session-car", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__maxage_lsa_protect = YANGDynClass(base=yc_maxage_lsa_protect_huawei_ospfv2__ospfv2_maxage_lsa_protect, is_container='container', yang_name="maxage-lsa-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__suppress_flap_intf = YANGDynClass(base=yc_suppress_flap_intf_huawei_ospfv2__ospfv2_suppress_flap_intf, is_container='container', yang_name="suppress-flap-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__mib_binding = YANGDynClass(base=yc_mib_binding_huawei_ospfv2__ospfv2_mib_binding, is_container='container', yang_name="mib-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    self.__flush_source_trace = YANGDynClass(base=yc_flush_source_trace_huawei_ospfv2__ospfv2_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ospfv2']

  def _get_check_rt_id(self):
    """
    Getter method for check_rt_id, mapped from YANG variable /ospfv2/check_rt_id (container)

    YANG Description: Configure automatic modification of conflicted router IDs. If enable, check and resolve OSPF router ID conflict.
    """
    return self.__check_rt_id
      
  def _set_check_rt_id(self, v, load=False):
    """
    Setter method for check_rt_id, mapped from YANG variable /ospfv2/check_rt_id (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_check_rt_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_check_rt_id() directly.

    YANG Description: Configure automatic modification of conflicted router IDs. If enable, check and resolve OSPF router ID conflict.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_check_rt_id_huawei_ospfv2__ospfv2_check_rt_id, is_container='container', yang_name="check-rt-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """check_rt_id must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_check_rt_id_huawei_ospfv2__ospfv2_check_rt_id, is_container='container', yang_name="check-rt-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__check_rt_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_check_rt_id(self):
    self.__check_rt_id = YANGDynClass(base=yc_check_rt_id_huawei_ospfv2__ospfv2_check_rt_id, is_container='container', yang_name="check-rt-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_session_car(self):
    """
    Getter method for session_car, mapped from YANG variable /ospfv2/session_car (container)

    YANG Description: Configure OSPF Session CAR.
    """
    return self.__session_car
      
  def _set_session_car(self, v, load=False):
    """
    Setter method for session_car, mapped from YANG variable /ospfv2/session_car (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_car is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_car() directly.

    YANG Description: Configure OSPF Session CAR.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_session_car_huawei_ospfv2__ospfv2_session_car, is_container='container', yang_name="session-car", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_car must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_session_car_huawei_ospfv2__ospfv2_session_car, is_container='container', yang_name="session-car", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__session_car = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_car(self):
    self.__session_car = YANGDynClass(base=yc_session_car_huawei_ospfv2__ospfv2_session_car, is_container='container', yang_name="session-car", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_maxage_lsa_protect(self):
    """
    Getter method for maxage_lsa_protect, mapped from YANG variable /ospfv2/maxage_lsa_protect (container)

    YANG Description: Configure auto protect of purge LSA error for OSPF.
    """
    return self.__maxage_lsa_protect
      
  def _set_maxage_lsa_protect(self, v, load=False):
    """
    Setter method for maxage_lsa_protect, mapped from YANG variable /ospfv2/maxage_lsa_protect (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxage_lsa_protect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxage_lsa_protect() directly.

    YANG Description: Configure auto protect of purge LSA error for OSPF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_maxage_lsa_protect_huawei_ospfv2__ospfv2_maxage_lsa_protect, is_container='container', yang_name="maxage-lsa-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxage_lsa_protect must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_maxage_lsa_protect_huawei_ospfv2__ospfv2_maxage_lsa_protect, is_container='container', yang_name="maxage-lsa-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__maxage_lsa_protect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxage_lsa_protect(self):
    self.__maxage_lsa_protect = YANGDynClass(base=yc_maxage_lsa_protect_huawei_ospfv2__ospfv2_maxage_lsa_protect, is_container='container', yang_name="maxage-lsa-protect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_suppress_flap_intf(self):
    """
    Getter method for suppress_flap_intf, mapped from YANG variable /ospfv2/suppress_flap_intf (container)

    YANG Description: Configure OSPF suppress flapping interface.
    """
    return self.__suppress_flap_intf
      
  def _set_suppress_flap_intf(self, v, load=False):
    """
    Setter method for suppress_flap_intf, mapped from YANG variable /ospfv2/suppress_flap_intf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_flap_intf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_flap_intf() directly.

    YANG Description: Configure OSPF suppress flapping interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_suppress_flap_intf_huawei_ospfv2__ospfv2_suppress_flap_intf, is_container='container', yang_name="suppress-flap-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_flap_intf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_suppress_flap_intf_huawei_ospfv2__ospfv2_suppress_flap_intf, is_container='container', yang_name="suppress-flap-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__suppress_flap_intf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_flap_intf(self):
    self.__suppress_flap_intf = YANGDynClass(base=yc_suppress_flap_intf_huawei_ospfv2__ospfv2_suppress_flap_intf, is_container='container', yang_name="suppress-flap-intf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_mib_binding(self):
    """
    Getter method for mib_binding, mapped from YANG variable /ospfv2/mib_binding (container)

    YANG Description: Configure MIB binding a OSPF process.
    """
    return self.__mib_binding
      
  def _set_mib_binding(self, v, load=False):
    """
    Setter method for mib_binding, mapped from YANG variable /ospfv2/mib_binding (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mib_binding is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mib_binding() directly.

    YANG Description: Configure MIB binding a OSPF process.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mib_binding_huawei_ospfv2__ospfv2_mib_binding, is_container='container', yang_name="mib-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mib_binding must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mib_binding_huawei_ospfv2__ospfv2_mib_binding, is_container='container', yang_name="mib-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__mib_binding = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mib_binding(self):
    self.__mib_binding = YANGDynClass(base=yc_mib_binding_huawei_ospfv2__ospfv2_mib_binding, is_container='container', yang_name="mib-binding", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)


  def _get_flush_source_trace(self):
    """
    Getter method for flush_source_trace, mapped from YANG variable /ospfv2/flush_source_trace (container)

    YANG Description: Configure OSPF flush source trace globally.
    """
    return self.__flush_source_trace
      
  def _set_flush_source_trace(self, v, load=False):
    """
    Setter method for flush_source_trace, mapped from YANG variable /ospfv2/flush_source_trace (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flush_source_trace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flush_source_trace() directly.

    YANG Description: Configure OSPF flush source trace globally.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_flush_source_trace_huawei_ospfv2__ospfv2_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flush_source_trace must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_flush_source_trace_huawei_ospfv2__ospfv2_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__flush_source_trace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flush_source_trace(self):
    self.__flush_source_trace = YANGDynClass(base=yc_flush_source_trace_huawei_ospfv2__ospfv2_flush_source_trace, is_container='container', yang_name="flush-source-trace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  check_rt_id = __builtin__.property(_get_check_rt_id, _set_check_rt_id) # type: yc_check_rt_id_huawei_ospfv2__ospfv2_check_rt_id
  session_car = __builtin__.property(_get_session_car, _set_session_car) # type: yc_session_car_huawei_ospfv2__ospfv2_session_car
  maxage_lsa_protect = __builtin__.property(_get_maxage_lsa_protect, _set_maxage_lsa_protect) # type: yc_maxage_lsa_protect_huawei_ospfv2__ospfv2_maxage_lsa_protect
  suppress_flap_intf = __builtin__.property(_get_suppress_flap_intf, _set_suppress_flap_intf) # type: yc_suppress_flap_intf_huawei_ospfv2__ospfv2_suppress_flap_intf
  mib_binding = __builtin__.property(_get_mib_binding, _set_mib_binding) # type: yc_mib_binding_huawei_ospfv2__ospfv2_mib_binding
  flush_source_trace = __builtin__.property(_get_flush_source_trace, _set_flush_source_trace) # type: yc_flush_source_trace_huawei_ospfv2__ospfv2_flush_source_trace


  _pyangbind_elements = OrderedDict([('check_rt_id', check_rt_id), ('session_car', session_car), ('maxage_lsa_protect', maxage_lsa_protect), ('suppress_flap_intf', suppress_flap_intf), ('mib_binding', mib_binding), ('flush_source_trace', flush_source_trace), ])


class huawei_ospfv2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2 - based on the path /huawei-ospfv2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OSPFv2.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ospfv2',)

  _yang_name = 'huawei-ospfv2'
  _yang_namespace = 'urn:huawei:yang:huawei-ospfv2'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ospfv2 = YANGDynClass(base=yc_ospfv2_huawei_ospfv2__ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ospfv2(self):
    """
    Getter method for ospfv2, mapped from YANG variable /ospfv2 (container)

    YANG Description: Configure OSPFv2 config.
    """
    return self.__ospfv2
      
  def _set_ospfv2(self, v, load=False):
    """
    Setter method for ospfv2, mapped from YANG variable /ospfv2 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospfv2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospfv2() directly.

    YANG Description: Configure OSPFv2 config.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ospfv2_huawei_ospfv2__ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospfv2 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ospfv2_huawei_ospfv2__ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)""",
        })

    self.__ospfv2 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospfv2(self):
    self.__ospfv2 = YANGDynClass(base=yc_ospfv2_huawei_ospfv2__ospfv2, is_container='container', yang_name="ospfv2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ospfv2', defining_module='huawei-ospfv2', yang_type='container', is_config=True)

  ospfv2 = __builtin__.property(_get_ospfv2, _set_ospfv2) # type: yc_ospfv2_huawei_ospfv2__ospfv2


  _pyangbind_elements = OrderedDict([('ospfv2', ospfv2), ])


class huawei_ospfv2_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ospfv2-type - based on the path /huawei-ospfv2-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OSPFv2 type.
  """
  _pyangbind_elements = {}

  

