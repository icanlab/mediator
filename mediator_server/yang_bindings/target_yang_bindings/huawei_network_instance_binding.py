# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_global__huawei_bgp__bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration for the BGP router.
  """
  __slots__ = ('_path_helper', '_extmethods', '__yang_enable',)

  _yang_name = 'global'
  _yang_namespace = 'urn:huawei:yang:huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__yang_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="yang-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'global']

  def _get_yang_enable(self):
    """
    Getter method for yang_enable, mapped from YANG variable /bgp/global/yang_enable (boolean)

    YANG Description: Enable BGP yang mode.
    """
    return self.__yang_enable
      
  def _set_yang_enable(self, v, load=False):
    """
    Setter method for yang_enable, mapped from YANG variable /bgp/global/yang_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_yang_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_yang_enable() directly.

    YANG Description: Enable BGP yang mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="yang-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """yang_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="yang-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__yang_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_yang_enable(self):
    self.__yang_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="yang-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  yang_enable = __builtin__.property(_get_yang_enable, _set_yang_enable)


  _pyangbind_elements = OrderedDict([('yang_enable', yang_enable), ])


class yc_base_process_huawei_bgp__bgp_base_process(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp/base-process. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__as_',)

  _yang_name = 'base-process'
  _yang_namespace = 'urn:huawei:yang:huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp', 'base-process']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /bgp/base_process/enable (boolean)

    YANG Description: Start or stop BGP function.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /bgp/base_process/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Start or stop BGP function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)


  def _get_as_(self):
    """
    Getter method for as_, mapped from YANG variable /bgp/base_process/as (as-number-validate)

    YANG Description: The object cannot be deleted or modified.
    """
    return self.__as_
      
  def _set_as_(self, v, load=False):
    """
    Setter method for as_, mapped from YANG variable /bgp/base_process/as (as-number-validate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_() directly.

    YANG Description: The object cannot be deleted or modified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_ must be of a type compatible with as-number-validate""",
          'defined-type': "huawei-bgp:as-number-validate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)""",
        })

    self.__as_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_(self):
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  as_ = __builtin__.property(_get_as_, _set_as_)


  _pyangbind_elements = OrderedDict([('enable', enable), ('as_', as_), ])


class yc_bgp_huawei_bgp__bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems,
Universal BGP configurations that contain the basic BGP configurations and the query information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_','__base_process',)

  _yang_name = 'bgp'
  _yang_namespace = 'urn:huawei:yang:huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_ = YANGDynClass(base=yc_global__huawei_bgp__bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__base_process = YANGDynClass(base=yc_base_process_huawei_bgp__bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bgp']

  def _get_global_(self):
    """
    Getter method for global_, mapped from YANG variable /bgp/global (container)

    YANG Description: Global configuration for the BGP router.
    """
    return self.__global_
      
  def _set_global_(self, v, load=False):
    """
    Setter method for global_, mapped from YANG variable /bgp/global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_() directly.

    YANG Description: Global configuration for the BGP router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global__huawei_bgp__bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global__huawei_bgp__bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__global_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_(self):
    self.__global_ = YANGDynClass(base=yc_global__huawei_bgp__bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_base_process(self):
    """
    Getter method for base_process, mapped from YANG variable /bgp/base_process (container)

    YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
    """
    return self.__base_process
      
  def _set_base_process(self, v, load=False):
    """
    Setter method for base_process, mapped from YANG variable /bgp/base_process (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_base_process is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_base_process() directly.

    YANG Description: Site containing the global BGP information, such as the protocol version, AS number, and system identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_base_process_huawei_bgp__bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """base_process must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_base_process_huawei_bgp__bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__base_process = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_base_process(self):
    self.__base_process = YANGDynClass(base=yc_base_process_huawei_bgp__bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  global_ = __builtin__.property(_get_global_, _set_global_) # type: yc_global__huawei_bgp__bgp_global
  base_process = __builtin__.property(_get_base_process, _set_base_process) # type: yc_base_process_huawei_bgp__bgp_base_process


  _pyangbind_elements = OrderedDict([('global_', global_), ('base_process', base_process), ])


class huawei_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp - based on the path /huawei-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description:  BGP systems.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bgp',)

  _yang_name = 'huawei-bgp'
  _yang_namespace = 'urn:huawei:yang:huawei-bgp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bgp = YANGDynClass(base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /bgp (container)

    YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems,
Universal BGP configurations that contain the basic BGP configurations and the query information.
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Inter-AS routing protocol that exchanges Network Layer Reachability Information (NLRI) with other BGP systems,
Universal BGP configurations that contain the basic BGP configurations and the query information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=yc_bgp_huawei_bgp__bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  bgp = __builtin__.property(_get_bgp, _set_bgp) # type: yc_bgp_huawei_bgp__bgp


  _pyangbind_elements = OrderedDict([('bgp', bgp), ])


class huawei_bgp_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-type - based on the path /huawei-bgp-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines type definitions associated with the huawei-bgp modules.
  """
  _pyangbind_elements = {}

  

class huawei_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-bgp-common - based on the path /huawei-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description:  BGP systems.
  """
  _pyangbind_elements = {}

  

class yc_network_route_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes_network_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/afs/af/ipv4-unicast/network-routes/network-route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Create a summarized route in the BGP routing table. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__mask_length','__policy_name',)

  _yang_name = 'network-route'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    self.__policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policy-name", parent=self, choice=('policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'afs', 'af', 'ipv4-unicast', 'network-routes', 'network-route']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route/address (inet:ipv4-address-no-zone)

    YANG Description: Sroute.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route/address (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Sroute.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_mask_length(self):
    """
    Getter method for mask_length, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route/mask_length (uint8)

    YANG Description: The mask length ranges from 0 to 32 for an IPv4 address.
    """
    return self.__mask_length
      
  def _set_mask_length(self, v, load=False):
    """
    Setter method for mask_length, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route/mask_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask_length() directly.

    YANG Description: The mask length ranges from 0 to 32 for an IPv4 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__mask_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask_length(self):
    self.__mask_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="mask-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='uint8', is_config=True)


  def _get_policy_name(self):
    """
    Getter method for policy_name, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route/policy_name (string)

    YANG Description: Specify the route policy.
    """
    return self.__policy_name
      
  def _set_policy_name(self, v, load=False):
    """
    Setter method for policy_name, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route/policy_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_name() directly.

    YANG Description: Specify the route policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="policy-name", parent=self, choice=('policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policy-name", parent=self, choice=('policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__policy_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_name(self):
    self.__policy_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="policy-name", parent=self, choice=('policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  mask_length = __builtin__.property(_get_mask_length, _set_mask_length)
  policy_name = __builtin__.property(_get_policy_name, _set_policy_name)

  __choices__ = {'policy-type': {'rtp-ref': ['policy_name']}}
  _pyangbind_elements = OrderedDict([('address', address), ('mask_length', mask_length), ('policy_name', policy_name), ])


class yc_network_routes_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/afs/af/ipv4-unicast/network-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of summarized routes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_route',)

  _yang_name = 'network-routes'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_route = YANGDynClass(base=YANGListType("address mask_length",yc_network_route_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes_network_route, yang_name="network-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address mask-length', extensions=None), is_container='list', yang_name="network-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'afs', 'af', 'ipv4-unicast', 'network-routes']

  def _get_network_route(self):
    """
    Getter method for network_route, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route (list)

    YANG Description: Create a summarized route in the BGP routing table. 
    """
    return self.__network_route
      
  def _set_network_route(self, v, load=False):
    """
    Setter method for network_route, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes/network_route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_route() directly.

    YANG Description: Create a summarized route in the BGP routing table. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address mask_length",yc_network_route_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes_network_route, yang_name="network-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address mask-length', extensions=None), is_container='list', yang_name="network-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address mask_length",yc_network_route_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes_network_route, yang_name="network-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address mask-length', extensions=None), is_container='list', yang_name="network-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__network_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_route(self):
    self.__network_route = YANGDynClass(base=YANGListType("address mask_length",yc_network_route_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes_network_route, yang_name="network-route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address mask-length', extensions=None), is_container='list', yang_name="network-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  network_route = __builtin__.property(_get_network_route, _set_network_route) # type: yc_network_route_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes_network_route


  _pyangbind_elements = OrderedDict([('network_route', network_route), ])


class yc_ipv4_unicast_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/afs/af/ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 unicast configuration options.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_routes',)

  _yang_name = 'ipv4-unicast'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_routes = YANGDynClass(base=yc_network_routes_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes, is_container='container', yang_name="network-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'afs', 'af', 'ipv4-unicast']

  def _get_network_routes(self):
    """
    Getter method for network_routes, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes (container)

    YANG Description: List of summarized routes.
    """
    return self.__network_routes
      
  def _set_network_routes(self, v, load=False):
    """
    Setter method for network_routes, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast/network_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_routes() directly.

    YANG Description: List of summarized routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_routes_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes, is_container='container', yang_name="network-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_routes_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes, is_container='container', yang_name="network-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__network_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_routes(self):
    self.__network_routes = YANGDynClass(base=yc_network_routes_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes, is_container='container', yang_name="network-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  network_routes = __builtin__.property(_get_network_routes, _set_network_routes) # type: yc_network_routes_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast_network_routes


  _pyangbind_elements = OrderedDict([('network_routes', network_routes), ])


class yc_ipv4_vpn_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_vpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/afs/af/ipv4-vpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 vpnv4 configuration options.
  """
  __slots__ = ('_path_helper', '_extmethods', '__policy_vpntarget',)

  _yang_name = 'ipv4-vpn'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__policy_vpntarget = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policy-vpntarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'afs', 'af', 'ipv4-vpn']

  def _get_policy_vpntarget(self):
    """
    Getter method for policy_vpntarget, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_vpn/policy_vpntarget (boolean)

    YANG Description: the ASBR MP-EBGP inter-AS L2VPN solution in Kompella mode.
    """
    return self.__policy_vpntarget
      
  def _set_policy_vpntarget(self, v, load=False):
    """
    Setter method for policy_vpntarget, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_vpn/policy_vpntarget (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_vpntarget is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_vpntarget() directly.

    YANG Description: the ASBR MP-EBGP inter-AS L2VPN solution in Kompella mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policy-vpntarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_vpntarget must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policy-vpntarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__policy_vpntarget = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_vpntarget(self):
    self.__policy_vpntarget = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="policy-vpntarget", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='boolean', is_config=True)

  policy_vpntarget = __builtin__.property(_get_policy_vpntarget, _set_policy_vpntarget)


  _pyangbind_elements = OrderedDict([('policy_vpntarget', policy_vpntarget), ])


class yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/afs/af. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP address family instance. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__ipv4_unicast','__ipv4_vpn',)

  _yang_name = 'af'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__ipv4_vpn = YANGDynClass(base=yc_ipv4_vpn_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_vpn, is_container='container', yang_name="ipv4-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'afs', 'af']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/type (bgp:af-type)

    YANG Description: Address family type of a BGP instance.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/type (bgp:af-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Address family type of a BGP instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with bgp:af-type""",
          'defined-type': "bgp:af-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)


  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast (container)

    YANG Description: IPv4 unicast configuration options.
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: IPv4 unicast configuration options.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_unicast_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_unicast_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_ipv4_vpn(self):
    """
    Getter method for ipv4_vpn, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_vpn (container)

    YANG Description: IPv4 vpnv4 configuration options.
    """
    return self.__ipv4_vpn
      
  def _set_ipv4_vpn(self, v, load=False):
    """
    Setter method for ipv4_vpn, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af/ipv4_vpn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_vpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_vpn() directly.

    YANG Description: IPv4 vpnv4 configuration options.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_vpn_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_vpn, is_container='container', yang_name="ipv4-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_vpn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_vpn_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_vpn, is_container='container', yang_name="ipv4-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_vpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_vpn(self):
    self.__ipv4_vpn = YANGDynClass(base=yc_ipv4_vpn_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_vpn, is_container='container', yang_name="ipv4-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  ipv4_unicast = __builtin__.property(_get_ipv4_unicast, _set_ipv4_unicast) # type: yc_ipv4_unicast_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_unicast
  ipv4_vpn = __builtin__.property(_get_ipv4_vpn, _set_ipv4_vpn) # type: yc_ipv4_vpn_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af_ipv4_vpn


  _pyangbind_elements = OrderedDict([('type', type), ('ipv4_unicast', ipv4_unicast), ('ipv4_vpn', ipv4_vpn), ])


class yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/afs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP address family instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__af',)

  _yang_name = 'afs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'afs']

  def _get_af(self):
    """
    Getter method for af, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af (list)

    YANG Description: BGP address family instance. 
    """
    return self.__af
      
  def _set_af(self, v, load=False):
    """
    Setter method for af, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs/af (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_af is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_af() directly.

    YANG Description: BGP address family instance. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """af must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__af = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_af(self):
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  af = __builtin__.property(_get_af, _set_af) # type: yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs_af


  _pyangbind_elements = OrderedDict([('af', af), ])


class yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs_af(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/peers/peer/afs/af. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peer in a specified address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type',)

  _yang_name = 'af'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'peers', 'peer', 'afs', 'af']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/afs/af/type (bgp:af-type)

    YANG Description: Specify the address family type to set the peer enable.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/afs/af/type (bgp:af-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specify the address family type to set the peer enable.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with bgp:af-type""",
          'defined-type': "bgp:af-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4uni': {'value': 1}, 'ipv4multi': {'value': 2}, 'ipv4vpn': {'value': 3}, 'ipv4labeluni': {'value': 4}, 'ipv6uni': {'value': 5}, 'ipv6vpn': {'value': 6}, 'ipv4flow': {'value': 7}, 'l2vpnad': {'value': 8}, 'evpn': {'value': 9}, 'mvpn': {'value': 10}, 'vpntarget': {'value': 11}, 'ipv4vpnmcast': {'value': 12}, 'ls': {'value': 13}, 'mdt': {'value': 14}, 'ipv6flow': {'value': 15}, 'mvpnv6': {'value': 16}, 'vpnv4flow': {'value': 17}, 'vpnv6flow': {'value': 18}, 'rpd': {'value': 19}, 'ipv4srpolicy': {'value': 20}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='bgp:af-type', is_config=True)

  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('type', type), ])


class yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/peers/peer/afs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Peers in a specified address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__af',)

  _yang_name = 'afs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'peers', 'peer', 'afs']

  def _get_af(self):
    """
    Getter method for af, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/afs/af (list)

    YANG Description: Peer in a specified address family.
    """
    return self.__af
      
  def _set_af(self, v, load=False):
    """
    Setter method for af, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/afs/af (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_af is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_af() directly.

    YANG Description: Peer in a specified address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """af must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__af = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_af(self):
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  af = __builtin__.property(_get_af, _set_af) # type: yc_af_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs_af


  _pyangbind_elements = OrderedDict([('af', af), ])


class yc_peer_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/peers/peer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurations of a single BGP peer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address','__remote_as','__local_if_name','__afs',)

  _yang_name = 'peer'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)
    self.__local_if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'peers', 'peer']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/address (inet:ip-address-no-zone)

    YANG Description: Connection address of a peer, which can be an IPv4 or IPv6 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/address (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Connection address of a peer, which can be an IPv4 or IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ip-address-no-zone', is_config=True)


  def _get_remote_as(self):
    """
    Getter method for remote_as, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/remote_as (as-number-validate)

    YANG Description: AS number of a peer
    """
    return self.__remote_as
      
  def _set_remote_as(self, v, load=False):
    """
    Setter method for remote_as, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/remote_as (as-number-validate)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_as() directly.

    YANG Description: AS number of a peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_as must be of a type compatible with as-number-validate""",
          'defined-type': "huawei-bgp:as-number-validate",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)""",
        })

    self.__remote_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_as(self):
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]\\d{0,8})|([1-3]\\d{9})|(4[0-1]\\d{8})|(42[0-8]\\d{7})|(429[0-3]\\d{6})|(4294[0-8]\\d{5})|(42949[0-5]\\d{4})|(429496[0-6]\\d{3})|(4294967[0-1]\\d{2})|(42949672[0-8]\\d{1})|(429496729[0-5]))|((([1-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))[\\.](([0-9]\\d{0,3})|([1-5]\\d{4})|(6[0-4]\\d{3})|(65[0-4]\\d{2})|(655[0-2]\\d)|(6553[0-5]))))', 'length': ['1..11']}), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='as-number-validate', is_config=True)


  def _get_local_if_name(self):
    """
    Getter method for local_if_name, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/local_if_name (string)

    YANG Description: Name of a source interface that sends BGP packets. 
    """
    return self.__local_if_name
      
  def _set_local_if_name(self, v, load=False):
    """
    Setter method for local_if_name, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/local_if_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_if_name() directly.

    YANG Description: Name of a source interface that sends BGP packets. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="local-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_if_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)""",
        })

    self.__local_if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_if_name(self):
    self.__local_if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="local-if-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='string', is_config=True)


  def _get_afs(self):
    """
    Getter method for afs, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/afs (container)

    YANG Description: Peers in a specified address family.
    """
    return self.__afs
      
  def _set_afs(self, v, load=False):
    """
    Setter method for afs, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer/afs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afs() directly.

    YANG Description: Peers in a specified address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__afs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afs(self):
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  address = __builtin__.property(_get_address, _set_address)
  remote_as = __builtin__.property(_get_remote_as, _set_remote_as)
  local_if_name = __builtin__.property(_get_local_if_name, _set_local_if_name)
  afs = __builtin__.property(_get_afs, _set_afs) # type: yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer_afs


  _pyangbind_elements = OrderedDict([('address', address), ('remote_as', remote_as), ('local_if_name', local_if_name), ('afs', afs), ])


class yc_peers_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process/peers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer',)

  _yang_name = 'peers'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer = YANGDynClass(base=YANGListType("address",yc_peer_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process', 'peers']

  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer (list)

    YANG Description: Configurations of a single BGP peer.
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers/peer (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.

    YANG Description: Configurations of a single BGP peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address",yc_peer_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address",yc_peer_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=YANGListType("address",yc_peer_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer, yang_name="peer", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='list', is_config=True)

  peer = __builtin__.property(_get_peer, _set_peer) # type: yc_peer_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers_peer


  _pyangbind_elements = OrderedDict([('peer', peer), ])


class yc_base_process_huawei_network_instance__network_instance_instances_instance_bgp_base_process(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp/base-process. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure BGP instances. The _public_ instance cannot be deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__afs','__peers',)

  _yang_name = 'base-process'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    self.__peers = YANGDynClass(base=yc_peers_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp', 'base-process']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/router_id (inet:ipv4-address-no-zone)

    YANG Description: the system reselects a router ID.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: the system reselects a router ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_afs(self):
    """
    Getter method for afs, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs (container)

    YANG Description: List of BGP address family instances.
    """
    return self.__afs
      
  def _set_afs(self, v, load=False):
    """
    Setter method for afs, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/afs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afs() directly.

    YANG Description: List of BGP address family instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__afs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afs(self):
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)


  def _get_peers(self):
    """
    Getter method for peers, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers (container)

    YANG Description: List of BGP peers.
    """
    return self.__peers
      
  def _set_peers(self, v, load=False):
    """
    Setter method for peers, mapped from YANG variable /network_instance/instances/instance/bgp/base_process/peers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peers() directly.

    YANG Description: List of BGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peers_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peers_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__peers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peers(self):
    self.__peers = YANGDynClass(base=yc_peers_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers, is_container='container', yang_name="peers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  afs = __builtin__.property(_get_afs, _set_afs) # type: yc_afs_huawei_network_instance__network_instance_instances_instance_bgp_base_process_afs
  peers = __builtin__.property(_get_peers, _set_peers) # type: yc_peers_huawei_network_instance__network_instance_instances_instance_bgp_base_process_peers


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('afs', afs), ('peers', peers), ])


class yc_bgp_huawei_network_instance__network_instance_instances_instance_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bgp network instance configration. All nodes of private VPN Instance in this container can be used only when the value of the global BGP enabling node (/bgp:bgp/bgp:global/bgp:yang-enable) is set to true.
  """
  __slots__ = ('_path_helper', '_extmethods', '__base_process',)

  _yang_name = 'bgp'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__base_process = YANGDynClass(base=yc_base_process_huawei_network_instance__network_instance_instances_instance_bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'bgp']

  def _get_base_process(self):
    """
    Getter method for base_process, mapped from YANG variable /network_instance/instances/instance/bgp/base_process (container)

    YANG Description: Configure BGP instances. The _public_ instance cannot be deleted.
    """
    return self.__base_process
      
  def _set_base_process(self, v, load=False):
    """
    Setter method for base_process, mapped from YANG variable /network_instance/instances/instance/bgp/base_process (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_base_process is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_base_process() directly.

    YANG Description: Configure BGP instances. The _public_ instance cannot be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_base_process_huawei_network_instance__network_instance_instances_instance_bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """base_process must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_base_process_huawei_network_instance__network_instance_instances_instance_bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__base_process = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_base_process(self):
    self.__base_process = YANGDynClass(base=yc_base_process_huawei_network_instance__network_instance_instances_instance_bgp_base_process, is_container='container', yang_name="base-process", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  base_process = __builtin__.property(_get_base_process, _set_base_process) # type: yc_base_process_huawei_network_instance__network_instance_instances_instance_bgp_base_process


  _pyangbind_elements = OrderedDict([('base_process', base_process), ])


class yc_instance_huawei_network_instance__network_instance_instances_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VPN instances. 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__bgp',)

  _yang_name = 'instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    self.__bgp = YANGDynClass(base=yc_bgp_huawei_network_instance__network_instance_instances_instance_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instance/instances/instance/name (string)

    YANG Description: VPN instance name. It uniquely identifies a VPN instance. The name is a string of case-sensitive characters.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instance/instances/instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: VPN instance name. It uniquely identifies a VPN instance. The name is a string of case-sensitive characters.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)


  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /network_instance/instances/instance/bgp (container)

    YANG Description: Bgp network instance configration. All nodes of private VPN Instance in this container can be used only when the value of the global BGP enabling node (/bgp:bgp/bgp:global/bgp:yang-enable) is set to true.
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /network_instance/instances/instance/bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Bgp network instance configration. All nodes of private VPN Instance in this container can be used only when the value of the global BGP enabling node (/bgp:bgp/bgp:global/bgp:yang-enable) is set to true.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_huawei_network_instance__network_instance_instances_instance_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_huawei_network_instance__network_instance_instances_instance_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=yc_bgp_huawei_network_instance__network_instance_instances_instance_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-bgp', defining_module='huawei-bgp', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  bgp = __builtin__.property(_get_bgp, _set_bgp) # type: yc_bgp_huawei_network_instance__network_instance_instances_instance_bgp


  _pyangbind_elements = OrderedDict([('name', name), ('bgp', bgp), ])


class yc_instances_huawei_network_instance__network_instance_instances(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VPN instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instance',)

  _yang_name = 'instances'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instance = YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances']

  def _get_instance(self):
    """
    Getter method for instance, mapped from YANG variable /network_instance/instances/instance (list)

    YANG Description: VPN instances. 
    """
    return self.__instance
      
  def _set_instance(self, v, load=False):
    """
    Setter method for instance, mapped from YANG variable /network_instance/instances/instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance() directly.

    YANG Description: VPN instances. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)""",
        })

    self.__instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance(self):
    self.__instance = YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)

  instance = __builtin__.property(_get_instance, _set_instance) # type: yc_instance_huawei_network_instance__network_instance_instances_instance


  _pyangbind_elements = OrderedDict([('instance', instance), ])


class yc_network_instance_huawei_network_instance__network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Layer 3 Virtual Private Network (L3VPN). 
  """
  __slots__ = ('_path_helper', '_extmethods', '__instances',)

  _yang_name = 'network-instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instances = YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance']

  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /network_instance/instances (container)

    YANG Description: List of VPN instances.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /network_instance/instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: List of VPN instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

  instances = __builtin__.property(_get_instances, _set_instances) # type: yc_instances_huawei_network_instance__network_instance_instances


  _pyangbind_elements = OrderedDict([('instances', instances), ])


class huawei_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /huawei-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Layer 3 Virtual Private Network (L3VPN). 
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instance',)

  _yang_name = 'huawei-network-instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instance = YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instance (container)

    YANG Description: Layer 3 Virtual Private Network (L3VPN). 
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: Layer 3 Virtual Private Network (L3VPN). 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

  network_instance = __builtin__.property(_get_network_instance, _set_network_instance) # type: yc_network_instance_huawei_network_instance__network_instance


  _pyangbind_elements = OrderedDict([('network_instance', network_instance), ])


