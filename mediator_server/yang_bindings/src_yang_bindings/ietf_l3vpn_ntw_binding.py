# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_cloud_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_cloud_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers/cloud-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for Cloud Identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'cloud-identifier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers', 'cloud-identifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/cloud_identifier/id (string)

    YANG Description: Identification of cloud service.
Local administration meaning.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/cloud_identifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identification of cloud service.
Local administration meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_encryption_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_encryption_profile_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers/encryption-profile-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for encryption profile identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'encryption-profile-identifier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers', 'encryption-profile-identifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/encryption_profile_identifier/id (string)

    YANG Description: Identification of the SP encryption profile
to be used.  Local administration meaning.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/encryption_profile_identifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identification of the SP encryption profile
to be used.  Local administration meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_qos_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_qos_profile_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers/qos-profile-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for QoS Profile Identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'qos-profile-identifier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers', 'qos-profile-identifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/qos_profile_identifier/id (string)

    YANG Description: Identification of the QoS Profile to be used.
Local administration meaning.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/qos_profile_identifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identification of the QoS Profile to be used.
Local administration meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_bfd_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_bfd_profile_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers/bfd-profile-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for BFD Profile identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'bfd-profile-identifier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers', 'bfd-profile-identifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/bfd_profile_identifier/id (string)

    YANG Description: Identification of the SP BFD Profile to be used.
Local administration meaning.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/bfd_profile_identifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identification of the SP BFD Profile to be used.
Local administration meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_forwarding_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_forwarding_profile_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers/forwarding-profile-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for Forwrding Profile identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'forwarding-profile-identifier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers', 'forwarding-profile-identifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/forwarding_profile_identifier/id (string)

    YANG Description: Identification of the Forwrding Profile Filter to be used.
Local administration meaning.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/forwarding_profile_identifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identification of the Forwrding Profile Filter to be used.
Local administration meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_routing_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_routing_profile_identifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers/routing-profile-identifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for Routing Profile Identifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id',)

  _yang_name = 'routing-profile-identifier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers', 'routing-profile-identifier']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/routing_profile_identifier/id (string)

    YANG Description: Identification of the routing Profile to be used
by the routing-protocols within sites, vpn-
network-accesses or vpn-nodes for refering
vrf-import/export policies.
This identifier has a local meaning.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/routing_profile_identifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identification of the routing Profile to be used
by the routing-protocols within sites, vpn-
network-accesses or vpn-nodes for refering
vrf-import/export policies.
This identifier has a local meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)


  _pyangbind_elements = OrderedDict([('id', id), ])


class yc_valid_provider_identifiers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles/valid-provider-identifiers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Valid Provider Identifies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cloud_identifier','__encryption_profile_identifier','__qos_profile_identifier','__bfd_profile_identifier','__forwarding_profile_identifier','__routing_profile_identifier',)

  _yang_name = 'valid-provider-identifiers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cloud_identifier = YANGDynClass(base=YANGListType("id",yc_cloud_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_cloud_identifier, yang_name="cloud-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="cloud-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__encryption_profile_identifier = YANGDynClass(base=YANGListType("id",yc_encryption_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_encryption_profile_identifier, yang_name="encryption-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__qos_profile_identifier = YANGDynClass(base=YANGListType("id",yc_qos_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_qos_profile_identifier, yang_name="qos-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="qos-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__bfd_profile_identifier = YANGDynClass(base=YANGListType("id",yc_bfd_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_bfd_profile_identifier, yang_name="bfd-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="bfd-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__forwarding_profile_identifier = YANGDynClass(base=YANGListType("id",yc_forwarding_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_forwarding_profile_identifier, yang_name="forwarding-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="forwarding-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__routing_profile_identifier = YANGDynClass(base=YANGListType("id",yc_routing_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_routing_profile_identifier, yang_name="routing-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles', 'valid-provider-identifiers']

  def _get_cloud_identifier(self):
    """
    Getter method for cloud_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/cloud_identifier (list)

    YANG Description: List for Cloud Identifiers.
    """
    return self.__cloud_identifier
      
  def _set_cloud_identifier(self, v, load=False):
    """
    Setter method for cloud_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/cloud_identifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_identifier() directly.

    YANG Description: List for Cloud Identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_cloud_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_cloud_identifier, yang_name="cloud-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="cloud-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud_identifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_cloud_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_cloud_identifier, yang_name="cloud-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="cloud-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__cloud_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud_identifier(self):
    self.__cloud_identifier = YANGDynClass(base=YANGListType("id",yc_cloud_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_cloud_identifier, yang_name="cloud-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="cloud-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_encryption_profile_identifier(self):
    """
    Getter method for encryption_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/encryption_profile_identifier (list)

    YANG Description: List for encryption profile identifiers.
    """
    return self.__encryption_profile_identifier
      
  def _set_encryption_profile_identifier(self, v, load=False):
    """
    Setter method for encryption_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/encryption_profile_identifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption_profile_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption_profile_identifier() directly.

    YANG Description: List for encryption profile identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_encryption_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_encryption_profile_identifier, yang_name="encryption-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption_profile_identifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_encryption_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_encryption_profile_identifier, yang_name="encryption-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__encryption_profile_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption_profile_identifier(self):
    self.__encryption_profile_identifier = YANGDynClass(base=YANGListType("id",yc_encryption_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_encryption_profile_identifier, yang_name="encryption-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_qos_profile_identifier(self):
    """
    Getter method for qos_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/qos_profile_identifier (list)

    YANG Description: List for QoS Profile Identifiers.
    """
    return self.__qos_profile_identifier
      
  def _set_qos_profile_identifier(self, v, load=False):
    """
    Setter method for qos_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/qos_profile_identifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_profile_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_profile_identifier() directly.

    YANG Description: List for QoS Profile Identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_qos_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_qos_profile_identifier, yang_name="qos-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="qos-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_profile_identifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_qos_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_qos_profile_identifier, yang_name="qos-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="qos-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__qos_profile_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_profile_identifier(self):
    self.__qos_profile_identifier = YANGDynClass(base=YANGListType("id",yc_qos_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_qos_profile_identifier, yang_name="qos-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="qos-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_bfd_profile_identifier(self):
    """
    Getter method for bfd_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/bfd_profile_identifier (list)

    YANG Description: List for BFD Profile identifiers.
    """
    return self.__bfd_profile_identifier
      
  def _set_bfd_profile_identifier(self, v, load=False):
    """
    Setter method for bfd_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/bfd_profile_identifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd_profile_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd_profile_identifier() directly.

    YANG Description: List for BFD Profile identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_bfd_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_bfd_profile_identifier, yang_name="bfd-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="bfd-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd_profile_identifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_bfd_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_bfd_profile_identifier, yang_name="bfd-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="bfd-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__bfd_profile_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd_profile_identifier(self):
    self.__bfd_profile_identifier = YANGDynClass(base=YANGListType("id",yc_bfd_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_bfd_profile_identifier, yang_name="bfd-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="bfd-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_forwarding_profile_identifier(self):
    """
    Getter method for forwarding_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/forwarding_profile_identifier (list)

    YANG Description: List for Forwrding Profile identifiers.
    """
    return self.__forwarding_profile_identifier
      
  def _set_forwarding_profile_identifier(self, v, load=False):
    """
    Setter method for forwarding_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/forwarding_profile_identifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_forwarding_profile_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_forwarding_profile_identifier() directly.

    YANG Description: List for Forwrding Profile identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_forwarding_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_forwarding_profile_identifier, yang_name="forwarding-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="forwarding-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """forwarding_profile_identifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_forwarding_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_forwarding_profile_identifier, yang_name="forwarding-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="forwarding-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__forwarding_profile_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_forwarding_profile_identifier(self):
    self.__forwarding_profile_identifier = YANGDynClass(base=YANGListType("id",yc_forwarding_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_forwarding_profile_identifier, yang_name="forwarding-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="forwarding-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_routing_profile_identifier(self):
    """
    Getter method for routing_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/routing_profile_identifier (list)

    YANG Description: List for Routing Profile Identifiers.
    """
    return self.__routing_profile_identifier
      
  def _set_routing_profile_identifier(self, v, load=False):
    """
    Setter method for routing_profile_identifier, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers/routing_profile_identifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_profile_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_profile_identifier() directly.

    YANG Description: List for Routing Profile Identifiers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_routing_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_routing_profile_identifier, yang_name="routing-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_profile_identifier must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_routing_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_routing_profile_identifier, yang_name="routing-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__routing_profile_identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_profile_identifier(self):
    self.__routing_profile_identifier = YANGDynClass(base=YANGListType("id",yc_routing_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_routing_profile_identifier, yang_name="routing-profile-identifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profile-identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  cloud_identifier = __builtin__.property(_get_cloud_identifier, _set_cloud_identifier) # type: yc_cloud_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_cloud_identifier
  encryption_profile_identifier = __builtin__.property(_get_encryption_profile_identifier, _set_encryption_profile_identifier) # type: yc_encryption_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_encryption_profile_identifier
  qos_profile_identifier = __builtin__.property(_get_qos_profile_identifier, _set_qos_profile_identifier) # type: yc_qos_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_qos_profile_identifier
  bfd_profile_identifier = __builtin__.property(_get_bfd_profile_identifier, _set_bfd_profile_identifier) # type: yc_bfd_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_bfd_profile_identifier
  forwarding_profile_identifier = __builtin__.property(_get_forwarding_profile_identifier, _set_forwarding_profile_identifier) # type: yc_forwarding_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_forwarding_profile_identifier
  routing_profile_identifier = __builtin__.property(_get_routing_profile_identifier, _set_routing_profile_identifier) # type: yc_routing_profile_identifier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers_routing_profile_identifier


  _pyangbind_elements = OrderedDict([('cloud_identifier', cloud_identifier), ('encryption_profile_identifier', encryption_profile_identifier), ('qos_profile_identifier', qos_profile_identifier), ('bfd_profile_identifier', bfd_profile_identifier), ('forwarding_profile_identifier', forwarding_profile_identifier), ('routing_profile_identifier', routing_profile_identifier), ])


class yc_vpn_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains a set of valid VPN Profiles to
reference in the VPN service.
  """
  __slots__ = ('_path_helper', '_extmethods', '__valid_provider_identifiers',)

  _yang_name = 'vpn-profiles'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__valid_provider_identifiers = YANGDynClass(base=yc_valid_provider_identifiers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers, is_container='container', yang_name="valid-provider-identifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-profiles']

  def _get_valid_provider_identifiers(self):
    """
    Getter method for valid_provider_identifiers, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers (container)

    YANG Description: Container for Valid Provider Identifies.
    """
    return self.__valid_provider_identifiers
      
  def _set_valid_provider_identifiers(self, v, load=False):
    """
    Setter method for valid_provider_identifiers, mapped from YANG variable /l3vpn_ntw/vpn_profiles/valid_provider_identifiers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_provider_identifiers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_provider_identifiers() directly.

    YANG Description: Container for Valid Provider Identifies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_valid_provider_identifiers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers, is_container='container', yang_name="valid-provider-identifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_provider_identifiers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_valid_provider_identifiers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers, is_container='container', yang_name="valid-provider-identifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__valid_provider_identifiers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_provider_identifiers(self):
    self.__valid_provider_identifiers = YANGDynClass(base=yc_valid_provider_identifiers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers, is_container='container', yang_name="valid-provider-identifiers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  valid_provider_identifiers = __builtin__.property(_get_valid_provider_identifiers, _set_valid_provider_identifiers) # type: yc_valid_provider_identifiers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles_valid_provider_identifiers


  _pyangbind_elements = OrderedDict([('valid_provider_identifiers', valid_provider_identifiers), ])


class yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_admin_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/status/admin-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'admin-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'status', 'admin-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/admin_status/status (identityref)

    YANG Description: Administrative service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/admin_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/admin_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/admin_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

  status = __builtin__.property(_get_status, _set_status)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_oper_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/status/oper-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'oper-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'status', 'oper-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/oper_status/status (identityref)

    YANG Description: Operations status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/oper_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Operations status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/oper_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/oper_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

  status = __builtin__.property(_get_status)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_status','__oper_status',)

  _yang_name = 'status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'status']

  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/admin_status (container)

    YANG Description: Administrative service status.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/admin_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/oper_status (container)

    YANG Description: Operational service status.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status/oper_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  admin_status = __builtin__.property(_get_admin_status, _set_admin_status) # type: yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_admin_status
  oper_status = __builtin__.property(_get_oper_status, _set_oper_status) # type: yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status_oper_status


  _pyangbind_elements = OrderedDict([('admin_status', admin_status), ('oper_status', oper_status), ])


class yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target_route_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/ie-profiles/ie-profile/vpn-targets/vpn-target/route-targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Route Targets.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_target',)

  _yang_name = 'route-targets'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_target = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'ie-profiles', 'ie-profile', 'vpn-targets', 'vpn-target', 'route-targets']

  def _get_route_target(self):
    """
    Getter method for route_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/route_targets/route_target (rt-types:route-target)

    YANG Description: Route Target value
    """
    return self.__route_target
      
  def _set_route_target(self, v, load=False):
    """
    Setter method for route_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/route_targets/route_target (rt-types:route-target)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_target() directly.

    YANG Description: Route Target value
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_target must be of a type compatible with rt-types:route-target""",
          'defined-type': "rt-types:route-target",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)""",
        })

    self.__route_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_target(self):
    self.__route_target = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)

  route_target = __builtin__.property(_get_route_target, _set_route_target)


  _pyangbind_elements = OrderedDict([('route_target', route_target), ])


class yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/ie-profiles/ie-profile/vpn-targets/vpn-target. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: L3VPN route targets. AND/OR Operations are available
based on the RTs assigment.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__route_targets','__route_target_type',)

  _yang_name = 'vpn-target'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)
    self.__route_targets = YANGDynClass(base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__route_target_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'ie-profiles', 'ie-profile', 'vpn-targets', 'vpn-target']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/id (int8)

    YANG Description: Identifies each VPN Target
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/id (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies each VPN Target
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)


  def _get_route_targets(self):
    """
    Getter method for route_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/route_targets (list)

    YANG Description: List of Route Targets.
    """
    return self.__route_targets
      
  def _set_route_targets(self, v, load=False):
    """
    Setter method for route_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/route_targets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_targets() directly.

    YANG Description: List of Route Targets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_targets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__route_targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_targets(self):
    self.__route_targets = YANGDynClass(base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_route_target_type(self):
    """
    Getter method for route_target_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/route_target_type (rt-types:route-target-type)

    YANG Description: Import/export type of the Route Target.
    """
    return self.__route_target_type
      
  def _set_route_target_type(self, v, load=False):
    """
    Setter method for route_target_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target/route_target_type (rt-types:route-target-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_target_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_target_type() directly.

    YANG Description: Import/export type of the Route Target.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_target_type must be of a type compatible with rt-types:route-target-type""",
          'defined-type': "rt-types:route-target-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)""",
        })

    self.__route_target_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_target_type(self):
    self.__route_target_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  route_targets = __builtin__.property(_get_route_targets, _set_route_targets) # type: yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target_route_targets
  route_target_type = __builtin__.property(_get_route_target_type, _set_route_target_type)


  _pyangbind_elements = OrderedDict([('id', id), ('route_targets', route_targets), ('route_target_type', route_target_type), ])


class yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/ie-profiles/ie-profile/vpn-targets/vpn-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VPN policies
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__export_policy',)

  _yang_name = 'vpn-policies'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'ie-profiles', 'ie-profile', 'vpn-targets', 'vpn-policies']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_policies/import_policy (string)

    YANG Description: Defines the import policy.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_policies/import_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: Defines the import policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_policies/export_policy (string)

    YANG Description: Defines the export policy.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_policies/export_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: Defines the export policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('export_policy', export_policy), ])


class yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/ie-profiles/ie-profile/vpn-targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set of route-targets to match for import and export routes
to/from VRF
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_target','__vpn_policies',)

  _yang_name = 'vpn-targets'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_target = YANGDynClass(base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__vpn_policies = YANGDynClass(base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'ie-profiles', 'ie-profile', 'vpn-targets']

  def _get_vpn_target(self):
    """
    Getter method for vpn_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target (list)

    YANG Description: L3VPN route targets. AND/OR Operations are available
based on the RTs assigment.
    """
    return self.__vpn_target
      
  def _set_vpn_target(self, v, load=False):
    """
    Setter method for vpn_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_target (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_target() directly.

    YANG Description: L3VPN route targets. AND/OR Operations are available
based on the RTs assigment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_target must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__vpn_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_target(self):
    self.__vpn_target = YANGDynClass(base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_vpn_policies(self):
    """
    Getter method for vpn_policies, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_policies (container)

    YANG Description: VPN policies
    """
    return self.__vpn_policies
      
  def _set_vpn_policies(self, v, load=False):
    """
    Setter method for vpn_policies, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets/vpn_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_policies() directly.

    YANG Description: VPN policies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_policies(self):
    self.__vpn_policies = YANGDynClass(base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  vpn_target = __builtin__.property(_get_vpn_target, _set_vpn_target) # type: yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_target
  vpn_policies = __builtin__.property(_get_vpn_policies, _set_vpn_policies) # type: yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets_vpn_policies


  _pyangbind_elements = OrderedDict([('vpn_target', vpn_target), ('vpn_policies', vpn_policies), ])


class yc_ie_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/ie-profiles/ie-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for Imort/Export profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ie_profile_id','__rd','__vpn_targets',)

  _yang_name = 'ie-profile'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ie_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ie-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__rd = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'ie-profiles', 'ie-profile']

  def _get_ie_profile_id(self):
    """
    Getter method for ie_profile_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/ie_profile_id (string)

    YANG Description: IE profile id.
    """
    return self.__ie_profile_id
      
  def _set_ie_profile_id(self, v, load=False):
    """
    Setter method for ie_profile_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/ie_profile_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ie_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ie_profile_id() directly.

    YANG Description: IE profile id.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ie-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ie_profile_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ie-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__ie_profile_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ie_profile_id(self):
    self.__ie_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ie-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_rd(self):
    """
    Getter method for rd, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/rd (union)

    YANG Description: Route distinguisher value. If this leaf has not been
configured, the server will auto-assign a route
distinguisher value and use that value operationally.
This calculated value is available in the operational
state.

Use the empty type to indicate RD has no value and
is not to be aouto-assigned.
    """
    return self.__rd
      
  def _set_rd(self, v, load=False):
    """
    Setter method for rd, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/rd (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rd() directly.

    YANG Description: Route distinguisher value. If this leaf has not been
configured, the server will auto-assign a route
distinguisher value and use that value operationally.
This calculated value is available in the operational
state.

Use the empty type to indicate RD has no value and
is not to be aouto-assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rd must be of a type compatible with union""",
          'defined-type': "ietf-l3vpn-ntw:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)""",
        })

    self.__rd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rd(self):
    self.__rd = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)


  def _get_vpn_targets(self):
    """
    Getter method for vpn_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets (container)

    YANG Description: Set of route-targets to match for import and export routes
to/from VRF
    """
    return self.__vpn_targets
      
  def _set_vpn_targets(self, v, load=False):
    """
    Setter method for vpn_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile/vpn_targets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_targets() directly.

    YANG Description: Set of route-targets to match for import and export routes
to/from VRF
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_targets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_targets(self):
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  ie_profile_id = __builtin__.property(_get_ie_profile_id, _set_ie_profile_id)
  rd = __builtin__.property(_get_rd, _set_rd)
  vpn_targets = __builtin__.property(_get_vpn_targets, _set_vpn_targets) # type: yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile_vpn_targets


  _pyangbind_elements = OrderedDict([('ie_profile_id', ie_profile_id), ('rd', rd), ('vpn_targets', vpn_targets), ])


class yc_ie_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/ie-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for Import/Export profiles.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ie_profile',)

  _yang_name = 'ie-profiles'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ie_profile = YANGDynClass(base=YANGListType("ie_profile_id",yc_ie_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile, yang_name="ie-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ie-profile-id', extensions=None), is_container='list', yang_name="ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'ie-profiles']

  def _get_ie_profile(self):
    """
    Getter method for ie_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile (list)

    YANG Description: List for Imort/Export profile.
    """
    return self.__ie_profile
      
  def _set_ie_profile(self, v, load=False):
    """
    Setter method for ie_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles/ie_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ie_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ie_profile() directly.

    YANG Description: List for Imort/Export profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ie_profile_id",yc_ie_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile, yang_name="ie-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ie-profile-id', extensions=None), is_container='list', yang_name="ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ie_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ie_profile_id",yc_ie_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile, yang_name="ie-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ie-profile-id', extensions=None), is_container='list', yang_name="ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__ie_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ie_profile(self):
    self.__ie_profile = YANGDynClass(base=YANGListType("ie_profile_id",yc_ie_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile, yang_name="ie-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ie-profile-id', extensions=None), is_container='list', yang_name="ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  ie_profile = __builtin__.property(_get_ie_profile, _set_ie_profile) # type: yc_ie_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles_ie_profile


  _pyangbind_elements = OrderedDict([('ie_profile', ie_profile), ])


class yc_underlay_transport_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_underlay_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/underlay-transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the Transport underlay.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type',)

  _yang_name = 'underlay-transport'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'underlay-transport']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/underlay_transport/type (identityref)

    YANG Description: Protocols used to deliver a VPN service.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/underlay_transport/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Protocols used to deliver a VPN service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:gre': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:sr-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rsvp-te': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-lu': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('type', type), ])


class yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target_route_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-targets/vpn-target/route-targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Route Targets.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_target',)

  _yang_name = 'route-targets'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_target = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-targets', 'vpn-target', 'route-targets']

  def _get_route_target(self):
    """
    Getter method for route_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/route_targets/route_target (rt-types:route-target)

    YANG Description: Route Target value
    """
    return self.__route_target
      
  def _set_route_target(self, v, load=False):
    """
    Setter method for route_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/route_targets/route_target (rt-types:route-target)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_target() directly.

    YANG Description: Route Target value
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_target must be of a type compatible with rt-types:route-target""",
          'defined-type': "rt-types:route-target",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)""",
        })

    self.__route_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_target(self):
    self.__route_target = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}), is_leaf=True, yang_name="route-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target', is_config=True)

  route_target = __builtin__.property(_get_route_target, _set_route_target)


  _pyangbind_elements = OrderedDict([('route_target', route_target), ])


class yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-targets/vpn-target. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: L3VPN route targets. AND/OR Operations are available
based on the RTs assigment.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__route_targets','__route_target_type',)

  _yang_name = 'vpn-target'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)
    self.__route_targets = YANGDynClass(base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__route_target_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-targets', 'vpn-target']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/id (int8)

    YANG Description: Identifies each VPN Target
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/id (int8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies each VPN Target
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with int8""",
          'defined-type': "int8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['-128..127']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='int8', is_config=True)


  def _get_route_targets(self):
    """
    Getter method for route_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/route_targets (list)

    YANG Description: List of Route Targets.
    """
    return self.__route_targets
      
  def _set_route_targets(self, v, load=False):
    """
    Setter method for route_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/route_targets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_targets() directly.

    YANG Description: List of Route Targets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_targets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__route_targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_targets(self):
    self.__route_targets = YANGDynClass(base=YANGListType("route_target",yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target_route_targets, yang_name="route-targets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='route-target', extensions=None), is_container='list', yang_name="route-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_route_target_type(self):
    """
    Getter method for route_target_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/route_target_type (rt-types:route-target-type)

    YANG Description: Import/export type of the Route Target.
    """
    return self.__route_target_type
      
  def _set_route_target_type(self, v, load=False):
    """
    Setter method for route_target_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target/route_target_type (rt-types:route-target-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_target_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_target_type() directly.

    YANG Description: Import/export type of the Route Target.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_target_type must be of a type compatible with rt-types:route-target-type""",
          'defined-type': "rt-types:route-target-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)""",
        })

    self.__route_target_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_target_type(self):
    self.__route_target_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'import': {'value': 0}, 'export': {'value': 1}, 'both': {'value': 2}},), is_leaf=True, yang_name="route-target-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='rt-types:route-target-type', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  route_targets = __builtin__.property(_get_route_targets, _set_route_targets) # type: yc_route_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target_route_targets
  route_target_type = __builtin__.property(_get_route_target_type, _set_route_target_type)


  _pyangbind_elements = OrderedDict([('id', id), ('route_targets', route_targets), ('route_target_type', route_target_type), ])


class yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-targets/vpn-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VPN policies
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__export_policy',)

  _yang_name = 'vpn-policies'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-targets', 'vpn-policies']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_policies/import_policy (string)

    YANG Description: Defines the import policy.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_policies/import_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: Defines the import policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_policies/export_policy (string)

    YANG Description: Defines the export policy.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_policies/export_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: Defines the export policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('export_policy', export_policy), ])


class yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set of route-targets to match for import and export routes
to/from VRF
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_target','__vpn_policies',)

  _yang_name = 'vpn-targets'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_target = YANGDynClass(base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__vpn_policies = YANGDynClass(base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-targets']

  def _get_vpn_target(self):
    """
    Getter method for vpn_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target (list)

    YANG Description: L3VPN route targets. AND/OR Operations are available
based on the RTs assigment.
    """
    return self.__vpn_target
      
  def _set_vpn_target(self, v, load=False):
    """
    Setter method for vpn_target, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_target (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_target() directly.

    YANG Description: L3VPN route targets. AND/OR Operations are available
based on the RTs assigment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_target must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__vpn_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_target(self):
    self.__vpn_target = YANGDynClass(base=YANGListType("id",yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_vpn_policies(self):
    """
    Getter method for vpn_policies, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_policies (container)

    YANG Description: VPN policies
    """
    return self.__vpn_policies
      
  def _set_vpn_policies(self, v, load=False):
    """
    Setter method for vpn_policies, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets/vpn_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_policies() directly.

    YANG Description: VPN policies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_policies(self):
    self.__vpn_policies = YANGDynClass(base=yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_policies, is_container='container', yang_name="vpn-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  vpn_target = __builtin__.property(_get_vpn_target, _set_vpn_target) # type: yc_vpn_target_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_target
  vpn_policies = __builtin__.property(_get_vpn_policies, _set_vpn_policies) # type: yc_vpn_policies_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets_vpn_policies


  _pyangbind_elements = OrderedDict([('vpn_target', vpn_target), ('vpn_policies', vpn_policies), ])


class yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_admin_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/status/admin-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'admin-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'status', 'admin-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/admin_status/status (identityref)

    YANG Description: Administrative service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/admin_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/admin_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/admin_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

  status = __builtin__.property(_get_status, _set_status)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_oper_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/status/oper-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'oper-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'status', 'oper-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/oper_status/status (identityref)

    YANG Description: Operations status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/oper_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Operations status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/oper_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/oper_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

  status = __builtin__.property(_get_status)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_status','__oper_status',)

  _yang_name = 'status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'status']

  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/admin_status (container)

    YANG Description: Administrative service status.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/admin_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/oper_status (container)

    YANG Description: Operational service status.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status/oper_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  admin_status = __builtin__.property(_get_admin_status, _set_admin_status) # type: yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_admin_status
  oper_status = __builtin__.property(_get_oper_status, _set_oper_status) # type: yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status_oper_status


  _pyangbind_elements = OrderedDict([('admin_status', admin_status), ('oper_status', oper_status), ])


class yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/groups/group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of group-ids.
  """
  __slots__ = ('_path_helper', '_extmethods', '__group_id',)

  _yang_name = 'group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__group_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'groups', 'group']

  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/groups/group/group_id (string)

    YANG Description: Group-id the vpn-node belongs to.
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/groups/group/group_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.

    YANG Description: Group-id the vpn-node belongs to.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  group_id = __builtin__.property(_get_group_id, _set_group_id)


  _pyangbind_elements = OrderedDict([('group_id', group_id), ])


class yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Groups the vpn node and network access belongs to.
  """
  __slots__ = ('_path_helper', '_extmethods', '__group',)

  _yang_name = 'groups'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__group = YANGDynClass(base=YANGListType("group_id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'groups']

  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/groups/group (list)

    YANG Description: List of group-ids.
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/groups/group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.

    YANG Description: List of group-ids.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("group_id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("group_id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=YANGListType("group_id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='group-id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  group = __builtin__.property(_get_group, _set_group) # type: yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups_group


  _pyangbind_elements = OrderedDict([('group', group), ])


class yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_admin_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/status/admin-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'admin-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'status', 'admin-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/admin_status/status (identityref)

    YANG Description: Administrative service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/admin_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/admin_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/admin_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

  status = __builtin__.property(_get_status, _set_status)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_oper_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/status/oper-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'oper-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'status', 'oper-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/oper_status/status (identityref)

    YANG Description: Operations status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/oper_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Operations status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/oper_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/oper_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

  status = __builtin__.property(_get_status)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_status','__oper_status',)

  _yang_name = 'status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'status']

  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/admin_status (container)

    YANG Description: Administrative service status.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/admin_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/oper_status (container)

    YANG Description: Operational service status.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status/oper_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  admin_status = __builtin__.property(_get_admin_status, _set_admin_status) # type: yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_admin_status
  oper_status = __builtin__.property(_get_oper_status, _set_oper_status) # type: yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status_oper_status


  _pyangbind_elements = OrderedDict([('admin_status', admin_status), ('oper_status', oper_status), ])


class yc_logical_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_logical_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/logical-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Reference of a logical interface
type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer_reference',)

  _yang_name = 'logical-interface'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer_reference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'logical-interface']

  def _get_peer_reference(self):
    """
    Getter method for peer_reference, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/logical_interface/peer_reference (uint32)

    YANG Description: Specify the associated logical peer
interface
    """
    return self.__peer_reference
      
  def _set_peer_reference(self, v, load=False):
    """
    Setter method for peer_reference, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/logical_interface/peer_reference (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_reference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_reference() directly.

    YANG Description: Specify the associated logical peer
interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_reference must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)""",
        })

    self.__peer_reference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_reference(self):
    self.__peer_reference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)

  peer_reference = __builtin__.property(_get_peer_reference, _set_peer_reference)


  _pyangbind_elements = OrderedDict([('peer_reference', peer_reference), ])


class yc_dot1q_vlan_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_dot1q_vlan_tagged(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface/dot1q-vlan-tagged. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Tagged interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tag_type','__cvlan_id',)

  _yang_name = 'dot1q-vlan-tagged'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__cvlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface', 'dot1q-vlan-tagged']

  def _get_tag_type(self):
    """
    Getter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/dot1q_vlan_tagged/tag_type (identityref)

    YANG Description: Tag type.  By default, the tag
type is 'c-vlan'.
    """
    return self.__tag_type
      
  def _set_tag_type(self, v, load=False):
    """
    Setter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/dot1q_vlan_tagged/tag_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag_type() directly.

    YANG Description: Tag type.  By default, the tag
type is 'c-vlan'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__tag_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag_type(self):
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_cvlan_id(self):
    """
    Getter method for cvlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/dot1q_vlan_tagged/cvlan_id (uint16)

    YANG Description: VLAN identifier.
    """
    return self.__cvlan_id
      
  def _set_cvlan_id(self, v, load=False):
    """
    Setter method for cvlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/dot1q_vlan_tagged/cvlan_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cvlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cvlan_id() directly.

    YANG Description: VLAN identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cvlan_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__cvlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cvlan_id(self):
    self.__cvlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

  tag_type = __builtin__.property(_get_tag_type, _set_tag_type)
  cvlan_id = __builtin__.property(_get_cvlan_id, _set_cvlan_id)


  _pyangbind_elements = OrderedDict([('tag_type', tag_type), ('cvlan_id', cvlan_id), ])


class yc_priority_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_priority_tagged(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface/priority-tagged. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Priority tagged.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tag_type',)

  _yang_name = 'priority-tagged'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface', 'priority-tagged']

  def _get_tag_type(self):
    """
    Getter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/priority_tagged/tag_type (identityref)

    YANG Description: Tag type.  By default, the tag
type is 'c-vlan'.
    """
    return self.__tag_type
      
  def _set_tag_type(self, v, load=False):
    """
    Setter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/priority_tagged/tag_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag_type() directly.

    YANG Description: Tag type.  By default, the tag
type is 'c-vlan'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__tag_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag_type(self):
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

  tag_type = __builtin__.property(_get_tag_type, _set_tag_type)


  _pyangbind_elements = OrderedDict([('tag_type', tag_type), ])


class yc_qinq_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinq(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface/qinq. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QinQ.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tag_type','__svlan_id','__cvlan_id',)

  _yang_name = 'qinq'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__svlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__cvlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface', 'qinq']

  def _get_tag_type(self):
    """
    Getter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq/tag_type (identityref)

    YANG Description: Tag type.  By default, the tag
type is 'c-s-vlan'.
    """
    return self.__tag_type
      
  def _set_tag_type(self, v, load=False):
    """
    Setter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq/tag_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag_type() directly.

    YANG Description: Tag type.  By default, the tag
type is 'c-s-vlan'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__tag_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag_type(self):
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:c-s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_svlan_id(self):
    """
    Getter method for svlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq/svlan_id (uint16)

    YANG Description: SVLAN identifier.
    """
    return self.__svlan_id
      
  def _set_svlan_id(self, v, load=False):
    """
    Setter method for svlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq/svlan_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_svlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_svlan_id() directly.

    YANG Description: SVLAN identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """svlan_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__svlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_svlan_id(self):
    self.__svlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_cvlan_id(self):
    """
    Getter method for cvlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq/cvlan_id (uint16)

    YANG Description: CVLAN identifier.
    """
    return self.__cvlan_id
      
  def _set_cvlan_id(self, v, load=False):
    """
    Setter method for cvlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq/cvlan_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cvlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cvlan_id() directly.

    YANG Description: CVLAN identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cvlan_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__cvlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cvlan_id(self):
    self.__cvlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cvlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

  tag_type = __builtin__.property(_get_tag_type, _set_tag_type)
  svlan_id = __builtin__.property(_get_svlan_id, _set_svlan_id)
  cvlan_id = __builtin__.property(_get_cvlan_id, _set_cvlan_id)


  _pyangbind_elements = OrderedDict([('tag_type', tag_type), ('svlan_id', svlan_id), ('cvlan_id', cvlan_id), ])


class yc_qinany_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinany(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface/qinany. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for QinAny.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tag_type','__svlan_id',)

  _yang_name = 'qinany'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__svlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface', 'qinany']

  def _get_tag_type(self):
    """
    Getter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinany/tag_type (identityref)

    YANG Description: Tag type.  By default, the tag type
is 's-vlan'.
    """
    return self.__tag_type
      
  def _set_tag_type(self, v, load=False):
    """
    Setter method for tag_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinany/tag_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag_type() directly.

    YANG Description: Tag type.  By default, the tag type
is 's-vlan'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__tag_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag_type(self):
    self.__tag_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 's-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:c-s-vlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:s-vlan"), is_leaf=True, yang_name="tag-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_svlan_id(self):
    """
    Getter method for svlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinany/svlan_id (uint16)

    YANG Description: Service VLAN ID.
    """
    return self.__svlan_id
      
  def _set_svlan_id(self, v, load=False):
    """
    Setter method for svlan_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinany/svlan_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_svlan_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_svlan_id() directly.

    YANG Description: Service VLAN ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """svlan_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__svlan_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_svlan_id(self):
    self.__svlan_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svlan-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

  tag_type = __builtin__.property(_get_tag_type, _set_tag_type)
  svlan_id = __builtin__.property(_get_svlan_id, _set_svlan_id)


  _pyangbind_elements = OrderedDict([('tag_type', tag_type), ('svlan_id', svlan_id), ])


class yc_peer_list_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan_peer_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface/vxlan/peer-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of peer IP addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer_ip',)

  _yang_name = 'peer-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface', 'vxlan', 'peer-list']

  def _get_peer_ip(self):
    """
    Getter method for peer_ip, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/peer_list/peer_ip (inet:ip-address)

    YANG Description: Peer IP.
    """
    return self.__peer_ip
      
  def _set_peer_ip(self, v, load=False):
    """
    Setter method for peer_ip, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/peer_list/peer_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_ip() directly.

    YANG Description: Peer IP.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__peer_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_ip(self):
    self.__peer_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

  peer_ip = __builtin__.property(_get_peer_ip, _set_peer_ip)


  _pyangbind_elements = OrderedDict([('peer_ip', peer_ip), ])


class yc_vxlan_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface/vxlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QinQ.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vni_id','__peer_mode','__peer_list',)

  _yang_name = 'vxlan'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vni_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vni-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    self.__peer_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-mode"), is_leaf=True, yang_name="peer-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__peer_list = YANGDynClass(base=YANGListType("peer_ip",yc_peer_list_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan_peer_list, yang_name="peer-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions=None), is_container='list', yang_name="peer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface', 'vxlan']

  def _get_vni_id(self):
    """
    Getter method for vni_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/vni_id (uint32)

    YANG Description: VXLAN Network Identifier (VNI).
    """
    return self.__vni_id
      
  def _set_vni_id(self, v, load=False):
    """
    Setter method for vni_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/vni_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vni_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vni_id() directly.

    YANG Description: VXLAN Network Identifier (VNI).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vni-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vni_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vni-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)""",
        })

    self.__vni_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vni_id(self):
    self.__vni_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vni-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)


  def _get_peer_mode(self):
    """
    Getter method for peer_mode, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/peer_mode (identityref)

    YANG Description: Specifies the VXLAN access mode.
By default, the peer mode is set
to 'static-mode'.
    """
    return self.__peer_mode
      
  def _set_peer_mode(self, v, load=False):
    """
    Setter method for peer_mode, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/peer_mode (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_mode() directly.

    YANG Description: Specifies the VXLAN access mode.
By default, the peer mode is set
to 'static-mode'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-mode"), is_leaf=True, yang_name="peer-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_mode must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-mode"), is_leaf=True, yang_name="peer-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__peer_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_mode(self):
    self.__peer_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp-mode': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-mode"), is_leaf=True, yang_name="peer-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_peer_list(self):
    """
    Getter method for peer_list, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/peer_list (list)

    YANG Description: List of peer IP addresses.
    """
    return self.__peer_list
      
  def _set_peer_list(self, v, load=False):
    """
    Setter method for peer_list, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan/peer_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_list() directly.

    YANG Description: List of peer IP addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_ip",yc_peer_list_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan_peer_list, yang_name="peer-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions=None), is_container='list', yang_name="peer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_ip",yc_peer_list_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan_peer_list, yang_name="peer-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions=None), is_container='list', yang_name="peer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__peer_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_list(self):
    self.__peer_list = YANGDynClass(base=YANGListType("peer_ip",yc_peer_list_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan_peer_list, yang_name="peer-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-ip', extensions=None), is_container='list', yang_name="peer-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  vni_id = __builtin__.property(_get_vni_id, _set_vni_id)
  peer_mode = __builtin__.property(_get_peer_mode, _set_peer_mode)
  peer_list = __builtin__.property(_get_peer_list, _set_peer_list) # type: yc_peer_list_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan_peer_list


  _pyangbind_elements = OrderedDict([('vni_id', vni_id), ('peer_mode', peer_mode), ('peer_list', peer_list), ])


class yc_tagged_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/tagged-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for tagged interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__dot1q_vlan_tagged','__priority_tagged','__qinq','__qinany','__vxlan',)

  _yang_name = 'tagged-interface'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:priority-tagged"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__dot1q_vlan_tagged = YANGDynClass(base=yc_dot1q_vlan_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_dot1q_vlan_tagged, is_container='container', yang_name="dot1q-vlan-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__priority_tagged = YANGDynClass(base=yc_priority_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_priority_tagged, is_container='container', yang_name="priority-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__qinq = YANGDynClass(base=yc_qinq_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinq, is_container='container', yang_name="qinq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__qinany = YANGDynClass(base=yc_qinany_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinany, is_container='container', yang_name="qinany", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vxlan = YANGDynClass(base=yc_vxlan_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan, is_container='container', yang_name="vxlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'tagged-interface']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/type (identityref)

    YANG Description: Tagged interface type.  By default,
the type of the tagged interface is
'priority-tagged'.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Tagged interface type.  By default,
the type of the tagged interface is
'priority-tagged'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:priority-tagged"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:priority-tagged"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:priority-tagged"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_dot1q_vlan_tagged(self):
    """
    Getter method for dot1q_vlan_tagged, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/dot1q_vlan_tagged (container)

    YANG Description: Tagged interface.
    """
    return self.__dot1q_vlan_tagged
      
  def _set_dot1q_vlan_tagged(self, v, load=False):
    """
    Setter method for dot1q_vlan_tagged, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/dot1q_vlan_tagged (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dot1q_vlan_tagged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dot1q_vlan_tagged() directly.

    YANG Description: Tagged interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dot1q_vlan_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_dot1q_vlan_tagged, is_container='container', yang_name="dot1q-vlan-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dot1q_vlan_tagged must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dot1q_vlan_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_dot1q_vlan_tagged, is_container='container', yang_name="dot1q-vlan-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__dot1q_vlan_tagged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dot1q_vlan_tagged(self):
    self.__dot1q_vlan_tagged = YANGDynClass(base=yc_dot1q_vlan_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_dot1q_vlan_tagged, is_container='container', yang_name="dot1q-vlan-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_priority_tagged(self):
    """
    Getter method for priority_tagged, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/priority_tagged (container)

    YANG Description: Priority tagged.
    """
    return self.__priority_tagged
      
  def _set_priority_tagged(self, v, load=False):
    """
    Setter method for priority_tagged, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/priority_tagged (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_tagged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_tagged() directly.

    YANG Description: Priority tagged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_priority_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_priority_tagged, is_container='container', yang_name="priority-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_tagged must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_priority_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_priority_tagged, is_container='container', yang_name="priority-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__priority_tagged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_tagged(self):
    self.__priority_tagged = YANGDynClass(base=yc_priority_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_priority_tagged, is_container='container', yang_name="priority-tagged", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_qinq(self):
    """
    Getter method for qinq, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq (container)

    YANG Description: QinQ.
    """
    return self.__qinq
      
  def _set_qinq(self, v, load=False):
    """
    Setter method for qinq, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qinq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qinq() directly.

    YANG Description: QinQ.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_qinq_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinq, is_container='container', yang_name="qinq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qinq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_qinq_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinq, is_container='container', yang_name="qinq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__qinq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qinq(self):
    self.__qinq = YANGDynClass(base=yc_qinq_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinq, is_container='container', yang_name="qinq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_qinany(self):
    """
    Getter method for qinany, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinany (container)

    YANG Description: Container for QinAny.
    """
    return self.__qinany
      
  def _set_qinany(self, v, load=False):
    """
    Setter method for qinany, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/qinany (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qinany is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qinany() directly.

    YANG Description: Container for QinAny.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_qinany_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinany, is_container='container', yang_name="qinany", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qinany must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_qinany_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinany, is_container='container', yang_name="qinany", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__qinany = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qinany(self):
    self.__qinany = YANGDynClass(base=yc_qinany_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinany, is_container='container', yang_name="qinany", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vxlan(self):
    """
    Getter method for vxlan, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan (container)

    YANG Description: QinQ.
    """
    return self.__vxlan
      
  def _set_vxlan(self, v, load=False):
    """
    Setter method for vxlan, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface/vxlan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vxlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vxlan() directly.

    YANG Description: QinQ.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vxlan_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan, is_container='container', yang_name="vxlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vxlan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vxlan_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan, is_container='container', yang_name="vxlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vxlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vxlan(self):
    self.__vxlan = YANGDynClass(base=yc_vxlan_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan, is_container='container', yang_name="vxlan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  dot1q_vlan_tagged = __builtin__.property(_get_dot1q_vlan_tagged, _set_dot1q_vlan_tagged) # type: yc_dot1q_vlan_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_dot1q_vlan_tagged
  priority_tagged = __builtin__.property(_get_priority_tagged, _set_priority_tagged) # type: yc_priority_tagged_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_priority_tagged
  qinq = __builtin__.property(_get_qinq, _set_qinq) # type: yc_qinq_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinq
  qinany = __builtin__.property(_get_qinany, _set_qinany) # type: yc_qinany_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_qinany
  vxlan = __builtin__.property(_get_vxlan, _set_vxlan) # type: yc_vxlan_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface_vxlan


  _pyangbind_elements = OrderedDict([('type', type), ('dot1q_vlan_tagged', dot1q_vlan_tagged), ('priority_tagged', priority_tagged), ('qinq', qinq), ('qinany', qinany), ('vxlan', vxlan), ])


class yc_pseudowire_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_pseudowire(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/bearer/pseudowire. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Pseudowire termination parameters
  """
  __slots__ = ('_path_helper', '_extmethods', '__vcid','__far_end',)

  _yang_name = 'pseudowire'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vcid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    self.__far_end = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'bearer', 'pseudowire']

  def _get_vcid(self):
    """
    Getter method for vcid, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/pseudowire/vcid (uint32)

    YANG Description: PW or VC identifier.
    """
    return self.__vcid
      
  def _set_vcid(self, v, load=False):
    """
    Setter method for vcid, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/pseudowire/vcid (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcid() directly.

    YANG Description: PW or VC identifier.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcid must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)""",
        })

    self.__vcid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcid(self):
    self.__vcid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)


  def _get_far_end(self):
    """
    Getter method for far_end, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/pseudowire/far_end (union)

    YANG Description: SDP/Far End/LDP neighbour reference.
    """
    return self.__far_end
      
  def _set_far_end(self, v, load=False):
    """
    Setter method for far_end, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/pseudowire/far_end (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end() directly.

    YANG Description: SDP/Far End/LDP neighbour reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end must be of a type compatible with union""",
          'defined-type': "ietf-l3vpn-ntw:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)""",
        })

    self.__far_end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end(self):
    self.__far_end = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)

  vcid = __builtin__.property(_get_vcid, _set_vcid)
  far_end = __builtin__.property(_get_far_end, _set_far_end)


  _pyangbind_elements = OrderedDict([('vcid', vcid), ('far_end', far_end), ])


class yc_vpls_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_vpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/bearer/vpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Pseudowire termination parameters
  """
  __slots__ = ('_path_helper', '_extmethods', '__vcid','__far_end',)

  _yang_name = 'vpls'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vcid = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    self.__far_end = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'bearer', 'vpls']

  def _get_vcid(self):
    """
    Getter method for vcid, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/vpls/vcid (union)

    YANG Description: VCID identifier, IRB/RVPPLs interface
supported using string
format.
    """
    return self.__vcid
      
  def _set_vcid(self, v, load=False):
    """
    Setter method for vcid, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/vpls/vcid (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcid() directly.

    YANG Description: VCID identifier, IRB/RVPPLs interface
supported using string
format.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcid must be of a type compatible with union""",
          'defined-type': "ietf-l3vpn-ntw:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)""",
        })

    self.__vcid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcid(self):
    self.__vcid = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="vcid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)


  def _get_far_end(self):
    """
    Getter method for far_end, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/vpls/far_end (union)

    YANG Description: SDP/Far End/LDP Neighbour reference.
    """
    return self.__far_end
      
  def _set_far_end(self, v, load=False):
    """
    Setter method for far_end, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/vpls/far_end (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_far_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_far_end() directly.

    YANG Description: SDP/Far End/LDP Neighbour reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """far_end must be of a type compatible with union""",
          'defined-type': "ietf-l3vpn-ntw:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)""",
        })

    self.__far_end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_far_end(self):
    self.__far_end = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="far-end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)

  vcid = __builtin__.property(_get_vcid, _set_vcid)
  far_end = __builtin__.property(_get_far_end, _set_far_end)


  _pyangbind_elements = OrderedDict([('vcid', vcid), ('far_end', far_end), ])


class yc_bearer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection/bearer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines physical properties of a site
attachment.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bearer_reference','__pseudowire','__vpls',)

  _yang_name = 'bearer'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bearer_reference = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bearer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__pseudowire = YANGDynClass(base=yc_pseudowire_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_pseudowire, is_container='container', yang_name="pseudowire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vpls = YANGDynClass(base=yc_vpls_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_vpls, is_container='container', yang_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection', 'bearer']

  def _get_bearer_reference(self):
    """
    Getter method for bearer_reference, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/bearer_reference (string)

    YANG Description: This is an internal reference for*
the SP.
    """
    return self.__bearer_reference
      
  def _set_bearer_reference(self, v, load=False):
    """
    Setter method for bearer_reference, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/bearer_reference (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bearer_reference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bearer_reference() directly.

    YANG Description: This is an internal reference for*
the SP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bearer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bearer_reference must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bearer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__bearer_reference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bearer_reference(self):
    self.__bearer_reference = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bearer-reference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_pseudowire(self):
    """
    Getter method for pseudowire, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/pseudowire (container)

    YANG Description: Pseudowire termination parameters
    """
    return self.__pseudowire
      
  def _set_pseudowire(self, v, load=False):
    """
    Setter method for pseudowire, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/pseudowire (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pseudowire is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pseudowire() directly.

    YANG Description: Pseudowire termination parameters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_pseudowire_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_pseudowire, is_container='container', yang_name="pseudowire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pseudowire must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_pseudowire_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_pseudowire, is_container='container', yang_name="pseudowire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__pseudowire = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pseudowire(self):
    self.__pseudowire = YANGDynClass(base=yc_pseudowire_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_pseudowire, is_container='container', yang_name="pseudowire", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vpls(self):
    """
    Getter method for vpls, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/vpls (container)

    YANG Description: Pseudowire termination parameters
    """
    return self.__vpls
      
  def _set_vpls(self, v, load=False):
    """
    Setter method for vpls, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer/vpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpls() directly.

    YANG Description: Pseudowire termination parameters
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpls_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_vpls, is_container='container', yang_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpls_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_vpls, is_container='container', yang_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpls(self):
    self.__vpls = YANGDynClass(base=yc_vpls_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_vpls, is_container='container', yang_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  bearer_reference = __builtin__.property(_get_bearer_reference, _set_bearer_reference)
  pseudowire = __builtin__.property(_get_pseudowire, _set_pseudowire) # type: yc_pseudowire_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_pseudowire
  vpls = __builtin__.property(_get_vpls, _set_vpls) # type: yc_vpls_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer_vpls


  _pyangbind_elements = OrderedDict([('bearer_reference', bearer_reference), ('pseudowire', pseudowire), ('vpls', vpls), ])


class yc_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/connection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Encapsulation types
  """
  __slots__ = ('_path_helper', '_extmethods', '__encapsulation_type','__logical_interface','__tagged_interface','__bearer',)

  _yang_name = 'connection'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:untagged-int"), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__logical_interface = YANGDynClass(base=yc_logical_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_logical_interface, is_container='container', yang_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__tagged_interface = YANGDynClass(base=yc_tagged_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface, is_container='container', yang_name="tagged-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__bearer = YANGDynClass(base=yc_bearer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer, is_container='container', yang_name="bearer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'connection']

  def _get_encapsulation_type(self):
    """
    Getter method for encapsulation_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/encapsulation_type (identityref)

    YANG Description: Encapsulation type.  By default,
the encapsulation type is set to
'untagged'.
    """
    return self.__encapsulation_type
      
  def _set_encapsulation_type(self, v, load=False):
    """
    Setter method for encapsulation_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/encapsulation_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation_type() directly.

    YANG Description: Encapsulation type.  By default,
the encapsulation type is set to
'untagged'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:untagged-int"), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:untagged-int"), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__encapsulation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation_type(self):
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:priority-tagged': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:dot1q': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinq': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:qinany': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vxlan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ethernet-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vlan-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:untagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:tagged-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:lag-int': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:untagged-int"), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_logical_interface(self):
    """
    Getter method for logical_interface, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/logical_interface (container)

    YANG Description: Reference of a logical interface
type.
    """
    return self.__logical_interface
      
  def _set_logical_interface(self, v, load=False):
    """
    Setter method for logical_interface, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/logical_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_interface() directly.

    YANG Description: Reference of a logical interface
type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logical_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_logical_interface, is_container='container', yang_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logical_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_logical_interface, is_container='container', yang_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__logical_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_interface(self):
    self.__logical_interface = YANGDynClass(base=yc_logical_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_logical_interface, is_container='container', yang_name="logical-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_tagged_interface(self):
    """
    Getter method for tagged_interface, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface (container)

    YANG Description: Container for tagged interfaces.
    """
    return self.__tagged_interface
      
  def _set_tagged_interface(self, v, load=False):
    """
    Setter method for tagged_interface, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/tagged_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tagged_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tagged_interface() directly.

    YANG Description: Container for tagged interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tagged_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface, is_container='container', yang_name="tagged-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tagged_interface must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tagged_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface, is_container='container', yang_name="tagged-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__tagged_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tagged_interface(self):
    self.__tagged_interface = YANGDynClass(base=yc_tagged_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface, is_container='container', yang_name="tagged-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_bearer(self):
    """
    Getter method for bearer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer (container)

    YANG Description: Defines physical properties of a site
attachment.
    """
    return self.__bearer
      
  def _set_bearer(self, v, load=False):
    """
    Setter method for bearer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection/bearer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bearer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bearer() directly.

    YANG Description: Defines physical properties of a site
attachment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bearer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer, is_container='container', yang_name="bearer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bearer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bearer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer, is_container='container', yang_name="bearer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__bearer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bearer(self):
    self.__bearer = YANGDynClass(base=yc_bearer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer, is_container='container', yang_name="bearer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  encapsulation_type = __builtin__.property(_get_encapsulation_type, _set_encapsulation_type)
  logical_interface = __builtin__.property(_get_logical_interface, _set_logical_interface) # type: yc_logical_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_logical_interface
  tagged_interface = __builtin__.property(_get_tagged_interface, _set_tagged_interface) # type: yc_tagged_interface_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_tagged_interface
  bearer = __builtin__.property(_get_bearer, _set_bearer) # type: yc_bearer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection_bearer


  _pyangbind_elements = OrderedDict([('encapsulation_type', encapsulation_type), ('logical_interface', logical_interface), ('tagged_interface', tagged_interface), ('bearer', bearer), ])


class yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_customer_dhcp_servers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/ipv4/customer-dhcp-servers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for list of customer
DHCP servers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__server_ip_address',)

  _yang_name = 'customer-dhcp-servers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__server_ip_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'ipv4', 'customer-dhcp-servers']

  def _get_server_ip_address(self):
    """
    Getter method for server_ip_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/customer_dhcp_servers/server_ip_address (inet:ipv4-address)

    YANG Description: IP address of customer DHCP
server.
    """
    return self.__server_ip_address
      
  def _set_server_ip_address(self, v, load=False):
    """
    Setter method for server_ip_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/customer_dhcp_servers/server_ip_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_ip_address() directly.

    YANG Description: IP address of customer DHCP
server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_ip_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__server_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_ip_address(self):
    self.__server_ip_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)

  server_ip_address = __builtin__.property(_get_server_ip_address, _set_server_ip_address)

  __choices__ = {'allocation-type': {'dhcp-relay': ['server_ip_address']}}
  _pyangbind_elements = OrderedDict([('server_ip_address', server_ip_address), ])


class yc_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/ipv4/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes IPv4 addresses used.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_id','__s_provider_address','__s_customer_address','__s_prefix_length',)

  _yang_name = 'address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__s_provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    self.__s_customer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    self.__s_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="s-prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'ipv4', 'address']

  def _get_address_id(self):
    """
    Getter method for address_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/address_id (string)

    YANG Description: IPv4 Address
    """
    return self.__address_id
      
  def _set_address_id(self, v, load=False):
    """
    Setter method for address_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/address_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_id() directly.

    YANG Description: IPv4 Address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__address_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_id(self):
    self.__address_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_s_provider_address(self):
    """
    Getter method for s_provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/s_provider_address (inet:ipv4-address)

    YANG Description: IPv4 Address List of the provider side.
When the protocol allocation type is
static, the provider address must be
configured.
    """
    return self.__s_provider_address
      
  def _set_s_provider_address(self, v, load=False):
    """
    Setter method for s_provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/s_provider_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_s_provider_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_s_provider_address() directly.

    YANG Description: IPv4 Address List of the provider side.
When the protocol allocation type is
static, the provider address must be
configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """s_provider_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__s_provider_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_s_provider_address(self):
    self.__s_provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)


  def _get_s_customer_address(self):
    """
    Getter method for s_customer_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/s_customer_address (inet:ipv4-address)

    YANG Description: IPv4 Address of customer side.
    """
    return self.__s_customer_address
      
  def _set_s_customer_address(self, v, load=False):
    """
    Setter method for s_customer_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/s_customer_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_s_customer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_s_customer_address() directly.

    YANG Description: IPv4 Address of customer side.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """s_customer_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__s_customer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_s_customer_address(self):
    self.__s_customer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="s-customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)


  def _get_s_prefix_length(self):
    """
    Getter method for s_prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/s_prefix_length (uint8)

    YANG Description: Subnet prefix length expressed
in bits. It is applied to both
provider-address and customer-address.
    """
    return self.__s_prefix_length
      
  def _set_s_prefix_length(self, v, load=False):
    """
    Setter method for s_prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address/s_prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_s_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_s_prefix_length() directly.

    YANG Description: Subnet prefix length expressed
in bits. It is applied to both
provider-address and customer-address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="s-prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """s_prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="s-prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__s_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_s_prefix_length(self):
    self.__s_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="s-prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)

  address_id = __builtin__.property(_get_address_id, _set_address_id)
  s_provider_address = __builtin__.property(_get_s_provider_address, _set_s_provider_address)
  s_customer_address = __builtin__.property(_get_s_customer_address, _set_s_customer_address)
  s_prefix_length = __builtin__.property(_get_s_prefix_length, _set_s_prefix_length)

  __choices__ = {'allocation-type': {'static-addresses': ['address_id', 's_provider_address', 's_customer_address', 's_prefix_length']}}
  _pyangbind_elements = OrderedDict([('address_id', address_id), ('s_provider_address', s_provider_address), ('s_customer_address', s_customer_address), ('s_prefix_length', s_prefix_length), ])


class yc_ipv4_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4-specific parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_allocation_type','__provider_address','__prefix_length','__dr_provider_address','__dr_prefix_length','__customer_dhcp_servers','__primary_address','__address',)

  _yang_name = 'ipv4'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_allocation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__dr_provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    self.__dr_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__customer_dhcp_servers = YANGDynClass(base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__primary_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    self.__address = YANGDynClass(base=YANGListType("address_id",yc_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'ipv4']

  def _get_address_allocation_type(self):
    """
    Getter method for address_allocation_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address_allocation_type (identityref)

    YANG Description: Defines how addresses are allocated.
If there is no value for the address
allocation type, then IPv4 is not enabled.
    """
    return self.__address_allocation_type
      
  def _set_address_allocation_type(self, v, load=False):
    """
    Setter method for address_allocation_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address_allocation_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_allocation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_allocation_type() directly.

    YANG Description: Defines how addresses are allocated.
If there is no value for the address
allocation type, then IPv4 is not enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_allocation_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__address_allocation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_allocation_type(self):
    self.__address_allocation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_provider_address(self):
    """
    Getter method for provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/provider_address (inet:ipv4-address)

    YANG Description: Address of provider side.
If provider-address is not specified,
then prefix length should not be
specified either.

It also implies provider-dhcp
allocation is not enabled.

If provider-address is specified,
then the prefix length may or
may not be specified.
    """
    return self.__provider_address
      
  def _set_provider_address(self, v, load=False):
    """
    Setter method for provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/provider_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_address() directly.

    YANG Description: Address of provider side.
If provider-address is not specified,
then prefix length should not be
specified either.

It also implies provider-dhcp
allocation is not enabled.

If provider-address is specified,
then the prefix length may or
may not be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__provider_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_address(self):
    self.__provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/prefix_length (uint8)

    YANG Description: Subnet prefix length expressed in bits.
If not specified, or specified as zero,
this means the customer leaves the actual
prefix length value to the provider.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Subnet prefix length expressed in bits.
If not specified, or specified as zero,
this means the customer leaves the actual
prefix length value to the provider.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_dr_provider_address(self):
    """
    Getter method for dr_provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/dr_provider_address (inet:ipv4-address)

    YANG Description: Address of provider side.

If provider-address is
not specified, then prefix length
should not be specified either.

It also implies provider-dhcp
allocation is not enabled.

If provider-address is specified,
then prefix length may or may
not be specified.
    """
    return self.__dr_provider_address
      
  def _set_dr_provider_address(self, v, load=False):
    """
    Setter method for dr_provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/dr_provider_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_provider_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_provider_address() directly.

    YANG Description: Address of provider side.

If provider-address is
not specified, then prefix length
should not be specified either.

It also implies provider-dhcp
allocation is not enabled.

If provider-address is specified,
then prefix length may or may
not be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_provider_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__dr_provider_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_provider_address(self):
    self.__dr_provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)


  def _get_dr_prefix_length(self):
    """
    Getter method for dr_prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/dr_prefix_length (uint8)

    YANG Description: Subnet prefix length expressed in bits.

If not specified, or specified as zero,
this means the customer leaves the
actual prefix  length value
to the provider.
    """
    return self.__dr_prefix_length
      
  def _set_dr_prefix_length(self, v, load=False):
    """
    Setter method for dr_prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/dr_prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_prefix_length() directly.

    YANG Description: Subnet prefix length expressed in bits.

If not specified, or specified as zero,
this means the customer leaves the
actual prefix  length value
to the provider.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__dr_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_prefix_length(self):
    self.__dr_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..32']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_customer_dhcp_servers(self):
    """
    Getter method for customer_dhcp_servers, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/customer_dhcp_servers (container)

    YANG Description: Container for list of customer
DHCP servers.
    """
    return self.__customer_dhcp_servers
      
  def _set_customer_dhcp_servers(self, v, load=False):
    """
    Setter method for customer_dhcp_servers, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/customer_dhcp_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_customer_dhcp_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_customer_dhcp_servers() directly.

    YANG Description: Container for list of customer
DHCP servers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """customer_dhcp_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__customer_dhcp_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_customer_dhcp_servers(self):
    self.__customer_dhcp_servers = YANGDynClass(base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_primary_address(self):
    """
    Getter method for primary_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/primary_address (leafref)

    YANG Description: Principal address of the connection.
    """
    return self.__primary_address
      
  def _set_primary_address(self, v, load=False):
    """
    Setter method for primary_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/primary_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_address() directly.

    YANG Description: Principal address of the connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__primary_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_address(self):
    self.__primary_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address (list)

    YANG Description: Describes IPv4 addresses used.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Describes IPv4 addresses used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address_id",yc_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address_id",yc_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("address_id",yc_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  address_allocation_type = __builtin__.property(_get_address_allocation_type, _set_address_allocation_type)
  provider_address = __builtin__.property(_get_provider_address, _set_provider_address)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  dr_provider_address = __builtin__.property(_get_dr_provider_address, _set_dr_provider_address)
  dr_prefix_length = __builtin__.property(_get_dr_prefix_length, _set_dr_prefix_length)
  customer_dhcp_servers = __builtin__.property(_get_customer_dhcp_servers, _set_customer_dhcp_servers) # type: yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_customer_dhcp_servers
  primary_address = __builtin__.property(_get_primary_address, _set_primary_address)
  address = __builtin__.property(_get_address, _set_address) # type: yc_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4_address

  __choices__ = {'allocation-type': {'provider-dhcp': ['provider_address', 'prefix_length'], 'dhcp-relay': ['dr_provider_address', 'dr_prefix_length', 'customer_dhcp_servers'], 'static-addresses': ['primary_address', 'address']}}
  _pyangbind_elements = OrderedDict([('address_allocation_type', address_allocation_type), ('provider_address', provider_address), ('prefix_length', prefix_length), ('dr_provider_address', dr_provider_address), ('dr_prefix_length', dr_prefix_length), ('customer_dhcp_servers', customer_dhcp_servers), ('primary_address', primary_address), ('address', address), ])


class yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_customer_dhcp_servers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/ipv6/customer-dhcp-servers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for list of customer DHCP
servers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__server_ip_address',)

  _yang_name = 'customer-dhcp-servers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__server_ip_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'ipv6', 'customer-dhcp-servers']

  def _get_server_ip_address(self):
    """
    Getter method for server_ip_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/customer_dhcp_servers/server_ip_address (inet:ipv6-address)

    YANG Description: This node contains the IP address of
the customer DHCP server.  If the DHCP
relay function is implemented by the
provider, this node contains the
configured value.
    """
    return self.__server_ip_address
      
  def _set_server_ip_address(self, v, load=False):
    """
    Setter method for server_ip_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/customer_dhcp_servers/server_ip_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_ip_address() directly.

    YANG Description: This node contains the IP address of
the customer DHCP server.  If the DHCP
relay function is implemented by the
provider, this node contains the
configured value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_ip_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__server_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_ip_address(self):
    self.__server_ip_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="server-ip-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)

  server_ip_address = __builtin__.property(_get_server_ip_address, _set_server_ip_address)

  __choices__ = {'allocation-type': {'dhcp-relay': ['server_ip_address']}}
  _pyangbind_elements = OrderedDict([('server_ip_address', server_ip_address), ])


class yc_s_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_s_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/ipv6/s-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes IPv6 addresses used.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_id','__provider_address','__customer_address','__prefix_length',)

  _yang_name = 's-address'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    self.__customer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'ipv6', 's-address']

  def _get_address_id(self):
    """
    Getter method for address_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/address_id (string)

    YANG Description: IPv4 Address
    """
    return self.__address_id
      
  def _set_address_id(self, v, load=False):
    """
    Setter method for address_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/address_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_id() directly.

    YANG Description: IPv4 Address
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__address_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_id(self):
    self.__address_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="address-id", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_provider_address(self):
    """
    Getter method for provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/provider_address (inet:ipv6-address)

    YANG Description: IPv6 Address of the provider side.  When
the protocol allocation type is static,
the provider address must be
configured.
    """
    return self.__provider_address
      
  def _set_provider_address(self, v, load=False):
    """
    Setter method for provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/provider_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_address() directly.

    YANG Description: IPv6 Address of the provider side.  When
the protocol allocation type is static,
the provider address must be
configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__provider_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_address(self):
    self.__provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)


  def _get_customer_address(self):
    """
    Getter method for customer_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/customer_address (inet:ipv6-address)

    YANG Description: The IPv6 Address of the customer side.
    """
    return self.__customer_address
      
  def _set_customer_address(self, v, load=False):
    """
    Setter method for customer_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/customer_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_customer_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_customer_address() directly.

    YANG Description: The IPv6 Address of the customer side.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """customer_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__customer_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_customer_address(self):
    self.__customer_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="customer-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/prefix_length (uint8)

    YANG Description: Subnet prefix length expressed in bits.
It is applied to both provider-address
and customer-address.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Subnet prefix length expressed in bits.
It is applied to both provider-address
and customer-address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)

  address_id = __builtin__.property(_get_address_id, _set_address_id)
  provider_address = __builtin__.property(_get_provider_address, _set_provider_address)
  customer_address = __builtin__.property(_get_customer_address, _set_customer_address)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)

  __choices__ = {'allocation-type': {'static-addresses': ['address_id', 'provider_address', 'customer_address', 'prefix_length']}}
  _pyangbind_elements = OrderedDict([('address_id', address_id), ('provider_address', provider_address), ('customer_address', customer_address), ('prefix_length', prefix_length), ])


class yc_ipv6_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6-specific parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_allocation_type','__provider_address','__prefix_length','__dr_provider_address','__dr_prefix_length','__customer_dhcp_servers','__s_primary_address','__s_address',)

  _yang_name = 'ipv6'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_allocation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__dr_provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    self.__dr_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__customer_dhcp_servers = YANGDynClass(base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__s_primary_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="s-primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    self.__s_address = YANGDynClass(base=YANGListType("address_id",yc_s_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_s_address, yang_name="s-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="s-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'ipv6']

  def _get_address_allocation_type(self):
    """
    Getter method for address_allocation_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/address_allocation_type (identityref)

    YANG Description: Defines how addresses are allocated.
If there is no value for the address
allocation type, then IPv6 is
not enabled.
    """
    return self.__address_allocation_type
      
  def _set_address_allocation_type(self, v, load=False):
    """
    Setter method for address_allocation_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/address_allocation_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_allocation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_allocation_type() directly.

    YANG Description: Defines how addresses are allocated.
If there is no value for the address
allocation type, then IPv6 is
not enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_allocation_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__address_allocation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_allocation_type(self):
    self.__address_allocation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-relay': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:provider-dhcp-slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:static-address': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:slaac': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="address-allocation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_provider_address(self):
    """
    Getter method for provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/provider_address (inet:ipv6-address)

    YANG Description: Address of the provider side.

If provider-address is not specified,
then prefix length should not be
specified either.  It also implies
provider-dhcp allocation is not
enabled.

If provider-address is
specified, then prefix length may
or may not be specified.
    """
    return self.__provider_address
      
  def _set_provider_address(self, v, load=False):
    """
    Setter method for provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/provider_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_address() directly.

    YANG Description: Address of the provider side.

If provider-address is not specified,
then prefix length should not be
specified either.  It also implies
provider-dhcp allocation is not
enabled.

If provider-address is
specified, then prefix length may
or may not be specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__provider_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_address(self):
    self.__provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="provider-address", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/prefix_length (uint8)

    YANG Description: Subnet prefix length expressed in
bits.

If not specified, or specified as
zero, this means the customer leaves
the actual prefix length value to
the provider.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Subnet prefix length expressed in
bits.

If not specified, or specified as
zero, this means the customer leaves
the actual prefix length value to
the provider.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('allocation-type', 'provider-dhcp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_dr_provider_address(self):
    """
    Getter method for dr_provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/dr_provider_address (inet:ipv6-address)

    YANG Description: Address of the provider side.

If provider-address is not specified,
then prefix length should not be
specified either.  It also implies
provider-dhcp allocation is not enabled.

If provider address is specified, then
prefix length may or may not be
specified.
    """
    return self.__dr_provider_address
      
  def _set_dr_provider_address(self, v, load=False):
    """
    Setter method for dr_provider_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/dr_provider_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_provider_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_provider_address() directly.

    YANG Description: Address of the provider side.

If provider-address is not specified,
then prefix length should not be
specified either.  It also implies
provider-dhcp allocation is not enabled.

If provider address is specified, then
prefix length may or may not be
specified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_provider_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__dr_provider_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_provider_address(self):
    self.__dr_provider_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="dr-provider-address", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)


  def _get_dr_prefix_length(self):
    """
    Getter method for dr_prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/dr_prefix_length (uint8)

    YANG Description: Subnet prefix length expressed in bits.

If not specified, or specified as zero,
this means the customer leaves the
actual prefix length value to the
provider.
    """
    return self.__dr_prefix_length
      
  def _set_dr_prefix_length(self, v, load=False):
    """
    Setter method for dr_prefix_length, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/dr_prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dr_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dr_prefix_length() directly.

    YANG Description: Subnet prefix length expressed in bits.

If not specified, or specified as zero,
this means the customer leaves the
actual prefix length value to the
provider.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dr_prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__dr_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dr_prefix_length(self):
    self.__dr_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="dr-prefix-length", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_customer_dhcp_servers(self):
    """
    Getter method for customer_dhcp_servers, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/customer_dhcp_servers (container)

    YANG Description: Container for list of customer DHCP
servers.
    """
    return self.__customer_dhcp_servers
      
  def _set_customer_dhcp_servers(self, v, load=False):
    """
    Setter method for customer_dhcp_servers, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/customer_dhcp_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_customer_dhcp_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_customer_dhcp_servers() directly.

    YANG Description: Container for list of customer DHCP
servers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """customer_dhcp_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__customer_dhcp_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_customer_dhcp_servers(self):
    self.__customer_dhcp_servers = YANGDynClass(base=yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_customer_dhcp_servers, is_container='container', yang_name="customer-dhcp-servers", parent=self, choice=('allocation-type', 'dhcp-relay'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_s_primary_address(self):
    """
    Getter method for s_primary_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_primary_address (leafref)

    YANG Description: Principal address of the connection
    """
    return self.__s_primary_address
      
  def _set_s_primary_address(self, v, load=False):
    """
    Setter method for s_primary_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_primary_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_s_primary_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_s_primary_address() directly.

    YANG Description: Principal address of the connection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="s-primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """s_primary_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="s-primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__s_primary_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_s_primary_address(self):
    self.__s_primary_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="s-primary-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)


  def _get_s_address(self):
    """
    Getter method for s_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address (list)

    YANG Description: Describes IPv6 addresses used.
    """
    return self.__s_address
      
  def _set_s_address(self, v, load=False):
    """
    Setter method for s_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6/s_address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_s_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_s_address() directly.

    YANG Description: Describes IPv6 addresses used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address_id",yc_s_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_s_address, yang_name="s-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="s-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """s_address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address_id",yc_s_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_s_address, yang_name="s-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="s-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__s_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_s_address(self):
    self.__s_address = YANGDynClass(base=YANGListType("address_id",yc_s_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_s_address, yang_name="s-address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-id', extensions=None, choice=False), is_container='list', yang_name="s-address", parent=self, choice=('allocation-type', 'static-addresses'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  address_allocation_type = __builtin__.property(_get_address_allocation_type, _set_address_allocation_type)
  provider_address = __builtin__.property(_get_provider_address, _set_provider_address)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  dr_provider_address = __builtin__.property(_get_dr_provider_address, _set_dr_provider_address)
  dr_prefix_length = __builtin__.property(_get_dr_prefix_length, _set_dr_prefix_length)
  customer_dhcp_servers = __builtin__.property(_get_customer_dhcp_servers, _set_customer_dhcp_servers) # type: yc_customer_dhcp_servers_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_customer_dhcp_servers
  s_primary_address = __builtin__.property(_get_s_primary_address, _set_s_primary_address)
  s_address = __builtin__.property(_get_s_address, _set_s_address) # type: yc_s_address_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6_s_address

  __choices__ = {'allocation-type': {'provider-dhcp': ['provider_address', 'prefix_length'], 'dhcp-relay': ['dr_provider_address', 'dr_prefix_length', 'customer_dhcp_servers'], 'static-addresses': ['s_primary_address', 's_address']}}
  _pyangbind_elements = OrderedDict([('address_allocation_type', address_allocation_type), ('provider_address', provider_address), ('prefix_length', prefix_length), ('dr_provider_address', dr_provider_address), ('dr_prefix_length', dr_prefix_length), ('customer_dhcp_servers', customer_dhcp_servers), ('s_primary_address', s_primary_address), ('s_address', s_address), ])


class yc_bfd_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/oam/bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__fixed_value','__profile_name',)

  _yang_name = 'bfd'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__fixed_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fixed-value", parent=self, choice=('holdtime', 'fixed'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    self.__profile_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('holdtime', 'profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'oam', 'bfd']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd/enabled (boolean)

    YANG Description: If true, BFD activation is required.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: If true, BFD activation is required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_fixed_value(self):
    """
    Getter method for fixed_value, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd/fixed_value (uint32)

    YANG Description: Expected BFD holdtime.

The customer may impose some fixed
values for the holdtime period if the
provider allows the customer use this
function.

If the provider doesn't allow the
customer to use this function,
the fixed-value will not be set.
    """
    return self.__fixed_value
      
  def _set_fixed_value(self, v, load=False):
    """
    Setter method for fixed_value, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd/fixed_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fixed_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fixed_value() directly.

    YANG Description: Expected BFD holdtime.

The customer may impose some fixed
values for the holdtime period if the
provider allows the customer use this
function.

If the provider doesn't allow the
customer to use this function,
the fixed-value will not be set.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fixed-value", parent=self, choice=('holdtime', 'fixed'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fixed_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fixed-value", parent=self, choice=('holdtime', 'fixed'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)""",
        })

    self.__fixed_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fixed_value(self):
    self.__fixed_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fixed-value", parent=self, choice=('holdtime', 'fixed'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)


  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd/profile_name (leafref)

    YANG Description: Well-known SP profile name.

The provider can propose some profiles
to the customer, depending on the
service level the customer wants to
achieve.

Profile names must be communicated to
the customer.
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd/profile_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: Well-known SP profile name.

The provider can propose some profiles
to the customer, depending on the
service level the customer wants to
achieve.

Profile names must be communicated to
the customer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('holdtime', 'profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('holdtime', 'profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('holdtime', 'profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  fixed_value = __builtin__.property(_get_fixed_value, _set_fixed_value)
  profile_name = __builtin__.property(_get_profile_name, _set_profile_name)

  __choices__ = {'holdtime': {'fixed': ['fixed_value'], 'profile': ['profile_name']}}
  _pyangbind_elements = OrderedDict([('enabled', enabled), ('fixed_value', fixed_value), ('profile_name', profile_name), ])


class yc_oam_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection/oam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the Operations, Administration,
and Maintenance (OAM)mechanisms used on
the connection.

BFD is set as a fault detection mechanism,
but the 'oam' container can easily
be augmented by other mechanisms
  """
  __slots__ = ('_path_helper', '_extmethods', '__bfd',)

  _yang_name = 'oam'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bfd = YANGDynClass(base=yc_bfd_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection', 'oam']

  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd (container)

    YANG Description: Container for BFD.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: Container for BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bfd_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bfd_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=yc_bfd_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  bfd = __builtin__.property(_get_bfd, _set_bfd) # type: yc_bfd_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam_bfd


  _pyangbind_elements = OrderedDict([('bfd', bfd), ])


class yc_ip_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/ip-connection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines connection parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv4','__ipv6','__oam',)

  _yang_name = 'ip-connection'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__oam = YANGDynClass(base=yc_oam_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'ip-connection']

  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4 (container)

    YANG Description: IPv4-specific parameters.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: IPv4-specific parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6 (container)

    YANG Description: IPv6-specific parameters.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: IPv6-specific parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_oam(self):
    """
    Getter method for oam, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam (container)

    YANG Description: Defines the Operations, Administration,
and Maintenance (OAM)mechanisms used on
the connection.

BFD is set as a fault detection mechanism,
but the 'oam' container can easily
be augmented by other mechanisms
    """
    return self.__oam
      
  def _set_oam(self, v, load=False):
    """
    Setter method for oam, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection/oam (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oam is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oam() directly.

    YANG Description: Defines the Operations, Administration,
and Maintenance (OAM)mechanisms used on
the connection.

BFD is set as a fault detection mechanism,
but the 'oam' container can easily
be augmented by other mechanisms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oam_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oam must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oam_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__oam = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oam(self):
    self.__oam = YANGDynClass(base=yc_oam_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4) # type: yc_ipv4_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv4
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6) # type: yc_ipv6_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_ipv6
  oam = __builtin__.property(_get_oam, _set_oam) # type: yc_oam_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection_oam


  _pyangbind_elements = OrderedDict([('ipv4', ipv4), ('ipv6', ipv6), ('oam', oam), ])


class yc_encryption_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/security/encryption. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for CE-PE security encryption.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__layer',)

  _yang_name = 'encryption'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__layer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'layer2': {}, 'layer3': {}},), is_leaf=True, yang_name="layer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'security', 'encryption']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption/enabled (boolean)

    YANG Description: If true, traffic encryption on the
connection is required. It is
disabled, otherwise.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: If true, traffic encryption on the
connection is required. It is
disabled, otherwise.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_layer(self):
    """
    Getter method for layer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption/layer (enumeration)

    YANG Description: Layer on which encryption is applied.
    """
    return self.__layer
      
  def _set_layer(self, v, load=False):
    """
    Setter method for layer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption/layer (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer() directly.

    YANG Description: Layer on which encryption is applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'layer2': {}, 'layer3': {}},), is_leaf=True, yang_name="layer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """layer must be of a type compatible with enumeration""",
          'defined-type': "ietf-l3vpn-ntw:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'layer2': {}, 'layer3': {}},), is_leaf=True, yang_name="layer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)""",
        })

    self.__layer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_layer(self):
    self.__layer = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'layer2': {}, 'layer3': {}},), is_leaf=True, yang_name="layer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  layer = __builtin__.property(_get_layer, _set_layer)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('layer', layer), ])


class yc_encryption_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/security/encryption-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for encryption profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile_name','__algorithm','__preshared_key',)

  _yang_name = 'encryption-profile'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('profile', 'provider-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, choice=('profile', 'customer-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__preshared_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preshared-key", parent=self, choice=('key-type', 'psk'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'security', 'encryption-profile']

  def _get_profile_name(self):
    """
    Getter method for profile_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile/profile_name (leafref)

    YANG Description: Name of the SP profile to be applied.
    """
    return self.__profile_name
      
  def _set_profile_name(self, v, load=False):
    """
    Setter method for profile_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile/profile_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile_name() directly.

    YANG Description: Name of the SP profile to be applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('profile', 'provider-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('profile', 'provider-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile_name(self):
    self.__profile_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile-name", parent=self, choice=('profile', 'provider-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)


  def _get_algorithm(self):
    """
    Getter method for algorithm, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile/algorithm (string)

    YANG Description: Encryption algorithm to be used.
    """
    return self.__algorithm
      
  def _set_algorithm(self, v, load=False):
    """
    Setter method for algorithm, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile/algorithm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: Encryption algorithm to be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, choice=('profile', 'customer-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, choice=('profile', 'customer-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__algorithm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm(self):
    self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, choice=('profile', 'customer-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_preshared_key(self):
    """
    Getter method for preshared_key, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile/preshared_key (string)

    YANG Description: Pre-Shared Key (PSK) coming from the
customer.
    """
    return self.__preshared_key
      
  def _set_preshared_key(self, v, load=False):
    """
    Setter method for preshared_key, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile/preshared_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preshared_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preshared_key() directly.

    YANG Description: Pre-Shared Key (PSK) coming from the
customer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="preshared-key", parent=self, choice=('key-type', 'psk'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preshared_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preshared-key", parent=self, choice=('key-type', 'psk'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__preshared_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preshared_key(self):
    self.__preshared_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preshared-key", parent=self, choice=('key-type', 'psk'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  profile_name = __builtin__.property(_get_profile_name, _set_profile_name)
  algorithm = __builtin__.property(_get_algorithm, _set_algorithm)
  preshared_key = __builtin__.property(_get_preshared_key, _set_preshared_key)

  __choices__ = {'profile': {'provider-profile': ['profile_name'], 'customer-profile': ['algorithm']}, 'key-type': {'psk': ['preshared_key']}}
  _pyangbind_elements = OrderedDict([('profile_name', profile_name), ('algorithm', algorithm), ('preshared_key', preshared_key), ])


class yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Site-specific security parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__encryption','__encryption_profile',)

  _yang_name = 'security'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encryption = YANGDynClass(base=yc_encryption_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__encryption_profile = YANGDynClass(base=yc_encryption_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption_profile, is_container='container', yang_name="encryption-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'security']

  def _get_encryption(self):
    """
    Getter method for encryption, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption (container)

    YANG Description: Container for CE-PE security encryption.
    """
    return self.__encryption
      
  def _set_encryption(self, v, load=False):
    """
    Setter method for encryption, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption() directly.

    YANG Description: Container for CE-PE security encryption.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encryption_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encryption_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption(self):
    self.__encryption = YANGDynClass(base=yc_encryption_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_encryption_profile(self):
    """
    Getter method for encryption_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile (container)

    YANG Description: Container for encryption profile.
    """
    return self.__encryption_profile
      
  def _set_encryption_profile(self, v, load=False):
    """
    Setter method for encryption_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security/encryption_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption_profile() directly.

    YANG Description: Container for encryption profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encryption_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption_profile, is_container='container', yang_name="encryption-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encryption_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption_profile, is_container='container', yang_name="encryption-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__encryption_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption_profile(self):
    self.__encryption_profile = YANGDynClass(base=yc_encryption_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption_profile, is_container='container', yang_name="encryption-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  encryption = __builtin__.property(_get_encryption, _set_encryption) # type: yc_encryption_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption
  encryption_profile = __builtin__.property(_get_encryption_profile, _set_encryption_profile) # type: yc_encryption_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security_encryption_profile


  _pyangbind_elements = OrderedDict([('encryption', encryption), ('encryption_profile', encryption_profile), ])


class yc_routing_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_routing_profiles(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/routing-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routing profiles.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type',)

  _yang_name = 'routing-profiles'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'routing-profiles']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/routing_profiles/id (leafref)

    YANG Description: Routing profile to be used.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/routing_profiles/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Routing profile to be used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/routing_profiles/type (identityref)

    YANG Description: Import, export or both.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/routing_profiles/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Import, export or both.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:import-export': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('id', id), ('type', type), ])


class yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/ospf/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for aggregating any security parameter
 for routing sessions between a PE and a CE.
  """
  __slots__ = ('_path_helper', '_extmethods', '__auth_key',)

  _yang_name = 'security'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__auth_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'security']

  def _get_auth_key(self):
    """
    Getter method for auth_key, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/security/auth_key (string)

    YANG Description: MD5 authentication password for the connection
towards the customer edge.
    """
    return self.__auth_key
      
  def _set_auth_key(self, v, load=False):
    """
    Setter method for auth_key, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/security/auth_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_key() directly.

    YANG Description: MD5 authentication password for the connection
towards the customer edge.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__auth_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_key(self):
    self.__auth_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  auth_key = __builtin__.property(_get_auth_key, _set_auth_key)


  _pyangbind_elements = OrderedDict([('auth_key', auth_key), ])


class yc_sham_link_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links_sham_link(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/ospf/sham-links/sham-link. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Creates a sham link with another site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__target_site','__metric',)

  _yang_name = 'sham-link'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__target_site = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target-site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links', 'sham-link']

  def _get_target_site(self):
    """
    Getter method for target_site, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links/sham_link/target_site (vpn-common:vpn-id)

    YANG Description: Target site for the sham link connection.
The site is referred to by its ID.
    """
    return self.__target_site
      
  def _set_target_site(self, v, load=False):
    """
    Setter method for target_site, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links/sham_link/target_site (vpn-common:vpn-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_site is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_site() directly.

    YANG Description: Target site for the sham link connection.
The site is referred to by its ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="target-site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_site must be of a type compatible with vpn-common:vpn-id""",
          'defined-type': "vpn-common:vpn-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target-site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)""",
        })

    self.__target_site = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_site(self):
    self.__target_site = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target-site", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)


  def _get_metric(self):
    """
    Getter method for metric, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links/sham_link/metric (uint16)

    YANG Description: Metric of the sham link.  It is used in
the routing state calculation and path
selection.  The default value is set
to 1.
    """
    return self.__metric
      
  def _set_metric(self, v, load=False):
    """
    Setter method for metric, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links/sham_link/metric (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric() directly.

    YANG Description: Metric of the sham link.  It is used in
the routing state calculation and path
selection.  The default value is set
to 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric(self):
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

  target_site = __builtin__.property(_get_target_site, _set_target_site)
  metric = __builtin__.property(_get_metric, _set_metric)


  _pyangbind_elements = OrderedDict([('target_site', target_site), ('metric', metric), ])


class yc_sham_links_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/ospf/sham-links. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of sham links.
  """
  __slots__ = ('_path_helper', '_extmethods', '__sham_link',)

  _yang_name = 'sham-links'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sham_link = YANGDynClass(base=YANGListType("target_site",yc_sham_link_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='target-site', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'ospf', 'sham-links']

  def _get_sham_link(self):
    """
    Getter method for sham_link, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links/sham_link (list)

    YANG Description: Creates a sham link with another site.
    """
    return self.__sham_link
      
  def _set_sham_link(self, v, load=False):
    """
    Setter method for sham_link, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links/sham_link (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sham_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sham_link() directly.

    YANG Description: Creates a sham link with another site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("target_site",yc_sham_link_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='target-site', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sham_link must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("target_site",yc_sham_link_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='target-site', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__sham_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sham_link(self):
    self.__sham_link = YANGDynClass(base=YANGListType("target_site",yc_sham_link_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links_sham_link, yang_name="sham-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='target-site', extensions=None), is_container='list', yang_name="sham-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  sham_link = __builtin__.property(_get_sham_link, _set_sham_link) # type: yc_sham_link_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links_sham_link


  _pyangbind_elements = OrderedDict([('sham_link', sham_link), ])


class yc_ospf_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/ospf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OSPF-specific configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_family','__area_address','__metric','__mtu','__process_id','__security','__sham_links',)

  _yang_name = 'ospf'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__area_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__security = YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__sham_links = YANGDynClass(base=yc_sham_links_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'ospf']

  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/address_family (vpn-common:address-family)

    YANG Description: If OSPF is used on this site, this node
contains a configured value.  This node
contains at least one address family
to be activated.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: If OSPF is used on this site, this node
contains a configured value.  This node
contains at least one address family
to be activated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_area_address(self):
    """
    Getter method for area_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/area_address (yang:dotted-quad)

    YANG Description: Area address.
    """
    return self.__area_address
      
  def _set_area_address(self, v, load=False):
    """
    Setter method for area_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/area_address (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_address() directly.

    YANG Description: Area address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_address must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__area_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_address(self):
    self.__area_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)


  def _get_metric(self):
    """
    Getter method for metric, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/metric (uint16)

    YANG Description: Metric of the PE-CE link.  It is used
in the routing state calculation and
path selection.
    """
    return self.__metric
      
  def _set_metric(self, v, load=False):
    """
    Setter method for metric, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/metric (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric() directly.

    YANG Description: Metric of the PE-CE link.  It is used
in the routing state calculation and
path selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric(self):
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/mtu (uint16)

    YANG Description: Maximum transmission unit for a given
OSPF link.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Maximum transmission unit for a given
OSPF link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_process_id(self):
    """
    Getter method for process_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/process_id (uint16)

    YANG Description: Process id of the OSPF CE-PE connection.
    """
    return self.__process_id
      
  def _set_process_id(self, v, load=False):
    """
    Setter method for process_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/process_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process_id() directly.

    YANG Description: Process id of the OSPF CE-PE connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__process_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process_id(self):
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/security (container)

    YANG Description: Container for aggregating any security parameter
 for routing sessions between a PE and a CE.
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Container for aggregating any security parameter
 for routing sessions between a PE and a CE.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_sham_links(self):
    """
    Getter method for sham_links, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links (container)

    YANG Description: List of sham links.
    """
    return self.__sham_links
      
  def _set_sham_links(self, v, load=False):
    """
    Setter method for sham_links, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf/sham_links (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sham_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sham_links() directly.

    YANG Description: List of sham links.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sham_links_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sham_links must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sham_links_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__sham_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sham_links(self):
    self.__sham_links = YANGDynClass(base=yc_sham_links_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links, is_container='container', yang_name="sham-links", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  address_family = __builtin__.property(_get_address_family, _set_address_family)
  area_address = __builtin__.property(_get_area_address, _set_area_address)
  metric = __builtin__.property(_get_metric, _set_metric)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  process_id = __builtin__.property(_get_process_id, _set_process_id)
  security = __builtin__.property(_get_security, _set_security) # type: yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_security
  sham_links = __builtin__.property(_get_sham_links, _set_sham_links) # type: yc_sham_links_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf_sham_links


  _pyangbind_elements = OrderedDict([('address_family', address_family), ('area_address', area_address), ('metric', metric), ('mtu', mtu), ('process_id', process_id), ('security', security), ('sham_links', sham_links), ])


class yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for aggregating any security parameter
 for routing sessions between a PE and a CE.
  """
  __slots__ = ('_path_helper', '_extmethods', '__auth_key',)

  _yang_name = 'security'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__auth_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp', 'security']

  def _get_auth_key(self):
    """
    Getter method for auth_key, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/security/auth_key (string)

    YANG Description: MD5 authentication password for the connection
towards the customer edge.
    """
    return self.__auth_key
      
  def _set_auth_key(self, v, load=False):
    """
    Setter method for auth_key, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/security/auth_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_key() directly.

    YANG Description: MD5 authentication password for the connection
towards the customer edge.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__auth_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_key(self):
    self.__auth_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  auth_key = __builtin__.property(_get_auth_key, _set_auth_key)


  _pyangbind_elements = OrderedDict([('auth_key', auth_key), ])


class yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_admin_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp/status/admin-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'admin-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp', 'status', 'admin-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/admin_status/status (identityref)

    YANG Description: Administrative service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/admin_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/admin_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/admin_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

  status = __builtin__.property(_get_status, _set_status)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_oper_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp/status/oper-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'oper-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp', 'status', 'oper-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/oper_status/status (identityref)

    YANG Description: Operations status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/oper_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Operations status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/oper_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/oper_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

  status = __builtin__.property(_get_status)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp/status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_status','__oper_status',)

  _yang_name = 'status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp', 'status']

  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/admin_status (container)

    YANG Description: Administrative service status.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/admin_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/oper_status (container)

    YANG Description: Operational service status.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status/oper_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  admin_status = __builtin__.property(_get_admin_status, _set_admin_status) # type: yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_admin_status
  oper_status = __builtin__.property(_get_oper_status, _set_oper_status) # type: yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status_oper_status


  _pyangbind_elements = OrderedDict([('admin_status', admin_status), ('oper_status', oper_status), ])


class yc_bgp_max_prefix_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_max_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp/bgp-max-prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Controls the behavior when a prefix
maximum is reached.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefix','__warning_threshold','__violate_action','__restart_interval',)

  _yang_name = 'bgp-max-prefix'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefix = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    self.__warning_threshold = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..100']}), default=Decimal(75), is_leaf=True, yang_name="warning-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='decimal64', is_config=True)
    self.__violate_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'warning': {}, 'discard-extra-paths': {}, 'restart': {}},), is_leaf=True, yang_name="violate-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    self.__restart_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="restart-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp', 'bgp-max-prefix']

  def _get_max_prefix(self):
    """
    Getter method for max_prefix, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/max_prefix (uint32)

    YANG Description: Indicates the maximimum number of BGP
prefixes allowed in the BGP session.

It allows to control how many prefixes
can be received from a neighbor.

If the limit is exceeded, the session
 can be teared down.
    """
    return self.__max_prefix
      
  def _set_max_prefix(self, v, load=False):
    """
    Setter method for max_prefix, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/max_prefix (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefix() directly.

    YANG Description: Indicates the maximimum number of BGP
prefixes allowed in the BGP session.

It allows to control how many prefixes
can be received from a neighbor.

If the limit is exceeded, the session
 can be teared down.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefix must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefix(self):
    self.__max_prefix = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(5000), is_leaf=True, yang_name="max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)


  def _get_warning_threshold(self):
    """
    Getter method for warning_threshold, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/warning_threshold (decimal64)

    YANG Description: When this value is reached, a warning
notification will be triggered.
    """
    return self.__warning_threshold
      
  def _set_warning_threshold(self, v, load=False):
    """
    Setter method for warning_threshold, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/warning_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_warning_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_warning_threshold() directly.

    YANG Description: When this value is reached, a warning
notification will be triggered.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..100']}), default=Decimal(75), is_leaf=True, yang_name="warning-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """warning_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..100']}), default=Decimal(75), is_leaf=True, yang_name="warning-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='decimal64', is_config=True)""",
        })

    self.__warning_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_warning_threshold(self):
    self.__warning_threshold = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..100']}), default=Decimal(75), is_leaf=True, yang_name="warning-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='decimal64', is_config=True)


  def _get_violate_action(self):
    """
    Getter method for violate_action, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/violate_action (enumeration)

    YANG Description: BGP neighbour max-prefix violate
action
    """
    return self.__violate_action
      
  def _set_violate_action(self, v, load=False):
    """
    Setter method for violate_action, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/violate_action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_violate_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_violate_action() directly.

    YANG Description: BGP neighbour max-prefix violate
action
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'warning': {}, 'discard-extra-paths': {}, 'restart': {}},), is_leaf=True, yang_name="violate-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """violate_action must be of a type compatible with enumeration""",
          'defined-type': "ietf-l3vpn-ntw:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'warning': {}, 'discard-extra-paths': {}, 'restart': {}},), is_leaf=True, yang_name="violate-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)""",
        })

    self.__violate_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_violate_action(self):
    self.__violate_action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'warning': {}, 'discard-extra-paths': {}, 'restart': {}},), is_leaf=True, yang_name="violate-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)


  def _get_restart_interval(self):
    """
    Getter method for restart_interval, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/restart_interval (uint16)

    YANG Description: Time interval (min) after which the
BGP session will be reestablished.
    """
    return self.__restart_interval
      
  def _set_restart_interval(self, v, load=False):
    """
    Setter method for restart_interval, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix/restart_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_interval() directly.

    YANG Description: Time interval (min) after which the
BGP session will be reestablished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="restart-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="restart-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__restart_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_interval(self):
    self.__restart_interval = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="restart-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

  max_prefix = __builtin__.property(_get_max_prefix, _set_max_prefix)
  warning_threshold = __builtin__.property(_get_warning_threshold, _set_warning_threshold)
  violate_action = __builtin__.property(_get_violate_action, _set_violate_action)
  restart_interval = __builtin__.property(_get_restart_interval, _set_restart_interval)


  _pyangbind_elements = OrderedDict([('max_prefix', max_prefix), ('warning_threshold', warning_threshold), ('violate_action', violate_action), ('restart_interval', restart_interval), ])


class yc_bgp_timer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_timer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp/bgp-timer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Includes two BGP timers that can be
customized when building a VPN service
with BGP used as CE-PE routing
protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__keep_alive','__hold_time',)

  _yang_name = 'bgp-timer'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__keep_alive = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keep-alive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp', 'bgp-timer']

  def _get_keep_alive(self):
    """
    Getter method for keep_alive, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_timer/keep_alive (uint16)

    YANG Description: This timer indicates the KEEPALIVE
messages'  frequency between a PE
and a BGP peer.

If set to '0', it indicates KEEPALIVE
messages are disabled.

It is suggested that the maximum time
between  KEEPALIVEmessages would be
one third of the Hold Time interval.
    """
    return self.__keep_alive
      
  def _set_keep_alive(self, v, load=False):
    """
    Setter method for keep_alive, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_timer/keep_alive (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keep_alive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keep_alive() directly.

    YANG Description: This timer indicates the KEEPALIVE
messages'  frequency between a PE
and a BGP peer.

If set to '0', it indicates KEEPALIVE
messages are disabled.

It is suggested that the maximum time
between  KEEPALIVEmessages would be
one third of the Hold Time interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keep-alive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keep_alive must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keep-alive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__keep_alive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keep_alive(self):
    self.__keep_alive = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keep-alive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_hold_time(self):
    """
    Getter method for hold_time, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_timer/hold_time (uint16)

    YANG Description: It indicates the maximum number of
seconds that may elapse between the
receipt of successive KEEPALIVE
and/or UPDATE   messages from the peer.

The Hold Time must be either zero or
at least three seconds.
    """
    return self.__hold_time
      
  def _set_hold_time(self, v, load=False):
    """
    Setter method for hold_time, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_timer/hold_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time() directly.

    YANG Description: It indicates the maximum number of
seconds that may elapse between the
receipt of successive KEEPALIVE
and/or UPDATE   messages from the peer.

The Hold Time must be either zero or
at least three seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time(self):
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)

  keep_alive = __builtin__.property(_get_keep_alive, _set_keep_alive)
  hold_time = __builtin__.property(_get_hold_time, _set_hold_time)


  _pyangbind_elements = OrderedDict([('keep_alive', keep_alive), ('hold_time', hold_time), ])


class yc_bgp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP-specific configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer_autonomous_system','__local_autonomous_system','__address_family','__neighbor','__multihop','__security','__status','__description','__as_override','__default_route','__bgp_max_prefix','__bgp_timer',)

  _yang_name = 'bgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer_autonomous_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)
    self.__local_autonomous_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__neighbor = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__multihop = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__security = YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__as_override = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-override", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__bgp_max_prefix = YANGDynClass(base=yc_bgp_max_prefix_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_max_prefix, is_container='container', yang_name="bgp-max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__bgp_timer = YANGDynClass(base=yc_bgp_timer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_timer, is_container='container', yang_name="bgp-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'bgp']

  def _get_peer_autonomous_system(self):
    """
    Getter method for peer_autonomous_system, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/peer_autonomous_system (inet:as-number)

    YANG Description: Indicates the Customer's AS Number (ASN) in
case the Customer requests BGP routing.
    """
    return self.__peer_autonomous_system
      
  def _set_peer_autonomous_system(self, v, load=False):
    """
    Setter method for peer_autonomous_system, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/peer_autonomous_system (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_autonomous_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_autonomous_system() directly.

    YANG Description: Indicates the Customer's AS Number (ASN) in
case the Customer requests BGP routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_autonomous_system must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)""",
        })

    self.__peer_autonomous_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_autonomous_system(self):
    self.__peer_autonomous_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)


  def _get_local_autonomous_system(self):
    """
    Getter method for local_autonomous_system, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/local_autonomous_system (inet:as-number)

    YANG Description: Is set to the ASN to override a peers' ASN
if such feature is requested by the
Customer.
    """
    return self.__local_autonomous_system
      
  def _set_local_autonomous_system(self, v, load=False):
    """
    Setter method for local_autonomous_system, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/local_autonomous_system (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_autonomous_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_autonomous_system() directly.

    YANG Description: Is set to the ASN to override a peers' ASN
if such feature is requested by the
Customer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_autonomous_system must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)""",
        })

    self.__local_autonomous_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_autonomous_system(self):
    self.__local_autonomous_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/address_family (vpn-common:address-family)

    YANG Description: This node contains at least one
address-family to be activated.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: This node contains at least one
address-family to be activated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/neighbor (inet:ip-address)

    YANG Description: IP address(es) of the BGP neighbor. IPv4
and IPv6 neighbors may be indicated if
two sessions will be used for IPv4 and
IPv6.
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/neighbor (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: IP address(es) of the BGP neighbor. IPv4
and IPv6 neighbors may be indicated if
two sessions will be used for IPv4 and
IPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_multihop(self):
    """
    Getter method for multihop, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/multihop (uint8)

    YANG Description: Describes the number of IP hops allowed
between a given BGP neighbor and the PE.
    """
    return self.__multihop
      
  def _set_multihop(self, v, load=False):
    """
    Setter method for multihop, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/multihop (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multihop() directly.

    YANG Description: Describes the number of IP hops allowed
between a given BGP neighbor and the PE.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multihop must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multihop(self):
    self.__multihop = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/security (container)

    YANG Description: Container for aggregating any security parameter
 for routing sessions between a PE and a CE.
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Container for aggregating any security parameter
 for routing sessions between a PE and a CE.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status (container)

    YANG Description: Service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/description (string)

    YANG Description: Includes a description of the BGP session.
Such description is meant to be used for
diagnosis purposes. The semantic of the
description is local to an
implementation.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Includes a description of the BGP session.
Such description is meant to be used for
diagnosis purposes. The semantic of the
description is local to an
implementation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_as_override(self):
    """
    Getter method for as_override, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/as_override (boolean)

    YANG Description: Defines whether AS override is enabled,
i.e., replace the ASN of the peer specified
in the AS Path attribute with the local
AS number.
    """
    return self.__as_override
      
  def _set_as_override(self, v, load=False):
    """
    Setter method for as_override, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/as_override (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_override is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_override() directly.

    YANG Description: Defines whether AS override is enabled,
i.e., replace the ASN of the peer specified
in the AS Path attribute with the local
AS number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-override", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_override must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-override", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__as_override = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_override(self):
    self.__as_override = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-override", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_default_route(self):
    """
    Getter method for default_route, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/default_route (boolean)

    YANG Description: Defines whether default route(s) can be
advertised to its peer. If set, the
default route(s) is advertised to its
peer.
    """
    return self.__default_route
      
  def _set_default_route(self, v, load=False):
    """
    Setter method for default_route, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_route() directly.

    YANG Description: Defines whether default route(s) can be
advertised to its peer. If set, the
default route(s) is advertised to its
peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_route(self):
    self.__default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_bgp_max_prefix(self):
    """
    Getter method for bgp_max_prefix, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix (container)

    YANG Description: Controls the behavior when a prefix
maximum is reached.
    """
    return self.__bgp_max_prefix
      
  def _set_bgp_max_prefix(self, v, load=False):
    """
    Setter method for bgp_max_prefix, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_max_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_max_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_max_prefix() directly.

    YANG Description: Controls the behavior when a prefix
maximum is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_max_prefix_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_max_prefix, is_container='container', yang_name="bgp-max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_max_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_max_prefix_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_max_prefix, is_container='container', yang_name="bgp-max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__bgp_max_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_max_prefix(self):
    self.__bgp_max_prefix = YANGDynClass(base=yc_bgp_max_prefix_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_max_prefix, is_container='container', yang_name="bgp-max-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_bgp_timer(self):
    """
    Getter method for bgp_timer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_timer (container)

    YANG Description: Includes two BGP timers that can be
customized when building a VPN service
with BGP used as CE-PE routing
protocol.
    """
    return self.__bgp_timer
      
  def _set_bgp_timer(self, v, load=False):
    """
    Setter method for bgp_timer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp/bgp_timer (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_timer() directly.

    YANG Description: Includes two BGP timers that can be
customized when building a VPN service
with BGP used as CE-PE routing
protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_timer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_timer, is_container='container', yang_name="bgp-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_timer must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_timer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_timer, is_container='container', yang_name="bgp-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__bgp_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_timer(self):
    self.__bgp_timer = YANGDynClass(base=yc_bgp_timer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_timer, is_container='container', yang_name="bgp-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  peer_autonomous_system = __builtin__.property(_get_peer_autonomous_system, _set_peer_autonomous_system)
  local_autonomous_system = __builtin__.property(_get_local_autonomous_system, _set_local_autonomous_system)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)
  multihop = __builtin__.property(_get_multihop, _set_multihop)
  security = __builtin__.property(_get_security, _set_security) # type: yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_security
  status = __builtin__.property(_get_status, _set_status) # type: yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_status
  description = __builtin__.property(_get_description, _set_description)
  as_override = __builtin__.property(_get_as_override, _set_as_override)
  default_route = __builtin__.property(_get_default_route, _set_default_route)
  bgp_max_prefix = __builtin__.property(_get_bgp_max_prefix, _set_bgp_max_prefix) # type: yc_bgp_max_prefix_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_max_prefix
  bgp_timer = __builtin__.property(_get_bgp_timer, _set_bgp_timer) # type: yc_bgp_timer_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp_bgp_timer


  _pyangbind_elements = OrderedDict([('peer_autonomous_system', peer_autonomous_system), ('local_autonomous_system', local_autonomous_system), ('address_family', address_family), ('neighbor', neighbor), ('multihop', multihop), ('security', security), ('status', status), ('description', description), ('as_override', as_override), ('default_route', default_route), ('bgp_max_prefix', bgp_max_prefix), ('bgp_timer', bgp_timer), ])


class yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_admin_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/isis/status/admin-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'admin-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'isis', 'status', 'admin-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/admin_status/status (identityref)

    YANG Description: Administrative service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/admin_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-testing': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:administrative-state-pre-deployment': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/admin_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/admin_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=True)

  status = __builtin__.property(_get_status, _set_status)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_oper_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/isis/status/oper-status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__last_updated',)

  _yang_name = 'oper-status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'isis', 'status', 'oper-status']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/oper_status/status (identityref)

    YANG Description: Operations status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/oper_status/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Operations status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-up': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-down': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:operational-state-unknown': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/oper_status/last_updated (yang:date-and-time)

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/oper_status/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Indicates the actual date and time of the service
status change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:date-and-time', is_config=False)

  status = __builtin__.property(_get_status)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('status', status), ('last_updated', last_updated), ])


class yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/isis/status. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service status.
  """
  __slots__ = ('_path_helper', '_extmethods', '__admin_status','__oper_status',)

  _yang_name = 'status'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'isis', 'status']

  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/admin_status (container)

    YANG Description: Administrative service status.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/admin_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_admin_status, is_container='container', yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/oper_status (container)

    YANG Description: Operational service status.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status/oper_status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Operational service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_oper_status, is_container='container', yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  admin_status = __builtin__.property(_get_admin_status, _set_admin_status) # type: yc_admin_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_admin_status
  oper_status = __builtin__.property(_get_oper_status, _set_oper_status) # type: yc_oper_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status_oper_status


  _pyangbind_elements = OrderedDict([('admin_status', admin_status), ('oper_status', oper_status), ])


class yc_isis_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/isis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IS-IS specific configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_family','__area_address','__level','__metric','__process_id','__mode','__status',)

  _yang_name = 'isis'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__area_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {}, 'passive': {}},), default=six.text_type("active"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'isis']

  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/address_family (vpn-common:address-family)

    YANG Description: If ISIS is used on this site, this node
contains a configured value.  This node
contains at least one address family
to be activated.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: If ISIS is used on this site, this node
contains a configured value.  This node
contains at least one address family
to be activated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_area_address(self):
    """
    Getter method for area_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/area_address (yang:dotted-quad)

    YANG Description: Area address.
    """
    return self.__area_address
      
  def _set_area_address(self, v, load=False):
    """
    Setter method for area_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/area_address (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_area_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_area_address() directly.

    YANG Description: Area address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """area_address must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__area_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_area_address(self):
    self.__area_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="area-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='yang:dotted-quad', is_config=True)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/level (identityref)

    YANG Description: level1, level2 or level1-2
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/level (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: level1, level2 or level1-2
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}, 'l3nm:level1-2': {'@module': 'ietf-l3vpn-ntw', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_metric(self):
    """
    Getter method for metric, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/metric (uint16)

    YANG Description: Metric of the PE-CE link.  It is used
in the routing state calculation and
path selection.
    """
    return self.__metric
      
  def _set_metric(self, v, load=False):
    """
    Setter method for metric, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/metric (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric() directly.

    YANG Description: Metric of the PE-CE link.  It is used
in the routing state calculation and
path selection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric(self):
    self.__metric = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_process_id(self):
    """
    Getter method for process_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/process_id (uint16)

    YANG Description: Process id of the IS-IS CE-PE
connection.
    """
    return self.__process_id
      
  def _set_process_id(self, v, load=False):
    """
    Setter method for process_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/process_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_process_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_process_id() directly.

    YANG Description: Process id of the IS-IS CE-PE
connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """process_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__process_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_process_id(self):
    self.__process_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="process-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/mode (enumeration)

    YANG Description: IS-IS interface mode type.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: IS-IS interface mode type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {}, 'passive': {}},), default=six.text_type("active"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "ietf-l3vpn-ntw:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {}, 'passive': {}},), default=six.text_type("active"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'active': {}, 'passive': {}},), default=six.text_type("active"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status (container)

    YANG Description: Service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis/status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  address_family = __builtin__.property(_get_address_family, _set_address_family)
  area_address = __builtin__.property(_get_area_address, _set_area_address)
  level = __builtin__.property(_get_level, _set_level)
  metric = __builtin__.property(_get_metric, _set_metric)
  process_id = __builtin__.property(_get_process_id, _set_process_id)
  mode = __builtin__.property(_get_mode, _set_mode)
  status = __builtin__.property(_get_status, _set_status) # type: yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis_status


  _pyangbind_elements = OrderedDict([('address_family', address_family), ('area_address', area_address), ('level', level), ('metric', metric), ('process_id', process_id), ('mode', mode), ('status', status), ])


class yc_ipv4_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv4_lan_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv4-lan-prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LAN prefixes for the site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lan','__lan_tag','__next_hop',)

  _yang_name = 'ipv4-lan-prefixes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lan = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-prefix', is_config=True)
    self.__lan_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv4-lan-prefixes']

  def _get_lan(self):
    """
    Getter method for lan, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes/lan (inet:ipv4-prefix)

    YANG Description: LAN prefixes.
    """
    return self.__lan
      
  def _set_lan(self, v, load=False):
    """
    Setter method for lan, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes/lan (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lan() directly.

    YANG Description: LAN prefixes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lan must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-prefix', is_config=True)""",
        })

    self.__lan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lan(self):
    self.__lan = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-prefix', is_config=True)


  def _get_lan_tag(self):
    """
    Getter method for lan_tag, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes/lan_tag (string)

    YANG Description: Internal tag to be used in VPN
policies.
    """
    return self.__lan_tag
      
  def _set_lan_tag(self, v, load=False):
    """
    Setter method for lan_tag, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes/lan_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lan_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lan_tag() directly.

    YANG Description: Internal tag to be used in VPN
policies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lan_tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__lan_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lan_tag(self):
    self.__lan_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes/next_hop (inet:ipv4-address)

    YANG Description: Next-hop address to use on the
customer side.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes/next_hop (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Next-hop address to use on the
customer side.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv4-address', is_config=True)

  lan = __builtin__.property(_get_lan, _set_lan)
  lan_tag = __builtin__.property(_get_lan_tag, _set_lan_tag)
  next_hop = __builtin__.property(_get_next_hop, _set_next_hop)


  _pyangbind_elements = OrderedDict([('lan', lan), ('lan_tag', lan_tag), ('next_hop', next_hop), ])


class yc_ipv6_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv6_lan_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes/ipv6-lan-prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of LAN prefixes for the site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lan','__lan_tag','__next_hop',)

  _yang_name = 'ipv6-lan-prefixes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lan = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-prefix', is_config=True)
    self.__lan_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes', 'ipv6-lan-prefixes']

  def _get_lan(self):
    """
    Getter method for lan, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes/lan (inet:ipv6-prefix)

    YANG Description: LAN prefixes.
    """
    return self.__lan
      
  def _set_lan(self, v, load=False):
    """
    Setter method for lan, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes/lan (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lan() directly.

    YANG Description: LAN prefixes.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lan must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-prefix', is_config=True)""",
        })

    self.__lan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lan(self):
    self.__lan = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="lan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-prefix', is_config=True)


  def _get_lan_tag(self):
    """
    Getter method for lan_tag, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes/lan_tag (string)

    YANG Description: Internal tag to be used in VPN
policies.
    """
    return self.__lan_tag
      
  def _set_lan_tag(self, v, load=False):
    """
    Setter method for lan_tag, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes/lan_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lan_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lan_tag() directly.

    YANG Description: Internal tag to be used in VPN
policies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lan_tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__lan_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lan_tag(self):
    self.__lan_tag = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lan-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes/next_hop (inet:ipv6-address)

    YANG Description: Next-hop address to use on the
customer side.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes/next_hop (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Next-hop address to use on the
customer side.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ipv6-address', is_config=True)

  lan = __builtin__.property(_get_lan, _set_lan)
  lan_tag = __builtin__.property(_get_lan_tag, _set_lan_tag)
  next_hop = __builtin__.property(_get_next_hop, _set_next_hop)


  _pyangbind_elements = OrderedDict([('lan', lan), ('lan_tag', lan_tag), ('next_hop', next_hop), ])


class yc_cascaded_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/static/cascaded-lan-prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: LAN prefixes from the customer.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipv4_lan_prefixes','__ipv6_lan_prefixes',)

  _yang_name = 'cascaded-lan-prefixes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipv4_lan_prefixes = YANGDynClass(base=YANGListType("lan next_hop",yc_ipv4_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv4_lan_prefixes, yang_name="ipv4-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv4-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__ipv6_lan_prefixes = YANGDynClass(base=YANGListType("lan next_hop",yc_ipv6_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv6_lan_prefixes, yang_name="ipv6-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv6-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'static', 'cascaded-lan-prefixes']

  def _get_ipv4_lan_prefixes(self):
    """
    Getter method for ipv4_lan_prefixes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes (list)

    YANG Description: List of LAN prefixes for the site.
    """
    return self.__ipv4_lan_prefixes
      
  def _set_ipv4_lan_prefixes(self, v, load=False):
    """
    Setter method for ipv4_lan_prefixes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv4_lan_prefixes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_lan_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_lan_prefixes() directly.

    YANG Description: List of LAN prefixes for the site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lan next_hop",yc_ipv4_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv4_lan_prefixes, yang_name="ipv4-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv4-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_lan_prefixes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lan next_hop",yc_ipv4_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv4_lan_prefixes, yang_name="ipv4-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv4-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__ipv4_lan_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_lan_prefixes(self):
    self.__ipv4_lan_prefixes = YANGDynClass(base=YANGListType("lan next_hop",yc_ipv4_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv4_lan_prefixes, yang_name="ipv4-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv4-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_ipv6_lan_prefixes(self):
    """
    Getter method for ipv6_lan_prefixes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes (list)

    YANG Description: List of LAN prefixes for the site.
    """
    return self.__ipv6_lan_prefixes
      
  def _set_ipv6_lan_prefixes(self, v, load=False):
    """
    Setter method for ipv6_lan_prefixes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes/ipv6_lan_prefixes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_lan_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_lan_prefixes() directly.

    YANG Description: List of LAN prefixes for the site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("lan next_hop",yc_ipv6_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv6_lan_prefixes, yang_name="ipv6-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv6-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_lan_prefixes must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("lan next_hop",yc_ipv6_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv6_lan_prefixes, yang_name="ipv6-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv6-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__ipv6_lan_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_lan_prefixes(self):
    self.__ipv6_lan_prefixes = YANGDynClass(base=YANGListType("lan next_hop",yc_ipv6_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv6_lan_prefixes, yang_name="ipv6-lan-prefixes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='lan next-hop', extensions=None), is_container='list', yang_name="ipv6-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  ipv4_lan_prefixes = __builtin__.property(_get_ipv4_lan_prefixes, _set_ipv4_lan_prefixes) # type: yc_ipv4_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv4_lan_prefixes
  ipv6_lan_prefixes = __builtin__.property(_get_ipv6_lan_prefixes, _set_ipv6_lan_prefixes) # type: yc_ipv6_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes_ipv6_lan_prefixes


  _pyangbind_elements = OrderedDict([('ipv4_lan_prefixes', ipv4_lan_prefixes), ('ipv6_lan_prefixes', ipv6_lan_prefixes), ])


class yc_static_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration specific to static routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cascaded_lan_prefixes',)

  _yang_name = 'static'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cascaded_lan_prefixes = YANGDynClass(base=yc_cascaded_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes, is_container='container', yang_name="cascaded-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'static']

  def _get_cascaded_lan_prefixes(self):
    """
    Getter method for cascaded_lan_prefixes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes (container)

    YANG Description: LAN prefixes from the customer.
    """
    return self.__cascaded_lan_prefixes
      
  def _set_cascaded_lan_prefixes(self, v, load=False):
    """
    Setter method for cascaded_lan_prefixes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static/cascaded_lan_prefixes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cascaded_lan_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cascaded_lan_prefixes() directly.

    YANG Description: LAN prefixes from the customer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cascaded_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes, is_container='container', yang_name="cascaded-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cascaded_lan_prefixes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cascaded_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes, is_container='container', yang_name="cascaded-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__cascaded_lan_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cascaded_lan_prefixes(self):
    self.__cascaded_lan_prefixes = YANGDynClass(base=yc_cascaded_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes, is_container='container', yang_name="cascaded-lan-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  cascaded_lan_prefixes = __builtin__.property(_get_cascaded_lan_prefixes, _set_cascaded_lan_prefixes) # type: yc_cascaded_lan_prefixes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static_cascaded_lan_prefixes


  _pyangbind_elements = OrderedDict([('cascaded_lan_prefixes', cascaded_lan_prefixes), ])


class yc_rip_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_rip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/rip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration specific to RIP routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_family',)

  _yang_name = 'rip'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'rip']

  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/rip/address_family (vpn-common:address-family)

    YANG Description: If RIP is used on this site, this node
contains a configured value.  This node
contains at least one address family
to be activated.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/rip/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: If RIP is used on this site, this node
contains a configured value.  This node
contains at least one address family
to be activated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)

  address_family = __builtin__.property(_get_address_family, _set_address_family)


  _pyangbind_elements = OrderedDict([('address_family', address_family), ])


class yc_vrrp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_vrrp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol/vrrp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration specific to VRRP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_family','__vrrp_group','__backup_peer','__priority','__ping_reply',)

  _yang_name = 'vrrp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__vrrp_group = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__backup_peer = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    self.__ping_reply = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ping-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol', 'vrrp']

  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/address_family (vpn-common:address-family)

    YANG Description: If VRRP is used on this site, this node
contains a configured value.  This node
contains at least one address family to
be activated.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: If VRRP is used on this site, this node
contains a configured value.  This node
contains at least one address family to
be activated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},)), is_leaf=False, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_vrrp_group(self):
    """
    Getter method for vrrp_group, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/vrrp_group (uint8)

    YANG Description: VRRP group number
    """
    return self.__vrrp_group
      
  def _set_vrrp_group(self, v, load=False):
    """
    Setter method for vrrp_group, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/vrrp_group (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp_group() directly.

    YANG Description: VRRP group number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp_group must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__vrrp_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp_group(self):
    self.__vrrp_group = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="vrrp-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_backup_peer(self):
    """
    Getter method for backup_peer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/backup_peer (inet:ip-address)

    YANG Description: IP address of the peer
    """
    return self.__backup_peer
      
  def _set_backup_peer(self, v, load=False):
    """
    Setter method for backup_peer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/backup_peer (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup_peer() directly.

    YANG Description: IP address of the peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup_peer must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__backup_peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup_peer(self):
    self.__backup_peer = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/priority (uint8)

    YANG Description: Local priority of the VRRP speaker
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Local priority of the VRRP speaker
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint8', is_config=True)


  def _get_ping_reply(self):
    """
    Getter method for ping_reply, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/ping_reply (boolean)

    YANG Description: Whether the VRRP speaker should answer
to ping requests
    """
    return self.__ping_reply
      
  def _set_ping_reply(self, v, load=False):
    """
    Setter method for ping_reply, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp/ping_reply (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ping_reply is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ping_reply() directly.

    YANG Description: Whether the VRRP speaker should answer
to ping requests
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ping-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ping_reply must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ping-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__ping_reply = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ping_reply(self):
    self.__ping_reply = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ping-reply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)

  address_family = __builtin__.property(_get_address_family, _set_address_family)
  vrrp_group = __builtin__.property(_get_vrrp_group, _set_vrrp_group)
  backup_peer = __builtin__.property(_get_backup_peer, _set_backup_peer)
  priority = __builtin__.property(_get_priority, _set_priority)
  ping_reply = __builtin__.property(_get_ping_reply, _set_ping_reply)


  _pyangbind_elements = OrderedDict([('address_family', address_family), ('vrrp_group', vrrp_group), ('backup_peer', backup_peer), ('priority', priority), ('ping_reply', ping_reply), ])


class yc_routing_protocol_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols/routing-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routing protocols used on
the site.  This list can be augmented.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type','__routing_profiles','__ospf','__bgp','__isis','__static','__rip','__vrrp',)

  _yang_name = 'routing-protocol'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__routing_profiles = YANGDynClass(base=YANGListType("id",yc_routing_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_routing_profiles, yang_name="routing-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    self.__ospf = YANGDynClass(base=yc_ospf_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf, is_container='container', yang_name="ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__bgp = YANGDynClass(base=yc_bgp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__isis = YANGDynClass(base=yc_isis_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis, is_container='container', yang_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__static = YANGDynClass(base=yc_static_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static, is_container='container', yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__rip = YANGDynClass(base=yc_rip_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_rip, is_container='container', yang_name="rip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vrrp = YANGDynClass(base=yc_vrrp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols', 'routing-protocol']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/id (string)

    YANG Description: Unique identifier for routing protocol.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for routing protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/type (identityref)

    YANG Description: Type of routing protocol.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of routing protocol.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ospf': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:rip': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:isis': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:vrrp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:direct': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_routing_profiles(self):
    """
    Getter method for routing_profiles, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/routing_profiles (list)

    YANG Description: Routing profiles.
    """
    return self.__routing_profiles
      
  def _set_routing_profiles(self, v, load=False):
    """
    Setter method for routing_profiles, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/routing_profiles (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_profiles() directly.

    YANG Description: Routing profiles.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_routing_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_routing_profiles, yang_name="routing-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_profiles must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_routing_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_routing_profiles, yang_name="routing-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__routing_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_profiles(self):
    self.__routing_profiles = YANGDynClass(base=YANGListType("id",yc_routing_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_routing_profiles, yang_name="routing-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)


  def _get_ospf(self):
    """
    Getter method for ospf, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf (container)

    YANG Description: OSPF-specific configuration.
    """
    return self.__ospf
      
  def _set_ospf(self, v, load=False):
    """
    Setter method for ospf, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/ospf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospf() directly.

    YANG Description: OSPF-specific configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ospf_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf, is_container='container', yang_name="ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ospf_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf, is_container='container', yang_name="ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__ospf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospf(self):
    self.__ospf = YANGDynClass(base=yc_ospf_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf, is_container='container', yang_name="ospf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp (container)

    YANG Description: BGP-specific configuration.
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: BGP-specific configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=yc_bgp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_isis(self):
    """
    Getter method for isis, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis (container)

    YANG Description: IS-IS specific configuration.
    """
    return self.__isis
      
  def _set_isis(self, v, load=False):
    """
    Setter method for isis, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/isis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_isis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_isis() directly.

    YANG Description: IS-IS specific configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_isis_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis, is_container='container', yang_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """isis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_isis_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis, is_container='container', yang_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__isis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_isis(self):
    self.__isis = YANGDynClass(base=yc_isis_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis, is_container='container', yang_name="isis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_static(self):
    """
    Getter method for static, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static (container)

    YANG Description: Configuration specific to static routing.
    """
    return self.__static
      
  def _set_static(self, v, load=False):
    """
    Setter method for static, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/static (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static() directly.

    YANG Description: Configuration specific to static routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_static_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static, is_container='container', yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_static_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static, is_container='container', yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__static = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static(self):
    self.__static = YANGDynClass(base=yc_static_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static, is_container='container', yang_name="static", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_rip(self):
    """
    Getter method for rip, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/rip (container)

    YANG Description: Configuration specific to RIP routing.
    """
    return self.__rip
      
  def _set_rip(self, v, load=False):
    """
    Setter method for rip, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/rip (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rip() directly.

    YANG Description: Configuration specific to RIP routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rip_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_rip, is_container='container', yang_name="rip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rip must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rip_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_rip, is_container='container', yang_name="rip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__rip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rip(self):
    self.__rip = YANGDynClass(base=yc_rip_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_rip, is_container='container', yang_name="rip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vrrp(self):
    """
    Getter method for vrrp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp (container)

    YANG Description: Configuration specific to VRRP.
    """
    return self.__vrrp
      
  def _set_vrrp(self, v, load=False):
    """
    Setter method for vrrp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol/vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp() directly.

    YANG Description: Configuration specific to VRRP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrrp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrrp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp(self):
    self.__vrrp = YANGDynClass(base=yc_vrrp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_vrrp, is_container='container', yang_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type = __builtin__.property(_get_type, _set_type)
  routing_profiles = __builtin__.property(_get_routing_profiles, _set_routing_profiles) # type: yc_routing_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_routing_profiles
  ospf = __builtin__.property(_get_ospf, _set_ospf) # type: yc_ospf_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_ospf
  bgp = __builtin__.property(_get_bgp, _set_bgp) # type: yc_bgp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_bgp
  isis = __builtin__.property(_get_isis, _set_isis) # type: yc_isis_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_isis
  static = __builtin__.property(_get_static, _set_static) # type: yc_static_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_static
  rip = __builtin__.property(_get_rip, _set_rip) # type: yc_rip_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_rip
  vrrp = __builtin__.property(_get_vrrp, _set_vrrp) # type: yc_vrrp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol_vrrp


  _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('routing_profiles', routing_profiles), ('ospf', ospf), ('bgp', bgp), ('isis', isis), ('static', static), ('rip', rip), ('vrrp', vrrp), ])


class yc_routing_protocols_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/routing-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines routing protocols.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_protocol',)

  _yang_name = 'routing-protocols'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_protocol = YANGDynClass(base=YANGListType("id",yc_routing_protocol_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'routing-protocols']

  def _get_routing_protocol(self):
    """
    Getter method for routing_protocol, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol (list)

    YANG Description: List of routing protocols used on
the site.  This list can be augmented.
    """
    return self.__routing_protocol
      
  def _set_routing_protocol(self, v, load=False):
    """
    Setter method for routing_protocol, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols/routing_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocol() directly.

    YANG Description: List of routing protocols used on
the site.  This list can be augmented.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_routing_protocol_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_routing_protocol_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__routing_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocol(self):
    self.__routing_protocol = YANGDynClass(base=YANGListType("id",yc_routing_protocol_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol, yang_name="routing-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="routing-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  routing_protocol = __builtin__.property(_get_routing_protocol, _set_routing_protocol) # type: yc_routing_protocol_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols_routing_protocol


  _pyangbind_elements = OrderedDict([('routing_protocol', routing_protocol), ])


class yc_rule_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy_rule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/qos/qos-classification-policy/rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of marking rules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__match_application','__target_class_id',)

  _yang_name = 'rule'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__match_application = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="match-application", parent=self, choice=('match-type', 'match-application'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__target_class_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target-class-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'qos', 'qos-classification-policy', 'rule']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule/id (string)

    YANG Description: A description identifying the
qos-classification-policy rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A description identifying the
qos-classification-policy rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_match_application(self):
    """
    Getter method for match_application, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule/match_application (identityref)

    YANG Description: Defines the application to match.
    """
    return self.__match_application
      
  def _set_match_application(self, v, load=False):
    """
    Setter method for match_application, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule/match_application (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match_application is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match_application() directly.

    YANG Description: Defines the application to match.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="match-application", parent=self, choice=('match-type', 'match-application'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match_application must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="match-application", parent=self, choice=('match-type', 'match-application'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__match_application = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match_application(self):
    self.__match_application = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:web': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mail': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:file-transfer': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:database': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:social': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:games': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:p2p': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:network-management': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:voice': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:video': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:embb': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:urllc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:mmtc': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="match-application", parent=self, choice=('match-type', 'match-application'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_target_class_id(self):
    """
    Getter method for target_class_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule/target_class_id (string)

    YANG Description: Identification of the class of service.
This identifier is internal to the
administration.
    """
    return self.__target_class_id
      
  def _set_target_class_id(self, v, load=False):
    """
    Setter method for target_class_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule/target_class_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_class_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_class_id() directly.

    YANG Description: Identification of the class of service.
This identifier is internal to the
administration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="target-class-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_class_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target-class-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__target_class_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_class_id(self):
    self.__target_class_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="target-class-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  match_application = __builtin__.property(_get_match_application, _set_match_application)
  target_class_id = __builtin__.property(_get_target_class_id, _set_target_class_id)

  __choices__ = {'match-type': {'match-application': ['match_application']}}
  _pyangbind_elements = OrderedDict([('id', id), ('match_application', match_application), ('target_class_id', target_class_id), ])


class yc_qos_classification_policy_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/qos/qos-classification-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of the traffic classification
policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rule',)

  _yang_name = 'qos-classification-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rule = YANGDynClass(base=YANGListType("id",yc_rule_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy_rule, yang_name="rule", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'qos', 'qos-classification-policy']

  def _get_rule(self):
    """
    Getter method for rule, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule (list)

    YANG Description: List of marking rules.
    """
    return self.__rule
      
  def _set_rule(self, v, load=False):
    """
    Setter method for rule, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy/rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule() directly.

    YANG Description: List of marking rules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_rule_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy_rule, yang_name="rule", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_rule_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy_rule, yang_name="rule", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule(self):
    self.__rule = YANGDynClass(base=YANGListType("id",yc_rule_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy_rule, yang_name="rule", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  rule = __builtin__.property(_get_rule, _set_rule) # type: yc_rule_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy_rule


  _pyangbind_elements = OrderedDict([('rule', rule), ])


class yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile_qos_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/qos/qos-profile/qos-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QoS profile.
Can be standard profile or customized
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__profile','__direction',)

  _yang_name = 'qos-profile'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:both"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'qos', 'qos-profile', 'qos-profile']

  def _get_profile(self):
    """
    Getter method for profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile/qos_profile/profile (leafref)

    YANG Description: QoS profile to be used.
    """
    return self.__profile
      
  def _set_profile(self, v, load=False):
    """
    Setter method for profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile/qos_profile/profile (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_profile() directly.

    YANG Description: QoS profile to be used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """profile must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_profile(self):
    self.__profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)


  def _get_direction(self):
    """
    Getter method for direction, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile/qos_profile/direction (identityref)

    YANG Description: The direction to which the QoS profile
is applied.
    """
    return self.__direction
      
  def _set_direction(self, v, load=False):
    """
    Setter method for direction, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile/qos_profile/direction (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: The direction to which the QoS profile
is applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:both"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """direction must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:both"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__direction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_direction(self):
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:site-to-wan': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:wan-to-site': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:both': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:both"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)

  profile = __builtin__.property(_get_profile, _set_profile)
  direction = __builtin__.property(_get_direction, _set_direction)


  _pyangbind_elements = OrderedDict([('profile', profile), ('direction', direction), ])


class yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/qos/qos-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QoS profile configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos_profile',)

  _yang_name = 'qos-profile'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos_profile = YANGDynClass(base=YANGListType("profile",yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile_qos_profile, yang_name="qos-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile', extensions=None), is_container='list', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'qos', 'qos-profile']

  def _get_qos_profile(self):
    """
    Getter method for qos_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile/qos_profile (list)

    YANG Description: QoS profile.
Can be standard profile or customized
profile.
    """
    return self.__qos_profile
      
  def _set_qos_profile(self, v, load=False):
    """
    Setter method for qos_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile/qos_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_profile() directly.

    YANG Description: QoS profile.
Can be standard profile or customized
profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("profile",yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile_qos_profile, yang_name="qos-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile', extensions=None), is_container='list', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_profile must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("profile",yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile_qos_profile, yang_name="qos-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile', extensions=None), is_container='list', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__qos_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_profile(self):
    self.__qos_profile = YANGDynClass(base=YANGListType("profile",yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile_qos_profile, yang_name="qos-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='profile', extensions=None), is_container='list', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  qos_profile = __builtin__.property(_get_qos_profile, _set_qos_profile) # type: yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile_qos_profile


  _pyangbind_elements = OrderedDict([('qos_profile', qos_profile), ])


class yc_qos_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/qos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QoS configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos_classification_policy','__qos_profile',)

  _yang_name = 'qos'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos_classification_policy = YANGDynClass(base=yc_qos_classification_policy_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy, is_container='container', yang_name="qos-classification-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__qos_profile = YANGDynClass(base=yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile, is_container='container', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'qos']

  def _get_qos_classification_policy(self):
    """
    Getter method for qos_classification_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy (container)

    YANG Description: Configuration of the traffic classification
policy.
    """
    return self.__qos_classification_policy
      
  def _set_qos_classification_policy(self, v, load=False):
    """
    Setter method for qos_classification_policy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_classification_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_classification_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_classification_policy() directly.

    YANG Description: Configuration of the traffic classification
policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_qos_classification_policy_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy, is_container='container', yang_name="qos-classification-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_classification_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_qos_classification_policy_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy, is_container='container', yang_name="qos-classification-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__qos_classification_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_classification_policy(self):
    self.__qos_classification_policy = YANGDynClass(base=yc_qos_classification_policy_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy, is_container='container', yang_name="qos-classification-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_qos_profile(self):
    """
    Getter method for qos_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile (container)

    YANG Description: QoS profile configuration.
    """
    return self.__qos_profile
      
  def _set_qos_profile(self, v, load=False):
    """
    Setter method for qos_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos/qos_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_profile() directly.

    YANG Description: QoS profile configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile, is_container='container', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile, is_container='container', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__qos_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_profile(self):
    self.__qos_profile = YANGDynClass(base=yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile, is_container='container', yang_name="qos-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  qos_classification_policy = __builtin__.property(_get_qos_classification_policy, _set_qos_classification_policy) # type: yc_qos_classification_policy_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_classification_policy
  qos_profile = __builtin__.property(_get_qos_profile, _set_qos_profile) # type: yc_qos_profile_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos_qos_profile


  _pyangbind_elements = OrderedDict([('qos_classification_policy', qos_classification_policy), ('qos_profile', qos_profile), ])


class yc_carrierscarrier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_carrierscarrier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/carrierscarrier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container is used when the customer
provides MPLS-based services.  This is
only used in the  case of CsC (i.e., a
customer builds an MPLSservice using an
IP VPN to carry its traffic).
  """
  __slots__ = ('_path_helper', '_extmethods', '__signalling_type',)

  _yang_name = 'carrierscarrier'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__signalling_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ldp': {}, 'bgp': {}},), default=six.text_type("bgp"), is_leaf=True, yang_name="signalling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'carrierscarrier']

  def _get_signalling_type(self):
    """
    Getter method for signalling_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/carrierscarrier/signalling_type (enumeration)

    YANG Description: MPLS signalling type.
    """
    return self.__signalling_type
      
  def _set_signalling_type(self, v, load=False):
    """
    Setter method for signalling_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/carrierscarrier/signalling_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_signalling_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_signalling_type() directly.

    YANG Description: MPLS signalling type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ldp': {}, 'bgp': {}},), default=six.text_type("bgp"), is_leaf=True, yang_name="signalling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """signalling_type must be of a type compatible with enumeration""",
          'defined-type': "ietf-l3vpn-ntw:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ldp': {}, 'bgp': {}},), default=six.text_type("bgp"), is_leaf=True, yang_name="signalling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)""",
        })

    self.__signalling_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_signalling_type(self):
    self.__signalling_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ldp': {}, 'bgp': {}},), default=six.text_type("bgp"), is_leaf=True, yang_name="signalling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)

  signalling_type = __builtin__.property(_get_signalling_type, _set_signalling_type)


  _pyangbind_elements = OrderedDict([('signalling_type', signalling_type), ])


class yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service/multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast parameters for the site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__site_type','__address_family','__protocol_type','__remote_source',)

  _yang_name = 'multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__site_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'receiver-only': {}, 'source-only': {}, 'source-receiver': {}},), default=six.text_type("source-receiver"), is_leaf=True, yang_name="site-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'host': {}, 'router': {}, 'both': {}},), default=six.text_type("both"), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    self.__remote_source = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="remote-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service', 'multicast']

  def _get_site_type(self):
    """
    Getter method for site_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/site_type (enumeration)

    YANG Description: Type of multicast site.
    """
    return self.__site_type
      
  def _set_site_type(self, v, load=False):
    """
    Setter method for site_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/site_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_site_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_site_type() directly.

    YANG Description: Type of multicast site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'receiver-only': {}, 'source-only': {}, 'source-receiver': {}},), default=six.text_type("source-receiver"), is_leaf=True, yang_name="site-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """site_type must be of a type compatible with enumeration""",
          'defined-type': "ietf-l3vpn-ntw:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'receiver-only': {}, 'source-only': {}, 'source-receiver': {}},), default=six.text_type("source-receiver"), is_leaf=True, yang_name="site-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)""",
        })

    self.__site_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_site_type(self):
    self.__site_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'receiver-only': {}, 'source-only': {}, 'source-receiver': {}},), default=six.text_type("source-receiver"), is_leaf=True, yang_name="site-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/address_family (vpn-common:address-family)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_protocol_type(self):
    """
    Getter method for protocol_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/protocol_type (enumeration)

    YANG Description: Multicast protocol type to be used with
the customer site.
    """
    return self.__protocol_type
      
  def _set_protocol_type(self, v, load=False):
    """
    Setter method for protocol_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/protocol_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_type() directly.

    YANG Description: Multicast protocol type to be used with
the customer site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'host': {}, 'router': {}, 'both': {}},), default=six.text_type("both"), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_type must be of a type compatible with enumeration""",
          'defined-type': "ietf-l3vpn-ntw:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'host': {}, 'router': {}, 'both': {}},), default=six.text_type("both"), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)""",
        })

    self.__protocol_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_type(self):
    self.__protocol_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'host': {}, 'router': {}, 'both': {}},), default=six.text_type("both"), is_leaf=True, yang_name="protocol-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='enumeration', is_config=True)


  def _get_remote_source(self):
    """
    Getter method for remote_source, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/remote_source (boolean)

    YANG Description: When true, there is no PIM adjacency on
the interface.
    """
    return self.__remote_source
      
  def _set_remote_source(self, v, load=False):
    """
    Setter method for remote_source, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast/remote_source (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_source() directly.

    YANG Description: When true, there is no PIM adjacency on
the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="remote-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_source must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="remote-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__remote_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_source(self):
    self.__remote_source = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="remote-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)

  site_type = __builtin__.property(_get_site_type, _set_site_type)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  protocol_type = __builtin__.property(_get_protocol_type, _set_protocol_type)
  remote_source = __builtin__.property(_get_remote_source, _set_remote_source)


  _pyangbind_elements = OrderedDict([('site_type', site_type), ('address_family', address_family), ('protocol_type', protocol_type), ('remote_source', remote_source), ])


class yc_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access/service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Service parameters on the attachment.
  """
  __slots__ = ('_path_helper', '_extmethods', '__svc_input_bandwidth','__svc_output_bandwidth','__svc_mtu','__qos','__carrierscarrier','__multicast',)

  _yang_name = 'service'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__svc_input_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-input-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)
    self.__svc_output_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-output-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)
    self.__svc_mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svc-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__qos = YANGDynClass(base=yc_qos_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__carrierscarrier = YANGDynClass(base=yc_carrierscarrier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_carrierscarrier, is_container='container', yang_name="carrierscarrier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__multicast = YANGDynClass(base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access', 'service']

  def _get_svc_input_bandwidth(self):
    """
    Getter method for svc_input_bandwidth, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/svc_input_bandwidth (uint64)

    YANG Description: From the customer site's perspective, the
service input bandwidth of the connection
or download bandwidth from the SP to
the site.
    """
    return self.__svc_input_bandwidth
      
  def _set_svc_input_bandwidth(self, v, load=False):
    """
    Setter method for svc_input_bandwidth, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/svc_input_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_svc_input_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_svc_input_bandwidth() directly.

    YANG Description: From the customer site's perspective, the
service input bandwidth of the connection
or download bandwidth from the SP to
the site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-input-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """svc_input_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-input-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)""",
        })

    self.__svc_input_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_svc_input_bandwidth(self):
    self.__svc_input_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-input-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)


  def _get_svc_output_bandwidth(self):
    """
    Getter method for svc_output_bandwidth, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/svc_output_bandwidth (uint64)

    YANG Description: From the customer site's perspective,
the service output bandwidth of the
connection or upload bandwidth from
the site to the SP.
    """
    return self.__svc_output_bandwidth
      
  def _set_svc_output_bandwidth(self, v, load=False):
    """
    Setter method for svc_output_bandwidth, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/svc_output_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_svc_output_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_svc_output_bandwidth() directly.

    YANG Description: From the customer site's perspective,
the service output bandwidth of the
connection or upload bandwidth from
the site to the SP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-output-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """svc_output_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-output-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)""",
        })

    self.__svc_output_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_svc_output_bandwidth(self):
    self.__svc_output_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="svc-output-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint64', is_config=True)


  def _get_svc_mtu(self):
    """
    Getter method for svc_mtu, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/svc_mtu (uint16)

    YANG Description: MTU at service level.  If the service is IP,
it refers to the IP MTU.  If CsC is enabled,
the requested 'svc-mtu' leaf will refer
 to the MPLS MTU and not to the IP MTU.
    """
    return self.__svc_mtu
      
  def _set_svc_mtu(self, v, load=False):
    """
    Setter method for svc_mtu, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/svc_mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_svc_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_svc_mtu() directly.

    YANG Description: MTU at service level.  If the service is IP,
it refers to the IP MTU.  If CsC is enabled,
the requested 'svc-mtu' leaf will refer
 to the MPLS MTU and not to the IP MTU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svc-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """svc_mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svc-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__svc_mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_svc_mtu(self):
    self.__svc_mtu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="svc-mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos (container)

    YANG Description: QoS configuration.
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: QoS configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_qos_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_qos_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=yc_qos_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_carrierscarrier(self):
    """
    Getter method for carrierscarrier, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/carrierscarrier (container)

    YANG Description: This container is used when the customer
provides MPLS-based services.  This is
only used in the  case of CsC (i.e., a
customer builds an MPLSservice using an
IP VPN to carry its traffic).
    """
    return self.__carrierscarrier
      
  def _set_carrierscarrier(self, v, load=False):
    """
    Setter method for carrierscarrier, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/carrierscarrier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrierscarrier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrierscarrier() directly.

    YANG Description: This container is used when the customer
provides MPLS-based services.  This is
only used in the  case of CsC (i.e., a
customer builds an MPLSservice using an
IP VPN to carry its traffic).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_carrierscarrier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_carrierscarrier, is_container='container', yang_name="carrierscarrier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrierscarrier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_carrierscarrier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_carrierscarrier, is_container='container', yang_name="carrierscarrier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__carrierscarrier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrierscarrier(self):
    self.__carrierscarrier = YANGDynClass(base=yc_carrierscarrier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_carrierscarrier, is_container='container', yang_name="carrierscarrier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_multicast(self):
    """
    Getter method for multicast, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast (container)

    YANG Description: Multicast parameters for the site.
    """
    return self.__multicast
      
  def _set_multicast(self, v, load=False):
    """
    Setter method for multicast, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service/multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicast() directly.

    YANG Description: Multicast parameters for the site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicast(self):
    self.__multicast = YANGDynClass(base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  svc_input_bandwidth = __builtin__.property(_get_svc_input_bandwidth, _set_svc_input_bandwidth)
  svc_output_bandwidth = __builtin__.property(_get_svc_output_bandwidth, _set_svc_output_bandwidth)
  svc_mtu = __builtin__.property(_get_svc_mtu, _set_svc_mtu)
  qos = __builtin__.property(_get_qos, _set_qos) # type: yc_qos_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_qos
  carrierscarrier = __builtin__.property(_get_carrierscarrier, _set_carrierscarrier) # type: yc_carrierscarrier_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_carrierscarrier
  multicast = __builtin__.property(_get_multicast, _set_multicast) # type: yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service_multicast


  _pyangbind_elements = OrderedDict([('svc_input_bandwidth', svc_input_bandwidth), ('svc_output_bandwidth', svc_output_bandwidth), ('svc_mtu', svc_mtu), ('qos', qos), ('carrierscarrier', carrierscarrier), ('multicast', multicast), ])


class yc_vpn_network_access_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses/vpn-network-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of accesses for a site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__port_id','__description','__status','__vpn_network_access_type','__connection','__ip_connection','__security','__routing_protocols','__service',)

  _yang_name = 'vpn-network-access'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vpn_network_access_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:point-to-point"), is_leaf=True, yang_name="vpn-network-access-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__connection = YANGDynClass(base=yc_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection, is_container='container', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__ip_connection = YANGDynClass(base=yc_ip_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection, is_container='container', yang_name="ip-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__security = YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__routing_protocols = YANGDynClass(base=yc_routing_protocols_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__service = YANGDynClass(base=yc_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service, is_container='container', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses', 'vpn-network-access']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/id (vpn-common:vpn-id)

    YANG Description: Identifier for the access.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/id (vpn-common:vpn-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the access.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with vpn-common:vpn-id""",
          'defined-type': "vpn-common:vpn-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)


  def _get_port_id(self):
    """
    Getter method for port_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/port_id (vpn-common:vpn-id)

    YANG Description: Identifier for the network access.
    """
    return self.__port_id
      
  def _set_port_id(self, v, load=False):
    """
    Setter method for port_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/port_id (vpn-common:vpn-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_id() directly.

    YANG Description: Identifier for the network access.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_id must be of a type compatible with vpn-common:vpn-id""",
          'defined-type': "vpn-common:vpn-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)""",
        })

    self.__port_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_id(self):
    self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/description (string)

    YANG Description: Textual description of a network access.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of a network access.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status (container)

    YANG Description: Service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vpn_network_access_type(self):
    """
    Getter method for vpn_network_access_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/vpn_network_access_type (identityref)

    YANG Description: Describes the type of connection, e.g.,
point-to-point or multipoint.
    """
    return self.__vpn_network_access_type
      
  def _set_vpn_network_access_type(self, v, load=False):
    """
    Setter method for vpn_network_access_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/vpn_network_access_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_network_access_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_network_access_type() directly.

    YANG Description: Describes the type of connection, e.g.,
point-to-point or multipoint.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:point-to-point"), is_leaf=True, yang_name="vpn-network-access-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_network_access_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:point-to-point"), is_leaf=True, yang_name="vpn-network-access-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__vpn_network_access_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_network_access_type(self):
    self.__vpn_network_access_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:point-to-point': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:multipoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:pseudowire': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:loopback': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:point-to-point"), is_leaf=True, yang_name="vpn-network-access-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_connection(self):
    """
    Getter method for connection, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection (container)

    YANG Description: Encapsulation types
    """
    return self.__connection
      
  def _set_connection(self, v, load=False):
    """
    Setter method for connection, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/connection (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection() directly.

    YANG Description: Encapsulation types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection, is_container='container', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connection must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection, is_container='container', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__connection = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connection(self):
    self.__connection = YANGDynClass(base=yc_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection, is_container='container', yang_name="connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_ip_connection(self):
    """
    Getter method for ip_connection, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection (container)

    YANG Description: Defines connection parameters.
    """
    return self.__ip_connection
      
  def _set_ip_connection(self, v, load=False):
    """
    Setter method for ip_connection, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/ip_connection (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_connection is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_connection() directly.

    YANG Description: Defines connection parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ip_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection, is_container='container', yang_name="ip-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_connection must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ip_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection, is_container='container', yang_name="ip-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__ip_connection = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_connection(self):
    self.__ip_connection = YANGDynClass(base=yc_ip_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection, is_container='container', yang_name="ip-connection", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security (container)

    YANG Description: Site-specific security parameters.
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Site-specific security parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_routing_protocols(self):
    """
    Getter method for routing_protocols, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols (container)

    YANG Description: Defines routing protocols.
    """
    return self.__routing_protocols
      
  def _set_routing_protocols(self, v, load=False):
    """
    Setter method for routing_protocols, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/routing_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocols() directly.

    YANG Description: Defines routing protocols.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_protocols_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_protocols_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__routing_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocols(self):
    self.__routing_protocols = YANGDynClass(base=yc_routing_protocols_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols, is_container='container', yang_name="routing-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service (container)

    YANG Description: Service parameters on the attachment.
    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access/service (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.

    YANG Description: Service parameters on the attachment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service, is_container='container', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service, is_container='container', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=yc_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service, is_container='container', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  port_id = __builtin__.property(_get_port_id, _set_port_id)
  description = __builtin__.property(_get_description, _set_description)
  status = __builtin__.property(_get_status, _set_status) # type: yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_status
  vpn_network_access_type = __builtin__.property(_get_vpn_network_access_type, _set_vpn_network_access_type)
  connection = __builtin__.property(_get_connection, _set_connection) # type: yc_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_connection
  ip_connection = __builtin__.property(_get_ip_connection, _set_ip_connection) # type: yc_ip_connection_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_ip_connection
  security = __builtin__.property(_get_security, _set_security) # type: yc_security_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_security
  routing_protocols = __builtin__.property(_get_routing_protocols, _set_routing_protocols) # type: yc_routing_protocols_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_routing_protocols
  service = __builtin__.property(_get_service, _set_service) # type: yc_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access_service


  _pyangbind_elements = OrderedDict([('id', id), ('port_id', port_id), ('description', description), ('status', status), ('vpn_network_access_type', vpn_network_access_type), ('connection', connection), ('ip_connection', ip_connection), ('security', security), ('routing_protocols', routing_protocols), ('service', service), ])


class yc_vpn_network_accesses_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/vpn-network-accesses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of accesses for a site.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_network_access',)

  _yang_name = 'vpn-network-accesses'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_network_access = YANGDynClass(base=YANGListType("id",yc_vpn_network_access_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access, yang_name="vpn-network-access", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-network-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'vpn-network-accesses']

  def _get_vpn_network_access(self):
    """
    Getter method for vpn_network_access, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access (list)

    YANG Description: List of accesses for a site.
    """
    return self.__vpn_network_access
      
  def _set_vpn_network_access(self, v, load=False):
    """
    Setter method for vpn_network_access, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses/vpn_network_access (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_network_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_network_access() directly.

    YANG Description: List of accesses for a site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_vpn_network_access_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access, yang_name="vpn-network-access", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-network-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_network_access must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_vpn_network_access_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access, yang_name="vpn-network-access", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-network-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__vpn_network_access = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_network_access(self):
    self.__vpn_network_access = YANGDynClass(base=YANGListType("id",yc_vpn_network_access_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access, yang_name="vpn-network-access", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vpn-network-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  vpn_network_access = __builtin__.property(_get_vpn_network_access, _set_vpn_network_access) # type: yc_vpn_network_access_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses_vpn_network_access


  _pyangbind_elements = OrderedDict([('vpn_network_access', vpn_network_access), ])


class yc_address_family_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes_address_family(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/maximum-routes/address-family. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of address families.
  """
  __slots__ = ('_path_helper', '_extmethods', '__af','__maximum_routes',)

  _yang_name = 'address-family'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__af = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__maximum_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'maximum-routes', 'address-family']

  def _get_af(self):
    """
    Getter method for af, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes/address_family/af (vpn-common:address-family)

    YANG Description: Indicates the address family
(IPv4 or IPv6).
    """
    return self.__af
      
  def _set_af(self, v, load=False):
    """
    Setter method for af, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes/address_family/af (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_af is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_af() directly.

    YANG Description: Indicates the address family
(IPv4 or IPv6).
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """af must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__af = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_af(self):
    self.__af = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_maximum_routes(self):
    """
    Getter method for maximum_routes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes/address_family/maximum_routes (uint32)

    YANG Description: Indicates the maximum prefixes the VRF
can accept for this address family.
    """
    return self.__maximum_routes
      
  def _set_maximum_routes(self, v, load=False):
    """
    Setter method for maximum_routes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes/address_family/maximum_routes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_routes() directly.

    YANG Description: Indicates the maximum prefixes the VRF
can accept for this address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_routes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_routes(self):
    self.__maximum_routes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint32', is_config=True)

  af = __builtin__.property(_get_af, _set_af)
  maximum_routes = __builtin__.property(_get_maximum_routes, _set_maximum_routes)


  _pyangbind_elements = OrderedDict([('af', af), ('maximum_routes', maximum_routes), ])


class yc_maximum_routes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/maximum-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines 'maximum-routes' for the VRF.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_family',)

  _yang_name = 'maximum-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_family = YANGDynClass(base=YANGListType("af",yc_address_family_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes_address_family, yang_name="address-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='af', extensions=None), is_container='list', yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'maximum-routes']

  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes/address_family (list)

    YANG Description: List of address families.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes/address_family (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: List of address families.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("af",yc_address_family_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes_address_family, yang_name="address-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='af', extensions=None), is_container='list', yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("af",yc_address_family_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes_address_family, yang_name="address-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='af', extensions=None), is_container='list', yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=YANGListType("af",yc_address_family_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes_address_family, yang_name="address-family", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='af', extensions=None), is_container='list', yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  address_family = __builtin__.property(_get_address_family, _set_address_family) # type: yc_address_family_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes_address_family


  _pyangbind_elements = OrderedDict([('address_family', address_family), ])


class yc_anycast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed_anycast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-group-mappings/rp-group-mapping/provider-managed/anycast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: PIM Anycast-RP parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_address','__rp_set_address',)

  _yang_name = 'anycast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__rp_set_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="rp-set-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'provider-managed', 'anycast']

  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/anycast/local_address (inet:ip-address)

    YANG Description: IP local address for PIM RP.
Usually, it corresponds to router
ID or primary address
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/anycast/local_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: IP local address for PIM RP.
Usually, it corresponds to router
ID or primary address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_rp_set_address(self):
    """
    Getter method for rp_set_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/anycast/rp_set_address (inet:ip-address)

    YANG Description: Address other RP routers
that share the same RP IP address.
    """
    return self.__rp_set_address
      
  def _set_rp_set_address(self, v, load=False):
    """
    Setter method for rp_set_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/anycast/rp_set_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_set_address() directly.

    YANG Description: Address other RP routers
that share the same RP IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="rp-set-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_set_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="rp-set-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__rp_set_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_set_address(self):
    self.__rp_set_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="rp-set-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

  local_address = __builtin__.property(_get_local_address, _set_local_address)
  rp_set_address = __builtin__.property(_get_rp_set_address, _set_rp_set_address)


  _pyangbind_elements = OrderedDict([('local_address', local_address), ('rp_set_address', rp_set_address), ])


class yc_provider_managed_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-group-mappings/rp-group-mapping/provider-managed. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for a provider-managed RP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__rp_redundancy','__optimal_traffic_delivery','__anycast',)

  _yang_name = 'provider-managed'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__rp_redundancy = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rp-redundancy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__optimal_traffic_delivery = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optimal-traffic-delivery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__anycast = YANGDynClass(base=yc_anycast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed_anycast, is_container='container', yang_name="anycast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'provider-managed']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/enabled (boolean)

    YANG Description: Set to true if the Rendezvous Point (RP)
must be a provider-managed node.  Set to
false if it is a customer-managed node.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Set to true if the Rendezvous Point (RP)
must be a provider-managed node.  Set to
false if it is a customer-managed node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_rp_redundancy(self):
    """
    Getter method for rp_redundancy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/rp_redundancy (boolean)

    YANG Description: If true, a redundancy mechanism for the
RP is required.
    """
    return self.__rp_redundancy
      
  def _set_rp_redundancy(self, v, load=False):
    """
    Setter method for rp_redundancy, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/rp_redundancy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_redundancy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_redundancy() directly.

    YANG Description: If true, a redundancy mechanism for the
RP is required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rp-redundancy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_redundancy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rp-redundancy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__rp_redundancy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_redundancy(self):
    self.__rp_redundancy = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="rp-redundancy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_optimal_traffic_delivery(self):
    """
    Getter method for optimal_traffic_delivery, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/optimal_traffic_delivery (boolean)

    YANG Description: If true, the SP must ensure that
traffic uses an optimal path.  An SP may
use Anycast RP or RP-tree-to-SPT
switchover architectures.
    """
    return self.__optimal_traffic_delivery
      
  def _set_optimal_traffic_delivery(self, v, load=False):
    """
    Setter method for optimal_traffic_delivery, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/optimal_traffic_delivery (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optimal_traffic_delivery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optimal_traffic_delivery() directly.

    YANG Description: If true, the SP must ensure that
traffic uses an optimal path.  An SP may
use Anycast RP or RP-tree-to-SPT
switchover architectures.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optimal-traffic-delivery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optimal_traffic_delivery must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optimal-traffic-delivery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__optimal_traffic_delivery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optimal_traffic_delivery(self):
    self.__optimal_traffic_delivery = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="optimal-traffic-delivery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_anycast(self):
    """
    Getter method for anycast, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/anycast (container)

    YANG Description: PIM Anycast-RP parameters.
    """
    return self.__anycast
      
  def _set_anycast(self, v, load=False):
    """
    Setter method for anycast, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed/anycast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_anycast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_anycast() directly.

    YANG Description: PIM Anycast-RP parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_anycast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed_anycast, is_container='container', yang_name="anycast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """anycast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_anycast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed_anycast, is_container='container', yang_name="anycast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__anycast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_anycast(self):
    self.__anycast = YANGDynClass(base=yc_anycast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed_anycast, is_container='container', yang_name="anycast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  rp_redundancy = __builtin__.property(_get_rp_redundancy, _set_rp_redundancy)
  optimal_traffic_delivery = __builtin__.property(_get_optimal_traffic_delivery, _set_optimal_traffic_delivery)
  anycast = __builtin__.property(_get_anycast, _set_anycast) # type: yc_anycast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed_anycast


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('rp_redundancy', rp_redundancy), ('optimal_traffic_delivery', optimal_traffic_delivery), ('anycast', anycast), ])


class yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-group-mappings/rp-group-mapping/groups/group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of multicast groups.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__group_address','__group_start','__group_end',)

  _yang_name = 'group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__group_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="group-address", parent=self, choice=('group-format', 'group-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-prefix', is_config=True)
    self.__group_start = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-start", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__group_end = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-end", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'groups', 'group']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/id (uint16)

    YANG Description: Identifier for the group.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the group.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_group_address(self):
    """
    Getter method for group_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/group_address (inet:ip-prefix)

    YANG Description: A single multicast group prefix.
    """
    return self.__group_address
      
  def _set_group_address(self, v, load=False):
    """
    Setter method for group_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/group_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_address() directly.

    YANG Description: A single multicast group prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="group-address", parent=self, choice=('group-format', 'group-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_address must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="group-address", parent=self, choice=('group-format', 'group-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__group_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_address(self):
    self.__group_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="group-address", parent=self, choice=('group-format', 'group-prefix'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-prefix', is_config=True)


  def _get_group_start(self):
    """
    Getter method for group_start, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/group_start (inet:ip-address)

    YANG Description: The first multicast group address in
the multicast group address range.
    """
    return self.__group_start
      
  def _set_group_start(self, v, load=False):
    """
    Setter method for group_start, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/group_start (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_start() directly.

    YANG Description: The first multicast group address in
the multicast group address range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-start", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_start must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-start", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__group_start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_start(self):
    self.__group_start = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-start", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_group_end(self):
    """
    Getter method for group_end, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/group_end (inet:ip-address)

    YANG Description: The last multicast group address in
the multicast group address range.
    """
    return self.__group_end
      
  def _set_group_end(self, v, load=False):
    """
    Setter method for group_end, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group/group_end (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_end() directly.

    YANG Description: The last multicast group address in
the multicast group address range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-end", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_end must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-end", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__group_end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_end(self):
    self.__group_end = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="group-end", parent=self, choice=('group-format', 'startend'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  group_address = __builtin__.property(_get_group_address, _set_group_address)
  group_start = __builtin__.property(_get_group_start, _set_group_start)
  group_end = __builtin__.property(_get_group_end, _set_group_end)

  __choices__ = {'group-format': {'group-prefix': ['group_address'], 'startend': ['group_start', 'group_end']}}
  _pyangbind_elements = OrderedDict([('id', id), ('group_address', group_address), ('group_start', group_start), ('group_end', group_end), ])


class yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-group-mappings/rp-group-mapping/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast groups associated with the RP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__group',)

  _yang_name = 'groups'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__group = YANGDynClass(base=YANGListType("id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping', 'groups']

  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group (list)

    YANG Description: List of multicast groups.
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups/group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.

    YANG Description: List of multicast groups.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=YANGListType("id",yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups_group, yang_name="group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  group = __builtin__.property(_get_group, _set_group) # type: yc_group_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups_group


  _pyangbind_elements = OrderedDict([('group', group), ])


class yc_rp_group_mapping_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-group-mappings/rp-group-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of RP-to-group mappings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__provider_managed','__rp_address','__groups',)

  _yang_name = 'rp-group-mapping'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    self.__provider_managed = YANGDynClass(base=yc_provider_managed_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed, is_container='container', yang_name="provider-managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__rp_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="rp-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__groups = YANGDynClass(base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-group-mappings', 'rp-group-mapping']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/id (uint16)

    YANG Description: Unique identifier for the mapping.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the mapping.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='uint16', is_config=True)


  def _get_provider_managed(self):
    """
    Getter method for provider_managed, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed (container)

    YANG Description: Parameters for a provider-managed RP.
    """
    return self.__provider_managed
      
  def _set_provider_managed(self, v, load=False):
    """
    Setter method for provider_managed, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/provider_managed (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_managed() directly.

    YANG Description: Parameters for a provider-managed RP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_provider_managed_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed, is_container='container', yang_name="provider-managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider_managed must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_provider_managed_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed, is_container='container', yang_name="provider-managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__provider_managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider_managed(self):
    self.__provider_managed = YANGDynClass(base=yc_provider_managed_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed, is_container='container', yang_name="provider-managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_rp_address(self):
    """
    Getter method for rp_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/rp_address (inet:ip-address)

    YANG Description: Defines the address of the RP.
Used if the RP is customer-managed.
    """
    return self.__rp_address
      
  def _set_rp_address(self, v, load=False):
    """
    Setter method for rp_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/rp_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_address() directly.

    YANG Description: Defines the address of the RP.
Used if the RP is customer-managed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="rp-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="rp-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__rp_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_address(self):
    self.__rp_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="rp-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups (container)

    YANG Description: Multicast groups associated with the RP.
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping/groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.

    YANG Description: Multicast groups associated with the RP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  provider_managed = __builtin__.property(_get_provider_managed, _set_provider_managed) # type: yc_provider_managed_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_provider_managed
  rp_address = __builtin__.property(_get_rp_address, _set_rp_address)
  groups = __builtin__.property(_get_groups, _set_groups) # type: yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping_groups


  _pyangbind_elements = OrderedDict([('id', id), ('provider_managed', provider_managed), ('rp_address', rp_address), ('groups', groups), ])


class yc_rp_group_mappings_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-group-mappings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RP-to-group mappings parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rp_group_mapping',)

  _yang_name = 'rp-group-mappings'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rp_group_mapping = YANGDynClass(base=YANGListType("id",yc_rp_group_mapping_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping, yang_name="rp-group-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rp-group-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-group-mappings']

  def _get_rp_group_mapping(self):
    """
    Getter method for rp_group_mapping, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping (list)

    YANG Description: List of RP-to-group mappings.
    """
    return self.__rp_group_mapping
      
  def _set_rp_group_mapping(self, v, load=False):
    """
    Setter method for rp_group_mapping, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings/rp_group_mapping (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_group_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_group_mapping() directly.

    YANG Description: List of RP-to-group mappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_rp_group_mapping_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping, yang_name="rp-group-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rp-group-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_group_mapping must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_rp_group_mapping_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping, yang_name="rp-group-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rp-group-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__rp_group_mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_group_mapping(self):
    self.__rp_group_mapping = YANGDynClass(base=YANGListType("id",yc_rp_group_mapping_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping, yang_name="rp-group-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rp-group-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  rp_group_mapping = __builtin__.property(_get_rp_group_mapping, _set_rp_group_mapping) # type: yc_rp_group_mapping_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings_rp_group_mapping


  _pyangbind_elements = OrderedDict([('rp_group_mapping', rp_group_mapping), ])


class yc_bsr_candidates_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery_bsr_candidates(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-discovery/bsr-candidates. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for List of Customer
BSR candidate's addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bsr_candidate_address',)

  _yang_name = 'bsr-candidates'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bsr_candidate_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="bsr-candidate-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-discovery', 'bsr-candidates']

  def _get_bsr_candidate_address(self):
    """
    Getter method for bsr_candidate_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery/bsr_candidates/bsr_candidate_address (inet:ip-address)

    YANG Description: Address of candidate Bootstrap Router
(BSR).
    """
    return self.__bsr_candidate_address
      
  def _set_bsr_candidate_address(self, v, load=False):
    """
    Setter method for bsr_candidate_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery/bsr_candidates/bsr_candidate_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bsr_candidate_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bsr_candidate_address() directly.

    YANG Description: Address of candidate Bootstrap Router
(BSR).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="bsr-candidate-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bsr_candidate_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="bsr-candidate-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__bsr_candidate_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bsr_candidate_address(self):
    self.__bsr_candidate_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="bsr-candidate-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

  bsr_candidate_address = __builtin__.property(_get_bsr_candidate_address, _set_bsr_candidate_address)


  _pyangbind_elements = OrderedDict([('bsr_candidate_address', bsr_candidate_address), ])


class yc_rp_discovery_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp/rp-discovery. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RP discovery parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rp_discovery_type','__bsr_candidates',)

  _yang_name = 'rp-discovery'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rp_discovery_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-rp"), is_leaf=True, yang_name="rp-discovery-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__bsr_candidates = YANGDynClass(base=yc_bsr_candidates_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery_bsr_candidates, is_container='container', yang_name="bsr-candidates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp', 'rp-discovery']

  def _get_rp_discovery_type(self):
    """
    Getter method for rp_discovery_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery/rp_discovery_type (identityref)

    YANG Description: Type of RP discovery used.
    """
    return self.__rp_discovery_type
      
  def _set_rp_discovery_type(self, v, load=False):
    """
    Setter method for rp_discovery_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery/rp_discovery_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_discovery_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_discovery_type() directly.

    YANG Description: Type of RP discovery used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-rp"), is_leaf=True, yang_name="rp-discovery-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_discovery_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-rp"), is_leaf=True, yang_name="rp-discovery-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__rp_discovery_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_discovery_type(self):
    self.__rp_discovery_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:auto-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:static-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bsr-rp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:static-rp"), is_leaf=True, yang_name="rp-discovery-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_bsr_candidates(self):
    """
    Getter method for bsr_candidates, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery/bsr_candidates (container)

    YANG Description: Container for List of Customer
BSR candidate's addresses.
    """
    return self.__bsr_candidates
      
  def _set_bsr_candidates(self, v, load=False):
    """
    Setter method for bsr_candidates, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery/bsr_candidates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bsr_candidates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bsr_candidates() directly.

    YANG Description: Container for List of Customer
BSR candidate's addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bsr_candidates_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery_bsr_candidates, is_container='container', yang_name="bsr-candidates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bsr_candidates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bsr_candidates_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery_bsr_candidates, is_container='container', yang_name="bsr-candidates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__bsr_candidates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bsr_candidates(self):
    self.__bsr_candidates = YANGDynClass(base=yc_bsr_candidates_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery_bsr_candidates, is_container='container', yang_name="bsr-candidates", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  rp_discovery_type = __builtin__.property(_get_rp_discovery_type, _set_rp_discovery_type)
  bsr_candidates = __builtin__.property(_get_bsr_candidates, _set_bsr_candidates) # type: yc_bsr_candidates_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery_bsr_candidates


  _pyangbind_elements = OrderedDict([('rp_discovery_type', rp_discovery_type), ('bsr_candidates', bsr_candidates), ])


class yc_rp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/rp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: RP parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rp_group_mappings','__rp_discovery',)

  _yang_name = 'rp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rp_group_mappings = YANGDynClass(base=yc_rp_group_mappings_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings, is_container='container', yang_name="rp-group-mappings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__rp_discovery = YANGDynClass(base=yc_rp_discovery_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery, is_container='container', yang_name="rp-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'rp']

  def _get_rp_group_mappings(self):
    """
    Getter method for rp_group_mappings, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings (container)

    YANG Description: RP-to-group mappings parameters.
    """
    return self.__rp_group_mappings
      
  def _set_rp_group_mappings(self, v, load=False):
    """
    Setter method for rp_group_mappings, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_group_mappings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_group_mappings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_group_mappings() directly.

    YANG Description: RP-to-group mappings parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rp_group_mappings_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings, is_container='container', yang_name="rp-group-mappings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_group_mappings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rp_group_mappings_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings, is_container='container', yang_name="rp-group-mappings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__rp_group_mappings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_group_mappings(self):
    self.__rp_group_mappings = YANGDynClass(base=yc_rp_group_mappings_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings, is_container='container', yang_name="rp-group-mappings", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_rp_discovery(self):
    """
    Getter method for rp_discovery, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery (container)

    YANG Description: RP discovery parameters.
    """
    return self.__rp_discovery
      
  def _set_rp_discovery(self, v, load=False):
    """
    Setter method for rp_discovery, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp/rp_discovery (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp_discovery() directly.

    YANG Description: RP discovery parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rp_discovery_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery, is_container='container', yang_name="rp-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp_discovery must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rp_discovery_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery, is_container='container', yang_name="rp-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__rp_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp_discovery(self):
    self.__rp_discovery = YANGDynClass(base=yc_rp_discovery_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery, is_container='container', yang_name="rp-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  rp_group_mappings = __builtin__.property(_get_rp_group_mappings, _set_rp_group_mappings) # type: yc_rp_group_mappings_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_group_mappings
  rp_discovery = __builtin__.property(_get_rp_discovery, _set_rp_discovery) # type: yc_rp_discovery_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp_rp_discovery


  _pyangbind_elements = OrderedDict([('rp_group_mappings', rp_group_mappings), ('rp_discovery', rp_discovery), ])


class yc_msdp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_msdp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast/msdp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: MSDP parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__peer','__local_address',)

  _yang_name = 'msdp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__peer = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast', 'msdp']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp/enabled (boolean)

    YANG Description: If true, MSDP is activated.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: If true, MSDP is activated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_peer(self):
    """
    Getter method for peer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp/peer (inet:ip-address)

    YANG Description: IP address of the MSDP peer.
    """
    return self.__peer
      
  def _set_peer(self, v, load=False):
    """
    Setter method for peer, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp/peer (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer() directly.

    YANG Description: IP address of the MSDP peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__peer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer(self):
    self.__peer = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="peer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp/local_address (inet:ip-address)

    YANG Description: IP address of the local end. This local
address must be configured on the
node.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp/local_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: IP address of the local end. This local
address must be configured on the
node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  peer = __builtin__.property(_get_peer, _set_peer)
  local_address = __builtin__.property(_get_local_address, _set_local_address)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('peer', peer), ('local_address', local_address), ])


class yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node/multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast global parameters for the VPN
service.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__tree_flavor','__rp','__msdp',)

  _yang_name = 'multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    self.__tree_flavor = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="tree-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__rp = YANGDynClass(base=yc_rp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp, is_container='container', yang_name="rp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__msdp = YANGDynClass(base=yc_msdp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_msdp, is_container='container', yang_name="msdp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node', 'multicast']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/enabled (boolean)

    YANG Description: Enables multicast.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enables multicast.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='boolean', is_config=True)


  def _get_tree_flavor(self):
    """
    Getter method for tree_flavor, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/tree_flavor (identityref)

    YANG Description: Type of tree to be used.
    """
    return self.__tree_flavor
      
  def _set_tree_flavor(self, v, load=False):
    """
    Setter method for tree_flavor, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/tree_flavor (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tree_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tree_flavor() directly.

    YANG Description: Type of tree to be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="tree-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tree_flavor must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="tree-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__tree_flavor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tree_flavor(self):
    self.__tree_flavor = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:ssm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:asm-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:bidir-tree-type': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},)), is_leaf=False, yang_name="tree-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_rp(self):
    """
    Getter method for rp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp (container)

    YANG Description: RP parameters.
    """
    return self.__rp
      
  def _set_rp(self, v, load=False):
    """
    Setter method for rp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/rp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rp() directly.

    YANG Description: RP parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp, is_container='container', yang_name="rp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp, is_container='container', yang_name="rp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__rp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rp(self):
    self.__rp = YANGDynClass(base=yc_rp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp, is_container='container', yang_name="rp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_msdp(self):
    """
    Getter method for msdp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp (container)

    YANG Description: MSDP parameters.
    """
    return self.__msdp
      
  def _set_msdp(self, v, load=False):
    """
    Setter method for msdp, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast/msdp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_msdp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_msdp() directly.

    YANG Description: MSDP parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_msdp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_msdp, is_container='container', yang_name="msdp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """msdp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_msdp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_msdp, is_container='container', yang_name="msdp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__msdp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_msdp(self):
    self.__msdp = YANGDynClass(base=yc_msdp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_msdp, is_container='container', yang_name="msdp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  tree_flavor = __builtin__.property(_get_tree_flavor, _set_tree_flavor)
  rp = __builtin__.property(_get_rp, _set_rp) # type: yc_rp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_rp
  msdp = __builtin__.property(_get_msdp, _set_msdp) # type: yc_msdp_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast_msdp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('tree_flavor', tree_flavor), ('rp', rp), ('msdp', msdp), ])


class yc_vpn_node_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes/vpn-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for VPN node.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_node_id','__local_autonomous_system','__description','__ne_id','__router_id','__address_family','__node_role','__rd','__vpn_targets','__status','__node_ie_profile','__groups','__vpn_network_accesses','__maximum_routes','__multicast',)

  _yang_name = 'vpn-node'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_node_id = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="vpn-node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    self.__local_autonomous_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__ne_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ne-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__router_id = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    self.__node_role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any-role"), is_leaf=True, yang_name="node-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__rd = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__node_ie_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    self.__groups = YANGDynClass(base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vpn_network_accesses = YANGDynClass(base=yc_vpn_network_accesses_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses, is_container='container', yang_name="vpn-network-accesses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__maximum_routes = YANGDynClass(base=yc_maximum_routes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes, is_container='container', yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__multicast = YANGDynClass(base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes', 'vpn-node']

  def _get_vpn_node_id(self):
    """
    Getter method for vpn_node_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_node_id (union)

    YANG Description: Type STRING or NUMBER Service-Id.
    """
    return self.__vpn_node_id
      
  def _set_vpn_node_id(self, v, load=False):
    """
    Setter method for vpn_node_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_node_id (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_node_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_node_id() directly.

    YANG Description: Type STRING or NUMBER Service-Id.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="vpn-node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_node_id must be of a type compatible with union""",
          'defined-type': "ietf-l3vpn-ntw:union",
          'generated-type': """YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="vpn-node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)""",
        })

    self.__vpn_node_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_node_id(self):
    self.__vpn_node_id = YANGDynClass(base=[six.text_type,RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),], is_leaf=True, yang_name="vpn-node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)


  def _get_local_autonomous_system(self):
    """
    Getter method for local_autonomous_system, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/local_autonomous_system (inet:as-number)

    YANG Description: Provider's AS number in case the customer
requests BGP routing.
    """
    return self.__local_autonomous_system
      
  def _set_local_autonomous_system(self, v, load=False):
    """
    Setter method for local_autonomous_system, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/local_autonomous_system (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_autonomous_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_autonomous_system() directly.

    YANG Description: Provider's AS number in case the customer
requests BGP routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_autonomous_system must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)""",
        })

    self.__local_autonomous_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_autonomous_system(self):
    self.__local_autonomous_system = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-autonomous-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:as-number', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/description (string)

    YANG Description: Textual description of the VPN node.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the VPN node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_ne_id(self):
    """
    Getter method for ne_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/ne_id (string)

    YANG Description: Unique identifier of the network element
where the VPN node is deployed.
    """
    return self.__ne_id
      
  def _set_ne_id(self, v, load=False):
    """
    Setter method for ne_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/ne_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ne_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ne_id() directly.

    YANG Description: Unique identifier of the network element
where the VPN node is deployed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ne-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ne_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ne-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__ne_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ne_id(self):
    self.__ne_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ne-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/router_id (inet:ip-address)

    YANG Description: The router-id information can be an IPv4
or IPv6 address.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/router_id (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: The router-id information can be an IPv4
or IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='inet:ip-address', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/address_family (vpn-common:address-family)

    YANG Description: The address family used for router-id
information.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/address_family (vpn-common:address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: The address family used for router-id
information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with vpn-common:address-family""",
          'defined-type': "vpn-common:address-family",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:address-family', is_config=True)


  def _get_node_role(self):
    """
    Getter method for node_role, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/node_role (identityref)

    YANG Description: Role of the VPN node in the IP VPN.
    """
    return self.__node_role
      
  def _set_node_role(self, v, load=False):
    """
    Setter method for node_role, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/node_role (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_role() directly.

    YANG Description: Role of the VPN node in the IP VPN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any-role"), is_leaf=True, yang_name="node-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_role must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any-role"), is_leaf=True, yang_name="node-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__node_role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_role(self):
    self.__node_role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:spoke-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom-role': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any-role"), is_leaf=True, yang_name="node-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_rd(self):
    """
    Getter method for rd, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/rd (union)

    YANG Description: Route distinguisher value. If this leaf has not been
configured, the server will auto-assign a route
distinguisher value and use that value operationally.
This calculated value is available in the operational
state.

Use the empty type to indicate RD has no value and
is not to be aouto-assigned.
    """
    return self.__rd
      
  def _set_rd(self, v, load=False):
    """
    Setter method for rd, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/rd (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rd() directly.

    YANG Description: Route distinguisher value. If this leaf has not been
configured, the server will auto-assign a route
distinguisher value and use that value operationally.
This calculated value is available in the operational
state.

Use the empty type to indicate RD has no value and
is not to be aouto-assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rd must be of a type compatible with union""",
          'defined-type': "ietf-l3vpn-ntw:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)""",
        })

    self.__rd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rd(self):
    self.__rd = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'}),YANGBool,], is_leaf=True, yang_name="rd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='union', is_config=True)


  def _get_vpn_targets(self):
    """
    Getter method for vpn_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets (container)

    YANG Description: Set of route-targets to match for import and export routes
to/from VRF
    """
    return self.__vpn_targets
      
  def _set_vpn_targets(self, v, load=False):
    """
    Setter method for vpn_targets, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_targets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_targets() directly.

    YANG Description: Set of route-targets to match for import and export routes
to/from VRF
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_targets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_targets(self):
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status (container)

    YANG Description: Service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_node_ie_profile(self):
    """
    Getter method for node_ie_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/node_ie_profile (leafref)

    YANG Description: Node's Import/Export profile.
    """
    return self.__node_ie_profile
      
  def _set_node_ie_profile(self, v, load=False):
    """
    Setter method for node_ie_profile, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/node_ie_profile (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_ie_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_ie_profile() directly.

    YANG Description: Node's Import/Export profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_ie_profile must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)""",
        })

    self.__node_ie_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_ie_profile(self):
    self.__node_ie_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ie-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='leafref', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/groups (container)

    YANG Description: Groups the vpn node and network access belongs to.
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.

    YANG Description: Groups the vpn node and network access belongs to.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups, is_container='container', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vpn_network_accesses(self):
    """
    Getter method for vpn_network_accesses, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses (container)

    YANG Description: List of accesses for a site.
    """
    return self.__vpn_network_accesses
      
  def _set_vpn_network_accesses(self, v, load=False):
    """
    Setter method for vpn_network_accesses, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/vpn_network_accesses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_network_accesses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_network_accesses() directly.

    YANG Description: List of accesses for a site.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_network_accesses_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses, is_container='container', yang_name="vpn-network-accesses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_network_accesses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_network_accesses_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses, is_container='container', yang_name="vpn-network-accesses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_network_accesses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_network_accesses(self):
    self.__vpn_network_accesses = YANGDynClass(base=yc_vpn_network_accesses_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses, is_container='container', yang_name="vpn-network-accesses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_maximum_routes(self):
    """
    Getter method for maximum_routes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes (container)

    YANG Description: Defines 'maximum-routes' for the VRF.
    """
    return self.__maximum_routes
      
  def _set_maximum_routes(self, v, load=False):
    """
    Setter method for maximum_routes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/maximum_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_routes() directly.

    YANG Description: Defines 'maximum-routes' for the VRF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_maximum_routes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes, is_container='container', yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_maximum_routes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes, is_container='container', yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__maximum_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_routes(self):
    self.__maximum_routes = YANGDynClass(base=yc_maximum_routes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes, is_container='container', yang_name="maximum-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_multicast(self):
    """
    Getter method for multicast, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast (container)

    YANG Description: Multicast global parameters for the VPN
service.
    """
    return self.__multicast
      
  def _set_multicast(self, v, load=False):
    """
    Setter method for multicast, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node/multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multicast() directly.

    YANG Description: Multicast global parameters for the VPN
service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multicast(self):
    self.__multicast = YANGDynClass(base=yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast, is_container='container', yang_name="multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  vpn_node_id = __builtin__.property(_get_vpn_node_id, _set_vpn_node_id)
  local_autonomous_system = __builtin__.property(_get_local_autonomous_system, _set_local_autonomous_system)
  description = __builtin__.property(_get_description, _set_description)
  ne_id = __builtin__.property(_get_ne_id, _set_ne_id)
  router_id = __builtin__.property(_get_router_id, _set_router_id)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  node_role = __builtin__.property(_get_node_role, _set_node_role)
  rd = __builtin__.property(_get_rd, _set_rd)
  vpn_targets = __builtin__.property(_get_vpn_targets, _set_vpn_targets) # type: yc_vpn_targets_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_targets
  status = __builtin__.property(_get_status, _set_status) # type: yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_status
  node_ie_profile = __builtin__.property(_get_node_ie_profile, _set_node_ie_profile)
  groups = __builtin__.property(_get_groups, _set_groups) # type: yc_groups_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_groups
  vpn_network_accesses = __builtin__.property(_get_vpn_network_accesses, _set_vpn_network_accesses) # type: yc_vpn_network_accesses_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_vpn_network_accesses
  maximum_routes = __builtin__.property(_get_maximum_routes, _set_maximum_routes) # type: yc_maximum_routes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_maximum_routes
  multicast = __builtin__.property(_get_multicast, _set_multicast) # type: yc_multicast_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node_multicast


  _pyangbind_elements = OrderedDict([('vpn_node_id', vpn_node_id), ('local_autonomous_system', local_autonomous_system), ('description', description), ('ne_id', ne_id), ('router_id', router_id), ('address_family', address_family), ('node_role', node_role), ('rd', rd), ('vpn_targets', vpn_targets), ('status', status), ('node_ie_profile', node_ie_profile), ('groups', groups), ('vpn_network_accesses', vpn_network_accesses), ('maximum_routes', maximum_routes), ('multicast', multicast), ])


class yc_vpn_nodes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service/vpn-nodes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for VPN nodes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_node',)

  _yang_name = 'vpn-nodes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_node = YANGDynClass(base=YANGListType("vpn_node_id",yc_vpn_node_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node, yang_name="vpn-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-node-id', extensions=None), is_container='list', yang_name="vpn-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service', 'vpn-nodes']

  def _get_vpn_node(self):
    """
    Getter method for vpn_node, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node (list)

    YANG Description: List for VPN node.
    """
    return self.__vpn_node
      
  def _set_vpn_node(self, v, load=False):
    """
    Setter method for vpn_node, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes/vpn_node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_node() directly.

    YANG Description: List for VPN node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vpn_node_id",yc_vpn_node_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node, yang_name="vpn-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-node-id', extensions=None), is_container='list', yang_name="vpn-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vpn_node_id",yc_vpn_node_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node, yang_name="vpn-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-node-id', extensions=None), is_container='list', yang_name="vpn-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__vpn_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_node(self):
    self.__vpn_node = YANGDynClass(base=YANGListType("vpn_node_id",yc_vpn_node_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node, yang_name="vpn-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-node-id', extensions=None), is_container='list', yang_name="vpn-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  vpn_node = __builtin__.property(_get_vpn_node, _set_vpn_node) # type: yc_vpn_node_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes_vpn_node


  _pyangbind_elements = OrderedDict([('vpn_node', vpn_node), ])


class yc_vpn_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services/vpn-service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VPN services.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__vpn_id','__vpn_name','__vpn_description','__customer_name','__l3sm_vpn_id','__vpn_type','__vpn_service_topology','__ie_profiles','__underlay_transport','__vpn_nodes',)

  _yang_name = 'vpn-service'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vpn_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    self.__vpn_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__vpn_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__customer_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="customer-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    self.__l3sm_vpn_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="l3sm-vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    self.__vpn_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 't-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:t-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="vpn-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__vpn_service_topology = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any"), is_leaf=True, yang_name="vpn-service-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    self.__ie_profiles = YANGDynClass(base=yc_ie_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles, is_container='container', yang_name="ie-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__underlay_transport = YANGDynClass(base=yc_underlay_transport_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_underlay_transport, is_container='container', yang_name="underlay-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vpn_nodes = YANGDynClass(base=yc_vpn_nodes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes, is_container='container', yang_name="vpn-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services', 'vpn-service']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status (container)

    YANG Description: Service status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/status (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Service status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status, is_container='container', yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vpn_id(self):
    """
    Getter method for vpn_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_id (vpn-common:vpn-id)

    YANG Description: VPN identifier.
This identifier has a local meaning.
    """
    return self.__vpn_id
      
  def _set_vpn_id(self, v, load=False):
    """
    Setter method for vpn_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_id (vpn-common:vpn-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_id() directly.

    YANG Description: VPN identifier.
This identifier has a local meaning.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_id must be of a type compatible with vpn-common:vpn-id""",
          'defined-type': "vpn-common:vpn-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)""",
        })

    self.__vpn_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_id(self):
    self.__vpn_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)


  def _get_vpn_name(self):
    """
    Getter method for vpn_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_name (string)

    YANG Description: A name used to refer to the VPN.
    """
    return self.__vpn_name
      
  def _set_vpn_name(self, v, load=False):
    """
    Setter method for vpn_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_name() directly.

    YANG Description: A name used to refer to the VPN.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpn-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__vpn_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_name(self):
    self.__vpn_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_vpn_description(self):
    """
    Getter method for vpn_description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_description (string)

    YANG Description: Textual description of a VPN service.
    """
    return self.__vpn_description
      
  def _set_vpn_description(self, v, load=False):
    """
    Setter method for vpn_description, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_description() directly.

    YANG Description: Textual description of a VPN service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="vpn-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__vpn_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_description(self):
    self.__vpn_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpn-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_customer_name(self):
    """
    Getter method for customer_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/customer_name (string)

    YANG Description: Name of the customer that actually uses the VPN service.
    """
    return self.__customer_name
      
  def _set_customer_name(self, v, load=False):
    """
    Setter method for customer_name, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/customer_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_customer_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_customer_name() directly.

    YANG Description: Name of the customer that actually uses the VPN service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="customer-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """customer_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="customer-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)""",
        })

    self.__customer_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_customer_name(self):
    self.__customer_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="customer-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='string', is_config=True)


  def _get_l3sm_vpn_id(self):
    """
    Getter method for l3sm_vpn_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/l3sm_vpn_id (vpn-common:vpn-id)

    YANG Description: Pointer to the parent L3SM service,
if any.
    """
    return self.__l3sm_vpn_id
      
  def _set_l3sm_vpn_id(self, v, load=False):
    """
    Setter method for l3sm_vpn_id, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/l3sm_vpn_id (vpn-common:vpn-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3sm_vpn_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3sm_vpn_id() directly.

    YANG Description: Pointer to the parent L3SM service,
if any.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="l3sm-vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3sm_vpn_id must be of a type compatible with vpn-common:vpn-id""",
          'defined-type': "vpn-common:vpn-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="l3sm-vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)""",
        })

    self.__l3sm_vpn_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3sm_vpn_id(self):
    self.__l3sm_vpn_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="l3sm-vpn-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='vpn-common:vpn-id', is_config=True)


  def _get_vpn_type(self):
    """
    Getter method for vpn_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_type (identityref)

    YANG Description: Indicates the service type
    """
    return self.__vpn_type
      
  def _set_vpn_type(self, v, load=False):
    """
    Setter method for vpn_type, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_type() directly.

    YANG Description: Indicates the service type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 't-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:t-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="vpn-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_type must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 't-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:t-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="vpn-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__vpn_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_type(self):
    self.__vpn_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2vpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:evpn-bgp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 't-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:t-ldp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:h-vpls': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:l2tp': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), is_leaf=True, yang_name="vpn-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_vpn_service_topology(self):
    """
    Getter method for vpn_service_topology, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_service_topology (identityref)

    YANG Description: VPN service topology.
    """
    return self.__vpn_service_topology
      
  def _set_vpn_service_topology(self, v, load=False):
    """
    Setter method for vpn_service_topology, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_service_topology (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_service_topology is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_service_topology() directly.

    YANG Description: VPN service topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any"), is_leaf=True, yang_name="vpn-service-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_service_topology must be of a type compatible with identityref""",
          'defined-type': "ietf-l3vpn-ntw:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any"), is_leaf=True, yang_name="vpn-service-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)""",
        })

    self.__vpn_service_topology = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_service_topology(self):
    self.__vpn_service_topology = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:any-to-any': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:hub-spoke-disjoint': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}, 'vpn-common:custom': {'@module': 'ietf-vpn-common', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-vpn-common'}},), default=six.text_type("vpn-common:any-to-any"), is_leaf=True, yang_name="vpn-service-topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='identityref', is_config=True)


  def _get_ie_profiles(self):
    """
    Getter method for ie_profiles, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles (container)

    YANG Description: Container for Import/Export profiles.
    """
    return self.__ie_profiles
      
  def _set_ie_profiles(self, v, load=False):
    """
    Setter method for ie_profiles, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/ie_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ie_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ie_profiles() directly.

    YANG Description: Container for Import/Export profiles.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ie_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles, is_container='container', yang_name="ie-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ie_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ie_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles, is_container='container', yang_name="ie-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__ie_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ie_profiles(self):
    self.__ie_profiles = YANGDynClass(base=yc_ie_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles, is_container='container', yang_name="ie-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_underlay_transport(self):
    """
    Getter method for underlay_transport, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/underlay_transport (container)

    YANG Description: Container for the Transport underlay.
    """
    return self.__underlay_transport
      
  def _set_underlay_transport(self, v, load=False):
    """
    Setter method for underlay_transport, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/underlay_transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_underlay_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_underlay_transport() directly.

    YANG Description: Container for the Transport underlay.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_underlay_transport_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_underlay_transport, is_container='container', yang_name="underlay-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """underlay_transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_underlay_transport_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_underlay_transport, is_container='container', yang_name="underlay-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__underlay_transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_underlay_transport(self):
    self.__underlay_transport = YANGDynClass(base=yc_underlay_transport_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_underlay_transport, is_container='container', yang_name="underlay-transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vpn_nodes(self):
    """
    Getter method for vpn_nodes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes (container)

    YANG Description: Container for VPN nodes.
    """
    return self.__vpn_nodes
      
  def _set_vpn_nodes(self, v, load=False):
    """
    Setter method for vpn_nodes, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service/vpn_nodes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_nodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_nodes() directly.

    YANG Description: Container for VPN nodes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_nodes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes, is_container='container', yang_name="vpn-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_nodes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_nodes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes, is_container='container', yang_name="vpn-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_nodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_nodes(self):
    self.__vpn_nodes = YANGDynClass(base=yc_vpn_nodes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes, is_container='container', yang_name="vpn-nodes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  status = __builtin__.property(_get_status, _set_status) # type: yc_status_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_status
  vpn_id = __builtin__.property(_get_vpn_id, _set_vpn_id)
  vpn_name = __builtin__.property(_get_vpn_name, _set_vpn_name)
  vpn_description = __builtin__.property(_get_vpn_description, _set_vpn_description)
  customer_name = __builtin__.property(_get_customer_name, _set_customer_name)
  l3sm_vpn_id = __builtin__.property(_get_l3sm_vpn_id, _set_l3sm_vpn_id)
  vpn_type = __builtin__.property(_get_vpn_type, _set_vpn_type)
  vpn_service_topology = __builtin__.property(_get_vpn_service_topology, _set_vpn_service_topology)
  ie_profiles = __builtin__.property(_get_ie_profiles, _set_ie_profiles) # type: yc_ie_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_ie_profiles
  underlay_transport = __builtin__.property(_get_underlay_transport, _set_underlay_transport) # type: yc_underlay_transport_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_underlay_transport
  vpn_nodes = __builtin__.property(_get_vpn_nodes, _set_vpn_nodes) # type: yc_vpn_nodes_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service_vpn_nodes


  _pyangbind_elements = OrderedDict([('status', status), ('vpn_id', vpn_id), ('vpn_name', vpn_name), ('vpn_description', vpn_description), ('customer_name', customer_name), ('l3sm_vpn_id', l3sm_vpn_id), ('vpn_type', vpn_type), ('vpn_service_topology', vpn_service_topology), ('ie_profiles', ie_profiles), ('underlay_transport', underlay_transport), ('vpn_nodes', vpn_nodes), ])


class yc_vpn_services_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw/vpn-services. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level container for the VPN services.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_service',)

  _yang_name = 'vpn-services'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_service = YANGDynClass(base=YANGListType("vpn_id",yc_vpn_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service, yang_name="vpn-service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-id', extensions=None), is_container='list', yang_name="vpn-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw', 'vpn-services']

  def _get_vpn_service(self):
    """
    Getter method for vpn_service, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service (list)

    YANG Description: List of VPN services.
    """
    return self.__vpn_service
      
  def _set_vpn_service(self, v, load=False):
    """
    Setter method for vpn_service, mapped from YANG variable /l3vpn_ntw/vpn_services/vpn_service (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_service() directly.

    YANG Description: List of VPN services.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("vpn_id",yc_vpn_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service, yang_name="vpn-service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-id', extensions=None), is_container='list', yang_name="vpn-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_service must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("vpn_id",yc_vpn_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service, yang_name="vpn-service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-id', extensions=None), is_container='list', yang_name="vpn-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)""",
        })

    self.__vpn_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_service(self):
    self.__vpn_service = YANGDynClass(base=YANGListType("vpn_id",yc_vpn_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service, yang_name="vpn-service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vpn-id', extensions=None), is_container='list', yang_name="vpn-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='list', is_config=True)

  vpn_service = __builtin__.property(_get_vpn_service, _set_vpn_service) # type: yc_vpn_service_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services_vpn_service


  _pyangbind_elements = OrderedDict([('vpn_service', vpn_service), ])


class yc_l3vpn_ntw_ietf_l3vpn_ntw__l3vpn_ntw(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /l3vpn-ntw. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Main container for L3VPN services management.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_profiles','__vpn_services',)

  _yang_name = 'l3vpn-ntw'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_profiles = YANGDynClass(base=yc_vpn_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles, is_container='container', yang_name="vpn-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    self.__vpn_services = YANGDynClass(base=yc_vpn_services_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services, is_container='container', yang_name="vpn-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['l3vpn-ntw']

  def _get_vpn_profiles(self):
    """
    Getter method for vpn_profiles, mapped from YANG variable /l3vpn_ntw/vpn_profiles (container)

    YANG Description: Contains a set of valid VPN Profiles to
reference in the VPN service.
    """
    return self.__vpn_profiles
      
  def _set_vpn_profiles(self, v, load=False):
    """
    Setter method for vpn_profiles, mapped from YANG variable /l3vpn_ntw/vpn_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_profiles() directly.

    YANG Description: Contains a set of valid VPN Profiles to
reference in the VPN service.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles, is_container='container', yang_name="vpn-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles, is_container='container', yang_name="vpn-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_profiles(self):
    self.__vpn_profiles = YANGDynClass(base=yc_vpn_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles, is_container='container', yang_name="vpn-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)


  def _get_vpn_services(self):
    """
    Getter method for vpn_services, mapped from YANG variable /l3vpn_ntw/vpn_services (container)

    YANG Description: Top-level container for the VPN services.
    """
    return self.__vpn_services
      
  def _set_vpn_services(self, v, load=False):
    """
    Setter method for vpn_services, mapped from YANG variable /l3vpn_ntw/vpn_services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_services() directly.

    YANG Description: Top-level container for the VPN services.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_services_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services, is_container='container', yang_name="vpn-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_services_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services, is_container='container', yang_name="vpn-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__vpn_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_services(self):
    self.__vpn_services = YANGDynClass(base=yc_vpn_services_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services, is_container='container', yang_name="vpn-services", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  vpn_profiles = __builtin__.property(_get_vpn_profiles, _set_vpn_profiles) # type: yc_vpn_profiles_ietf_l3vpn_ntw__l3vpn_ntw_vpn_profiles
  vpn_services = __builtin__.property(_get_vpn_services, _set_vpn_services) # type: yc_vpn_services_ietf_l3vpn_ntw__l3vpn_ntw_vpn_services


  _pyangbind_elements = OrderedDict([('vpn_profiles', vpn_profiles), ('vpn_services', vpn_services), ])


class ietf_l3vpn_ntw(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-l3vpn-ntw - based on the path /ietf-l3vpn-ntw. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines a generic network-oriented model
for the configuration of Layer 3 Virtual Private Networks.

Copyright (c) 2020 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__l3vpn_ntw',)

  _yang_name = 'ietf-l3vpn-ntw'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__l3vpn_ntw = YANGDynClass(base=yc_l3vpn_ntw_ietf_l3vpn_ntw__l3vpn_ntw, is_container='container', yang_name="l3vpn-ntw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_l3vpn_ntw(self):
    """
    Getter method for l3vpn_ntw, mapped from YANG variable /l3vpn_ntw (container)

    YANG Description: Main container for L3VPN services management.
    """
    return self.__l3vpn_ntw
      
  def _set_l3vpn_ntw(self, v, load=False):
    """
    Setter method for l3vpn_ntw, mapped from YANG variable /l3vpn_ntw (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ntw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ntw() directly.

    YANG Description: Main container for L3VPN services management.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ntw_ietf_l3vpn_ntw__l3vpn_ntw, is_container='container', yang_name="l3vpn-ntw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ntw must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ntw_ietf_l3vpn_ntw__l3vpn_ntw, is_container='container', yang_name="l3vpn-ntw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ntw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ntw(self):
    self.__l3vpn_ntw = YANGDynClass(base=yc_l3vpn_ntw_ietf_l3vpn_ntw__l3vpn_ntw, is_container='container', yang_name="l3vpn-ntw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw', defining_module='ietf-l3vpn-ntw', yang_type='container', is_config=True)

  l3vpn_ntw = __builtin__.property(_get_l3vpn_ntw, _set_l3vpn_ntw) # type: yc_l3vpn_ntw_ietf_l3vpn_ntw__l3vpn_ntw


  _pyangbind_elements = OrderedDict([('l3vpn_ntw', l3vpn_ntw), ])


class ietf_vpn_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-vpn-common - based on the path /ietf-vpn-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines a common module that is meant
to be reused by various VPN-related modules (e.g.,
Layer 3 VPN Service Model (L3SM), Layer 2 VPN Service
Model (L2SM), Layer 3 VPN Network Model (L3NM), Layer 2
VPN Network Model (L2NM)).

Copyright (c) 2020 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.
  """
  _pyangbind_elements = {}

  

