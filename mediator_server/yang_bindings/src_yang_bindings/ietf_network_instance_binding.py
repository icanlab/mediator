# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_vrf_root_ietf_network_instance__network_instances_network_instance_root_type_vrf_root(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance/root-type/vrf-root. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for mount point.
  """
  _pyangbind_elements = {}


class yc_root_type_ietf_network_instance__network_instances_network_instance_root_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance/root-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Well known mount points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vrf_root',)

  _yang_name = 'root-type'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vrf_root = YANGDynClass(base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_root_type_vrf_root, is_container='container', yang_name="vrf-root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'root-type']

  def _get_vrf_root(self):
    """
    Getter method for vrf_root, mapped from YANG variable /network_instances/network_instance/root_type/vrf_root (container)

    YANG Description: Container for mount point.
    """
    return self.__vrf_root
      
  def _set_vrf_root(self, v, load=False):
    """
    Setter method for vrf_root, mapped from YANG variable /network_instances/network_instance/root_type/vrf_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_root() directly.

    YANG Description: Container for mount point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_root_type_vrf_root, is_container='container', yang_name="vrf-root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_root must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_root_type_vrf_root, is_container='container', yang_name="vrf-root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__vrf_root = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_root(self):
    self.__vrf_root = YANGDynClass(base=yc_vrf_root_ietf_network_instance__network_instances_network_instance_root_type_vrf_root, is_container='container', yang_name="vrf-root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

  vrf_root = __builtin__.property(_get_vrf_root, _set_vrf_root) # type: yc_vrf_root_ietf_network_instance__network_instances_network_instance_root_type_vrf_root


  _pyangbind_elements = OrderedDict([('vrf_root', vrf_root), ])


class yc_network_instance_ietf_network_instance__network_instances_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances/network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of network-instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__enabled','__description','__root_type',)

  _yang_name = 'network-instance'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    self.__root_type = YANGDynClass(base=yc_root_type_ietf_network_instance__network_instances_network_instance_root_type, is_container='container', yang_name="root-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instances/network_instance/name (string)

    YANG Description: device scoped identifier for the network
instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instances/network_instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: device scoped identifier for the network
instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/enabled (boolean)

    YANG Description: Flag indicating whether or not the network
instance is enabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Flag indicating whether or not the network
instance is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='boolean', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instances/network_instance/description (string)

    YANG Description: Description of the network instance
and its intended purpose.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instances/network_instance/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the network instance
and its intended purpose.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='string', is_config=True)


  def _get_root_type(self):
    """
    Getter method for root_type, mapped from YANG variable /network_instances/network_instance/root_type (container)

    YANG Description: Well known mount points.
    """
    return self.__root_type
      
  def _set_root_type(self, v, load=False):
    """
    Setter method for root_type, mapped from YANG variable /network_instances/network_instance/root_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_type() directly.

    YANG Description: Well known mount points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_root_type_ietf_network_instance__network_instances_network_instance_root_type, is_container='container', yang_name="root-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """root_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_root_type_ietf_network_instance__network_instances_network_instance_root_type, is_container='container', yang_name="root-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__root_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_root_type(self):
    self.__root_type = YANGDynClass(base=yc_root_type_ietf_network_instance__network_instances_network_instance_root_type, is_container='container', yang_name="root-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  description = __builtin__.property(_get_description, _set_description)
  root_type = __builtin__.property(_get_root_type, _set_root_type) # type: yc_root_type_ietf_network_instance__network_instances_network_instance_root_type


  _pyangbind_elements = OrderedDict([('name', name), ('enabled', enabled), ('description', description), ('root_type', root_type), ])


class yc_network_instances_ietf_network_instance__network_instances(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /network-instances. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network instances each of which consists of a
VRFs (virtual routing and forwarding) and/or
VSIs (virtual switching instances).
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instance',)

  _yang_name = 'network-instances'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instance = YANGDynClass(base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances']

  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instances/network_instance (list)

    YANG Description: List of network-instances.
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instances/network_instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: List of network-instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=YANGListType("name",yc_network_instance_ietf_network_instance__network_instances_network_instance, yang_name="network-instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='list', is_config=True)

  network_instance = __builtin__.property(_get_network_instance, _set_network_instance) # type: yc_network_instance_ietf_network_instance__network_instances_network_instance


  _pyangbind_elements = OrderedDict([('network_instance', network_instance), ])


class ietf_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-instance - based on the path /ietf-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module is used to support multiple network instances
within a single physical or virtual device.  Network
instances are commonly known as VRFs (virtual routing
and forwarding) and VSIs (virtual switching instances).

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instances',)

  _yang_name = 'ietf-network-instance'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instances = YANGDynClass(base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instances(self):
    """
    Getter method for network_instances, mapped from YANG variable /network_instances (container)

    YANG Description: Network instances each of which consists of a
VRFs (virtual routing and forwarding) and/or
VSIs (virtual switching instances).
    """
    return self.__network_instances
      
  def _set_network_instances(self, v, load=False):
    """
    Setter method for network_instances, mapped from YANG variable /network_instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instances() directly.

    YANG Description: Network instances each of which consists of a
VRFs (virtual routing and forwarding) and/or
VSIs (virtual switching instances).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instances(self):
    self.__network_instances = YANGDynClass(base=yc_network_instances_ietf_network_instance__network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-instance', defining_module='ietf-network-instance', yang_type='container', is_config=True)

  network_instances = __builtin__.property(_get_network_instances, _set_network_instances) # type: yc_network_instances_ietf_network_instance__network_instances


  _pyangbind_elements = OrderedDict([('network_instances', network_instances), ])
